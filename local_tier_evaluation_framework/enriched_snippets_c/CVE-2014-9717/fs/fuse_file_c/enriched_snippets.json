[
  {
    "function_name": "fuse_init_file_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "3009-3013",
    "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
      "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
  },
  {
    "function_name": "fuse_file_fallocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "2882-2956",
    "snippet": "static long fuse_file_fallocate(struct file *file, int mode, loff_t offset,\n\t\t\t\tloff_t length)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_conn *fc = ff->fc;\n\tFUSE_ARGS(args);\n\tstruct fuse_fallocate_in inarg = {\n\t\t.fh = ff->fh,\n\t\t.offset = offset,\n\t\t.length = length,\n\t\t.mode = mode\n\t};\n\tint err;\n\tbool lock_inode = !(mode & FALLOC_FL_KEEP_SIZE) ||\n\t\t\t   (mode & FALLOC_FL_PUNCH_HOLE);\n\n\tif (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (fc->no_fallocate)\n\t\treturn -EOPNOTSUPP;\n\n\tif (lock_inode) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\tif (mode & FALLOC_FL_PUNCH_HOLE) {\n\t\t\tloff_t endbyte = offset + length - 1;\n\t\t\terr = filemap_write_and_wait_range(inode->i_mapping,\n\t\t\t\t\t\t\t   offset, endbyte);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tfuse_sync_writes(inode);\n\t\t}\n\t}\n\n\tif (!(mode & FALLOC_FL_KEEP_SIZE))\n\t\tset_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\n\targs.in.h.opcode = FUSE_FALLOCATE;\n\targs.in.h.nodeid = ff->nodeid;\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (err == -ENOSYS) {\n\t\tfc->no_fallocate = 1;\n\t\terr = -EOPNOTSUPP;\n\t}\n\tif (err)\n\t\tgoto out;\n\n\t/* we could have extended the file */\n\tif (!(mode & FALLOC_FL_KEEP_SIZE)) {\n\t\tbool changed = fuse_write_update_size(inode, offset + length);\n\n\t\tif (changed && fc->writeback_cache)\n\t\t\tfile_update_time(file);\n\t}\n\n\tif (mode & FALLOC_FL_PUNCH_HOLE)\n\t\ttruncate_pagecache_range(inode, offset, offset + length - 1);\n\n\tfuse_invalidate_attr(inode);\n\nout:\n\tif (!(mode & FALLOC_FL_KEEP_SIZE))\n\t\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\n\tif (lock_inode)\n\t\tmutex_unlock(&inode->i_mutex);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "FUSE_I_SIZE_UNSTABLE",
            "&fi->state"
          ],
          "line": 2950
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_invalidate_attr",
          "args": [
            "inode"
          ],
          "line": 2946
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "110-113",
          "snippet": "void fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_pagecache_range",
          "args": [
            "inode",
            "offset",
            "offset + length - 1"
          ],
          "line": 2944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_update_time",
          "args": [
            "file"
          ],
          "line": 2940
        },
        "resolved": true,
        "details": {
          "function_name": "file_update_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1716-1748",
          "snippet": "int file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_write_update_size",
          "args": [
            "inode",
            "offset + length"
          ],
          "line": 2937
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_write_update_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "957-972",
          "snippet": "bool fuse_write_update_size(struct inode *inode, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tbool ret = false;\n\n\tspin_lock(&fc->lock);\n\tfi->attr_version = ++fc->attr_version;\n\tif (pos > inode->i_size) {\n\t\ti_size_write(inode, pos);\n\t\tret = true;\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nbool fuse_write_update_size(struct inode *inode, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tbool ret = false;\n\n\tspin_lock(&fc->lock);\n\tfi->attr_version = ++fc->attr_version;\n\tif (pos > inode->i_size) {\n\t\ti_size_write(inode, pos);\n\t\tret = true;\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_simple_request",
          "args": [
            "fc",
            "&args"
          ],
          "line": 2927
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_simple_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "558-588",
          "snippet": "ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "FUSE_I_SIZE_UNSTABLE",
            "&fi->state"
          ],
          "line": 2920
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_sync_writes",
          "args": [
            "inode"
          ],
          "line": 2915
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_sync_writes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "391-395",
          "snippet": "static void fuse_sync_writes(struct inode *inode)\n{\n\tfuse_set_nowrite(inode);\n\tfuse_release_nowrite(inode);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_sync_writes(struct inode *inode)\n{\n\tfuse_set_nowrite(inode);\n\tfuse_release_nowrite(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "inode->i_mapping",
            "offset",
            "endbyte"
          ],
          "line": 2910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUSE_ARGS",
          "args": [
            "args"
          ],
          "line": 2889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 2887
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 2886
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic long fuse_file_fallocate(struct file *file, int mode, loff_t offset,\n\t\t\t\tloff_t length)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_conn *fc = ff->fc;\n\tFUSE_ARGS(args);\n\tstruct fuse_fallocate_in inarg = {\n\t\t.fh = ff->fh,\n\t\t.offset = offset,\n\t\t.length = length,\n\t\t.mode = mode\n\t};\n\tint err;\n\tbool lock_inode = !(mode & FALLOC_FL_KEEP_SIZE) ||\n\t\t\t   (mode & FALLOC_FL_PUNCH_HOLE);\n\n\tif (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (fc->no_fallocate)\n\t\treturn -EOPNOTSUPP;\n\n\tif (lock_inode) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\tif (mode & FALLOC_FL_PUNCH_HOLE) {\n\t\t\tloff_t endbyte = offset + length - 1;\n\t\t\terr = filemap_write_and_wait_range(inode->i_mapping,\n\t\t\t\t\t\t\t   offset, endbyte);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tfuse_sync_writes(inode);\n\t\t}\n\t}\n\n\tif (!(mode & FALLOC_FL_KEEP_SIZE))\n\t\tset_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\n\targs.in.h.opcode = FUSE_FALLOCATE;\n\targs.in.h.nodeid = ff->nodeid;\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (err == -ENOSYS) {\n\t\tfc->no_fallocate = 1;\n\t\terr = -EOPNOTSUPP;\n\t}\n\tif (err)\n\t\tgoto out;\n\n\t/* we could have extended the file */\n\tif (!(mode & FALLOC_FL_KEEP_SIZE)) {\n\t\tbool changed = fuse_write_update_size(inode, offset + length);\n\n\t\tif (changed && fc->writeback_cache)\n\t\t\tfile_update_time(file);\n\t}\n\n\tif (mode & FALLOC_FL_PUNCH_HOLE)\n\t\ttruncate_pagecache_range(inode, offset, offset + length - 1);\n\n\tfuse_invalidate_attr(inode);\n\nout:\n\tif (!(mode & FALLOC_FL_KEEP_SIZE))\n\t\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\n\tif (lock_inode)\n\t\tmutex_unlock(&inode->i_mutex);\n\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_direct_IO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "2800-2880",
    "snippet": "static ssize_t\nfuse_direct_IO(int rw, struct kiocb *iocb, struct iov_iter *iter,\n\t\t\tloff_t offset)\n{\n\tssize_t ret = 0;\n\tstruct file *file = iocb->ki_filp;\n\tstruct fuse_file *ff = file->private_data;\n\tbool async_dio = ff->fc->async_dio;\n\tloff_t pos = 0;\n\tstruct inode *inode;\n\tloff_t i_size;\n\tsize_t count = iov_iter_count(iter);\n\tstruct fuse_io_priv *io;\n\n\tpos = offset;\n\tinode = file->f_mapping->host;\n\ti_size = i_size_read(inode);\n\n\tif ((rw == READ) && (offset > i_size))\n\t\treturn 0;\n\n\t/* optimization for short read */\n\tif (async_dio && rw != WRITE && offset + count > i_size) {\n\t\tif (offset >= i_size)\n\t\t\treturn 0;\n\t\tcount = min_t(loff_t, count, fuse_round_up(i_size - offset));\n\t\tiov_iter_truncate(iter, count);\n\t}\n\n\tio = kmalloc(sizeof(struct fuse_io_priv), GFP_KERNEL);\n\tif (!io)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&io->lock);\n\tio->reqs = 1;\n\tio->bytes = -1;\n\tio->size = 0;\n\tio->offset = offset;\n\tio->write = (rw == WRITE);\n\tio->err = 0;\n\tio->file = file;\n\t/*\n\t * By default, we want to optimize all I/Os with async request\n\t * submission to the client filesystem if supported.\n\t */\n\tio->async = async_dio;\n\tio->iocb = iocb;\n\n\t/*\n\t * We cannot asynchronously extend the size of a file. We have no method\n\t * to wait on real async I/O requests, so we must submit this request\n\t * synchronously.\n\t */\n\tif (!is_sync_kiocb(iocb) && (offset + count > i_size) && rw == WRITE)\n\t\tio->async = false;\n\n\tif (rw == WRITE)\n\t\tret = __fuse_direct_write(io, iter, &pos);\n\telse\n\t\tret = __fuse_direct_read(io, iter, &pos);\n\n\tif (io->async) {\n\t\tfuse_aio_complete(io, ret < 0 ? ret : 0, -1);\n\n\t\t/* we have a non-extending, async request, so return */\n\t\tif (!is_sync_kiocb(iocb))\n\t\t\treturn -EIOCBQUEUED;\n\n\t\tret = wait_on_sync_kiocb(iocb);\n\t} else {\n\t\tkfree(io);\n\t}\n\n\tif (rw == WRITE) {\n\t\tif (ret > 0)\n\t\t\tfuse_write_update_size(inode, pos);\n\t\telse if (ret < 0 && offset + count > i_size)\n\t\t\tfuse_do_truncate(file);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_do_truncate",
          "args": [
            "file"
          ],
          "line": 2876
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_do_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "2781-2793",
          "snippet": "static void fuse_do_truncate(struct file *file)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct iattr attr;\n\n\tattr.ia_valid = ATTR_SIZE;\n\tattr.ia_size = i_size_read(inode);\n\n\tattr.ia_file = file;\n\tattr.ia_valid |= ATTR_FILE;\n\n\tfuse_do_setattr(inode, &attr, file);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_do_truncate(struct file *file)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct iattr attr;\n\n\tattr.ia_valid = ATTR_SIZE;\n\tattr.ia_size = i_size_read(inode);\n\n\tattr.ia_file = file;\n\tattr.ia_valid |= ATTR_FILE;\n\n\tfuse_do_setattr(inode, &attr, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_write_update_size",
          "args": [
            "inode",
            "pos"
          ],
          "line": 2874
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_write_update_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "957-972",
          "snippet": "bool fuse_write_update_size(struct inode *inode, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tbool ret = false;\n\n\tspin_lock(&fc->lock);\n\tfi->attr_version = ++fc->attr_version;\n\tif (pos > inode->i_size) {\n\t\ti_size_write(inode, pos);\n\t\tret = true;\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nbool fuse_write_update_size(struct inode *inode, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tbool ret = false;\n\n\tspin_lock(&fc->lock);\n\tfi->attr_version = ++fc->attr_version;\n\tif (pos > inode->i_size) {\n\t\ti_size_write(inode, pos);\n\t\tret = true;\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "io"
          ],
          "line": 2869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_sync_kiocb",
          "args": [
            "iocb"
          ],
          "line": 2867
        },
        "resolved": true,
        "details": {
          "function_name": "wait_on_sync_kiocb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "784-794",
          "snippet": "ssize_t wait_on_sync_kiocb(struct kiocb *req)\n{\n\twhile (!req->ki_ctx) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (req->ki_ctx)\n\t\t\tbreak;\n\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treturn req->ki_user_data;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nssize_t wait_on_sync_kiocb(struct kiocb *req)\n{\n\twhile (!req->ki_ctx) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (req->ki_ctx)\n\t\t\tbreak;\n\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treturn req->ki_user_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_sync_kiocb",
          "args": [
            "iocb"
          ],
          "line": 2864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_aio_complete",
          "args": [
            "io",
            "ret < 0 ? ret : 0",
            "-1"
          ],
          "line": 2861
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_aio_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "547-584",
          "snippet": "static void fuse_aio_complete(struct fuse_io_priv *io, int err, ssize_t pos)\n{\n\tint left;\n\n\tspin_lock(&io->lock);\n\tif (err)\n\t\tio->err = io->err ? : err;\n\telse if (pos >= 0 && (io->bytes < 0 || pos < io->bytes))\n\t\tio->bytes = pos;\n\n\tleft = --io->reqs;\n\tspin_unlock(&io->lock);\n\n\tif (!left) {\n\t\tlong res;\n\n\t\tif (io->err)\n\t\t\tres = io->err;\n\t\telse if (io->bytes >= 0 && io->write)\n\t\t\tres = -EIO;\n\t\telse {\n\t\t\tres = io->bytes < 0 ? io->size : io->bytes;\n\n\t\t\tif (!is_sync_kiocb(io->iocb)) {\n\t\t\t\tstruct inode *inode = file_inode(io->iocb->ki_filp);\n\t\t\t\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\t\t\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\t\t\tspin_lock(&fc->lock);\n\t\t\t\tfi->attr_version = ++fc->attr_version;\n\t\t\t\tspin_unlock(&fc->lock);\n\t\t\t}\n\t\t}\n\n\t\taio_complete(io->iocb, res, 0);\n\t\tkfree(io);\n\t}\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_aio_complete(struct fuse_io_priv *io, int err, ssize_t pos)\n{\n\tint left;\n\n\tspin_lock(&io->lock);\n\tif (err)\n\t\tio->err = io->err ? : err;\n\telse if (pos >= 0 && (io->bytes < 0 || pos < io->bytes))\n\t\tio->bytes = pos;\n\n\tleft = --io->reqs;\n\tspin_unlock(&io->lock);\n\n\tif (!left) {\n\t\tlong res;\n\n\t\tif (io->err)\n\t\t\tres = io->err;\n\t\telse if (io->bytes >= 0 && io->write)\n\t\t\tres = -EIO;\n\t\telse {\n\t\t\tres = io->bytes < 0 ? io->size : io->bytes;\n\n\t\t\tif (!is_sync_kiocb(io->iocb)) {\n\t\t\t\tstruct inode *inode = file_inode(io->iocb->ki_filp);\n\t\t\t\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\t\t\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\t\t\tspin_lock(&fc->lock);\n\t\t\t\tfi->attr_version = ++fc->attr_version;\n\t\t\t\tspin_unlock(&fc->lock);\n\t\t\t}\n\t\t}\n\n\t\taio_complete(io->iocb, res, 0);\n\t\tkfree(io);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fuse_direct_read",
          "args": [
            "io",
            "iter",
            "&pos"
          ],
          "line": 2858
        },
        "resolved": true,
        "details": {
          "function_name": "__fuse_direct_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1380-1396",
          "snippet": "static ssize_t __fuse_direct_read(struct fuse_io_priv *io,\n\t\t\t\t  struct iov_iter *iter,\n\t\t\t\t  loff_t *ppos)\n{\n\tssize_t res;\n\tstruct file *file = io->file;\n\tstruct inode *inode = file_inode(file);\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tres = fuse_direct_io(io, iter, ppos, 0);\n\n\tfuse_invalidate_attr(inode);\n\n\treturn res;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t __fuse_direct_read(struct fuse_io_priv *io,\n\t\t\t\t  struct iov_iter *iter,\n\t\t\t\t  loff_t *ppos)\n{\n\tssize_t res;\n\tstruct file *file = io->file;\n\tstruct inode *inode = file_inode(file);\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tres = fuse_direct_io(io, iter, ppos, 0);\n\n\tfuse_invalidate_attr(inode);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fuse_direct_write",
          "args": [
            "io",
            "iter",
            "&pos"
          ],
          "line": 2856
        },
        "resolved": true,
        "details": {
          "function_name": "__fuse_direct_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1408-1427",
          "snippet": "static ssize_t __fuse_direct_write(struct fuse_io_priv *io,\n\t\t\t\t   struct iov_iter *iter,\n\t\t\t\t   loff_t *ppos)\n{\n\tstruct file *file = io->file;\n\tstruct inode *inode = file_inode(file);\n\tsize_t count = iov_iter_count(iter);\n\tssize_t res;\n\n\n\tres = generic_write_checks(file, ppos, &count, 0);\n\tif (!res) {\n\t\tiov_iter_truncate(iter, count);\n\t\tres = fuse_direct_io(io, iter, ppos, FUSE_DIO_WRITE);\n\t}\n\n\tfuse_invalidate_attr(inode);\n\n\treturn res;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t __fuse_direct_write(struct fuse_io_priv *io,\n\t\t\t\t   struct iov_iter *iter,\n\t\t\t\t   loff_t *ppos)\n{\n\tstruct file *file = io->file;\n\tstruct inode *inode = file_inode(file);\n\tsize_t count = iov_iter_count(iter);\n\tssize_t res;\n\n\n\tres = generic_write_checks(file, ppos, &count, 0);\n\tif (!res) {\n\t\tiov_iter_truncate(iter, count);\n\t\tres = fuse_direct_io(io, iter, ppos, FUSE_DIO_WRITE);\n\t}\n\n\tfuse_invalidate_attr(inode);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_sync_kiocb",
          "args": [
            "iocb"
          ],
          "line": 2852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&io->lock"
          ],
          "line": 2832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct fuse_io_priv)",
            "GFP_KERNEL"
          ],
          "line": 2829
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_truncate",
          "args": [
            "iter",
            "count"
          ],
          "line": 2826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "loff_t",
            "count",
            "fuse_round_up(i_size - offset)"
          ],
          "line": 2825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_round_up",
          "args": [
            "i_size - offset"
          ],
          "line": 2825
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_round_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "2795-2798",
          "snippet": "static inline loff_t fuse_round_up(loff_t off)\n{\n\treturn round_up(off, FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline loff_t fuse_round_up(loff_t off)\n{\n\treturn round_up(off, FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 2811
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t\nfuse_direct_IO(int rw, struct kiocb *iocb, struct iov_iter *iter,\n\t\t\tloff_t offset)\n{\n\tssize_t ret = 0;\n\tstruct file *file = iocb->ki_filp;\n\tstruct fuse_file *ff = file->private_data;\n\tbool async_dio = ff->fc->async_dio;\n\tloff_t pos = 0;\n\tstruct inode *inode;\n\tloff_t i_size;\n\tsize_t count = iov_iter_count(iter);\n\tstruct fuse_io_priv *io;\n\n\tpos = offset;\n\tinode = file->f_mapping->host;\n\ti_size = i_size_read(inode);\n\n\tif ((rw == READ) && (offset > i_size))\n\t\treturn 0;\n\n\t/* optimization for short read */\n\tif (async_dio && rw != WRITE && offset + count > i_size) {\n\t\tif (offset >= i_size)\n\t\t\treturn 0;\n\t\tcount = min_t(loff_t, count, fuse_round_up(i_size - offset));\n\t\tiov_iter_truncate(iter, count);\n\t}\n\n\tio = kmalloc(sizeof(struct fuse_io_priv), GFP_KERNEL);\n\tif (!io)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&io->lock);\n\tio->reqs = 1;\n\tio->bytes = -1;\n\tio->size = 0;\n\tio->offset = offset;\n\tio->write = (rw == WRITE);\n\tio->err = 0;\n\tio->file = file;\n\t/*\n\t * By default, we want to optimize all I/Os with async request\n\t * submission to the client filesystem if supported.\n\t */\n\tio->async = async_dio;\n\tio->iocb = iocb;\n\n\t/*\n\t * We cannot asynchronously extend the size of a file. We have no method\n\t * to wait on real async I/O requests, so we must submit this request\n\t * synchronously.\n\t */\n\tif (!is_sync_kiocb(iocb) && (offset + count > i_size) && rw == WRITE)\n\t\tio->async = false;\n\n\tif (rw == WRITE)\n\t\tret = __fuse_direct_write(io, iter, &pos);\n\telse\n\t\tret = __fuse_direct_read(io, iter, &pos);\n\n\tif (io->async) {\n\t\tfuse_aio_complete(io, ret < 0 ? ret : 0, -1);\n\n\t\t/* we have a non-extending, async request, so return */\n\t\tif (!is_sync_kiocb(iocb))\n\t\t\treturn -EIOCBQUEUED;\n\n\t\tret = wait_on_sync_kiocb(iocb);\n\t} else {\n\t\tkfree(io);\n\t}\n\n\tif (rw == WRITE) {\n\t\tif (ret > 0)\n\t\t\tfuse_write_update_size(inode, pos);\n\t\telse if (ret < 0 && offset + count > i_size)\n\t\t\tfuse_do_truncate(file);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fuse_round_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "2795-2798",
    "snippet": "static inline loff_t fuse_round_up(loff_t off)\n{\n\treturn round_up(off, FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "off",
            "FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT"
          ],
          "line": 2797
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline loff_t fuse_round_up(loff_t off)\n{\n\treturn round_up(off, FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT);\n}"
  },
  {
    "function_name": "fuse_do_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "2781-2793",
    "snippet": "static void fuse_do_truncate(struct file *file)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct iattr attr;\n\n\tattr.ia_valid = ATTR_SIZE;\n\tattr.ia_size = i_size_read(inode);\n\n\tattr.ia_file = file;\n\tattr.ia_valid |= ATTR_FILE;\n\n\tfuse_do_setattr(inode, &attr, file);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_do_setattr",
          "args": [
            "inode",
            "&attr",
            "file"
          ],
          "line": 2792
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_do_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "1605-1711",
          "snippet": "int fuse_do_setattr(struct inode *inode, struct iattr *attr,\n\t\t    struct file *file)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_setattr_in inarg;\n\tstruct fuse_attr_out outarg;\n\tbool is_truncate = false;\n\tbool is_wb = fc->writeback_cache;\n\tloff_t oldsize;\n\tint err;\n\tbool trust_local_cmtime = is_wb && S_ISREG(inode->i_mode);\n\n\tif (!(fc->flags & FUSE_DEFAULT_PERMISSIONS))\n\t\tattr->ia_valid |= ATTR_FORCE;\n\n\terr = inode_change_ok(inode, attr);\n\tif (err)\n\t\treturn err;\n\n\tif (attr->ia_valid & ATTR_OPEN) {\n\t\tif (fc->atomic_o_trunc)\n\t\t\treturn 0;\n\t\tfile = NULL;\n\t}\n\n\tif (attr->ia_valid & ATTR_SIZE)\n\t\tis_truncate = true;\n\n\tif (is_truncate) {\n\t\tfuse_set_nowrite(inode);\n\t\tset_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\t\tif (trust_local_cmtime && attr->ia_size != inode->i_size)\n\t\t\tattr->ia_valid |= ATTR_MTIME | ATTR_CTIME;\n\t}\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outarg, 0, sizeof(outarg));\n\tiattr_to_fattr(attr, &inarg, trust_local_cmtime);\n\tif (file) {\n\t\tstruct fuse_file *ff = file->private_data;\n\t\tinarg.valid |= FATTR_FH;\n\t\tinarg.fh = ff->fh;\n\t}\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\t/* For mandatory locking in truncate */\n\t\tinarg.valid |= FATTR_LOCKOWNER;\n\t\tinarg.lock_owner = fuse_lock_owner_id(fc, current->files);\n\t}\n\tfuse_setattr_fill(fc, &args, inode, &inarg, &outarg);\n\terr = fuse_simple_request(fc, &args);\n\tif (err) {\n\t\tif (err == -EINTR)\n\t\t\tfuse_invalidate_attr(inode);\n\t\tgoto error;\n\t}\n\n\tif ((inode->i_mode ^ outarg.attr.mode) & S_IFMT) {\n\t\tmake_bad_inode(inode);\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\n\tspin_lock(&fc->lock);\n\t/* the kernel maintains i_mtime locally */\n\tif (trust_local_cmtime) {\n\t\tif (attr->ia_valid & ATTR_MTIME)\n\t\t\tinode->i_mtime = attr->ia_mtime;\n\t\tif (attr->ia_valid & ATTR_CTIME)\n\t\t\tinode->i_ctime = attr->ia_ctime;\n\t\t/* FIXME: clear I_DIRTY_SYNC? */\n\t}\n\n\tfuse_change_attributes_common(inode, &outarg.attr,\n\t\t\t\t      attr_timeout(&outarg));\n\toldsize = inode->i_size;\n\t/* see the comment in fuse_change_attributes() */\n\tif (!is_wb || is_truncate || !S_ISREG(inode->i_mode))\n\t\ti_size_write(inode, outarg.attr.size);\n\n\tif (is_truncate) {\n\t\t/* NOTE: this may release/reacquire fc->lock */\n\t\t__fuse_release_nowrite(inode);\n\t}\n\tspin_unlock(&fc->lock);\n\n\t/*\n\t * Only call invalidate_inode_pages2() after removing\n\t * FUSE_NOWRITE, otherwise fuse_launder_page() would deadlock.\n\t */\n\tif ((is_truncate || !is_wb) &&\n\t    S_ISREG(inode->i_mode) && oldsize != outarg.attr.size) {\n\t\ttruncate_pagecache(inode, outarg.attr.size);\n\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t}\n\n\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\treturn 0;\n\nerror:\n\tif (is_truncate)\n\t\tfuse_release_nowrite(inode);\n\n\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_do_setattr(struct inode *inode, struct iattr *attr,\n\t\t    struct file *file)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_setattr_in inarg;\n\tstruct fuse_attr_out outarg;\n\tbool is_truncate = false;\n\tbool is_wb = fc->writeback_cache;\n\tloff_t oldsize;\n\tint err;\n\tbool trust_local_cmtime = is_wb && S_ISREG(inode->i_mode);\n\n\tif (!(fc->flags & FUSE_DEFAULT_PERMISSIONS))\n\t\tattr->ia_valid |= ATTR_FORCE;\n\n\terr = inode_change_ok(inode, attr);\n\tif (err)\n\t\treturn err;\n\n\tif (attr->ia_valid & ATTR_OPEN) {\n\t\tif (fc->atomic_o_trunc)\n\t\t\treturn 0;\n\t\tfile = NULL;\n\t}\n\n\tif (attr->ia_valid & ATTR_SIZE)\n\t\tis_truncate = true;\n\n\tif (is_truncate) {\n\t\tfuse_set_nowrite(inode);\n\t\tset_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\t\tif (trust_local_cmtime && attr->ia_size != inode->i_size)\n\t\t\tattr->ia_valid |= ATTR_MTIME | ATTR_CTIME;\n\t}\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outarg, 0, sizeof(outarg));\n\tiattr_to_fattr(attr, &inarg, trust_local_cmtime);\n\tif (file) {\n\t\tstruct fuse_file *ff = file->private_data;\n\t\tinarg.valid |= FATTR_FH;\n\t\tinarg.fh = ff->fh;\n\t}\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\t/* For mandatory locking in truncate */\n\t\tinarg.valid |= FATTR_LOCKOWNER;\n\t\tinarg.lock_owner = fuse_lock_owner_id(fc, current->files);\n\t}\n\tfuse_setattr_fill(fc, &args, inode, &inarg, &outarg);\n\terr = fuse_simple_request(fc, &args);\n\tif (err) {\n\t\tif (err == -EINTR)\n\t\t\tfuse_invalidate_attr(inode);\n\t\tgoto error;\n\t}\n\n\tif ((inode->i_mode ^ outarg.attr.mode) & S_IFMT) {\n\t\tmake_bad_inode(inode);\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\n\tspin_lock(&fc->lock);\n\t/* the kernel maintains i_mtime locally */\n\tif (trust_local_cmtime) {\n\t\tif (attr->ia_valid & ATTR_MTIME)\n\t\t\tinode->i_mtime = attr->ia_mtime;\n\t\tif (attr->ia_valid & ATTR_CTIME)\n\t\t\tinode->i_ctime = attr->ia_ctime;\n\t\t/* FIXME: clear I_DIRTY_SYNC? */\n\t}\n\n\tfuse_change_attributes_common(inode, &outarg.attr,\n\t\t\t\t      attr_timeout(&outarg));\n\toldsize = inode->i_size;\n\t/* see the comment in fuse_change_attributes() */\n\tif (!is_wb || is_truncate || !S_ISREG(inode->i_mode))\n\t\ti_size_write(inode, outarg.attr.size);\n\n\tif (is_truncate) {\n\t\t/* NOTE: this may release/reacquire fc->lock */\n\t\t__fuse_release_nowrite(inode);\n\t}\n\tspin_unlock(&fc->lock);\n\n\t/*\n\t * Only call invalidate_inode_pages2() after removing\n\t * FUSE_NOWRITE, otherwise fuse_launder_page() would deadlock.\n\t */\n\tif ((is_truncate || !is_wb) &&\n\t    S_ISREG(inode->i_mode) && oldsize != outarg.attr.size) {\n\t\ttruncate_pagecache(inode, outarg.attr.size);\n\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t}\n\n\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\treturn 0;\n\nerror:\n\tif (is_truncate)\n\t\tfuse_release_nowrite(inode);\n\n\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_do_truncate(struct file *file)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct iattr attr;\n\n\tattr.ia_valid = ATTR_SIZE;\n\tattr.ia_size = i_size_read(inode);\n\n\tattr.ia_file = file;\n\tattr.ia_valid |= ATTR_FILE;\n\n\tfuse_do_setattr(inode, &attr, file);\n}"
  },
  {
    "function_name": "fuse_notify_poll_wakeup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "2761-2779",
    "snippet": "int fuse_notify_poll_wakeup(struct fuse_conn *fc,\n\t\t\t    struct fuse_notify_poll_wakeup_out *outarg)\n{\n\tu64 kh = outarg->kh;\n\tstruct rb_node **link;\n\n\tspin_lock(&fc->lock);\n\n\tlink = fuse_find_polled_node(fc, kh, NULL);\n\tif (*link) {\n\t\tstruct fuse_file *ff;\n\n\t\tff = rb_entry(*link, struct fuse_file, polled_node);\n\t\twake_up_interruptible_sync(&ff->poll_wait);\n\t}\n\n\tspin_unlock(&fc->lock);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 2777
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible_sync",
          "args": [
            "&ff->poll_wait"
          ],
          "line": 2774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "*link",
            "structfuse_file",
            "polled_node"
          ],
          "line": 2773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_find_polled_node",
          "args": [
            "fc",
            "kh",
            "NULL"
          ],
          "line": 2769
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_find_polled_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "2667-2690",
          "snippet": "static struct rb_node **fuse_find_polled_node(struct fuse_conn *fc, u64 kh,\n\t\t\t\t\t      struct rb_node **parent_out)\n{\n\tstruct rb_node **link = &fc->polled_files.rb_node;\n\tstruct rb_node *last = NULL;\n\n\twhile (*link) {\n\t\tstruct fuse_file *ff;\n\n\t\tlast = *link;\n\t\tff = rb_entry(last, struct fuse_file, polled_node);\n\n\t\tif (kh < ff->kh)\n\t\t\tlink = &last->rb_left;\n\t\telse if (kh > ff->kh)\n\t\t\tlink = &last->rb_right;\n\t\telse\n\t\t\treturn link;\n\t}\n\n\tif (parent_out)\n\t\t*parent_out = last;\n\treturn link;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct rb_node **fuse_find_polled_node(struct fuse_conn *fc, u64 kh,\n\t\t\t\t\t      struct rb_node **parent_out)\n{\n\tstruct rb_node **link = &fc->polled_files.rb_node;\n\tstruct rb_node *last = NULL;\n\n\twhile (*link) {\n\t\tstruct fuse_file *ff;\n\n\t\tlast = *link;\n\t\tff = rb_entry(last, struct fuse_file, polled_node);\n\n\t\tif (kh < ff->kh)\n\t\t\tlink = &last->rb_left;\n\t\telse if (kh > ff->kh)\n\t\t\tlink = &last->rb_right;\n\t\telse\n\t\t\treturn link;\n\t}\n\n\tif (parent_out)\n\t\t*parent_out = last;\n\treturn link;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 2767
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_notify_poll_wakeup(struct fuse_conn *fc,\n\t\t\t    struct fuse_notify_poll_wakeup_out *outarg)\n{\n\tu64 kh = outarg->kh;\n\tstruct rb_node **link;\n\n\tspin_lock(&fc->lock);\n\n\tlink = fuse_find_polled_node(fc, kh, NULL);\n\tif (*link) {\n\t\tstruct fuse_file *ff;\n\n\t\tff = rb_entry(*link, struct fuse_file, polled_node);\n\t\twake_up_interruptible_sync(&ff->poll_wait);\n\t}\n\n\tspin_unlock(&fc->lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "fuse_file_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "2713-2754",
    "snippet": "unsigned fuse_file_poll(struct file *file, poll_table *wait)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_poll_in inarg = { .fh = ff->fh, .kh = ff->kh };\n\tstruct fuse_poll_out outarg;\n\tFUSE_ARGS(args);\n\tint err;\n\n\tif (fc->no_poll)\n\t\treturn DEFAULT_POLLMASK;\n\n\tpoll_wait(file, &ff->poll_wait, wait);\n\tinarg.events = (__u32)poll_requested_events(wait);\n\n\t/*\n\t * Ask for notification iff there's someone waiting for it.\n\t * The client may ignore the flag and always notify.\n\t */\n\tif (waitqueue_active(&ff->poll_wait)) {\n\t\tinarg.flags |= FUSE_POLL_SCHEDULE_NOTIFY;\n\t\tfuse_register_polled_file(fc, ff);\n\t}\n\n\targs.in.h.opcode = FUSE_POLL;\n\targs.in.h.nodeid = ff->nodeid;\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.out.numargs = 1;\n\targs.out.args[0].size = sizeof(outarg);\n\targs.out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, &args);\n\n\tif (!err)\n\t\treturn outarg.revents;\n\tif (err == -ENOSYS) {\n\t\tfc->no_poll = 1;\n\t\treturn DEFAULT_POLLMASK;\n\t}\n\treturn POLLERR;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_simple_request",
          "args": [
            "fc",
            "&args"
          ],
          "line": 2745
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_simple_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "558-588",
          "snippet": "ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_register_polled_file",
          "args": [
            "fc",
            "ff"
          ],
          "line": 2734
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_register_polled_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "2698-2711",
          "snippet": "static void fuse_register_polled_file(struct fuse_conn *fc,\n\t\t\t\t      struct fuse_file *ff)\n{\n\tspin_lock(&fc->lock);\n\tif (RB_EMPTY_NODE(&ff->polled_node)) {\n\t\tstruct rb_node **link, *uninitialized_var(parent);\n\n\t\tlink = fuse_find_polled_node(fc, ff->kh, &parent);\n\t\tBUG_ON(*link);\n\t\trb_link_node(&ff->polled_node, parent, link);\n\t\trb_insert_color(&ff->polled_node, &fc->polled_files);\n\t}\n\tspin_unlock(&fc->lock);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_register_polled_file(struct fuse_conn *fc,\n\t\t\t\t      struct fuse_file *ff)\n{\n\tspin_lock(&fc->lock);\n\tif (RB_EMPTY_NODE(&ff->polled_node)) {\n\t\tstruct rb_node **link, *uninitialized_var(parent);\n\n\t\tlink = fuse_find_polled_node(fc, ff->kh, &parent);\n\t\tBUG_ON(*link);\n\t\trb_link_node(&ff->polled_node, parent, link);\n\t\trb_insert_color(&ff->polled_node, &fc->polled_files);\n\t}\n\tspin_unlock(&fc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ff->poll_wait"
          ],
          "line": 2732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll_requested_events",
          "args": [
            "wait"
          ],
          "line": 2726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "file",
            "&ff->poll_wait",
            "wait"
          ],
          "line": 2725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUSE_ARGS",
          "args": [
            "args"
          ],
          "line": 2719
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nunsigned fuse_file_poll(struct file *file, poll_table *wait)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_poll_in inarg = { .fh = ff->fh, .kh = ff->kh };\n\tstruct fuse_poll_out outarg;\n\tFUSE_ARGS(args);\n\tint err;\n\n\tif (fc->no_poll)\n\t\treturn DEFAULT_POLLMASK;\n\n\tpoll_wait(file, &ff->poll_wait, wait);\n\tinarg.events = (__u32)poll_requested_events(wait);\n\n\t/*\n\t * Ask for notification iff there's someone waiting for it.\n\t * The client may ignore the flag and always notify.\n\t */\n\tif (waitqueue_active(&ff->poll_wait)) {\n\t\tinarg.flags |= FUSE_POLL_SCHEDULE_NOTIFY;\n\t\tfuse_register_polled_file(fc, ff);\n\t}\n\n\targs.in.h.opcode = FUSE_POLL;\n\targs.in.h.nodeid = ff->nodeid;\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.out.numargs = 1;\n\targs.out.args[0].size = sizeof(outarg);\n\targs.out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, &args);\n\n\tif (!err)\n\t\treturn outarg.revents;\n\tif (err == -ENOSYS) {\n\t\tfc->no_poll = 1;\n\t\treturn DEFAULT_POLLMASK;\n\t}\n\treturn POLLERR;\n}"
  },
  {
    "function_name": "fuse_register_polled_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "2698-2711",
    "snippet": "static void fuse_register_polled_file(struct fuse_conn *fc,\n\t\t\t\t      struct fuse_file *ff)\n{\n\tspin_lock(&fc->lock);\n\tif (RB_EMPTY_NODE(&ff->polled_node)) {\n\t\tstruct rb_node **link, *uninitialized_var(parent);\n\n\t\tlink = fuse_find_polled_node(fc, ff->kh, &parent);\n\t\tBUG_ON(*link);\n\t\trb_link_node(&ff->polled_node, parent, link);\n\t\trb_insert_color(&ff->polled_node, &fc->polled_files);\n\t}\n\tspin_unlock(&fc->lock);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 2710
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&ff->polled_node",
            "&fc->polled_files"
          ],
          "line": 2708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&ff->polled_node",
            "parent",
            "link"
          ],
          "line": 2707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "*link"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_find_polled_node",
          "args": [
            "fc",
            "ff->kh",
            "&parent"
          ],
          "line": 2705
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_find_polled_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "2667-2690",
          "snippet": "static struct rb_node **fuse_find_polled_node(struct fuse_conn *fc, u64 kh,\n\t\t\t\t\t      struct rb_node **parent_out)\n{\n\tstruct rb_node **link = &fc->polled_files.rb_node;\n\tstruct rb_node *last = NULL;\n\n\twhile (*link) {\n\t\tstruct fuse_file *ff;\n\n\t\tlast = *link;\n\t\tff = rb_entry(last, struct fuse_file, polled_node);\n\n\t\tif (kh < ff->kh)\n\t\t\tlink = &last->rb_left;\n\t\telse if (kh > ff->kh)\n\t\t\tlink = &last->rb_right;\n\t\telse\n\t\t\treturn link;\n\t}\n\n\tif (parent_out)\n\t\t*parent_out = last;\n\treturn link;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct rb_node **fuse_find_polled_node(struct fuse_conn *fc, u64 kh,\n\t\t\t\t\t      struct rb_node **parent_out)\n{\n\tstruct rb_node **link = &fc->polled_files.rb_node;\n\tstruct rb_node *last = NULL;\n\n\twhile (*link) {\n\t\tstruct fuse_file *ff;\n\n\t\tlast = *link;\n\t\tff = rb_entry(last, struct fuse_file, polled_node);\n\n\t\tif (kh < ff->kh)\n\t\t\tlink = &last->rb_left;\n\t\telse if (kh > ff->kh)\n\t\t\tlink = &last->rb_right;\n\t\telse\n\t\t\treturn link;\n\t}\n\n\tif (parent_out)\n\t\t*parent_out = last;\n\treturn link;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&ff->polled_node"
          ],
          "line": 2702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 2701
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_register_polled_file(struct fuse_conn *fc,\n\t\t\t\t      struct fuse_file *ff)\n{\n\tspin_lock(&fc->lock);\n\tif (RB_EMPTY_NODE(&ff->polled_node)) {\n\t\tstruct rb_node **link, *uninitialized_var(parent);\n\n\t\tlink = fuse_find_polled_node(fc, ff->kh, &parent);\n\t\tBUG_ON(*link);\n\t\trb_link_node(&ff->polled_node, parent, link);\n\t\trb_insert_color(&ff->polled_node, &fc->polled_files);\n\t}\n\tspin_unlock(&fc->lock);\n}"
  },
  {
    "function_name": "fuse_find_polled_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "2667-2690",
    "snippet": "static struct rb_node **fuse_find_polled_node(struct fuse_conn *fc, u64 kh,\n\t\t\t\t\t      struct rb_node **parent_out)\n{\n\tstruct rb_node **link = &fc->polled_files.rb_node;\n\tstruct rb_node *last = NULL;\n\n\twhile (*link) {\n\t\tstruct fuse_file *ff;\n\n\t\tlast = *link;\n\t\tff = rb_entry(last, struct fuse_file, polled_node);\n\n\t\tif (kh < ff->kh)\n\t\t\tlink = &last->rb_left;\n\t\telse if (kh > ff->kh)\n\t\t\tlink = &last->rb_right;\n\t\telse\n\t\t\treturn link;\n\t}\n\n\tif (parent_out)\n\t\t*parent_out = last;\n\treturn link;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "last",
            "structfuse_file",
            "polled_node"
          ],
          "line": 2677
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct rb_node **fuse_find_polled_node(struct fuse_conn *fc, u64 kh,\n\t\t\t\t\t      struct rb_node **parent_out)\n{\n\tstruct rb_node **link = &fc->polled_files.rb_node;\n\tstruct rb_node *last = NULL;\n\n\twhile (*link) {\n\t\tstruct fuse_file *ff;\n\n\t\tlast = *link;\n\t\tff = rb_entry(last, struct fuse_file, polled_node);\n\n\t\tif (kh < ff->kh)\n\t\t\tlink = &last->rb_left;\n\t\telse if (kh > ff->kh)\n\t\t\tlink = &last->rb_right;\n\t\telse\n\t\t\treturn link;\n\t}\n\n\tif (parent_out)\n\t\t*parent_out = last;\n\treturn link;\n}"
  },
  {
    "function_name": "fuse_file_compat_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "2656-2660",
    "snippet": "static long fuse_file_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t   unsigned long arg)\n{\n\treturn fuse_ioctl_common(file, cmd, arg, FUSE_IOCTL_COMPAT);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_ioctl_common",
          "args": [
            "file",
            "cmd",
            "arg",
            "FUSE_IOCTL_COMPAT"
          ],
          "line": 2659
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_ioctl_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "2635-2648",
          "snippet": "long fuse_ioctl_common(struct file *file, unsigned int cmd,\n\t\t       unsigned long arg, unsigned int flags)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (!fuse_allow_current_process(fc))\n\t\treturn -EACCES;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\treturn fuse_do_ioctl(file, cmd, arg, flags);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nlong fuse_ioctl_common(struct file *file, unsigned int cmd,\n\t\t       unsigned long arg, unsigned int flags)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (!fuse_allow_current_process(fc))\n\t\treturn -EACCES;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\treturn fuse_do_ioctl(file, cmd, arg, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic long fuse_file_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t   unsigned long arg)\n{\n\treturn fuse_ioctl_common(file, cmd, arg, FUSE_IOCTL_COMPAT);\n}"
  },
  {
    "function_name": "fuse_file_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "2650-2654",
    "snippet": "static long fuse_file_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\treturn fuse_ioctl_common(file, cmd, arg, 0);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_ioctl_common",
          "args": [
            "file",
            "cmd",
            "arg",
            "0"
          ],
          "line": 2653
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_ioctl_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "2635-2648",
          "snippet": "long fuse_ioctl_common(struct file *file, unsigned int cmd,\n\t\t       unsigned long arg, unsigned int flags)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (!fuse_allow_current_process(fc))\n\t\treturn -EACCES;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\treturn fuse_do_ioctl(file, cmd, arg, flags);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nlong fuse_ioctl_common(struct file *file, unsigned int cmd,\n\t\t       unsigned long arg, unsigned int flags)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (!fuse_allow_current_process(fc))\n\t\treturn -EACCES;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\treturn fuse_do_ioctl(file, cmd, arg, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic long fuse_file_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\treturn fuse_ioctl_common(file, cmd, arg, 0);\n}"
  },
  {
    "function_name": "fuse_ioctl_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "2635-2648",
    "snippet": "long fuse_ioctl_common(struct file *file, unsigned int cmd,\n\t\t       unsigned long arg, unsigned int flags)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (!fuse_allow_current_process(fc))\n\t\treturn -EACCES;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\treturn fuse_do_ioctl(file, cmd, arg, flags);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_do_ioctl",
          "args": [
            "file",
            "cmd",
            "arg",
            "flags"
          ],
          "line": 2647
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_do_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "2453-2632",
          "snippet": "long fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,\n\t\t   unsigned int flags)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_ioctl_in inarg = {\n\t\t.fh = ff->fh,\n\t\t.cmd = cmd,\n\t\t.arg = arg,\n\t\t.flags = flags\n\t};\n\tstruct fuse_ioctl_out outarg;\n\tstruct fuse_req *req = NULL;\n\tstruct page **pages = NULL;\n\tstruct iovec *iov_page = NULL;\n\tstruct iovec *in_iov = NULL, *out_iov = NULL;\n\tunsigned int in_iovs = 0, out_iovs = 0, num_pages = 0, max_pages;\n\tsize_t in_size, out_size, transferred;\n\tint err;\n\n#if BITS_PER_LONG == 32\n\tinarg.flags |= FUSE_IOCTL_32BIT;\n#else\n\tif (flags & FUSE_IOCTL_COMPAT)\n\t\tinarg.flags |= FUSE_IOCTL_32BIT;\n#endif\n\n\t/* assume all the iovs returned by client always fits in a page */\n\tBUILD_BUG_ON(sizeof(struct fuse_ioctl_iovec) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE);\n\n\terr = -ENOMEM;\n\tpages = kcalloc(FUSE_MAX_PAGES_PER_REQ, sizeof(pages[0]), GFP_KERNEL);\n\tiov_page = (struct iovec *) __get_free_page(GFP_KERNEL);\n\tif (!pages || !iov_page)\n\t\tgoto out;\n\n\t/*\n\t * If restricted, initialize IO parameters as encoded in @cmd.\n\t * RETRY from server is not allowed.\n\t */\n\tif (!(flags & FUSE_IOCTL_UNRESTRICTED)) {\n\t\tstruct iovec *iov = iov_page;\n\n\t\tiov->iov_base = (void __user *)arg;\n\t\tiov->iov_len = _IOC_SIZE(cmd);\n\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tin_iov = iov;\n\t\t\tin_iovs = 1;\n\t\t}\n\n\t\tif (_IOC_DIR(cmd) & _IOC_READ) {\n\t\t\tout_iov = iov;\n\t\t\tout_iovs = 1;\n\t\t}\n\t}\n\n retry:\n\tinarg.in_size = in_size = iov_length(in_iov, in_iovs);\n\tinarg.out_size = out_size = iov_length(out_iov, out_iovs);\n\n\t/*\n\t * Out data can be used either for actual out data or iovs,\n\t * make sure there always is at least one page.\n\t */\n\tout_size = max_t(size_t, out_size, PAGE_SIZE);\n\tmax_pages = DIV_ROUND_UP(max(in_size, out_size), PAGE_SIZE);\n\n\t/* make sure there are enough buffer pages and init request with them */\n\terr = -ENOMEM;\n\tif (max_pages > FUSE_MAX_PAGES_PER_REQ)\n\t\tgoto out;\n\twhile (num_pages < max_pages) {\n\t\tpages[num_pages] = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);\n\t\tif (!pages[num_pages])\n\t\t\tgoto out;\n\t\tnum_pages++;\n\t}\n\n\treq = fuse_get_req(fc, num_pages);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\treq = NULL;\n\t\tgoto out;\n\t}\n\tmemcpy(req->pages, pages, sizeof(req->pages[0]) * num_pages);\n\treq->num_pages = num_pages;\n\tfuse_page_descs_length_init(req, 0, req->num_pages);\n\n\t/* okay, let's send it to the client */\n\treq->in.h.opcode = FUSE_IOCTL;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\tif (in_size) {\n\t\treq->in.numargs++;\n\t\treq->in.args[1].size = in_size;\n\t\treq->in.argpages = 1;\n\n\t\terr = fuse_ioctl_copy_user(pages, in_iov, in_iovs, in_size,\n\t\t\t\t\t   false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\treq->out.numargs = 2;\n\treq->out.args[0].size = sizeof(outarg);\n\treq->out.args[0].value = &outarg;\n\treq->out.args[1].size = out_size;\n\treq->out.argpages = 1;\n\treq->out.argvar = 1;\n\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\ttransferred = req->out.args[1].size;\n\tfuse_put_request(fc, req);\n\treq = NULL;\n\tif (err)\n\t\tgoto out;\n\n\t/* did it ask for retry? */\n\tif (outarg.flags & FUSE_IOCTL_RETRY) {\n\t\tvoid *vaddr;\n\n\t\t/* no retry if in restricted mode */\n\t\terr = -EIO;\n\t\tif (!(flags & FUSE_IOCTL_UNRESTRICTED))\n\t\t\tgoto out;\n\n\t\tin_iovs = outarg.in_iovs;\n\t\tout_iovs = outarg.out_iovs;\n\n\t\t/*\n\t\t * Make sure things are in boundary, separate checks\n\t\t * are to protect against overflow.\n\t\t */\n\t\terr = -ENOMEM;\n\t\tif (in_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    out_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV)\n\t\t\tgoto out;\n\n\t\tvaddr = kmap_atomic(pages[0]);\n\t\terr = fuse_copy_ioctl_iovec(fc, iov_page, vaddr,\n\t\t\t\t\t    transferred, in_iovs + out_iovs,\n\t\t\t\t\t    (flags & FUSE_IOCTL_COMPAT) != 0);\n\t\tkunmap_atomic(vaddr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tin_iov = iov_page;\n\t\tout_iov = in_iov + in_iovs;\n\n\t\terr = fuse_verify_ioctl_iov(in_iov, in_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = fuse_verify_ioctl_iov(out_iov, out_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tgoto retry;\n\t}\n\n\terr = -EIO;\n\tif (transferred > inarg.out_size)\n\t\tgoto out;\n\n\terr = fuse_ioctl_copy_user(pages, out_iov, out_iovs, transferred, true);\n out:\n\tif (req)\n\t\tfuse_put_request(fc, req);\n\tfree_page((unsigned long) iov_page);\n\twhile (num_pages)\n\t\t__free_page(pages[--num_pages]);\n\tkfree(pages);\n\n\treturn err ? err : outarg.result;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nlong fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,\n\t\t   unsigned int flags)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_ioctl_in inarg = {\n\t\t.fh = ff->fh,\n\t\t.cmd = cmd,\n\t\t.arg = arg,\n\t\t.flags = flags\n\t};\n\tstruct fuse_ioctl_out outarg;\n\tstruct fuse_req *req = NULL;\n\tstruct page **pages = NULL;\n\tstruct iovec *iov_page = NULL;\n\tstruct iovec *in_iov = NULL, *out_iov = NULL;\n\tunsigned int in_iovs = 0, out_iovs = 0, num_pages = 0, max_pages;\n\tsize_t in_size, out_size, transferred;\n\tint err;\n\n#if BITS_PER_LONG == 32\n\tinarg.flags |= FUSE_IOCTL_32BIT;\n#else\n\tif (flags & FUSE_IOCTL_COMPAT)\n\t\tinarg.flags |= FUSE_IOCTL_32BIT;\n#endif\n\n\t/* assume all the iovs returned by client always fits in a page */\n\tBUILD_BUG_ON(sizeof(struct fuse_ioctl_iovec) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE);\n\n\terr = -ENOMEM;\n\tpages = kcalloc(FUSE_MAX_PAGES_PER_REQ, sizeof(pages[0]), GFP_KERNEL);\n\tiov_page = (struct iovec *) __get_free_page(GFP_KERNEL);\n\tif (!pages || !iov_page)\n\t\tgoto out;\n\n\t/*\n\t * If restricted, initialize IO parameters as encoded in @cmd.\n\t * RETRY from server is not allowed.\n\t */\n\tif (!(flags & FUSE_IOCTL_UNRESTRICTED)) {\n\t\tstruct iovec *iov = iov_page;\n\n\t\tiov->iov_base = (void __user *)arg;\n\t\tiov->iov_len = _IOC_SIZE(cmd);\n\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tin_iov = iov;\n\t\t\tin_iovs = 1;\n\t\t}\n\n\t\tif (_IOC_DIR(cmd) & _IOC_READ) {\n\t\t\tout_iov = iov;\n\t\t\tout_iovs = 1;\n\t\t}\n\t}\n\n retry:\n\tinarg.in_size = in_size = iov_length(in_iov, in_iovs);\n\tinarg.out_size = out_size = iov_length(out_iov, out_iovs);\n\n\t/*\n\t * Out data can be used either for actual out data or iovs,\n\t * make sure there always is at least one page.\n\t */\n\tout_size = max_t(size_t, out_size, PAGE_SIZE);\n\tmax_pages = DIV_ROUND_UP(max(in_size, out_size), PAGE_SIZE);\n\n\t/* make sure there are enough buffer pages and init request with them */\n\terr = -ENOMEM;\n\tif (max_pages > FUSE_MAX_PAGES_PER_REQ)\n\t\tgoto out;\n\twhile (num_pages < max_pages) {\n\t\tpages[num_pages] = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);\n\t\tif (!pages[num_pages])\n\t\t\tgoto out;\n\t\tnum_pages++;\n\t}\n\n\treq = fuse_get_req(fc, num_pages);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\treq = NULL;\n\t\tgoto out;\n\t}\n\tmemcpy(req->pages, pages, sizeof(req->pages[0]) * num_pages);\n\treq->num_pages = num_pages;\n\tfuse_page_descs_length_init(req, 0, req->num_pages);\n\n\t/* okay, let's send it to the client */\n\treq->in.h.opcode = FUSE_IOCTL;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\tif (in_size) {\n\t\treq->in.numargs++;\n\t\treq->in.args[1].size = in_size;\n\t\treq->in.argpages = 1;\n\n\t\terr = fuse_ioctl_copy_user(pages, in_iov, in_iovs, in_size,\n\t\t\t\t\t   false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\treq->out.numargs = 2;\n\treq->out.args[0].size = sizeof(outarg);\n\treq->out.args[0].value = &outarg;\n\treq->out.args[1].size = out_size;\n\treq->out.argpages = 1;\n\treq->out.argvar = 1;\n\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\ttransferred = req->out.args[1].size;\n\tfuse_put_request(fc, req);\n\treq = NULL;\n\tif (err)\n\t\tgoto out;\n\n\t/* did it ask for retry? */\n\tif (outarg.flags & FUSE_IOCTL_RETRY) {\n\t\tvoid *vaddr;\n\n\t\t/* no retry if in restricted mode */\n\t\terr = -EIO;\n\t\tif (!(flags & FUSE_IOCTL_UNRESTRICTED))\n\t\t\tgoto out;\n\n\t\tin_iovs = outarg.in_iovs;\n\t\tout_iovs = outarg.out_iovs;\n\n\t\t/*\n\t\t * Make sure things are in boundary, separate checks\n\t\t * are to protect against overflow.\n\t\t */\n\t\terr = -ENOMEM;\n\t\tif (in_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    out_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV)\n\t\t\tgoto out;\n\n\t\tvaddr = kmap_atomic(pages[0]);\n\t\terr = fuse_copy_ioctl_iovec(fc, iov_page, vaddr,\n\t\t\t\t\t    transferred, in_iovs + out_iovs,\n\t\t\t\t\t    (flags & FUSE_IOCTL_COMPAT) != 0);\n\t\tkunmap_atomic(vaddr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tin_iov = iov_page;\n\t\tout_iov = in_iov + in_iovs;\n\n\t\terr = fuse_verify_ioctl_iov(in_iov, in_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = fuse_verify_ioctl_iov(out_iov, out_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tgoto retry;\n\t}\n\n\terr = -EIO;\n\tif (transferred > inarg.out_size)\n\t\tgoto out;\n\n\terr = fuse_ioctl_copy_user(pages, out_iov, out_iovs, transferred, true);\n out:\n\tif (req)\n\t\tfuse_put_request(fc, req);\n\tfree_page((unsigned long) iov_page);\n\twhile (num_pages)\n\t\t__free_page(pages[--num_pages]);\n\tkfree(pages);\n\n\treturn err ? err : outarg.result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 2644
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_allow_current_process",
          "args": [
            "fc"
          ],
          "line": 2641
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_allow_current_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "1013-1030",
          "snippet": "int fuse_allow_current_process(struct fuse_conn *fc)\n{\n\tconst struct cred *cred;\n\n\tif (fc->flags & FUSE_ALLOW_OTHER)\n\t\treturn 1;\n\n\tcred = current_cred();\n\tif (uid_eq(cred->euid, fc->user_id) &&\n\t    uid_eq(cred->suid, fc->user_id) &&\n\t    uid_eq(cred->uid,  fc->user_id) &&\n\t    gid_eq(cred->egid, fc->group_id) &&\n\t    gid_eq(cred->sgid, fc->group_id) &&\n\t    gid_eq(cred->gid,  fc->group_id))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_allow_current_process(struct fuse_conn *fc)\n{\n\tconst struct cred *cred;\n\n\tif (fc->flags & FUSE_ALLOW_OTHER)\n\t\treturn 1;\n\n\tcred = current_cred();\n\tif (uid_eq(cred->euid, fc->user_id) &&\n\t    uid_eq(cred->suid, fc->user_id) &&\n\t    uid_eq(cred->uid,  fc->user_id) &&\n\t    gid_eq(cred->egid, fc->group_id) &&\n\t    gid_eq(cred->sgid, fc->group_id) &&\n\t    gid_eq(cred->gid,  fc->group_id))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 2639
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 2638
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nlong fuse_ioctl_common(struct file *file, unsigned int cmd,\n\t\t       unsigned long arg, unsigned int flags)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (!fuse_allow_current_process(fc))\n\t\treturn -EACCES;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\treturn fuse_do_ioctl(file, cmd, arg, flags);\n}"
  },
  {
    "function_name": "fuse_do_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "2453-2632",
    "snippet": "long fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,\n\t\t   unsigned int flags)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_ioctl_in inarg = {\n\t\t.fh = ff->fh,\n\t\t.cmd = cmd,\n\t\t.arg = arg,\n\t\t.flags = flags\n\t};\n\tstruct fuse_ioctl_out outarg;\n\tstruct fuse_req *req = NULL;\n\tstruct page **pages = NULL;\n\tstruct iovec *iov_page = NULL;\n\tstruct iovec *in_iov = NULL, *out_iov = NULL;\n\tunsigned int in_iovs = 0, out_iovs = 0, num_pages = 0, max_pages;\n\tsize_t in_size, out_size, transferred;\n\tint err;\n\n#if BITS_PER_LONG == 32\n\tinarg.flags |= FUSE_IOCTL_32BIT;\n#else\n\tif (flags & FUSE_IOCTL_COMPAT)\n\t\tinarg.flags |= FUSE_IOCTL_32BIT;\n#endif\n\n\t/* assume all the iovs returned by client always fits in a page */\n\tBUILD_BUG_ON(sizeof(struct fuse_ioctl_iovec) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE);\n\n\terr = -ENOMEM;\n\tpages = kcalloc(FUSE_MAX_PAGES_PER_REQ, sizeof(pages[0]), GFP_KERNEL);\n\tiov_page = (struct iovec *) __get_free_page(GFP_KERNEL);\n\tif (!pages || !iov_page)\n\t\tgoto out;\n\n\t/*\n\t * If restricted, initialize IO parameters as encoded in @cmd.\n\t * RETRY from server is not allowed.\n\t */\n\tif (!(flags & FUSE_IOCTL_UNRESTRICTED)) {\n\t\tstruct iovec *iov = iov_page;\n\n\t\tiov->iov_base = (void __user *)arg;\n\t\tiov->iov_len = _IOC_SIZE(cmd);\n\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tin_iov = iov;\n\t\t\tin_iovs = 1;\n\t\t}\n\n\t\tif (_IOC_DIR(cmd) & _IOC_READ) {\n\t\t\tout_iov = iov;\n\t\t\tout_iovs = 1;\n\t\t}\n\t}\n\n retry:\n\tinarg.in_size = in_size = iov_length(in_iov, in_iovs);\n\tinarg.out_size = out_size = iov_length(out_iov, out_iovs);\n\n\t/*\n\t * Out data can be used either for actual out data or iovs,\n\t * make sure there always is at least one page.\n\t */\n\tout_size = max_t(size_t, out_size, PAGE_SIZE);\n\tmax_pages = DIV_ROUND_UP(max(in_size, out_size), PAGE_SIZE);\n\n\t/* make sure there are enough buffer pages and init request with them */\n\terr = -ENOMEM;\n\tif (max_pages > FUSE_MAX_PAGES_PER_REQ)\n\t\tgoto out;\n\twhile (num_pages < max_pages) {\n\t\tpages[num_pages] = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);\n\t\tif (!pages[num_pages])\n\t\t\tgoto out;\n\t\tnum_pages++;\n\t}\n\n\treq = fuse_get_req(fc, num_pages);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\treq = NULL;\n\t\tgoto out;\n\t}\n\tmemcpy(req->pages, pages, sizeof(req->pages[0]) * num_pages);\n\treq->num_pages = num_pages;\n\tfuse_page_descs_length_init(req, 0, req->num_pages);\n\n\t/* okay, let's send it to the client */\n\treq->in.h.opcode = FUSE_IOCTL;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\tif (in_size) {\n\t\treq->in.numargs++;\n\t\treq->in.args[1].size = in_size;\n\t\treq->in.argpages = 1;\n\n\t\terr = fuse_ioctl_copy_user(pages, in_iov, in_iovs, in_size,\n\t\t\t\t\t   false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\treq->out.numargs = 2;\n\treq->out.args[0].size = sizeof(outarg);\n\treq->out.args[0].value = &outarg;\n\treq->out.args[1].size = out_size;\n\treq->out.argpages = 1;\n\treq->out.argvar = 1;\n\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\ttransferred = req->out.args[1].size;\n\tfuse_put_request(fc, req);\n\treq = NULL;\n\tif (err)\n\t\tgoto out;\n\n\t/* did it ask for retry? */\n\tif (outarg.flags & FUSE_IOCTL_RETRY) {\n\t\tvoid *vaddr;\n\n\t\t/* no retry if in restricted mode */\n\t\terr = -EIO;\n\t\tif (!(flags & FUSE_IOCTL_UNRESTRICTED))\n\t\t\tgoto out;\n\n\t\tin_iovs = outarg.in_iovs;\n\t\tout_iovs = outarg.out_iovs;\n\n\t\t/*\n\t\t * Make sure things are in boundary, separate checks\n\t\t * are to protect against overflow.\n\t\t */\n\t\terr = -ENOMEM;\n\t\tif (in_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    out_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV)\n\t\t\tgoto out;\n\n\t\tvaddr = kmap_atomic(pages[0]);\n\t\terr = fuse_copy_ioctl_iovec(fc, iov_page, vaddr,\n\t\t\t\t\t    transferred, in_iovs + out_iovs,\n\t\t\t\t\t    (flags & FUSE_IOCTL_COMPAT) != 0);\n\t\tkunmap_atomic(vaddr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tin_iov = iov_page;\n\t\tout_iov = in_iov + in_iovs;\n\n\t\terr = fuse_verify_ioctl_iov(in_iov, in_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = fuse_verify_ioctl_iov(out_iov, out_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tgoto retry;\n\t}\n\n\terr = -EIO;\n\tif (transferred > inarg.out_size)\n\t\tgoto out;\n\n\terr = fuse_ioctl_copy_user(pages, out_iov, out_iovs, transferred, true);\n out:\n\tif (req)\n\t\tfuse_put_request(fc, req);\n\tfree_page((unsigned long) iov_page);\n\twhile (num_pages)\n\t\t__free_page(pages[--num_pages]);\n\tkfree(pages);\n\n\treturn err ? err : outarg.result;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pages"
          ],
          "line": 2629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "pages[--num_pages]"
          ],
          "line": 2628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long) iov_page"
          ],
          "line": 2626
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_put_request",
          "args": [
            "fc",
            "req"
          ],
          "line": 2625
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "277-299",
          "snippet": "void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_ioctl_copy_user",
          "args": [
            "pages",
            "out_iov",
            "out_iovs",
            "transferred",
            "true"
          ],
          "line": 2622
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_ioctl_copy_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "2276-2317",
          "snippet": "static int fuse_ioctl_copy_user(struct page **pages, struct iovec *iov,\n\t\t\tunsigned int nr_segs, size_t bytes, bool to_user)\n{\n\tstruct iov_iter ii;\n\tint page_idx = 0;\n\n\tif (!bytes)\n\t\treturn 0;\n\n\tiov_iter_init(&ii, to_user ? READ : WRITE, iov, nr_segs, bytes);\n\n\twhile (iov_iter_count(&ii)) {\n\t\tstruct page *page = pages[page_idx++];\n\t\tsize_t todo = min_t(size_t, PAGE_SIZE, iov_iter_count(&ii));\n\t\tvoid *kaddr;\n\n\t\tkaddr = kmap(page);\n\n\t\twhile (todo) {\n\t\t\tchar __user *uaddr = ii.iov->iov_base + ii.iov_offset;\n\t\t\tsize_t iov_len = ii.iov->iov_len - ii.iov_offset;\n\t\t\tsize_t copy = min(todo, iov_len);\n\t\t\tsize_t left;\n\n\t\t\tif (!to_user)\n\t\t\t\tleft = copy_from_user(kaddr, uaddr, copy);\n\t\t\telse\n\t\t\t\tleft = copy_to_user(uaddr, kaddr, copy);\n\n\t\t\tif (unlikely(left))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tiov_iter_advance(&ii, copy);\n\t\t\ttodo -= copy;\n\t\t\tkaddr += copy;\n\t\t}\n\n\t\tkunmap(page);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_ioctl_copy_user(struct page **pages, struct iovec *iov,\n\t\t\tunsigned int nr_segs, size_t bytes, bool to_user)\n{\n\tstruct iov_iter ii;\n\tint page_idx = 0;\n\n\tif (!bytes)\n\t\treturn 0;\n\n\tiov_iter_init(&ii, to_user ? READ : WRITE, iov, nr_segs, bytes);\n\n\twhile (iov_iter_count(&ii)) {\n\t\tstruct page *page = pages[page_idx++];\n\t\tsize_t todo = min_t(size_t, PAGE_SIZE, iov_iter_count(&ii));\n\t\tvoid *kaddr;\n\n\t\tkaddr = kmap(page);\n\n\t\twhile (todo) {\n\t\t\tchar __user *uaddr = ii.iov->iov_base + ii.iov_offset;\n\t\t\tsize_t iov_len = ii.iov->iov_len - ii.iov_offset;\n\t\t\tsize_t copy = min(todo, iov_len);\n\t\t\tsize_t left;\n\n\t\t\tif (!to_user)\n\t\t\t\tleft = copy_from_user(kaddr, uaddr, copy);\n\t\t\telse\n\t\t\t\tleft = copy_to_user(uaddr, kaddr, copy);\n\n\t\t\tif (unlikely(left))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tiov_iter_advance(&ii, copy);\n\t\t\ttodo -= copy;\n\t\t\tkaddr += copy;\n\t\t}\n\n\t\tkunmap(page);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_verify_ioctl_iov",
          "args": [
            "out_iov",
            "out_iovs"
          ],
          "line": 2611
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_verify_ioctl_iov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "2358-2369",
          "snippet": "static int fuse_verify_ioctl_iov(struct iovec *iov, size_t count)\n{\n\tsize_t n;\n\tu32 max = FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT;\n\n\tfor (n = 0; n < count; n++, iov++) {\n\t\tif (iov->iov_len > (size_t) max)\n\t\t\treturn -ENOMEM;\n\t\tmax -= iov->iov_len;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_verify_ioctl_iov(struct iovec *iov, size_t count)\n{\n\tsize_t n;\n\tu32 max = FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT;\n\n\tfor (n = 0; n < count; n++, iov++) {\n\t\tif (iov->iov_len > (size_t) max)\n\t\t\treturn -ENOMEM;\n\t\tmax -= iov->iov_len;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "vaddr"
          ],
          "line": 2600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_copy_ioctl_iovec",
          "args": [
            "fc",
            "iov_page",
            "vaddr",
            "transferred",
            "in_iovs + out_iovs",
            "(flags & FUSE_IOCTL_COMPAT) != 0"
          ],
          "line": 2597
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_ioctl_iovec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "2371-2404",
          "snippet": "static int fuse_copy_ioctl_iovec(struct fuse_conn *fc, struct iovec *dst,\n\t\t\t\t void *src, size_t transferred, unsigned count,\n\t\t\t\t bool is_compat)\n{\n\tunsigned i;\n\tstruct fuse_ioctl_iovec *fiov = src;\n\n\tif (fc->minor < 16) {\n\t\treturn fuse_copy_ioctl_iovec_old(dst, src, transferred,\n\t\t\t\t\t\t count, is_compat);\n\t}\n\n\tif (count * sizeof(struct fuse_ioctl_iovec) != transferred)\n\t\treturn -EIO;\n\n\tfor (i = 0; i < count; i++) {\n\t\t/* Did the server supply an inappropriate value? */\n\t\tif (fiov[i].base != (unsigned long) fiov[i].base ||\n\t\t    fiov[i].len != (unsigned long) fiov[i].len)\n\t\t\treturn -EIO;\n\n\t\tdst[i].iov_base = (void __user *) (unsigned long) fiov[i].base;\n\t\tdst[i].iov_len = (size_t) fiov[i].len;\n\n#ifdef CONFIG_COMPAT\n\t\tif (is_compat &&\n\t\t    (ptr_to_compat(dst[i].iov_base) != fiov[i].base ||\n\t\t     (compat_size_t) dst[i].iov_len != fiov[i].len))\n\t\t\treturn -EIO;\n#endif\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_ioctl_iovec(struct fuse_conn *fc, struct iovec *dst,\n\t\t\t\t void *src, size_t transferred, unsigned count,\n\t\t\t\t bool is_compat)\n{\n\tunsigned i;\n\tstruct fuse_ioctl_iovec *fiov = src;\n\n\tif (fc->minor < 16) {\n\t\treturn fuse_copy_ioctl_iovec_old(dst, src, transferred,\n\t\t\t\t\t\t count, is_compat);\n\t}\n\n\tif (count * sizeof(struct fuse_ioctl_iovec) != transferred)\n\t\treturn -EIO;\n\n\tfor (i = 0; i < count; i++) {\n\t\t/* Did the server supply an inappropriate value? */\n\t\tif (fiov[i].base != (unsigned long) fiov[i].base ||\n\t\t    fiov[i].len != (unsigned long) fiov[i].len)\n\t\t\treturn -EIO;\n\n\t\tdst[i].iov_base = (void __user *) (unsigned long) fiov[i].base;\n\t\tdst[i].iov_len = (size_t) fiov[i].len;\n\n#ifdef CONFIG_COMPAT\n\t\tif (is_compat &&\n\t\t    (ptr_to_compat(dst[i].iov_base) != fiov[i].base ||\n\t\t     (compat_size_t) dst[i].iov_len != fiov[i].len))\n\t\t\treturn -EIO;\n#endif\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "pages[0]"
          ],
          "line": 2596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_request_send",
          "args": [
            "fc",
            "req"
          ],
          "line": 2566
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_send_background_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "647-652",
          "snippet": "void fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_page_descs_length_init",
          "args": [
            "req",
            "0",
            "req->num_pages"
          ],
          "line": 2540
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_page_descs_length_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1217-1225",
          "snippet": "static inline void fuse_page_descs_length_init(struct fuse_req *req,\n\t\tunsigned index, unsigned nr_pages)\n{\n\tint i;\n\n\tfor (i = index; i < index + nr_pages; i++)\n\t\treq->page_descs[i].length = PAGE_SIZE -\n\t\t\treq->page_descs[i].offset;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline void fuse_page_descs_length_init(struct fuse_req *req,\n\t\tunsigned index, unsigned nr_pages)\n{\n\tint i;\n\n\tfor (i = index; i < index + nr_pages; i++)\n\t\treq->page_descs[i].length = PAGE_SIZE -\n\t\t\treq->page_descs[i].offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "req->pages",
            "pages",
            "sizeof(req->pages[0]) * num_pages"
          ],
          "line": 2538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 2534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_get_req",
          "args": [
            "fc",
            "num_pages"
          ],
          "line": 2532
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_req_nofail_nopages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "258-275",
          "snippet": "struct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc,\n\t\t\t\t\t     struct file *file)\n{\n\tstruct fuse_req *req;\n\n\tatomic_inc(&fc->num_waiting);\n\twait_event(fc->blocked_waitq, fc->initialized);\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\treq = fuse_request_alloc(0);\n\tif (!req)\n\t\treq = get_reserved_req(fc, file);\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = 0;\n\treturn req;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstruct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc,\n\t\t\t\t\t     struct file *file)\n{\n\tstruct fuse_req *req;\n\n\tatomic_inc(&fc->num_waiting);\n\twait_event(fc->blocked_waitq, fc->initialized);\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\treq = fuse_request_alloc(0);\n\tif (!req)\n\t\treq = get_reserved_req(fc, file);\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = 0;\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL | __GFP_HIGHMEM"
          ],
          "line": 2526
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "max(in_size, out_size)",
            "PAGE_SIZE"
          ],
          "line": 2519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "in_size",
            "out_size"
          ],
          "line": 2519
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_max_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
          "lines": "13-18",
          "snippet": "static u32 omfs_max_extents(struct omfs_sb_info *sbi, int offset)\n{\n\treturn (sbi->s_sys_blocksize - offset -\n\t\tsizeof(struct omfs_extent)) /\n\t\tsizeof(struct omfs_extent_entry) + 1;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u32 omfs_max_extents(struct omfs_sb_info *sbi, int offset)\n{\n\treturn (sbi->s_sys_blocksize - offset -\n\t\tsizeof(struct omfs_extent)) /\n\t\tsizeof(struct omfs_extent_entry) + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "size_t",
            "out_size",
            "PAGE_SIZE"
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_length",
          "args": [
            "out_iov",
            "out_iovs"
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_length",
          "args": [
            "in_iov",
            "in_iovs"
          ],
          "line": 2511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_IOC_DIR",
          "args": [
            "cmd"
          ],
          "line": 2504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_IOC_DIR",
          "args": [
            "cmd"
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_IOC_SIZE",
          "args": [
            "cmd"
          ],
          "line": 2497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 2485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "FUSE_MAX_PAGES_PER_REQ",
            "sizeof(pages[0])",
            "GFP_KERNEL"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(struct fuse_ioctl_iovec) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE"
          ],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nlong fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,\n\t\t   unsigned int flags)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_ioctl_in inarg = {\n\t\t.fh = ff->fh,\n\t\t.cmd = cmd,\n\t\t.arg = arg,\n\t\t.flags = flags\n\t};\n\tstruct fuse_ioctl_out outarg;\n\tstruct fuse_req *req = NULL;\n\tstruct page **pages = NULL;\n\tstruct iovec *iov_page = NULL;\n\tstruct iovec *in_iov = NULL, *out_iov = NULL;\n\tunsigned int in_iovs = 0, out_iovs = 0, num_pages = 0, max_pages;\n\tsize_t in_size, out_size, transferred;\n\tint err;\n\n#if BITS_PER_LONG == 32\n\tinarg.flags |= FUSE_IOCTL_32BIT;\n#else\n\tif (flags & FUSE_IOCTL_COMPAT)\n\t\tinarg.flags |= FUSE_IOCTL_32BIT;\n#endif\n\n\t/* assume all the iovs returned by client always fits in a page */\n\tBUILD_BUG_ON(sizeof(struct fuse_ioctl_iovec) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE);\n\n\terr = -ENOMEM;\n\tpages = kcalloc(FUSE_MAX_PAGES_PER_REQ, sizeof(pages[0]), GFP_KERNEL);\n\tiov_page = (struct iovec *) __get_free_page(GFP_KERNEL);\n\tif (!pages || !iov_page)\n\t\tgoto out;\n\n\t/*\n\t * If restricted, initialize IO parameters as encoded in @cmd.\n\t * RETRY from server is not allowed.\n\t */\n\tif (!(flags & FUSE_IOCTL_UNRESTRICTED)) {\n\t\tstruct iovec *iov = iov_page;\n\n\t\tiov->iov_base = (void __user *)arg;\n\t\tiov->iov_len = _IOC_SIZE(cmd);\n\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tin_iov = iov;\n\t\t\tin_iovs = 1;\n\t\t}\n\n\t\tif (_IOC_DIR(cmd) & _IOC_READ) {\n\t\t\tout_iov = iov;\n\t\t\tout_iovs = 1;\n\t\t}\n\t}\n\n retry:\n\tinarg.in_size = in_size = iov_length(in_iov, in_iovs);\n\tinarg.out_size = out_size = iov_length(out_iov, out_iovs);\n\n\t/*\n\t * Out data can be used either for actual out data or iovs,\n\t * make sure there always is at least one page.\n\t */\n\tout_size = max_t(size_t, out_size, PAGE_SIZE);\n\tmax_pages = DIV_ROUND_UP(max(in_size, out_size), PAGE_SIZE);\n\n\t/* make sure there are enough buffer pages and init request with them */\n\terr = -ENOMEM;\n\tif (max_pages > FUSE_MAX_PAGES_PER_REQ)\n\t\tgoto out;\n\twhile (num_pages < max_pages) {\n\t\tpages[num_pages] = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);\n\t\tif (!pages[num_pages])\n\t\t\tgoto out;\n\t\tnum_pages++;\n\t}\n\n\treq = fuse_get_req(fc, num_pages);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\treq = NULL;\n\t\tgoto out;\n\t}\n\tmemcpy(req->pages, pages, sizeof(req->pages[0]) * num_pages);\n\treq->num_pages = num_pages;\n\tfuse_page_descs_length_init(req, 0, req->num_pages);\n\n\t/* okay, let's send it to the client */\n\treq->in.h.opcode = FUSE_IOCTL;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\tif (in_size) {\n\t\treq->in.numargs++;\n\t\treq->in.args[1].size = in_size;\n\t\treq->in.argpages = 1;\n\n\t\terr = fuse_ioctl_copy_user(pages, in_iov, in_iovs, in_size,\n\t\t\t\t\t   false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\treq->out.numargs = 2;\n\treq->out.args[0].size = sizeof(outarg);\n\treq->out.args[0].value = &outarg;\n\treq->out.args[1].size = out_size;\n\treq->out.argpages = 1;\n\treq->out.argvar = 1;\n\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\ttransferred = req->out.args[1].size;\n\tfuse_put_request(fc, req);\n\treq = NULL;\n\tif (err)\n\t\tgoto out;\n\n\t/* did it ask for retry? */\n\tif (outarg.flags & FUSE_IOCTL_RETRY) {\n\t\tvoid *vaddr;\n\n\t\t/* no retry if in restricted mode */\n\t\terr = -EIO;\n\t\tif (!(flags & FUSE_IOCTL_UNRESTRICTED))\n\t\t\tgoto out;\n\n\t\tin_iovs = outarg.in_iovs;\n\t\tout_iovs = outarg.out_iovs;\n\n\t\t/*\n\t\t * Make sure things are in boundary, separate checks\n\t\t * are to protect against overflow.\n\t\t */\n\t\terr = -ENOMEM;\n\t\tif (in_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    out_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV)\n\t\t\tgoto out;\n\n\t\tvaddr = kmap_atomic(pages[0]);\n\t\terr = fuse_copy_ioctl_iovec(fc, iov_page, vaddr,\n\t\t\t\t\t    transferred, in_iovs + out_iovs,\n\t\t\t\t\t    (flags & FUSE_IOCTL_COMPAT) != 0);\n\t\tkunmap_atomic(vaddr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tin_iov = iov_page;\n\t\tout_iov = in_iov + in_iovs;\n\n\t\terr = fuse_verify_ioctl_iov(in_iov, in_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = fuse_verify_ioctl_iov(out_iov, out_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tgoto retry;\n\t}\n\n\terr = -EIO;\n\tif (transferred > inarg.out_size)\n\t\tgoto out;\n\n\terr = fuse_ioctl_copy_user(pages, out_iov, out_iovs, transferred, true);\n out:\n\tif (req)\n\t\tfuse_put_request(fc, req);\n\tfree_page((unsigned long) iov_page);\n\twhile (num_pages)\n\t\t__free_page(pages[--num_pages]);\n\tkfree(pages);\n\n\treturn err ? err : outarg.result;\n}"
  },
  {
    "function_name": "fuse_copy_ioctl_iovec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "2371-2404",
    "snippet": "static int fuse_copy_ioctl_iovec(struct fuse_conn *fc, struct iovec *dst,\n\t\t\t\t void *src, size_t transferred, unsigned count,\n\t\t\t\t bool is_compat)\n{\n\tunsigned i;\n\tstruct fuse_ioctl_iovec *fiov = src;\n\n\tif (fc->minor < 16) {\n\t\treturn fuse_copy_ioctl_iovec_old(dst, src, transferred,\n\t\t\t\t\t\t count, is_compat);\n\t}\n\n\tif (count * sizeof(struct fuse_ioctl_iovec) != transferred)\n\t\treturn -EIO;\n\n\tfor (i = 0; i < count; i++) {\n\t\t/* Did the server supply an inappropriate value? */\n\t\tif (fiov[i].base != (unsigned long) fiov[i].base ||\n\t\t    fiov[i].len != (unsigned long) fiov[i].len)\n\t\t\treturn -EIO;\n\n\t\tdst[i].iov_base = (void __user *) (unsigned long) fiov[i].base;\n\t\tdst[i].iov_len = (size_t) fiov[i].len;\n\n#ifdef CONFIG_COMPAT\n\t\tif (is_compat &&\n\t\t    (ptr_to_compat(dst[i].iov_base) != fiov[i].base ||\n\t\t     (compat_size_t) dst[i].iov_len != fiov[i].len))\n\t\t\treturn -EIO;\n#endif\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptr_to_compat",
          "args": [
            "dst[i].iov_base"
          ],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_copy_ioctl_iovec_old",
          "args": [
            "dst",
            "src",
            "transferred",
            "count",
            "is_compat"
          ],
          "line": 2379
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_copy_ioctl_iovec_old",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "2325-2355",
          "snippet": "static int fuse_copy_ioctl_iovec_old(struct iovec *dst, void *src,\n\t\t\t\t     size_t transferred, unsigned count,\n\t\t\t\t     bool is_compat)\n{\n#ifdef CONFIG_COMPAT\n\tif (count * sizeof(struct compat_iovec) == transferred) {\n\t\tstruct compat_iovec *ciov = src;\n\t\tunsigned i;\n\n\t\t/*\n\t\t * With this interface a 32bit server cannot support\n\t\t * non-compat (i.e. ones coming from 64bit apps) ioctl\n\t\t * requests\n\t\t */\n\t\tif (!is_compat)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tdst[i].iov_base = compat_ptr(ciov[i].iov_base);\n\t\t\tdst[i].iov_len = ciov[i].iov_len;\n\t\t}\n\t\treturn 0;\n\t}\n#endif\n\n\tif (count * sizeof(struct iovec) != transferred)\n\t\treturn -EIO;\n\n\tmemcpy(dst, src, transferred);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_ioctl_iovec_old(struct iovec *dst, void *src,\n\t\t\t\t     size_t transferred, unsigned count,\n\t\t\t\t     bool is_compat)\n{\n#ifdef CONFIG_COMPAT\n\tif (count * sizeof(struct compat_iovec) == transferred) {\n\t\tstruct compat_iovec *ciov = src;\n\t\tunsigned i;\n\n\t\t/*\n\t\t * With this interface a 32bit server cannot support\n\t\t * non-compat (i.e. ones coming from 64bit apps) ioctl\n\t\t * requests\n\t\t */\n\t\tif (!is_compat)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tdst[i].iov_base = compat_ptr(ciov[i].iov_base);\n\t\t\tdst[i].iov_len = ciov[i].iov_len;\n\t\t}\n\t\treturn 0;\n\t}\n#endif\n\n\tif (count * sizeof(struct iovec) != transferred)\n\t\treturn -EIO;\n\n\tmemcpy(dst, src, transferred);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_ioctl_iovec(struct fuse_conn *fc, struct iovec *dst,\n\t\t\t\t void *src, size_t transferred, unsigned count,\n\t\t\t\t bool is_compat)\n{\n\tunsigned i;\n\tstruct fuse_ioctl_iovec *fiov = src;\n\n\tif (fc->minor < 16) {\n\t\treturn fuse_copy_ioctl_iovec_old(dst, src, transferred,\n\t\t\t\t\t\t count, is_compat);\n\t}\n\n\tif (count * sizeof(struct fuse_ioctl_iovec) != transferred)\n\t\treturn -EIO;\n\n\tfor (i = 0; i < count; i++) {\n\t\t/* Did the server supply an inappropriate value? */\n\t\tif (fiov[i].base != (unsigned long) fiov[i].base ||\n\t\t    fiov[i].len != (unsigned long) fiov[i].len)\n\t\t\treturn -EIO;\n\n\t\tdst[i].iov_base = (void __user *) (unsigned long) fiov[i].base;\n\t\tdst[i].iov_len = (size_t) fiov[i].len;\n\n#ifdef CONFIG_COMPAT\n\t\tif (is_compat &&\n\t\t    (ptr_to_compat(dst[i].iov_base) != fiov[i].base ||\n\t\t     (compat_size_t) dst[i].iov_len != fiov[i].len))\n\t\t\treturn -EIO;\n#endif\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fuse_verify_ioctl_iov",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "2358-2369",
    "snippet": "static int fuse_verify_ioctl_iov(struct iovec *iov, size_t count)\n{\n\tsize_t n;\n\tu32 max = FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT;\n\n\tfor (n = 0; n < count; n++, iov++) {\n\t\tif (iov->iov_len > (size_t) max)\n\t\t\treturn -ENOMEM;\n\t\tmax -= iov->iov_len;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_verify_ioctl_iov(struct iovec *iov, size_t count)\n{\n\tsize_t n;\n\tu32 max = FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT;\n\n\tfor (n = 0; n < count; n++, iov++) {\n\t\tif (iov->iov_len > (size_t) max)\n\t\t\treturn -ENOMEM;\n\t\tmax -= iov->iov_len;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "fuse_copy_ioctl_iovec_old",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "2325-2355",
    "snippet": "static int fuse_copy_ioctl_iovec_old(struct iovec *dst, void *src,\n\t\t\t\t     size_t transferred, unsigned count,\n\t\t\t\t     bool is_compat)\n{\n#ifdef CONFIG_COMPAT\n\tif (count * sizeof(struct compat_iovec) == transferred) {\n\t\tstruct compat_iovec *ciov = src;\n\t\tunsigned i;\n\n\t\t/*\n\t\t * With this interface a 32bit server cannot support\n\t\t * non-compat (i.e. ones coming from 64bit apps) ioctl\n\t\t * requests\n\t\t */\n\t\tif (!is_compat)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tdst[i].iov_base = compat_ptr(ciov[i].iov_base);\n\t\t\tdst[i].iov_len = ciov[i].iov_len;\n\t\t}\n\t\treturn 0;\n\t}\n#endif\n\n\tif (count * sizeof(struct iovec) != transferred)\n\t\treturn -EIO;\n\n\tmemcpy(dst, src, transferred);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "src",
            "transferred"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "ciov[i].iov_base"
          ],
          "line": 2343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_copy_ioctl_iovec_old(struct iovec *dst, void *src,\n\t\t\t\t     size_t transferred, unsigned count,\n\t\t\t\t     bool is_compat)\n{\n#ifdef CONFIG_COMPAT\n\tif (count * sizeof(struct compat_iovec) == transferred) {\n\t\tstruct compat_iovec *ciov = src;\n\t\tunsigned i;\n\n\t\t/*\n\t\t * With this interface a 32bit server cannot support\n\t\t * non-compat (i.e. ones coming from 64bit apps) ioctl\n\t\t * requests\n\t\t */\n\t\tif (!is_compat)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tdst[i].iov_base = compat_ptr(ciov[i].iov_base);\n\t\t\tdst[i].iov_len = ciov[i].iov_len;\n\t\t}\n\t\treturn 0;\n\t}\n#endif\n\n\tif (count * sizeof(struct iovec) != transferred)\n\t\treturn -EIO;\n\n\tmemcpy(dst, src, transferred);\n\treturn 0;\n}"
  },
  {
    "function_name": "fuse_ioctl_copy_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "2276-2317",
    "snippet": "static int fuse_ioctl_copy_user(struct page **pages, struct iovec *iov,\n\t\t\tunsigned int nr_segs, size_t bytes, bool to_user)\n{\n\tstruct iov_iter ii;\n\tint page_idx = 0;\n\n\tif (!bytes)\n\t\treturn 0;\n\n\tiov_iter_init(&ii, to_user ? READ : WRITE, iov, nr_segs, bytes);\n\n\twhile (iov_iter_count(&ii)) {\n\t\tstruct page *page = pages[page_idx++];\n\t\tsize_t todo = min_t(size_t, PAGE_SIZE, iov_iter_count(&ii));\n\t\tvoid *kaddr;\n\n\t\tkaddr = kmap(page);\n\n\t\twhile (todo) {\n\t\t\tchar __user *uaddr = ii.iov->iov_base + ii.iov_offset;\n\t\t\tsize_t iov_len = ii.iov->iov_len - ii.iov_offset;\n\t\t\tsize_t copy = min(todo, iov_len);\n\t\t\tsize_t left;\n\n\t\t\tif (!to_user)\n\t\t\t\tleft = copy_from_user(kaddr, uaddr, copy);\n\t\t\telse\n\t\t\t\tleft = copy_to_user(uaddr, kaddr, copy);\n\n\t\t\tif (unlikely(left))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tiov_iter_advance(&ii, copy);\n\t\t\ttodo -= copy;\n\t\t\tkaddr += copy;\n\t\t}\n\n\t\tkunmap(page);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_advance",
          "args": [
            "&ii",
            "copy"
          ],
          "line": 2308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "left"
          ],
          "line": 2305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "uaddr",
            "kaddr",
            "copy"
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "kaddr",
            "uaddr",
            "copy"
          ],
          "line": 2301
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "todo",
            "iov_len"
          ],
          "line": 2297
        },
        "resolved": true,
        "details": {
          "function_name": "minix_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/file.c",
          "lines": "26-48",
          "snippet": "static int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"minix.h\"\n\nstatic int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 2292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "PAGE_SIZE",
            "iov_iter_count(&ii)"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "&ii"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "&ii"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_init",
          "args": [
            "&ii",
            "to_user ? READ : WRITE",
            "iov",
            "nr_segs",
            "bytes"
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_ioctl_copy_user(struct page **pages, struct iovec *iov,\n\t\t\tunsigned int nr_segs, size_t bytes, bool to_user)\n{\n\tstruct iov_iter ii;\n\tint page_idx = 0;\n\n\tif (!bytes)\n\t\treturn 0;\n\n\tiov_iter_init(&ii, to_user ? READ : WRITE, iov, nr_segs, bytes);\n\n\twhile (iov_iter_count(&ii)) {\n\t\tstruct page *page = pages[page_idx++];\n\t\tsize_t todo = min_t(size_t, PAGE_SIZE, iov_iter_count(&ii));\n\t\tvoid *kaddr;\n\n\t\tkaddr = kmap(page);\n\n\t\twhile (todo) {\n\t\t\tchar __user *uaddr = ii.iov->iov_base + ii.iov_offset;\n\t\t\tsize_t iov_len = ii.iov->iov_len - ii.iov_offset;\n\t\t\tsize_t copy = min(todo, iov_len);\n\t\t\tsize_t left;\n\n\t\t\tif (!to_user)\n\t\t\t\tleft = copy_from_user(kaddr, uaddr, copy);\n\t\t\telse\n\t\t\t\tleft = copy_to_user(uaddr, kaddr, copy);\n\n\t\t\tif (unlikely(left))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tiov_iter_advance(&ii, copy);\n\t\t\ttodo -= copy;\n\t\t\tkaddr += copy;\n\t\t}\n\n\t\tkunmap(page);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fuse_file_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "2258-2274",
    "snippet": "static loff_t fuse_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t retval;\n\tstruct inode *inode = file_inode(file);\n\n\t/* No i_mutex protection necessary for SEEK_CUR and SEEK_SET */\n\tif (whence == SEEK_CUR || whence == SEEK_SET)\n\t\treturn generic_file_llseek(file, offset, whence);\n\n\tmutex_lock(&inode->i_mutex);\n\tretval = fuse_update_attributes(inode, NULL, file, NULL);\n\tif (!retval)\n\t\tretval = generic_file_llseek(file, offset, whence);\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn retval;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_file_llseek",
          "args": [
            "file",
            "offset",
            "whence"
          ],
          "line": 2270
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_llseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "147-154",
          "snippet": "loff_t generic_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\tinode->i_sb->s_maxbytes,\n\t\t\t\t\ti_size_read(inode));\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t generic_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\tinode->i_sb->s_maxbytes,\n\t\t\t\t\ti_size_read(inode));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_update_attributes",
          "args": [
            "inode",
            "NULL",
            "file",
            "NULL"
          ],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_update_attributes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "909-933",
          "snippet": "int fuse_update_attributes(struct inode *inode, struct kstat *stat,\n\t\t\t   struct file *file, bool *refreshed)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tint err;\n\tbool r;\n\n\tif (time_before64(fi->i_time, get_jiffies_64())) {\n\t\tr = true;\n\t\terr = fuse_do_getattr(inode, stat, file);\n\t} else {\n\t\tr = false;\n\t\terr = 0;\n\t\tif (stat) {\n\t\t\tgeneric_fillattr(inode, stat);\n\t\t\tstat->mode = fi->orig_i_mode;\n\t\t\tstat->ino = fi->orig_ino;\n\t\t}\n\t}\n\n\tif (refreshed != NULL)\n\t\t*refreshed = r;\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_update_attributes(struct inode *inode, struct kstat *stat,\n\t\t\t   struct file *file, bool *refreshed)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tint err;\n\tbool r;\n\n\tif (time_before64(fi->i_time, get_jiffies_64())) {\n\t\tr = true;\n\t\terr = fuse_do_getattr(inode, stat, file);\n\t} else {\n\t\tr = false;\n\t\terr = 0;\n\t\tif (stat) {\n\t\t\tgeneric_fillattr(inode, stat);\n\t\t\tstat->mode = fi->orig_i_mode;\n\t\t\tstat->ino = fi->orig_ino;\n\t\t}\n\t}\n\n\tif (refreshed != NULL)\n\t\t*refreshed = r;\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 2261
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic loff_t fuse_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t retval;\n\tstruct inode *inode = file_inode(file);\n\n\t/* No i_mutex protection necessary for SEEK_CUR and SEEK_SET */\n\tif (whence == SEEK_CUR || whence == SEEK_SET)\n\t\treturn generic_file_llseek(file, offset, whence);\n\n\tmutex_lock(&inode->i_mutex);\n\tretval = fuse_update_attributes(inode, NULL, file, NULL);\n\tif (!retval)\n\t\tretval = generic_file_llseek(file, offset, whence);\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn retval;\n}"
  },
  {
    "function_name": "fuse_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "2228-2256",
    "snippet": "static sector_t fuse_bmap(struct address_space *mapping, sector_t block)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_bmap_in inarg;\n\tstruct fuse_bmap_out outarg;\n\tint err;\n\n\tif (!inode->i_sb->s_bdev || fc->no_bmap)\n\t\treturn 0;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.block = block;\n\tinarg.blocksize = inode->i_sb->s_blocksize;\n\targs.in.h.opcode = FUSE_BMAP;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.out.numargs = 1;\n\targs.out.args[0].size = sizeof(outarg);\n\targs.out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (err == -ENOSYS)\n\t\tfc->no_bmap = 1;\n\n\treturn err ? 0 : outarg.block;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_simple_request",
          "args": [
            "fc",
            "&args"
          ],
          "line": 2251
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_simple_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "558-588",
          "snippet": "ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_id",
          "args": [
            "inode"
          ],
          "line": 2244
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "633-636",
          "snippet": "static inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&inarg",
            "0",
            "sizeof(inarg)"
          ],
          "line": 2240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUSE_ARGS",
          "args": [
            "args"
          ],
          "line": 2232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 2231
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic sector_t fuse_bmap(struct address_space *mapping, sector_t block)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_bmap_in inarg;\n\tstruct fuse_bmap_out outarg;\n\tint err;\n\n\tif (!inode->i_sb->s_bdev || fc->no_bmap)\n\t\treturn 0;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.block = block;\n\tinarg.blocksize = inode->i_sb->s_blocksize;\n\targs.in.h.opcode = FUSE_BMAP;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.out.numargs = 1;\n\targs.out.args[0].size = sizeof(outarg);\n\targs.out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (err == -ENOSYS)\n\t\tfc->no_bmap = 1;\n\n\treturn err ? 0 : outarg.block;\n}"
  },
  {
    "function_name": "fuse_file_flock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "2209-2226",
    "snippet": "static int fuse_file_flock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tint err;\n\n\tif (fc->no_flock) {\n\t\terr = flock_lock_file_wait(file, fl);\n\t} else {\n\t\tstruct fuse_file *ff = file->private_data;\n\n\t\t/* emulate flock with POSIX locks */\n\t\tff->flock = true;\n\t\terr = fuse_setlk(file, fl, 1);\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_setlk",
          "args": [
            "file",
            "fl",
            "1"
          ],
          "line": 2222
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_setlk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "2157-2184",
          "snippet": "static int fuse_setlk(struct file *file, struct file_lock *fl, int flock)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_lk_in inarg;\n\tint opcode = (fl->fl_flags & FL_SLEEP) ? FUSE_SETLKW : FUSE_SETLK;\n\tpid_t pid = fl->fl_type != F_UNLCK ? current->tgid : 0;\n\tint err;\n\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant) {\n\t\t/* NLM needs asynchronous locks, which we don't support yet */\n\t\treturn -ENOLCK;\n\t}\n\n\t/* Unlock on close is handled by the flush method */\n\tif (fl->fl_flags & FL_CLOSE)\n\t\treturn 0;\n\n\tfuse_lk_fill(&args, file, fl, opcode, pid, flock, &inarg);\n\terr = fuse_simple_request(fc, &args);\n\n\t/* locking is restartable */\n\tif (err == -EINTR)\n\t\terr = -ERESTARTSYS;\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_setlk(struct file *file, struct file_lock *fl, int flock)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_lk_in inarg;\n\tint opcode = (fl->fl_flags & FL_SLEEP) ? FUSE_SETLKW : FUSE_SETLK;\n\tpid_t pid = fl->fl_type != F_UNLCK ? current->tgid : 0;\n\tint err;\n\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant) {\n\t\t/* NLM needs asynchronous locks, which we don't support yet */\n\t\treturn -ENOLCK;\n\t}\n\n\t/* Unlock on close is handled by the flush method */\n\tif (fl->fl_flags & FL_CLOSE)\n\t\treturn 0;\n\n\tfuse_lk_fill(&args, file, fl, opcode, pid, flock, &inarg);\n\terr = fuse_simple_request(fc, &args);\n\n\t/* locking is restartable */\n\tif (err == -EINTR)\n\t\terr = -ERESTARTSYS;\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flock_lock_file_wait",
          "args": [
            "file",
            "fl"
          ],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "flock_lock_file_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1858-1874",
          "snippet": "int flock_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_file(filp, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint flock_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_file(filp, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 2211
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_file_flock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tint err;\n\n\tif (fc->no_flock) {\n\t\terr = flock_lock_file_wait(file, fl);\n\t} else {\n\t\tstruct fuse_file *ff = file->private_data;\n\n\t\t/* emulate flock with POSIX locks */\n\t\tff->flock = true;\n\t\terr = fuse_setlk(file, fl, 1);\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_file_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "2186-2207",
    "snippet": "static int fuse_file_lock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tint err;\n\n\tif (cmd == F_CANCELLK) {\n\t\terr = 0;\n\t} else if (cmd == F_GETLK) {\n\t\tif (fc->no_lock) {\n\t\t\tposix_test_lock(file, fl);\n\t\t\terr = 0;\n\t\t} else\n\t\t\terr = fuse_getlk(file, fl);\n\t} else {\n\t\tif (fc->no_lock)\n\t\t\terr = posix_lock_file(file, fl, NULL);\n\t\telse\n\t\t\terr = fuse_setlk(file, fl, 0);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_setlk",
          "args": [
            "file",
            "fl",
            "0"
          ],
          "line": 2204
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_setlk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "2157-2184",
          "snippet": "static int fuse_setlk(struct file *file, struct file_lock *fl, int flock)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_lk_in inarg;\n\tint opcode = (fl->fl_flags & FL_SLEEP) ? FUSE_SETLKW : FUSE_SETLK;\n\tpid_t pid = fl->fl_type != F_UNLCK ? current->tgid : 0;\n\tint err;\n\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant) {\n\t\t/* NLM needs asynchronous locks, which we don't support yet */\n\t\treturn -ENOLCK;\n\t}\n\n\t/* Unlock on close is handled by the flush method */\n\tif (fl->fl_flags & FL_CLOSE)\n\t\treturn 0;\n\n\tfuse_lk_fill(&args, file, fl, opcode, pid, flock, &inarg);\n\terr = fuse_simple_request(fc, &args);\n\n\t/* locking is restartable */\n\tif (err == -EINTR)\n\t\terr = -ERESTARTSYS;\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_setlk(struct file *file, struct file_lock *fl, int flock)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_lk_in inarg;\n\tint opcode = (fl->fl_flags & FL_SLEEP) ? FUSE_SETLKW : FUSE_SETLK;\n\tpid_t pid = fl->fl_type != F_UNLCK ? current->tgid : 0;\n\tint err;\n\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant) {\n\t\t/* NLM needs asynchronous locks, which we don't support yet */\n\t\treturn -ENOLCK;\n\t}\n\n\t/* Unlock on close is handled by the flush method */\n\tif (fl->fl_flags & FL_CLOSE)\n\t\treturn 0;\n\n\tfuse_lk_fill(&args, file, fl, opcode, pid, flock, &inarg);\n\terr = fuse_simple_request(fc, &args);\n\n\t/* locking is restartable */\n\tif (err == -EINTR)\n\t\terr = -ERESTARTSYS;\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_lock_file",
          "args": [
            "file",
            "fl",
            "NULL"
          ],
          "line": 2202
        },
        "resolved": true,
        "details": {
          "function_name": "posix_lock_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1157-1161",
          "snippet": "int posix_lock_file(struct file *filp, struct file_lock *fl,\n\t\t\tstruct file_lock *conflock)\n{\n\treturn __posix_lock_file(file_inode(filp), fl, conflock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint posix_lock_file(struct file *filp, struct file_lock *fl,\n\t\t\tstruct file_lock *conflock)\n{\n\treturn __posix_lock_file(file_inode(filp), fl, conflock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_getlk",
          "args": [
            "file",
            "fl"
          ],
          "line": 2199
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_getlk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "2137-2155",
          "snippet": "static int fuse_getlk(struct file *file, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_lk_in inarg;\n\tstruct fuse_lk_out outarg;\n\tint err;\n\n\tfuse_lk_fill(&args, file, fl, FUSE_GETLK, 0, 0, &inarg);\n\targs.out.numargs = 1;\n\targs.out.args[0].size = sizeof(outarg);\n\targs.out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (!err)\n\t\terr = convert_fuse_file_lock(&outarg.lk, fl);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_getlk(struct file *file, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_lk_in inarg;\n\tstruct fuse_lk_out outarg;\n\tint err;\n\n\tfuse_lk_fill(&args, file, fl, FUSE_GETLK, 0, 0, &inarg);\n\targs.out.numargs = 1;\n\targs.out.args[0].size = sizeof(outarg);\n\targs.out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (!err)\n\t\terr = convert_fuse_file_lock(&outarg.lk, fl);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_test_lock",
          "args": [
            "file",
            "fl"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "posix_test_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "759-785",
          "snippet": "void\nposix_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tstruct file_lock *cfl;\n\tstruct file_lock_context *ctx;\n\tstruct inode *inode = file_inode(filp);\n\n\tctx = inode->i_flctx;\n\tif (!ctx || list_empty_careful(&ctx->flc_posix)) {\n\t\tfl->fl_type = F_UNLCK;\n\t\treturn;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(cfl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_locks_conflict(fl, cfl)) {\n\t\t\tlocks_copy_conflock(fl, cfl);\n\t\t\tif (cfl->fl_nspid)\n\t\t\t\tfl->fl_pid = pid_vnr(cfl->fl_nspid);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfl->fl_type = F_UNLCK;\nout:\n\tspin_unlock(&ctx->flc_lock);\n\treturn;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid\nposix_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tstruct file_lock *cfl;\n\tstruct file_lock_context *ctx;\n\tstruct inode *inode = file_inode(filp);\n\n\tctx = inode->i_flctx;\n\tif (!ctx || list_empty_careful(&ctx->flc_posix)) {\n\t\tfl->fl_type = F_UNLCK;\n\t\treturn;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(cfl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_locks_conflict(fl, cfl)) {\n\t\t\tlocks_copy_conflock(fl, cfl);\n\t\t\tif (cfl->fl_nspid)\n\t\t\t\tfl->fl_pid = pid_vnr(cfl->fl_nspid);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfl->fl_type = F_UNLCK;\nout:\n\tspin_unlock(&ctx->flc_lock);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 2189
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 2188
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_file_lock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tint err;\n\n\tif (cmd == F_CANCELLK) {\n\t\terr = 0;\n\t} else if (cmd == F_GETLK) {\n\t\tif (fc->no_lock) {\n\t\t\tposix_test_lock(file, fl);\n\t\t\terr = 0;\n\t\t} else\n\t\t\terr = fuse_getlk(file, fl);\n\t} else {\n\t\tif (fc->no_lock)\n\t\t\terr = posix_lock_file(file, fl, NULL);\n\t\telse\n\t\t\terr = fuse_setlk(file, fl, 0);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_setlk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "2157-2184",
    "snippet": "static int fuse_setlk(struct file *file, struct file_lock *fl, int flock)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_lk_in inarg;\n\tint opcode = (fl->fl_flags & FL_SLEEP) ? FUSE_SETLKW : FUSE_SETLK;\n\tpid_t pid = fl->fl_type != F_UNLCK ? current->tgid : 0;\n\tint err;\n\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant) {\n\t\t/* NLM needs asynchronous locks, which we don't support yet */\n\t\treturn -ENOLCK;\n\t}\n\n\t/* Unlock on close is handled by the flush method */\n\tif (fl->fl_flags & FL_CLOSE)\n\t\treturn 0;\n\n\tfuse_lk_fill(&args, file, fl, opcode, pid, flock, &inarg);\n\terr = fuse_simple_request(fc, &args);\n\n\t/* locking is restartable */\n\tif (err == -EINTR)\n\t\terr = -ERESTARTSYS;\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_simple_request",
          "args": [
            "fc",
            "&args"
          ],
          "line": 2177
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_simple_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "558-588",
          "snippet": "ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_lk_fill",
          "args": [
            "&args",
            "file",
            "fl",
            "opcode",
            "pid",
            "flock",
            "&inarg"
          ],
          "line": 2176
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lk_fill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "2113-2135",
          "snippet": "static void fuse_lk_fill(struct fuse_args *args, struct file *file,\n\t\t\t const struct file_lock *fl, int opcode, pid_t pid,\n\t\t\t int flock, struct fuse_lk_in *inarg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_file *ff = file->private_data;\n\n\tmemset(inarg, 0, sizeof(*inarg));\n\tinarg->fh = ff->fh;\n\tinarg->owner = fuse_lock_owner_id(fc, fl->fl_owner);\n\tinarg->lk.start = fl->fl_start;\n\tinarg->lk.end = fl->fl_end;\n\tinarg->lk.type = fl->fl_type;\n\tinarg->lk.pid = pid;\n\tif (flock)\n\t\tinarg->lk_flags |= FUSE_LK_FLOCK;\n\targs->in.h.opcode = opcode;\n\targs->in.h.nodeid = get_node_id(inode);\n\targs->in.numargs = 1;\n\targs->in.args[0].size = sizeof(*inarg);\n\targs->in.args[0].value = inarg;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_lk_fill(struct fuse_args *args, struct file *file,\n\t\t\t const struct file_lock *fl, int opcode, pid_t pid,\n\t\t\t int flock, struct fuse_lk_in *inarg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_file *ff = file->private_data;\n\n\tmemset(inarg, 0, sizeof(*inarg));\n\tinarg->fh = ff->fh;\n\tinarg->owner = fuse_lock_owner_id(fc, fl->fl_owner);\n\tinarg->lk.start = fl->fl_start;\n\tinarg->lk.end = fl->fl_end;\n\tinarg->lk.type = fl->fl_type;\n\tinarg->lk.pid = pid;\n\tif (flock)\n\t\tinarg->lk_flags |= FUSE_LK_FLOCK;\n\targs->in.h.opcode = opcode;\n\targs->in.h.nodeid = get_node_id(inode);\n\targs->in.numargs = 1;\n\targs->in.args[0].size = sizeof(*inarg);\n\targs->in.args[0].value = inarg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUSE_ARGS",
          "args": [
            "args"
          ],
          "line": 2161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 2160
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 2159
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_setlk(struct file *file, struct file_lock *fl, int flock)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_lk_in inarg;\n\tint opcode = (fl->fl_flags & FL_SLEEP) ? FUSE_SETLKW : FUSE_SETLK;\n\tpid_t pid = fl->fl_type != F_UNLCK ? current->tgid : 0;\n\tint err;\n\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant) {\n\t\t/* NLM needs asynchronous locks, which we don't support yet */\n\t\treturn -ENOLCK;\n\t}\n\n\t/* Unlock on close is handled by the flush method */\n\tif (fl->fl_flags & FL_CLOSE)\n\t\treturn 0;\n\n\tfuse_lk_fill(&args, file, fl, opcode, pid, flock, &inarg);\n\terr = fuse_simple_request(fc, &args);\n\n\t/* locking is restartable */\n\tif (err == -EINTR)\n\t\terr = -ERESTARTSYS;\n\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_getlk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "2137-2155",
    "snippet": "static int fuse_getlk(struct file *file, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_lk_in inarg;\n\tstruct fuse_lk_out outarg;\n\tint err;\n\n\tfuse_lk_fill(&args, file, fl, FUSE_GETLK, 0, 0, &inarg);\n\targs.out.numargs = 1;\n\targs.out.args[0].size = sizeof(outarg);\n\targs.out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (!err)\n\t\terr = convert_fuse_file_lock(&outarg.lk, fl);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "convert_fuse_file_lock",
          "args": [
            "&outarg.lk",
            "fl"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "convert_fuse_file_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "2088-2111",
          "snippet": "static int convert_fuse_file_lock(const struct fuse_file_lock *ffl,\n\t\t\t\t  struct file_lock *fl)\n{\n\tswitch (ffl->type) {\n\tcase F_UNLCK:\n\t\tbreak;\n\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\t\tif (ffl->start > OFFSET_MAX || ffl->end > OFFSET_MAX ||\n\t\t    ffl->end < ffl->start)\n\t\t\treturn -EIO;\n\n\t\tfl->fl_start = ffl->start;\n\t\tfl->fl_end = ffl->end;\n\t\tfl->fl_pid = ffl->pid;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EIO;\n\t}\n\tfl->fl_type = ffl->type;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int convert_fuse_file_lock(const struct fuse_file_lock *ffl,\n\t\t\t\t  struct file_lock *fl)\n{\n\tswitch (ffl->type) {\n\tcase F_UNLCK:\n\t\tbreak;\n\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\t\tif (ffl->start > OFFSET_MAX || ffl->end > OFFSET_MAX ||\n\t\t    ffl->end < ffl->start)\n\t\t\treturn -EIO;\n\n\t\tfl->fl_start = ffl->start;\n\t\tfl->fl_end = ffl->end;\n\t\tfl->fl_pid = ffl->pid;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EIO;\n\t}\n\tfl->fl_type = ffl->type;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_simple_request",
          "args": [
            "fc",
            "&args"
          ],
          "line": 2150
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_simple_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "558-588",
          "snippet": "ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_lk_fill",
          "args": [
            "&args",
            "file",
            "fl",
            "FUSE_GETLK",
            "0",
            "0",
            "&inarg"
          ],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lk_fill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "2113-2135",
          "snippet": "static void fuse_lk_fill(struct fuse_args *args, struct file *file,\n\t\t\t const struct file_lock *fl, int opcode, pid_t pid,\n\t\t\t int flock, struct fuse_lk_in *inarg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_file *ff = file->private_data;\n\n\tmemset(inarg, 0, sizeof(*inarg));\n\tinarg->fh = ff->fh;\n\tinarg->owner = fuse_lock_owner_id(fc, fl->fl_owner);\n\tinarg->lk.start = fl->fl_start;\n\tinarg->lk.end = fl->fl_end;\n\tinarg->lk.type = fl->fl_type;\n\tinarg->lk.pid = pid;\n\tif (flock)\n\t\tinarg->lk_flags |= FUSE_LK_FLOCK;\n\targs->in.h.opcode = opcode;\n\targs->in.h.nodeid = get_node_id(inode);\n\targs->in.numargs = 1;\n\targs->in.args[0].size = sizeof(*inarg);\n\targs->in.args[0].value = inarg;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_lk_fill(struct fuse_args *args, struct file *file,\n\t\t\t const struct file_lock *fl, int opcode, pid_t pid,\n\t\t\t int flock, struct fuse_lk_in *inarg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_file *ff = file->private_data;\n\n\tmemset(inarg, 0, sizeof(*inarg));\n\tinarg->fh = ff->fh;\n\tinarg->owner = fuse_lock_owner_id(fc, fl->fl_owner);\n\tinarg->lk.start = fl->fl_start;\n\tinarg->lk.end = fl->fl_end;\n\tinarg->lk.type = fl->fl_type;\n\tinarg->lk.pid = pid;\n\tif (flock)\n\t\tinarg->lk_flags |= FUSE_LK_FLOCK;\n\targs->in.h.opcode = opcode;\n\targs->in.h.nodeid = get_node_id(inode);\n\targs->in.numargs = 1;\n\targs->in.args[0].size = sizeof(*inarg);\n\targs->in.args[0].value = inarg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUSE_ARGS",
          "args": [
            "args"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 2140
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 2139
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_getlk(struct file *file, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_lk_in inarg;\n\tstruct fuse_lk_out outarg;\n\tint err;\n\n\tfuse_lk_fill(&args, file, fl, FUSE_GETLK, 0, 0, &inarg);\n\targs.out.numargs = 1;\n\targs.out.args[0].size = sizeof(outarg);\n\targs.out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (!err)\n\t\terr = convert_fuse_file_lock(&outarg.lk, fl);\n\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_lk_fill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "2113-2135",
    "snippet": "static void fuse_lk_fill(struct fuse_args *args, struct file *file,\n\t\t\t const struct file_lock *fl, int opcode, pid_t pid,\n\t\t\t int flock, struct fuse_lk_in *inarg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_file *ff = file->private_data;\n\n\tmemset(inarg, 0, sizeof(*inarg));\n\tinarg->fh = ff->fh;\n\tinarg->owner = fuse_lock_owner_id(fc, fl->fl_owner);\n\tinarg->lk.start = fl->fl_start;\n\tinarg->lk.end = fl->fl_end;\n\tinarg->lk.type = fl->fl_type;\n\tinarg->lk.pid = pid;\n\tif (flock)\n\t\tinarg->lk_flags |= FUSE_LK_FLOCK;\n\targs->in.h.opcode = opcode;\n\targs->in.h.nodeid = get_node_id(inode);\n\targs->in.numargs = 1;\n\targs->in.args[0].size = sizeof(*inarg);\n\targs->in.args[0].value = inarg;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_node_id",
          "args": [
            "inode"
          ],
          "line": 2131
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "633-636",
          "snippet": "static inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_lock_owner_id",
          "args": [
            "fc",
            "fl->fl_owner"
          ],
          "line": 2123
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lock_owner_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "314-330",
          "snippet": "u64 fuse_lock_owner_id(struct fuse_conn *fc, fl_owner_t id)\n{\n\tu32 *k = fc->scramble_key;\n\tu64 v = (unsigned long) id;\n\tu32 v0 = v;\n\tu32 v1 = v >> 32;\n\tu32 sum = 0;\n\tint i;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tv0 += ((v1 << 4 ^ v1 >> 5) + v1) ^ (sum + k[sum & 3]);\n\t\tsum += 0x9E3779B9;\n\t\tv1 += ((v0 << 4 ^ v0 >> 5) + v0) ^ (sum + k[sum>>11 & 3]);\n\t}\n\n\treturn (u64) v0 + ((u64) v1 << 32);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nu64 fuse_lock_owner_id(struct fuse_conn *fc, fl_owner_t id)\n{\n\tu32 *k = fc->scramble_key;\n\tu64 v = (unsigned long) id;\n\tu32 v0 = v;\n\tu32 v1 = v >> 32;\n\tu32 sum = 0;\n\tint i;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tv0 += ((v1 << 4 ^ v1 >> 5) + v1) ^ (sum + k[sum & 3]);\n\t\tsum += 0x9E3779B9;\n\t\tv1 += ((v0 << 4 ^ v0 >> 5) + v0) ^ (sum + k[sum>>11 & 3]);\n\t}\n\n\treturn (u64) v0 + ((u64) v1 << 32);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "inarg",
            "0",
            "sizeof(*inarg)"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 2118
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_lk_fill(struct fuse_args *args, struct file *file,\n\t\t\t const struct file_lock *fl, int opcode, pid_t pid,\n\t\t\t int flock, struct fuse_lk_in *inarg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_file *ff = file->private_data;\n\n\tmemset(inarg, 0, sizeof(*inarg));\n\tinarg->fh = ff->fh;\n\tinarg->owner = fuse_lock_owner_id(fc, fl->fl_owner);\n\tinarg->lk.start = fl->fl_start;\n\tinarg->lk.end = fl->fl_end;\n\tinarg->lk.type = fl->fl_type;\n\tinarg->lk.pid = pid;\n\tif (flock)\n\t\tinarg->lk_flags |= FUSE_LK_FLOCK;\n\targs->in.h.opcode = opcode;\n\targs->in.h.nodeid = get_node_id(inode);\n\targs->in.numargs = 1;\n\targs->in.args[0].size = sizeof(*inarg);\n\targs->in.args[0].value = inarg;\n}"
  },
  {
    "function_name": "convert_fuse_file_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "2088-2111",
    "snippet": "static int convert_fuse_file_lock(const struct fuse_file_lock *ffl,\n\t\t\t\t  struct file_lock *fl)\n{\n\tswitch (ffl->type) {\n\tcase F_UNLCK:\n\t\tbreak;\n\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\t\tif (ffl->start > OFFSET_MAX || ffl->end > OFFSET_MAX ||\n\t\t    ffl->end < ffl->start)\n\t\t\treturn -EIO;\n\n\t\tfl->fl_start = ffl->start;\n\t\tfl->fl_end = ffl->end;\n\t\tfl->fl_pid = ffl->pid;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EIO;\n\t}\n\tfl->fl_type = ffl->type;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int convert_fuse_file_lock(const struct fuse_file_lock *ffl,\n\t\t\t\t  struct file_lock *fl)\n{\n\tswitch (ffl->type) {\n\tcase F_UNLCK:\n\t\tbreak;\n\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\t\tif (ffl->start > OFFSET_MAX || ffl->end > OFFSET_MAX ||\n\t\t    ffl->end < ffl->start)\n\t\t\treturn -EIO;\n\n\t\tfl->fl_start = ffl->start;\n\t\tfl->fl_end = ffl->end;\n\t\tfl->fl_pid = ffl->pid;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EIO;\n\t}\n\tfl->fl_type = ffl->type;\n\treturn 0;\n}"
  },
  {
    "function_name": "fuse_direct_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "2077-2086",
    "snippet": "static int fuse_direct_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\t/* Can't provide the coherency needed for MAP_SHARED */\n\tif (vma->vm_flags & VM_MAYSHARE)\n\t\treturn -ENODEV;\n\n\tinvalidate_inode_pages2(file->f_mapping);\n\n\treturn generic_file_mmap(file, vma);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_file_mmap",
          "args": [
            "file",
            "vma"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_inode_pages2",
          "args": [
            "file->f_mapping"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_direct_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\t/* Can't provide the coherency needed for MAP_SHARED */\n\tif (vma->vm_flags & VM_MAYSHARE)\n\t\treturn -ENODEV;\n\n\tinvalidate_inode_pages2(file->f_mapping);\n\n\treturn generic_file_mmap(file, vma);\n}"
  },
  {
    "function_name": "fuse_file_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "2067-2075",
    "snippet": "static int fuse_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tif ((vma->vm_flags & VM_SHARED) && (vma->vm_flags & VM_MAYWRITE))\n\t\tfuse_link_write_file(file);\n\n\tfile_accessed(file);\n\tvma->vm_ops = &fuse_file_vm_ops;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct vm_operations_struct fuse_file_vm_ops = {\n\t.close\t\t= fuse_vma_close,\n\t.fault\t\t= filemap_fault,\n\t.map_pages\t= filemap_map_pages,\n\t.page_mkwrite\t= fuse_page_mkwrite,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_accessed",
          "args": [
            "file"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_link_write_file",
          "args": [
            "file"
          ],
          "line": 2070
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_link_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "155-169",
          "snippet": "static void fuse_link_write_file(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_file *ff = file->private_data;\n\t/*\n\t * file may be written through mmap, so chain it onto the\n\t * inodes's write_file list\n\t */\n\tspin_lock(&fc->lock);\n\tif (list_empty(&ff->write_entry))\n\t\tlist_add(&ff->write_entry, &fi->write_files);\n\tspin_unlock(&fc->lock);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_link_write_file(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_file *ff = file->private_data;\n\t/*\n\t * file may be written through mmap, so chain it onto the\n\t * inodes's write_file list\n\t */\n\tspin_lock(&fc->lock);\n\tif (list_empty(&ff->write_entry))\n\t\tlist_add(&ff->write_entry, &fi->write_files);\n\tspin_unlock(&fc->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct vm_operations_struct fuse_file_vm_ops = {\n\t.close\t\t= fuse_vma_close,\n\t.fault\t\t= filemap_fault,\n\t.map_pages\t= filemap_map_pages,\n\t.page_mkwrite\t= fuse_page_mkwrite,\n};\n\nstatic int fuse_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tif ((vma->vm_flags & VM_SHARED) && (vma->vm_flags & VM_MAYWRITE))\n\t\tfuse_link_write_file(file);\n\n\tfile_accessed(file);\n\tvma->vm_ops = &fuse_file_vm_ops;\n\treturn 0;\n}"
  },
  {
    "function_name": "fuse_page_mkwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "2044-2058",
    "snippet": "static int fuse_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\n\tfile_update_time(vma->vm_file);\n\tlock_page(page);\n\tif (page->mapping != inode->i_mapping) {\n\t\tunlock_page(page);\n\t\treturn VM_FAULT_NOPAGE;\n\t}\n\n\tfuse_wait_on_page_writeback(inode, page->index);\n\treturn VM_FAULT_LOCKED;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_wait_on_page_writeback",
          "args": [
            "inode",
            "page->index"
          ],
          "line": 2056
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "374-380",
          "snippet": "static int fuse_wait_on_page_writeback(struct inode *inode, pgoff_t index)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\twait_event(fi->page_waitq, !fuse_page_is_writeback(inode, index));\n\treturn 0;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_wait_on_page_writeback(struct inode *inode, pgoff_t index)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\twait_event(fi->page_waitq, !fuse_page_is_writeback(inode, index));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2052
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_update_time",
          "args": [
            "vma->vm_file"
          ],
          "line": 2049
        },
        "resolved": true,
        "details": {
          "function_name": "file_update_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1716-1748",
          "snippet": "int file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 2047
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\n\tfile_update_time(vma->vm_file);\n\tlock_page(page);\n\tif (page->mapping != inode->i_mapping) {\n\t\tunlock_page(page);\n\t\treturn VM_FAULT_NOPAGE;\n\t}\n\n\tfuse_wait_on_page_writeback(inode, page->index);\n\treturn VM_FAULT_LOCKED;\n}"
  },
  {
    "function_name": "fuse_vma_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "2024-2027",
    "snippet": "static void fuse_vma_close(struct vm_area_struct *vma)\n{\n\tfilemap_write_and_wait(vma->vm_file->f_mapping);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "vma->vm_file->f_mapping"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_vma_close(struct vm_area_struct *vma)\n{\n\tfilemap_write_and_wait(vma->vm_file->f_mapping);\n}"
  },
  {
    "function_name": "fuse_launder_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "2008-2018",
    "snippet": "static int fuse_launder_page(struct page *page)\n{\n\tint err = 0;\n\tif (clear_page_dirty_for_io(page)) {\n\t\tstruct inode *inode = page->mapping->host;\n\t\terr = fuse_writepage_locked(page);\n\t\tif (!err)\n\t\t\tfuse_wait_on_page_writeback(inode, page->index);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_wait_on_page_writeback",
          "args": [
            "inode",
            "page->index"
          ],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "374-380",
          "snippet": "static int fuse_wait_on_page_writeback(struct inode *inode, pgoff_t index)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\twait_event(fi->page_waitq, !fuse_page_is_writeback(inode, index));\n\treturn 0;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_wait_on_page_writeback(struct inode *inode, pgoff_t index)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\twait_event(fi->page_waitq, !fuse_page_is_writeback(inode, index));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_writepage_locked",
          "args": [
            "page"
          ],
          "line": 2013
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_writepage_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1622-1681",
          "snippet": "static int fuse_writepage_locked(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_req *req;\n\tstruct page *tmp_page;\n\tint error = -ENOMEM;\n\n\tset_page_writeback(page);\n\n\treq = fuse_request_alloc_nofs(1);\n\tif (!req)\n\t\tgoto err;\n\n\treq->background = 1; /* writeback always goes to bg_queue */\n\ttmp_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\tif (!tmp_page)\n\t\tgoto err_free;\n\n\terror = -EIO;\n\treq->ff = fuse_write_file_get(fc, fi);\n\tif (!req->ff)\n\t\tgoto err_nofile;\n\n\tfuse_write_fill(req, req->ff, page_offset(page), 0);\n\n\tcopy_highpage(tmp_page, page);\n\treq->misc.write.in.write_flags |= FUSE_WRITE_CACHE;\n\treq->misc.write.next = NULL;\n\treq->in.argpages = 1;\n\treq->num_pages = 1;\n\treq->pages[0] = tmp_page;\n\treq->page_descs[0].offset = 0;\n\treq->page_descs[0].length = PAGE_SIZE;\n\treq->end = fuse_writepage_end;\n\treq->inode = inode;\n\n\tinc_bdi_stat(inode_to_bdi(inode), BDI_WRITEBACK);\n\tinc_zone_page_state(tmp_page, NR_WRITEBACK_TEMP);\n\n\tspin_lock(&fc->lock);\n\tlist_add(&req->writepages_entry, &fi->writepages);\n\tlist_add_tail(&req->list, &fi->queued_writes);\n\tfuse_flush_writepages(inode);\n\tspin_unlock(&fc->lock);\n\n\tend_page_writeback(page);\n\n\treturn 0;\n\nerr_nofile:\n\t__free_page(tmp_page);\nerr_free:\n\tfuse_request_free(req);\nerr:\n\tend_page_writeback(page);\n\treturn error;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_writepage_locked(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_req *req;\n\tstruct page *tmp_page;\n\tint error = -ENOMEM;\n\n\tset_page_writeback(page);\n\n\treq = fuse_request_alloc_nofs(1);\n\tif (!req)\n\t\tgoto err;\n\n\treq->background = 1; /* writeback always goes to bg_queue */\n\ttmp_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\tif (!tmp_page)\n\t\tgoto err_free;\n\n\terror = -EIO;\n\treq->ff = fuse_write_file_get(fc, fi);\n\tif (!req->ff)\n\t\tgoto err_nofile;\n\n\tfuse_write_fill(req, req->ff, page_offset(page), 0);\n\n\tcopy_highpage(tmp_page, page);\n\treq->misc.write.in.write_flags |= FUSE_WRITE_CACHE;\n\treq->misc.write.next = NULL;\n\treq->in.argpages = 1;\n\treq->num_pages = 1;\n\treq->pages[0] = tmp_page;\n\treq->page_descs[0].offset = 0;\n\treq->page_descs[0].length = PAGE_SIZE;\n\treq->end = fuse_writepage_end;\n\treq->inode = inode;\n\n\tinc_bdi_stat(inode_to_bdi(inode), BDI_WRITEBACK);\n\tinc_zone_page_state(tmp_page, NR_WRITEBACK_TEMP);\n\n\tspin_lock(&fc->lock);\n\tlist_add(&req->writepages_entry, &fi->writepages);\n\tlist_add_tail(&req->list, &fi->queued_writes);\n\tfuse_flush_writepages(inode);\n\tspin_unlock(&fc->lock);\n\n\tend_page_writeback(page);\n\n\treturn 0;\n\nerr_nofile:\n\t__free_page(tmp_page);\nerr_free:\n\tfuse_request_free(req);\nerr:\n\tend_page_writeback(page);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "page"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_launder_page(struct page *page)\n{\n\tint err = 0;\n\tif (clear_page_dirty_for_io(page)) {\n\t\tstruct inode *inode = page->mapping->host;\n\t\terr = fuse_writepage_locked(page);\n\t\tif (!err)\n\t\t\tfuse_wait_on_page_writeback(inode, page->index);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1986-2006",
    "snippet": "static int fuse_write_end(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned copied,\n\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = page->mapping->host;\n\n\tif (!PageUptodate(page)) {\n\t\t/* Zero any unwritten bytes at the end of the page */\n\t\tsize_t endoff = (pos + copied) & ~PAGE_CACHE_MASK;\n\t\tif (endoff)\n\t\t\tzero_user_segment(page, endoff, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t}\n\n\tfuse_write_update_size(inode, pos + copied);\n\tset_page_dirty(page);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\treturn copied;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2002
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 2001
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_write_update_size",
          "args": [
            "inode",
            "pos + copied"
          ],
          "line": 2000
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_write_update_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "957-972",
          "snippet": "bool fuse_write_update_size(struct inode *inode, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tbool ret = false;\n\n\tspin_lock(&fc->lock);\n\tfi->attr_version = ++fc->attr_version;\n\tif (pos > inode->i_size) {\n\t\ti_size_write(inode, pos);\n\t\tret = true;\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nbool fuse_write_update_size(struct inode *inode, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tbool ret = false;\n\n\tspin_lock(&fc->lock);\n\tfi->attr_version = ++fc->attr_version;\n\tif (pos > inode->i_size) {\n\t\ti_size_write(inode, pos);\n\t\tret = true;\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "endoff",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_write_end(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned copied,\n\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = page->mapping->host;\n\n\tif (!PageUptodate(page)) {\n\t\t/* Zero any unwritten bytes at the end of the page */\n\t\tsize_t endoff = (pos + copied) & ~PAGE_CACHE_MASK;\n\t\tif (endoff)\n\t\t\tzero_user_segment(page, endoff, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t}\n\n\tfuse_write_update_size(inode, pos + copied);\n\tset_page_dirty(page);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\treturn copied;\n}"
  },
  {
    "function_name": "fuse_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1941-1984",
    "snippet": "static int fuse_write_begin(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, void **fsdata)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct fuse_conn *fc = get_fuse_conn(file_inode(file));\n\tstruct page *page;\n\tloff_t fsize;\n\tint err = -ENOMEM;\n\n\tWARN_ON(!fc->writeback_cache);\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\tgoto error;\n\n\tfuse_wait_on_page_writeback(mapping->host, page->index);\n\n\tif (PageUptodate(page) || len == PAGE_CACHE_SIZE)\n\t\tgoto success;\n\t/*\n\t * Check if the start this page comes after the end of file, in which\n\t * case the readpage can be optimized away.\n\t */\n\tfsize = i_size_read(mapping->host);\n\tif (fsize <= (pos & PAGE_CACHE_MASK)) {\n\t\tsize_t off = pos & ~PAGE_CACHE_MASK;\n\t\tif (off)\n\t\t\tzero_user_segment(page, 0, off);\n\t\tgoto success;\n\t}\n\terr = fuse_do_readpage(file, page);\n\tif (err)\n\t\tgoto cleanup;\nsuccess:\n\t*pagep = page;\n\treturn 0;\n\ncleanup:\n\tunlock_page(page);\n\tpage_cache_release(page);\nerror:\n\treturn err;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1980
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_do_readpage",
          "args": [
            "file",
            "page"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_do_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "686-732",
          "snippet": "static int fuse_do_readpage(struct file *file, struct page *page)\n{\n\tstruct fuse_io_priv io = { .async = 0, .file = file };\n\tstruct inode *inode = page->mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_req *req;\n\tsize_t num_read;\n\tloff_t pos = page_offset(page);\n\tsize_t count = PAGE_CACHE_SIZE;\n\tu64 attr_ver;\n\tint err;\n\n\t/*\n\t * Page writeback can extend beyond the lifetime of the\n\t * page-cache page, so make sure we read a properly synced\n\t * page.\n\t */\n\tfuse_wait_on_page_writeback(inode, page->index);\n\n\treq = fuse_get_req(fc, 1);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tattr_ver = fuse_get_attr_version(fc);\n\n\treq->out.page_zeroing = 1;\n\treq->out.argpages = 1;\n\treq->num_pages = 1;\n\treq->pages[0] = page;\n\treq->page_descs[0].length = count;\n\tnum_read = fuse_send_read(req, &io, pos, count, NULL);\n\terr = req->out.h.error;\n\n\tif (!err) {\n\t\t/*\n\t\t * Short read means EOF.  If file size is larger, truncate it\n\t\t */\n\t\tif (num_read < count)\n\t\t\tfuse_short_read(req, inode, attr_ver);\n\n\t\tSetPageUptodate(page);\n\t}\n\n\tfuse_put_request(fc, req);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_do_readpage(struct file *file, struct page *page)\n{\n\tstruct fuse_io_priv io = { .async = 0, .file = file };\n\tstruct inode *inode = page->mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_req *req;\n\tsize_t num_read;\n\tloff_t pos = page_offset(page);\n\tsize_t count = PAGE_CACHE_SIZE;\n\tu64 attr_ver;\n\tint err;\n\n\t/*\n\t * Page writeback can extend beyond the lifetime of the\n\t * page-cache page, so make sure we read a properly synced\n\t * page.\n\t */\n\tfuse_wait_on_page_writeback(inode, page->index);\n\n\treq = fuse_get_req(fc, 1);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tattr_ver = fuse_get_attr_version(fc);\n\n\treq->out.page_zeroing = 1;\n\treq->out.argpages = 1;\n\treq->num_pages = 1;\n\treq->pages[0] = page;\n\treq->page_descs[0].length = count;\n\tnum_read = fuse_send_read(req, &io, pos, count, NULL);\n\terr = req->out.h.error;\n\n\tif (!err) {\n\t\t/*\n\t\t * Short read means EOF.  If file size is larger, truncate it\n\t\t */\n\t\tif (num_read < count)\n\t\t\tfuse_short_read(req, inode, attr_ver);\n\n\t\tSetPageUptodate(page);\n\t}\n\n\tfuse_put_request(fc, req);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "0",
            "off"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "mapping->host"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_wait_on_page_writeback",
          "args": [
            "mapping->host",
            "page->index"
          ],
          "line": 1957
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "374-380",
          "snippet": "static int fuse_wait_on_page_writeback(struct inode *inode, pgoff_t index)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\twait_event(fi->page_waitq, !fuse_page_is_writeback(inode, index));\n\treturn 0;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_wait_on_page_writeback(struct inode *inode, pgoff_t index)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\twait_event(fi->page_waitq, !fuse_page_is_writeback(inode, index));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "mapping",
            "index",
            "flags"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!fc->writeback_cache"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "file_inode(file)"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_write_begin(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, void **fsdata)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct fuse_conn *fc = get_fuse_conn(file_inode(file));\n\tstruct page *page;\n\tloff_t fsize;\n\tint err = -ENOMEM;\n\n\tWARN_ON(!fc->writeback_cache);\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\tgoto error;\n\n\tfuse_wait_on_page_writeback(mapping->host, page->index);\n\n\tif (PageUptodate(page) || len == PAGE_CACHE_SIZE)\n\t\tgoto success;\n\t/*\n\t * Check if the start this page comes after the end of file, in which\n\t * case the readpage can be optimized away.\n\t */\n\tfsize = i_size_read(mapping->host);\n\tif (fsize <= (pos & PAGE_CACHE_MASK)) {\n\t\tsize_t off = pos & ~PAGE_CACHE_MASK;\n\t\tif (off)\n\t\t\tzero_user_segment(page, 0, off);\n\t\tgoto success;\n\t}\n\terr = fuse_do_readpage(file, page);\n\tif (err)\n\t\tgoto cleanup;\nsuccess:\n\t*pagep = page;\n\treturn 0;\n\ncleanup:\n\tunlock_page(page);\n\tpage_cache_release(page);\nerror:\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_writepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1900-1935",
    "snippet": "static int fuse_writepages(struct address_space *mapping,\n\t\t\t   struct writeback_control *wbc)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_fill_wb_data data;\n\tint err;\n\n\terr = -EIO;\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\n\tdata.inode = inode;\n\tdata.req = NULL;\n\tdata.ff = NULL;\n\n\terr = -ENOMEM;\n\tdata.orig_pages = kcalloc(FUSE_MAX_PAGES_PER_REQ,\n\t\t\t\t  sizeof(struct page *),\n\t\t\t\t  GFP_NOFS);\n\tif (!data.orig_pages)\n\t\tgoto out;\n\n\terr = write_cache_pages(mapping, wbc, fuse_writepages_fill, &data);\n\tif (data.req) {\n\t\t/* Ignore errors if we can write at least one page */\n\t\tBUG_ON(!data.req->num_pages);\n\t\tfuse_writepages_send(&data);\n\t\terr = 0;\n\t}\n\tif (data.ff)\n\t\tfuse_file_put(data.ff, false);\n\n\tkfree(data.orig_pages);\nout:\n\treturn err;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data.orig_pages"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_file_put",
          "args": [
            "data.ff",
            "false"
          ],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_file_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "89-114",
          "snippet": "static void fuse_file_put(struct fuse_file *ff, bool sync)\n{\n\tif (atomic_dec_and_test(&ff->count)) {\n\t\tstruct fuse_req *req = ff->reserved_req;\n\n\t\tif (ff->fc->no_open) {\n\t\t\t/*\n\t\t\t * Drop the release request when client does not\n\t\t\t * implement 'open'\n\t\t\t */\n\t\t\treq->background = 0;\n\t\t\tiput(req->misc.release.inode);\n\t\t\tfuse_put_request(ff->fc, req);\n\t\t} else if (sync) {\n\t\t\treq->background = 0;\n\t\t\tfuse_request_send(ff->fc, req);\n\t\t\tiput(req->misc.release.inode);\n\t\t\tfuse_put_request(ff->fc, req);\n\t\t} else {\n\t\t\treq->end = fuse_release_end;\n\t\t\treq->background = 1;\n\t\t\tfuse_request_send_background(ff->fc, req);\n\t\t}\n\t\tkfree(ff);\n\t}\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_file_put(struct fuse_file *ff, bool sync)\n{\n\tif (atomic_dec_and_test(&ff->count)) {\n\t\tstruct fuse_req *req = ff->reserved_req;\n\n\t\tif (ff->fc->no_open) {\n\t\t\t/*\n\t\t\t * Drop the release request when client does not\n\t\t\t * implement 'open'\n\t\t\t */\n\t\t\treq->background = 0;\n\t\t\tiput(req->misc.release.inode);\n\t\t\tfuse_put_request(ff->fc, req);\n\t\t} else if (sync) {\n\t\t\treq->background = 0;\n\t\t\tfuse_request_send(ff->fc, req);\n\t\t\tiput(req->misc.release.inode);\n\t\t\tfuse_put_request(ff->fc, req);\n\t\t} else {\n\t\t\treq->end = fuse_release_end;\n\t\t\treq->background = 1;\n\t\t\tfuse_request_send_background(ff->fc, req);\n\t\t}\n\t\tkfree(ff);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_writepages_send",
          "args": [
            "&data"
          ],
          "line": 1926
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_writepages_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1712-1729",
          "snippet": "static void fuse_writepages_send(struct fuse_fill_wb_data *data)\n{\n\tstruct fuse_req *req = data->req;\n\tstruct inode *inode = data->inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tint num_pages = req->num_pages;\n\tint i;\n\n\treq->ff = fuse_file_get(data->ff);\n\tspin_lock(&fc->lock);\n\tlist_add_tail(&req->list, &fi->queued_writes);\n\tfuse_flush_writepages(inode);\n\tspin_unlock(&fc->lock);\n\n\tfor (i = 0; i < num_pages; i++)\n\t\tend_page_writeback(data->orig_pages[i]);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_writepages_send(struct fuse_fill_wb_data *data)\n{\n\tstruct fuse_req *req = data->req;\n\tstruct inode *inode = data->inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tint num_pages = req->num_pages;\n\tint i;\n\n\treq->ff = fuse_file_get(data->ff);\n\tspin_lock(&fc->lock);\n\tlist_add_tail(&req->list, &fi->queued_writes);\n\tfuse_flush_writepages(inode);\n\tspin_unlock(&fc->lock);\n\n\tfor (i = 0; i < num_pages; i++)\n\t\tend_page_writeback(data->orig_pages[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!data.req->num_pages"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_cache_pages",
          "args": [
            "mapping",
            "wbc",
            "fuse_writepages_fill",
            "&data"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "FUSE_MAX_PAGES_PER_REQ",
            "sizeof(struct page *)",
            "GFP_NOFS"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_writepages(struct address_space *mapping,\n\t\t\t   struct writeback_control *wbc)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_fill_wb_data data;\n\tint err;\n\n\terr = -EIO;\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\n\tdata.inode = inode;\n\tdata.req = NULL;\n\tdata.ff = NULL;\n\n\terr = -ENOMEM;\n\tdata.orig_pages = kcalloc(FUSE_MAX_PAGES_PER_REQ,\n\t\t\t\t  sizeof(struct page *),\n\t\t\t\t  GFP_NOFS);\n\tif (!data.orig_pages)\n\t\tgoto out;\n\n\terr = write_cache_pages(mapping, wbc, fuse_writepages_fill, &data);\n\tif (data.req) {\n\t\t/* Ignore errors if we can write at least one page */\n\t\tBUG_ON(!data.req->num_pages);\n\t\tfuse_writepages_send(&data);\n\t\terr = 0;\n\t}\n\tif (data.ff)\n\t\tfuse_file_put(data.ff, false);\n\n\tkfree(data.orig_pages);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_writepages_fill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1792-1898",
    "snippet": "static int fuse_writepages_fill(struct page *page,\n\t\tstruct writeback_control *wbc, void *_data)\n{\n\tstruct fuse_fill_wb_data *data = _data;\n\tstruct fuse_req *req = data->req;\n\tstruct inode *inode = data->inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct page *tmp_page;\n\tbool is_writeback;\n\tint err;\n\n\tif (!data->ff) {\n\t\terr = -EIO;\n\t\tdata->ff = fuse_write_file_get(fc, get_fuse_inode(inode));\n\t\tif (!data->ff)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Being under writeback is unlikely but possible.  For example direct\n\t * read to an mmaped fuse file will set the page dirty twice; once when\n\t * the pages are faulted with get_user_pages(), and then after the read\n\t * completed.\n\t */\n\tis_writeback = fuse_page_is_writeback(inode, page->index);\n\n\tif (req && req->num_pages &&\n\t    (is_writeback || req->num_pages == FUSE_MAX_PAGES_PER_REQ ||\n\t     (req->num_pages + 1) * PAGE_CACHE_SIZE > fc->max_write ||\n\t     data->orig_pages[req->num_pages - 1]->index + 1 != page->index)) {\n\t\tfuse_writepages_send(data);\n\t\tdata->req = NULL;\n\t}\n\terr = -ENOMEM;\n\ttmp_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\tif (!tmp_page)\n\t\tgoto out_unlock;\n\n\t/*\n\t * The page must not be redirtied until the writeout is completed\n\t * (i.e. userspace has sent a reply to the write request).  Otherwise\n\t * there could be more than one temporary page instance for each real\n\t * page.\n\t *\n\t * This is ensured by holding the page lock in page_mkwrite() while\n\t * checking fuse_page_is_writeback().  We already hold the page lock\n\t * since clear_page_dirty_for_io() and keep it held until we add the\n\t * request to the fi->writepages list and increment req->num_pages.\n\t * After this fuse_page_is_writeback() will indicate that the page is\n\t * under writeback, so we can release the page lock.\n\t */\n\tif (data->req == NULL) {\n\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\terr = -ENOMEM;\n\t\treq = fuse_request_alloc_nofs(FUSE_MAX_PAGES_PER_REQ);\n\t\tif (!req) {\n\t\t\t__free_page(tmp_page);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tfuse_write_fill(req, data->ff, page_offset(page), 0);\n\t\treq->misc.write.in.write_flags |= FUSE_WRITE_CACHE;\n\t\treq->misc.write.next = NULL;\n\t\treq->in.argpages = 1;\n\t\treq->background = 1;\n\t\treq->num_pages = 0;\n\t\treq->end = fuse_writepage_end;\n\t\treq->inode = inode;\n\n\t\tspin_lock(&fc->lock);\n\t\tlist_add(&req->writepages_entry, &fi->writepages);\n\t\tspin_unlock(&fc->lock);\n\n\t\tdata->req = req;\n\t}\n\tset_page_writeback(page);\n\n\tcopy_highpage(tmp_page, page);\n\treq->pages[req->num_pages] = tmp_page;\n\treq->page_descs[req->num_pages].offset = 0;\n\treq->page_descs[req->num_pages].length = PAGE_SIZE;\n\n\tinc_bdi_stat(inode_to_bdi(inode), BDI_WRITEBACK);\n\tinc_zone_page_state(tmp_page, NR_WRITEBACK_TEMP);\n\n\terr = 0;\n\tif (is_writeback && fuse_writepage_in_flight(req, page)) {\n\t\tend_page_writeback(page);\n\t\tdata->req = NULL;\n\t\tgoto out_unlock;\n\t}\n\tdata->orig_pages[req->num_pages] = page;\n\n\t/*\n\t * Protected by fc->lock against concurrent access by\n\t * fuse_page_is_writeback().\n\t */\n\tspin_lock(&fc->lock);\n\treq->num_pages++;\n\tspin_unlock(&fc->lock);\n\nout_unlock:\n\tunlock_page(page);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1895
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 1892
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 1880
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_writepage_in_flight",
          "args": [
            "req",
            "page"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_writepage_in_flight",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1731-1790",
          "snippet": "static bool fuse_writepage_in_flight(struct fuse_req *new_req,\n\t\t\t\t     struct page *page)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(new_req->inode);\n\tstruct fuse_inode *fi = get_fuse_inode(new_req->inode);\n\tstruct fuse_req *tmp;\n\tstruct fuse_req *old_req;\n\tbool found = false;\n\tpgoff_t curr_index;\n\n\tBUG_ON(new_req->num_pages != 0);\n\n\tspin_lock(&fc->lock);\n\tlist_del(&new_req->writepages_entry);\n\tlist_for_each_entry(old_req, &fi->writepages, writepages_entry) {\n\t\tBUG_ON(old_req->inode != new_req->inode);\n\t\tcurr_index = old_req->misc.write.in.offset >> PAGE_CACHE_SHIFT;\n\t\tif (curr_index <= page->index &&\n\t\t    page->index < curr_index + old_req->num_pages) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tlist_add(&new_req->writepages_entry, &fi->writepages);\n\t\tgoto out_unlock;\n\t}\n\n\tnew_req->num_pages = 1;\n\tfor (tmp = old_req; tmp != NULL; tmp = tmp->misc.write.next) {\n\t\tBUG_ON(tmp->inode != new_req->inode);\n\t\tcurr_index = tmp->misc.write.in.offset >> PAGE_CACHE_SHIFT;\n\t\tif (tmp->num_pages == 1 &&\n\t\t    curr_index == page->index) {\n\t\t\told_req = tmp;\n\t\t}\n\t}\n\n\tif (old_req->num_pages == 1 && (old_req->state == FUSE_REQ_INIT ||\n\t\t\t\t\told_req->state == FUSE_REQ_PENDING)) {\n\t\tstruct backing_dev_info *bdi = inode_to_bdi(page->mapping->host);\n\n\t\tcopy_highpage(old_req->pages[0], page);\n\t\tspin_unlock(&fc->lock);\n\n\t\tdec_bdi_stat(bdi, BDI_WRITEBACK);\n\t\tdec_zone_page_state(page, NR_WRITEBACK_TEMP);\n\t\tbdi_writeout_inc(bdi);\n\t\tfuse_writepage_free(fc, new_req);\n\t\tfuse_request_free(new_req);\n\t\tgoto out;\n\t} else {\n\t\tnew_req->misc.write.next = old_req->misc.write.next;\n\t\told_req->misc.write.next = new_req;\n\t}\nout_unlock:\n\tspin_unlock(&fc->lock);\nout:\n\treturn found;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic bool fuse_writepage_in_flight(struct fuse_req *new_req,\n\t\t\t\t     struct page *page)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(new_req->inode);\n\tstruct fuse_inode *fi = get_fuse_inode(new_req->inode);\n\tstruct fuse_req *tmp;\n\tstruct fuse_req *old_req;\n\tbool found = false;\n\tpgoff_t curr_index;\n\n\tBUG_ON(new_req->num_pages != 0);\n\n\tspin_lock(&fc->lock);\n\tlist_del(&new_req->writepages_entry);\n\tlist_for_each_entry(old_req, &fi->writepages, writepages_entry) {\n\t\tBUG_ON(old_req->inode != new_req->inode);\n\t\tcurr_index = old_req->misc.write.in.offset >> PAGE_CACHE_SHIFT;\n\t\tif (curr_index <= page->index &&\n\t\t    page->index < curr_index + old_req->num_pages) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tlist_add(&new_req->writepages_entry, &fi->writepages);\n\t\tgoto out_unlock;\n\t}\n\n\tnew_req->num_pages = 1;\n\tfor (tmp = old_req; tmp != NULL; tmp = tmp->misc.write.next) {\n\t\tBUG_ON(tmp->inode != new_req->inode);\n\t\tcurr_index = tmp->misc.write.in.offset >> PAGE_CACHE_SHIFT;\n\t\tif (tmp->num_pages == 1 &&\n\t\t    curr_index == page->index) {\n\t\t\told_req = tmp;\n\t\t}\n\t}\n\n\tif (old_req->num_pages == 1 && (old_req->state == FUSE_REQ_INIT ||\n\t\t\t\t\told_req->state == FUSE_REQ_PENDING)) {\n\t\tstruct backing_dev_info *bdi = inode_to_bdi(page->mapping->host);\n\n\t\tcopy_highpage(old_req->pages[0], page);\n\t\tspin_unlock(&fc->lock);\n\n\t\tdec_bdi_stat(bdi, BDI_WRITEBACK);\n\t\tdec_zone_page_state(page, NR_WRITEBACK_TEMP);\n\t\tbdi_writeout_inc(bdi);\n\t\tfuse_writepage_free(fc, new_req);\n\t\tfuse_request_free(new_req);\n\t\tgoto out;\n\t} else {\n\t\tnew_req->misc.write.next = old_req->misc.write.next;\n\t\told_req->misc.write.next = new_req;\n\t}\nout_unlock:\n\tspin_unlock(&fc->lock);\nout:\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_zone_page_state",
          "args": [
            "tmp_page",
            "NR_WRITEBACK_TEMP"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_bdi_stat",
          "args": [
            "inode_to_bdi(inode)",
            "BDI_WRITEBACK"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "inode"
          ],
          "line": 1875
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_bdi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "69-82",
          "snippet": "struct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_highpage",
          "args": [
            "tmp_page",
            "page"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "265-277",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&req->writepages_entry",
            "&fi->writepages"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_write_fill",
          "args": [
            "req",
            "data->ff",
            "page_offset(page)",
            "0"
          ],
          "line": 1853
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_write_fill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "912-933",
          "snippet": "static void fuse_write_fill(struct fuse_req *req, struct fuse_file *ff,\n\t\t\t    loff_t pos, size_t count)\n{\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\tstruct fuse_write_out *outarg = &req->misc.write.out;\n\n\tinarg->fh = ff->fh;\n\tinarg->offset = pos;\n\tinarg->size = count;\n\treq->in.h.opcode = FUSE_WRITE;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 2;\n\tif (ff->fc->minor < 9)\n\t\treq->in.args[0].size = FUSE_COMPAT_WRITE_IN_SIZE;\n\telse\n\t\treq->in.args[0].size = sizeof(struct fuse_write_in);\n\treq->in.args[0].value = inarg;\n\treq->in.args[1].size = count;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = sizeof(struct fuse_write_out);\n\treq->out.args[0].value = outarg;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_write_fill(struct fuse_req *req, struct fuse_file *ff,\n\t\t\t    loff_t pos, size_t count)\n{\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\tstruct fuse_write_out *outarg = &req->misc.write.out;\n\n\tinarg->fh = ff->fh;\n\tinarg->offset = pos;\n\tinarg->size = count;\n\treq->in.h.opcode = FUSE_WRITE;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 2;\n\tif (ff->fc->minor < 9)\n\t\treq->in.args[0].size = FUSE_COMPAT_WRITE_IN_SIZE;\n\telse\n\t\treq->in.args[0].size = sizeof(struct fuse_write_in);\n\treq->in.args[0].value = inarg;\n\treq->in.args[1].size = count;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = sizeof(struct fuse_write_out);\n\treq->out.args[0].value = outarg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "tmp_page"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_request_alloc_nofs",
          "args": [
            "FUSE_MAX_PAGES_PER_REQ"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_alloc_nofs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "88-91",
          "snippet": "struct fuse_req *fuse_request_alloc_nofs(unsigned npages)\n{\n\treturn __fuse_request_alloc(npages, GFP_NOFS);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstruct fuse_req *fuse_request_alloc_nofs(unsigned npages)\n{\n\treturn __fuse_request_alloc(npages, GFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 1844
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_NOFS | __GFP_HIGHMEM"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_writepages_send",
          "args": [
            "data"
          ],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_writepages_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1712-1729",
          "snippet": "static void fuse_writepages_send(struct fuse_fill_wb_data *data)\n{\n\tstruct fuse_req *req = data->req;\n\tstruct inode *inode = data->inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tint num_pages = req->num_pages;\n\tint i;\n\n\treq->ff = fuse_file_get(data->ff);\n\tspin_lock(&fc->lock);\n\tlist_add_tail(&req->list, &fi->queued_writes);\n\tfuse_flush_writepages(inode);\n\tspin_unlock(&fc->lock);\n\n\tfor (i = 0; i < num_pages; i++)\n\t\tend_page_writeback(data->orig_pages[i]);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_writepages_send(struct fuse_fill_wb_data *data)\n{\n\tstruct fuse_req *req = data->req;\n\tstruct inode *inode = data->inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tint num_pages = req->num_pages;\n\tint i;\n\n\treq->ff = fuse_file_get(data->ff);\n\tspin_lock(&fc->lock);\n\tlist_add_tail(&req->list, &fi->queued_writes);\n\tfuse_flush_writepages(inode);\n\tspin_unlock(&fc->lock);\n\n\tfor (i = 0; i < num_pages; i++)\n\t\tend_page_writeback(data->orig_pages[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_page_is_writeback",
          "args": [
            "inode",
            "page->index"
          ],
          "line": 1816
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_page_is_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "363-366",
          "snippet": "static inline bool fuse_page_is_writeback(struct inode *inode, pgoff_t index)\n{\n\treturn fuse_range_is_writeback(inode, index, index);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline bool fuse_page_is_writeback(struct inode *inode, pgoff_t index)\n{\n\treturn fuse_range_is_writeback(inode, index, index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_write_file_get",
          "args": [
            "fc",
            "get_fuse_inode(inode)"
          ],
          "line": 1805
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_write_file_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1599-1605",
          "snippet": "static struct fuse_file *fuse_write_file_get(struct fuse_conn *fc,\n\t\t\t\t\t     struct fuse_inode *fi)\n{\n\tstruct fuse_file *ff = __fuse_write_file_get(fc, fi);\n\tWARN_ON(!ff);\n\treturn ff;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_file *fuse_write_file_get(struct fuse_conn *fc,\n\t\t\t\t\t     struct fuse_inode *fi)\n{\n\tstruct fuse_file *ff = __fuse_write_file_get(fc, fi);\n\tWARN_ON(!ff);\n\treturn ff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_writepages_fill(struct page *page,\n\t\tstruct writeback_control *wbc, void *_data)\n{\n\tstruct fuse_fill_wb_data *data = _data;\n\tstruct fuse_req *req = data->req;\n\tstruct inode *inode = data->inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct page *tmp_page;\n\tbool is_writeback;\n\tint err;\n\n\tif (!data->ff) {\n\t\terr = -EIO;\n\t\tdata->ff = fuse_write_file_get(fc, get_fuse_inode(inode));\n\t\tif (!data->ff)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Being under writeback is unlikely but possible.  For example direct\n\t * read to an mmaped fuse file will set the page dirty twice; once when\n\t * the pages are faulted with get_user_pages(), and then after the read\n\t * completed.\n\t */\n\tis_writeback = fuse_page_is_writeback(inode, page->index);\n\n\tif (req && req->num_pages &&\n\t    (is_writeback || req->num_pages == FUSE_MAX_PAGES_PER_REQ ||\n\t     (req->num_pages + 1) * PAGE_CACHE_SIZE > fc->max_write ||\n\t     data->orig_pages[req->num_pages - 1]->index + 1 != page->index)) {\n\t\tfuse_writepages_send(data);\n\t\tdata->req = NULL;\n\t}\n\terr = -ENOMEM;\n\ttmp_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\tif (!tmp_page)\n\t\tgoto out_unlock;\n\n\t/*\n\t * The page must not be redirtied until the writeout is completed\n\t * (i.e. userspace has sent a reply to the write request).  Otherwise\n\t * there could be more than one temporary page instance for each real\n\t * page.\n\t *\n\t * This is ensured by holding the page lock in page_mkwrite() while\n\t * checking fuse_page_is_writeback().  We already hold the page lock\n\t * since clear_page_dirty_for_io() and keep it held until we add the\n\t * request to the fi->writepages list and increment req->num_pages.\n\t * After this fuse_page_is_writeback() will indicate that the page is\n\t * under writeback, so we can release the page lock.\n\t */\n\tif (data->req == NULL) {\n\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\terr = -ENOMEM;\n\t\treq = fuse_request_alloc_nofs(FUSE_MAX_PAGES_PER_REQ);\n\t\tif (!req) {\n\t\t\t__free_page(tmp_page);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tfuse_write_fill(req, data->ff, page_offset(page), 0);\n\t\treq->misc.write.in.write_flags |= FUSE_WRITE_CACHE;\n\t\treq->misc.write.next = NULL;\n\t\treq->in.argpages = 1;\n\t\treq->background = 1;\n\t\treq->num_pages = 0;\n\t\treq->end = fuse_writepage_end;\n\t\treq->inode = inode;\n\n\t\tspin_lock(&fc->lock);\n\t\tlist_add(&req->writepages_entry, &fi->writepages);\n\t\tspin_unlock(&fc->lock);\n\n\t\tdata->req = req;\n\t}\n\tset_page_writeback(page);\n\n\tcopy_highpage(tmp_page, page);\n\treq->pages[req->num_pages] = tmp_page;\n\treq->page_descs[req->num_pages].offset = 0;\n\treq->page_descs[req->num_pages].length = PAGE_SIZE;\n\n\tinc_bdi_stat(inode_to_bdi(inode), BDI_WRITEBACK);\n\tinc_zone_page_state(tmp_page, NR_WRITEBACK_TEMP);\n\n\terr = 0;\n\tif (is_writeback && fuse_writepage_in_flight(req, page)) {\n\t\tend_page_writeback(page);\n\t\tdata->req = NULL;\n\t\tgoto out_unlock;\n\t}\n\tdata->orig_pages[req->num_pages] = page;\n\n\t/*\n\t * Protected by fc->lock against concurrent access by\n\t * fuse_page_is_writeback().\n\t */\n\tspin_lock(&fc->lock);\n\treq->num_pages++;\n\tspin_unlock(&fc->lock);\n\nout_unlock:\n\tunlock_page(page);\n\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_writepage_in_flight",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1731-1790",
    "snippet": "static bool fuse_writepage_in_flight(struct fuse_req *new_req,\n\t\t\t\t     struct page *page)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(new_req->inode);\n\tstruct fuse_inode *fi = get_fuse_inode(new_req->inode);\n\tstruct fuse_req *tmp;\n\tstruct fuse_req *old_req;\n\tbool found = false;\n\tpgoff_t curr_index;\n\n\tBUG_ON(new_req->num_pages != 0);\n\n\tspin_lock(&fc->lock);\n\tlist_del(&new_req->writepages_entry);\n\tlist_for_each_entry(old_req, &fi->writepages, writepages_entry) {\n\t\tBUG_ON(old_req->inode != new_req->inode);\n\t\tcurr_index = old_req->misc.write.in.offset >> PAGE_CACHE_SHIFT;\n\t\tif (curr_index <= page->index &&\n\t\t    page->index < curr_index + old_req->num_pages) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tlist_add(&new_req->writepages_entry, &fi->writepages);\n\t\tgoto out_unlock;\n\t}\n\n\tnew_req->num_pages = 1;\n\tfor (tmp = old_req; tmp != NULL; tmp = tmp->misc.write.next) {\n\t\tBUG_ON(tmp->inode != new_req->inode);\n\t\tcurr_index = tmp->misc.write.in.offset >> PAGE_CACHE_SHIFT;\n\t\tif (tmp->num_pages == 1 &&\n\t\t    curr_index == page->index) {\n\t\t\told_req = tmp;\n\t\t}\n\t}\n\n\tif (old_req->num_pages == 1 && (old_req->state == FUSE_REQ_INIT ||\n\t\t\t\t\told_req->state == FUSE_REQ_PENDING)) {\n\t\tstruct backing_dev_info *bdi = inode_to_bdi(page->mapping->host);\n\n\t\tcopy_highpage(old_req->pages[0], page);\n\t\tspin_unlock(&fc->lock);\n\n\t\tdec_bdi_stat(bdi, BDI_WRITEBACK);\n\t\tdec_zone_page_state(page, NR_WRITEBACK_TEMP);\n\t\tbdi_writeout_inc(bdi);\n\t\tfuse_writepage_free(fc, new_req);\n\t\tfuse_request_free(new_req);\n\t\tgoto out;\n\t} else {\n\t\tnew_req->misc.write.next = old_req->misc.write.next;\n\t\told_req->misc.write.next = new_req;\n\t}\nout_unlock:\n\tspin_unlock(&fc->lock);\nout:\n\treturn found;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_request_free",
          "args": [
            "new_req"
          ],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "93-100",
          "snippet": "void fuse_request_free(struct fuse_req *req)\n{\n\tif (req->pages != req->inline_pages) {\n\t\tkfree(req->pages);\n\t\tkfree(req->page_descs);\n\t}\n\tkmem_cache_free(fuse_req_cachep, req);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fuse_req_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct kmem_cache *fuse_req_cachep;\n\nvoid fuse_request_free(struct fuse_req *req)\n{\n\tif (req->pages != req->inline_pages) {\n\t\tkfree(req->pages);\n\t\tkfree(req->page_descs);\n\t}\n\tkmem_cache_free(fuse_req_cachep, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_writepage_free",
          "args": [
            "fc",
            "new_req"
          ],
          "line": 1779
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_writepage_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1452-1461",
          "snippet": "static void fuse_writepage_free(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tint i;\n\n\tfor (i = 0; i < req->num_pages; i++)\n\t\t__free_page(req->pages[i]);\n\n\tif (req->ff)\n\t\tfuse_file_put(req->ff, false);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_writepage_free(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tint i;\n\n\tfor (i = 0; i < req->num_pages; i++)\n\t\t__free_page(req->pages[i]);\n\n\tif (req->ff)\n\t\tfuse_file_put(req->ff, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdi_writeout_inc",
          "args": [
            "bdi"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_zone_page_state",
          "args": [
            "page",
            "NR_WRITEBACK_TEMP"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_bdi_stat",
          "args": [
            "bdi",
            "BDI_WRITEBACK"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_highpage",
          "args": [
            "old_req->pages[0]",
            "page"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "page->mapping->host"
          ],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_bdi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "69-82",
          "snippet": "struct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "tmp->inode != new_req->inode"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&new_req->writepages_entry",
            "&fi->writepages"
          ],
          "line": 1755
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "old_req->inode != new_req->inode"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "old_req",
            "&fi->writepages",
            "writepages_entry"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&new_req->writepages_entry"
          ],
          "line": 1744
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "new_req->num_pages != 0"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "new_req->inode"
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "new_req->inode"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic bool fuse_writepage_in_flight(struct fuse_req *new_req,\n\t\t\t\t     struct page *page)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(new_req->inode);\n\tstruct fuse_inode *fi = get_fuse_inode(new_req->inode);\n\tstruct fuse_req *tmp;\n\tstruct fuse_req *old_req;\n\tbool found = false;\n\tpgoff_t curr_index;\n\n\tBUG_ON(new_req->num_pages != 0);\n\n\tspin_lock(&fc->lock);\n\tlist_del(&new_req->writepages_entry);\n\tlist_for_each_entry(old_req, &fi->writepages, writepages_entry) {\n\t\tBUG_ON(old_req->inode != new_req->inode);\n\t\tcurr_index = old_req->misc.write.in.offset >> PAGE_CACHE_SHIFT;\n\t\tif (curr_index <= page->index &&\n\t\t    page->index < curr_index + old_req->num_pages) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tlist_add(&new_req->writepages_entry, &fi->writepages);\n\t\tgoto out_unlock;\n\t}\n\n\tnew_req->num_pages = 1;\n\tfor (tmp = old_req; tmp != NULL; tmp = tmp->misc.write.next) {\n\t\tBUG_ON(tmp->inode != new_req->inode);\n\t\tcurr_index = tmp->misc.write.in.offset >> PAGE_CACHE_SHIFT;\n\t\tif (tmp->num_pages == 1 &&\n\t\t    curr_index == page->index) {\n\t\t\told_req = tmp;\n\t\t}\n\t}\n\n\tif (old_req->num_pages == 1 && (old_req->state == FUSE_REQ_INIT ||\n\t\t\t\t\told_req->state == FUSE_REQ_PENDING)) {\n\t\tstruct backing_dev_info *bdi = inode_to_bdi(page->mapping->host);\n\n\t\tcopy_highpage(old_req->pages[0], page);\n\t\tspin_unlock(&fc->lock);\n\n\t\tdec_bdi_stat(bdi, BDI_WRITEBACK);\n\t\tdec_zone_page_state(page, NR_WRITEBACK_TEMP);\n\t\tbdi_writeout_inc(bdi);\n\t\tfuse_writepage_free(fc, new_req);\n\t\tfuse_request_free(new_req);\n\t\tgoto out;\n\t} else {\n\t\tnew_req->misc.write.next = old_req->misc.write.next;\n\t\told_req->misc.write.next = new_req;\n\t}\nout_unlock:\n\tspin_unlock(&fc->lock);\nout:\n\treturn found;\n}"
  },
  {
    "function_name": "fuse_writepages_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1712-1729",
    "snippet": "static void fuse_writepages_send(struct fuse_fill_wb_data *data)\n{\n\tstruct fuse_req *req = data->req;\n\tstruct inode *inode = data->inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tint num_pages = req->num_pages;\n\tint i;\n\n\treq->ff = fuse_file_get(data->ff);\n\tspin_lock(&fc->lock);\n\tlist_add_tail(&req->list, &fi->queued_writes);\n\tfuse_flush_writepages(inode);\n\tspin_unlock(&fc->lock);\n\n\tfor (i = 0; i < num_pages; i++)\n\t\tend_page_writeback(data->orig_pages[i]);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "data->orig_pages[i]"
          ],
          "line": 1728
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_flush_writepages",
          "args": [
            "inode"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_flush_writepages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1520-1534",
          "snippet": "void fuse_flush_writepages(struct inode *inode)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tsize_t crop = i_size_read(inode);\n\tstruct fuse_req *req;\n\n\twhile (fi->writectr >= 0 && !list_empty(&fi->queued_writes)) {\n\t\treq = list_entry(fi->queued_writes.next, struct fuse_req, list);\n\t\tlist_del_init(&req->list);\n\t\tfuse_send_writepage(fc, req, crop);\n\t}\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_flush_writepages(struct inode *inode)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tsize_t crop = i_size_read(inode);\n\tstruct fuse_req *req;\n\n\twhile (fi->writectr >= 0 && !list_empty(&fi->queued_writes)) {\n\t\treq = list_entry(fi->queued_writes.next, struct fuse_req, list);\n\t\tlist_del_init(&req->list);\n\t\tfuse_send_writepage(fc, req, crop);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&req->list",
            "&fi->queued_writes"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_file_get",
          "args": [
            "data->ff"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_file_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "78-82",
          "snippet": "struct fuse_file *fuse_file_get(struct fuse_file *ff)\n{\n\tatomic_inc(&ff->count);\n\treturn ff;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstruct fuse_file *fuse_file_get(struct fuse_file *ff)\n{\n\tatomic_inc(&ff->count);\n\treturn ff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_writepages_send(struct fuse_fill_wb_data *data)\n{\n\tstruct fuse_req *req = data->req;\n\tstruct inode *inode = data->inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tint num_pages = req->num_pages;\n\tint i;\n\n\treq->ff = fuse_file_get(data->ff);\n\tspin_lock(&fc->lock);\n\tlist_add_tail(&req->list, &fi->queued_writes);\n\tfuse_flush_writepages(inode);\n\tspin_unlock(&fc->lock);\n\n\tfor (i = 0; i < num_pages; i++)\n\t\tend_page_writeback(data->orig_pages[i]);\n}"
  },
  {
    "function_name": "fuse_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1683-1703",
    "snippet": "static int fuse_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tint err;\n\n\tif (fuse_page_is_writeback(page->mapping->host, page->index)) {\n\t\t/*\n\t\t * ->writepages() should be called for sync() and friends.  We\n\t\t * should only get here on direct reclaim and then we are\n\t\t * allowed to skip a page which is already in flight\n\t\t */\n\t\tWARN_ON(wbc->sync_mode == WB_SYNC_ALL);\n\n\t\tredirty_page_for_writepage(wbc, page);\n\t\treturn 0;\n\t}\n\n\terr = fuse_writepage_locked(page);\n\tunlock_page(page);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_writepage_locked",
          "args": [
            "page"
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_writepage_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1622-1681",
          "snippet": "static int fuse_writepage_locked(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_req *req;\n\tstruct page *tmp_page;\n\tint error = -ENOMEM;\n\n\tset_page_writeback(page);\n\n\treq = fuse_request_alloc_nofs(1);\n\tif (!req)\n\t\tgoto err;\n\n\treq->background = 1; /* writeback always goes to bg_queue */\n\ttmp_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\tif (!tmp_page)\n\t\tgoto err_free;\n\n\terror = -EIO;\n\treq->ff = fuse_write_file_get(fc, fi);\n\tif (!req->ff)\n\t\tgoto err_nofile;\n\n\tfuse_write_fill(req, req->ff, page_offset(page), 0);\n\n\tcopy_highpage(tmp_page, page);\n\treq->misc.write.in.write_flags |= FUSE_WRITE_CACHE;\n\treq->misc.write.next = NULL;\n\treq->in.argpages = 1;\n\treq->num_pages = 1;\n\treq->pages[0] = tmp_page;\n\treq->page_descs[0].offset = 0;\n\treq->page_descs[0].length = PAGE_SIZE;\n\treq->end = fuse_writepage_end;\n\treq->inode = inode;\n\n\tinc_bdi_stat(inode_to_bdi(inode), BDI_WRITEBACK);\n\tinc_zone_page_state(tmp_page, NR_WRITEBACK_TEMP);\n\n\tspin_lock(&fc->lock);\n\tlist_add(&req->writepages_entry, &fi->writepages);\n\tlist_add_tail(&req->list, &fi->queued_writes);\n\tfuse_flush_writepages(inode);\n\tspin_unlock(&fc->lock);\n\n\tend_page_writeback(page);\n\n\treturn 0;\n\nerr_nofile:\n\t__free_page(tmp_page);\nerr_free:\n\tfuse_request_free(req);\nerr:\n\tend_page_writeback(page);\n\treturn error;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_writepage_locked(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_req *req;\n\tstruct page *tmp_page;\n\tint error = -ENOMEM;\n\n\tset_page_writeback(page);\n\n\treq = fuse_request_alloc_nofs(1);\n\tif (!req)\n\t\tgoto err;\n\n\treq->background = 1; /* writeback always goes to bg_queue */\n\ttmp_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\tif (!tmp_page)\n\t\tgoto err_free;\n\n\terror = -EIO;\n\treq->ff = fuse_write_file_get(fc, fi);\n\tif (!req->ff)\n\t\tgoto err_nofile;\n\n\tfuse_write_fill(req, req->ff, page_offset(page), 0);\n\n\tcopy_highpage(tmp_page, page);\n\treq->misc.write.in.write_flags |= FUSE_WRITE_CACHE;\n\treq->misc.write.next = NULL;\n\treq->in.argpages = 1;\n\treq->num_pages = 1;\n\treq->pages[0] = tmp_page;\n\treq->page_descs[0].offset = 0;\n\treq->page_descs[0].length = PAGE_SIZE;\n\treq->end = fuse_writepage_end;\n\treq->inode = inode;\n\n\tinc_bdi_stat(inode_to_bdi(inode), BDI_WRITEBACK);\n\tinc_zone_page_state(tmp_page, NR_WRITEBACK_TEMP);\n\n\tspin_lock(&fc->lock);\n\tlist_add(&req->writepages_entry, &fi->writepages);\n\tlist_add_tail(&req->list, &fi->queued_writes);\n\tfuse_flush_writepages(inode);\n\tspin_unlock(&fc->lock);\n\n\tend_page_writeback(page);\n\n\treturn 0;\n\nerr_nofile:\n\t__free_page(tmp_page);\nerr_free:\n\tfuse_request_free(req);\nerr:\n\tend_page_writeback(page);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "redirty_page_for_writepage",
          "args": [
            "wbc",
            "page"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "wbc->sync_mode == WB_SYNC_ALL"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_page_is_writeback",
          "args": [
            "page->mapping->host",
            "page->index"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_page_is_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "363-366",
          "snippet": "static inline bool fuse_page_is_writeback(struct inode *inode, pgoff_t index)\n{\n\treturn fuse_range_is_writeback(inode, index, index);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline bool fuse_page_is_writeback(struct inode *inode, pgoff_t index)\n{\n\treturn fuse_range_is_writeback(inode, index, index);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tint err;\n\n\tif (fuse_page_is_writeback(page->mapping->host, page->index)) {\n\t\t/*\n\t\t * ->writepages() should be called for sync() and friends.  We\n\t\t * should only get here on direct reclaim and then we are\n\t\t * allowed to skip a page which is already in flight\n\t\t */\n\t\tWARN_ON(wbc->sync_mode == WB_SYNC_ALL);\n\n\t\tredirty_page_for_writepage(wbc, page);\n\t\treturn 0;\n\t}\n\n\terr = fuse_writepage_locked(page);\n\tunlock_page(page);\n\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_writepage_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1622-1681",
    "snippet": "static int fuse_writepage_locked(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_req *req;\n\tstruct page *tmp_page;\n\tint error = -ENOMEM;\n\n\tset_page_writeback(page);\n\n\treq = fuse_request_alloc_nofs(1);\n\tif (!req)\n\t\tgoto err;\n\n\treq->background = 1; /* writeback always goes to bg_queue */\n\ttmp_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\tif (!tmp_page)\n\t\tgoto err_free;\n\n\terror = -EIO;\n\treq->ff = fuse_write_file_get(fc, fi);\n\tif (!req->ff)\n\t\tgoto err_nofile;\n\n\tfuse_write_fill(req, req->ff, page_offset(page), 0);\n\n\tcopy_highpage(tmp_page, page);\n\treq->misc.write.in.write_flags |= FUSE_WRITE_CACHE;\n\treq->misc.write.next = NULL;\n\treq->in.argpages = 1;\n\treq->num_pages = 1;\n\treq->pages[0] = tmp_page;\n\treq->page_descs[0].offset = 0;\n\treq->page_descs[0].length = PAGE_SIZE;\n\treq->end = fuse_writepage_end;\n\treq->inode = inode;\n\n\tinc_bdi_stat(inode_to_bdi(inode), BDI_WRITEBACK);\n\tinc_zone_page_state(tmp_page, NR_WRITEBACK_TEMP);\n\n\tspin_lock(&fc->lock);\n\tlist_add(&req->writepages_entry, &fi->writepages);\n\tlist_add_tail(&req->list, &fi->queued_writes);\n\tfuse_flush_writepages(inode);\n\tspin_unlock(&fc->lock);\n\n\tend_page_writeback(page);\n\n\treturn 0;\n\nerr_nofile:\n\t__free_page(tmp_page);\nerr_free:\n\tfuse_request_free(req);\nerr:\n\tend_page_writeback(page);\n\treturn error;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_request_free",
          "args": [
            "req"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "93-100",
          "snippet": "void fuse_request_free(struct fuse_req *req)\n{\n\tif (req->pages != req->inline_pages) {\n\t\tkfree(req->pages);\n\t\tkfree(req->page_descs);\n\t}\n\tkmem_cache_free(fuse_req_cachep, req);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fuse_req_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct kmem_cache *fuse_req_cachep;\n\nvoid fuse_request_free(struct fuse_req *req)\n{\n\tif (req->pages != req->inline_pages) {\n\t\tkfree(req->pages);\n\t\tkfree(req->page_descs);\n\t}\n\tkmem_cache_free(fuse_req_cachep, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "tmp_page"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 1668
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_flush_writepages",
          "args": [
            "inode"
          ],
          "line": 1667
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_flush_writepages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1520-1534",
          "snippet": "void fuse_flush_writepages(struct inode *inode)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tsize_t crop = i_size_read(inode);\n\tstruct fuse_req *req;\n\n\twhile (fi->writectr >= 0 && !list_empty(&fi->queued_writes)) {\n\t\treq = list_entry(fi->queued_writes.next, struct fuse_req, list);\n\t\tlist_del_init(&req->list);\n\t\tfuse_send_writepage(fc, req, crop);\n\t}\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_flush_writepages(struct inode *inode)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tsize_t crop = i_size_read(inode);\n\tstruct fuse_req *req;\n\n\twhile (fi->writectr >= 0 && !list_empty(&fi->queued_writes)) {\n\t\treq = list_entry(fi->queued_writes.next, struct fuse_req, list);\n\t\tlist_del_init(&req->list);\n\t\tfuse_send_writepage(fc, req, crop);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&req->list",
            "&fi->queued_writes"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&req->writepages_entry",
            "&fi->writepages"
          ],
          "line": 1665
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_zone_page_state",
          "args": [
            "tmp_page",
            "NR_WRITEBACK_TEMP"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_bdi_stat",
          "args": [
            "inode_to_bdi(inode)",
            "BDI_WRITEBACK"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "inode"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_bdi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "69-82",
          "snippet": "struct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_highpage",
          "args": [
            "tmp_page",
            "page"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_write_fill",
          "args": [
            "req",
            "req->ff",
            "page_offset(page)",
            "0"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_write_fill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "912-933",
          "snippet": "static void fuse_write_fill(struct fuse_req *req, struct fuse_file *ff,\n\t\t\t    loff_t pos, size_t count)\n{\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\tstruct fuse_write_out *outarg = &req->misc.write.out;\n\n\tinarg->fh = ff->fh;\n\tinarg->offset = pos;\n\tinarg->size = count;\n\treq->in.h.opcode = FUSE_WRITE;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 2;\n\tif (ff->fc->minor < 9)\n\t\treq->in.args[0].size = FUSE_COMPAT_WRITE_IN_SIZE;\n\telse\n\t\treq->in.args[0].size = sizeof(struct fuse_write_in);\n\treq->in.args[0].value = inarg;\n\treq->in.args[1].size = count;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = sizeof(struct fuse_write_out);\n\treq->out.args[0].value = outarg;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_write_fill(struct fuse_req *req, struct fuse_file *ff,\n\t\t\t    loff_t pos, size_t count)\n{\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\tstruct fuse_write_out *outarg = &req->misc.write.out;\n\n\tinarg->fh = ff->fh;\n\tinarg->offset = pos;\n\tinarg->size = count;\n\treq->in.h.opcode = FUSE_WRITE;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 2;\n\tif (ff->fc->minor < 9)\n\t\treq->in.args[0].size = FUSE_COMPAT_WRITE_IN_SIZE;\n\telse\n\t\treq->in.args[0].size = sizeof(struct fuse_write_in);\n\treq->in.args[0].value = inarg;\n\treq->in.args[1].size = count;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = sizeof(struct fuse_write_out);\n\treq->out.args[0].value = outarg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_write_file_get",
          "args": [
            "fc",
            "fi"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_write_file_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1599-1605",
          "snippet": "static struct fuse_file *fuse_write_file_get(struct fuse_conn *fc,\n\t\t\t\t\t     struct fuse_inode *fi)\n{\n\tstruct fuse_file *ff = __fuse_write_file_get(fc, fi);\n\tWARN_ON(!ff);\n\treturn ff;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_file *fuse_write_file_get(struct fuse_conn *fc,\n\t\t\t\t\t     struct fuse_inode *fi)\n{\n\tstruct fuse_file *ff = __fuse_write_file_get(fc, fi);\n\tWARN_ON(!ff);\n\treturn ff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_NOFS | __GFP_HIGHMEM"
          ],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_request_alloc_nofs",
          "args": [
            "1"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_alloc_nofs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "88-91",
          "snippet": "struct fuse_req *fuse_request_alloc_nofs(unsigned npages)\n{\n\treturn __fuse_request_alloc(npages, GFP_NOFS);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstruct fuse_req *fuse_request_alloc_nofs(unsigned npages)\n{\n\treturn __fuse_request_alloc(npages, GFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "265-277",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_writepage_locked(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_req *req;\n\tstruct page *tmp_page;\n\tint error = -ENOMEM;\n\n\tset_page_writeback(page);\n\n\treq = fuse_request_alloc_nofs(1);\n\tif (!req)\n\t\tgoto err;\n\n\treq->background = 1; /* writeback always goes to bg_queue */\n\ttmp_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\tif (!tmp_page)\n\t\tgoto err_free;\n\n\terror = -EIO;\n\treq->ff = fuse_write_file_get(fc, fi);\n\tif (!req->ff)\n\t\tgoto err_nofile;\n\n\tfuse_write_fill(req, req->ff, page_offset(page), 0);\n\n\tcopy_highpage(tmp_page, page);\n\treq->misc.write.in.write_flags |= FUSE_WRITE_CACHE;\n\treq->misc.write.next = NULL;\n\treq->in.argpages = 1;\n\treq->num_pages = 1;\n\treq->pages[0] = tmp_page;\n\treq->page_descs[0].offset = 0;\n\treq->page_descs[0].length = PAGE_SIZE;\n\treq->end = fuse_writepage_end;\n\treq->inode = inode;\n\n\tinc_bdi_stat(inode_to_bdi(inode), BDI_WRITEBACK);\n\tinc_zone_page_state(tmp_page, NR_WRITEBACK_TEMP);\n\n\tspin_lock(&fc->lock);\n\tlist_add(&req->writepages_entry, &fi->writepages);\n\tlist_add_tail(&req->list, &fi->queued_writes);\n\tfuse_flush_writepages(inode);\n\tspin_unlock(&fc->lock);\n\n\tend_page_writeback(page);\n\n\treturn 0;\n\nerr_nofile:\n\t__free_page(tmp_page);\nerr_free:\n\tfuse_request_free(req);\nerr:\n\tend_page_writeback(page);\n\treturn error;\n}"
  },
  {
    "function_name": "fuse_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1607-1620",
    "snippet": "int fuse_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_file *ff;\n\tint err;\n\n\tff = __fuse_write_file_get(fc, fi);\n\terr = fuse_flush_times(inode, ff);\n\tif (ff)\n\t\tfuse_file_put(ff, 0);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_file_put",
          "args": [
            "ff",
            "0"
          ],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_file_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "89-114",
          "snippet": "static void fuse_file_put(struct fuse_file *ff, bool sync)\n{\n\tif (atomic_dec_and_test(&ff->count)) {\n\t\tstruct fuse_req *req = ff->reserved_req;\n\n\t\tif (ff->fc->no_open) {\n\t\t\t/*\n\t\t\t * Drop the release request when client does not\n\t\t\t * implement 'open'\n\t\t\t */\n\t\t\treq->background = 0;\n\t\t\tiput(req->misc.release.inode);\n\t\t\tfuse_put_request(ff->fc, req);\n\t\t} else if (sync) {\n\t\t\treq->background = 0;\n\t\t\tfuse_request_send(ff->fc, req);\n\t\t\tiput(req->misc.release.inode);\n\t\t\tfuse_put_request(ff->fc, req);\n\t\t} else {\n\t\t\treq->end = fuse_release_end;\n\t\t\treq->background = 1;\n\t\t\tfuse_request_send_background(ff->fc, req);\n\t\t}\n\t\tkfree(ff);\n\t}\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_file_put(struct fuse_file *ff, bool sync)\n{\n\tif (atomic_dec_and_test(&ff->count)) {\n\t\tstruct fuse_req *req = ff->reserved_req;\n\n\t\tif (ff->fc->no_open) {\n\t\t\t/*\n\t\t\t * Drop the release request when client does not\n\t\t\t * implement 'open'\n\t\t\t */\n\t\t\treq->background = 0;\n\t\t\tiput(req->misc.release.inode);\n\t\t\tfuse_put_request(ff->fc, req);\n\t\t} else if (sync) {\n\t\t\treq->background = 0;\n\t\t\tfuse_request_send(ff->fc, req);\n\t\t\tiput(req->misc.release.inode);\n\t\t\tfuse_put_request(ff->fc, req);\n\t\t} else {\n\t\t\treq->end = fuse_release_end;\n\t\t\treq->background = 1;\n\t\t\tfuse_request_send_background(ff->fc, req);\n\t\t}\n\t\tkfree(ff);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_flush_times",
          "args": [
            "inode",
            "ff"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_flush_times",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "1570-1595",
          "snippet": "int fuse_flush_times(struct inode *inode, struct fuse_file *ff)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_setattr_in inarg;\n\tstruct fuse_attr_out outarg;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outarg, 0, sizeof(outarg));\n\n\tinarg.valid = FATTR_MTIME;\n\tinarg.mtime = inode->i_mtime.tv_sec;\n\tinarg.mtimensec = inode->i_mtime.tv_nsec;\n\tif (fc->minor >= 23) {\n\t\tinarg.valid |= FATTR_CTIME;\n\t\tinarg.ctime = inode->i_ctime.tv_sec;\n\t\tinarg.ctimensec = inode->i_ctime.tv_nsec;\n\t}\n\tif (ff) {\n\t\tinarg.valid |= FATTR_FH;\n\t\tinarg.fh = ff->fh;\n\t}\n\tfuse_setattr_fill(fc, &args, inode, &inarg, &outarg);\n\n\treturn fuse_simple_request(fc, &args);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_flush_times(struct inode *inode, struct fuse_file *ff)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_setattr_in inarg;\n\tstruct fuse_attr_out outarg;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outarg, 0, sizeof(outarg));\n\n\tinarg.valid = FATTR_MTIME;\n\tinarg.mtime = inode->i_mtime.tv_sec;\n\tinarg.mtimensec = inode->i_mtime.tv_nsec;\n\tif (fc->minor >= 23) {\n\t\tinarg.valid |= FATTR_CTIME;\n\t\tinarg.ctime = inode->i_ctime.tv_sec;\n\t\tinarg.ctimensec = inode->i_ctime.tv_nsec;\n\t}\n\tif (ff) {\n\t\tinarg.valid |= FATTR_FH;\n\t\tinarg.fh = ff->fh;\n\t}\n\tfuse_setattr_fill(fc, &args, inode, &inarg, &outarg);\n\n\treturn fuse_simple_request(fc, &args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fuse_write_file_get",
          "args": [
            "fc",
            "fi"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "__fuse_write_file_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1583-1597",
          "snippet": "static struct fuse_file *__fuse_write_file_get(struct fuse_conn *fc,\n\t\t\t\t\t       struct fuse_inode *fi)\n{\n\tstruct fuse_file *ff = NULL;\n\n\tspin_lock(&fc->lock);\n\tif (!list_empty(&fi->write_files)) {\n\t\tff = list_entry(fi->write_files.next, struct fuse_file,\n\t\t\t\twrite_entry);\n\t\tfuse_file_get(ff);\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn ff;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_file *__fuse_write_file_get(struct fuse_conn *fc,\n\t\t\t\t\t       struct fuse_inode *fi)\n{\n\tstruct fuse_file *ff = NULL;\n\n\tspin_lock(&fc->lock);\n\tif (!list_empty(&fi->write_files)) {\n\t\tff = list_entry(fi->write_files.next, struct fuse_file,\n\t\t\t\twrite_entry);\n\t\tfuse_file_get(ff);\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn ff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 1610
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_file *ff;\n\tint err;\n\n\tff = __fuse_write_file_get(fc, fi);\n\terr = fuse_flush_times(inode, ff);\n\tif (ff)\n\t\tfuse_file_put(ff, 0);\n\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_write_file_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1599-1605",
    "snippet": "static struct fuse_file *fuse_write_file_get(struct fuse_conn *fc,\n\t\t\t\t\t     struct fuse_inode *fi)\n{\n\tstruct fuse_file *ff = __fuse_write_file_get(fc, fi);\n\tWARN_ON(!ff);\n\treturn ff;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!ff"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fuse_write_file_get",
          "args": [
            "fc",
            "fi"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "__fuse_write_file_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1583-1597",
          "snippet": "static struct fuse_file *__fuse_write_file_get(struct fuse_conn *fc,\n\t\t\t\t\t       struct fuse_inode *fi)\n{\n\tstruct fuse_file *ff = NULL;\n\n\tspin_lock(&fc->lock);\n\tif (!list_empty(&fi->write_files)) {\n\t\tff = list_entry(fi->write_files.next, struct fuse_file,\n\t\t\t\twrite_entry);\n\t\tfuse_file_get(ff);\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn ff;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_file *__fuse_write_file_get(struct fuse_conn *fc,\n\t\t\t\t\t       struct fuse_inode *fi)\n{\n\tstruct fuse_file *ff = NULL;\n\n\tspin_lock(&fc->lock);\n\tif (!list_empty(&fi->write_files)) {\n\t\tff = list_entry(fi->write_files.next, struct fuse_file,\n\t\t\t\twrite_entry);\n\t\tfuse_file_get(ff);\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn ff;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_file *fuse_write_file_get(struct fuse_conn *fc,\n\t\t\t\t\t     struct fuse_inode *fi)\n{\n\tstruct fuse_file *ff = __fuse_write_file_get(fc, fi);\n\tWARN_ON(!ff);\n\treturn ff;\n}"
  },
  {
    "function_name": "__fuse_write_file_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1583-1597",
    "snippet": "static struct fuse_file *__fuse_write_file_get(struct fuse_conn *fc,\n\t\t\t\t\t       struct fuse_inode *fi)\n{\n\tstruct fuse_file *ff = NULL;\n\n\tspin_lock(&fc->lock);\n\tif (!list_empty(&fi->write_files)) {\n\t\tff = list_entry(fi->write_files.next, struct fuse_file,\n\t\t\t\twrite_entry);\n\t\tfuse_file_get(ff);\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn ff;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_file_get",
          "args": [
            "ff"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_file_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "78-82",
          "snippet": "struct fuse_file *fuse_file_get(struct fuse_file *ff)\n{\n\tatomic_inc(&ff->count);\n\treturn ff;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstruct fuse_file *fuse_file_get(struct fuse_file *ff)\n{\n\tatomic_inc(&ff->count);\n\treturn ff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "fi->write_files.next",
            "structfuse_file",
            "write_entry"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fi->write_files"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_file *__fuse_write_file_get(struct fuse_conn *fc,\n\t\t\t\t\t       struct fuse_inode *fi)\n{\n\tstruct fuse_file *ff = NULL;\n\n\tspin_lock(&fc->lock);\n\tif (!list_empty(&fi->write_files)) {\n\t\tff = list_entry(fi->write_files.next, struct fuse_file,\n\t\t\t\twrite_entry);\n\t\tfuse_file_get(ff);\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn ff;\n}"
  },
  {
    "function_name": "fuse_writepage_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1536-1581",
    "snippet": "static void fuse_writepage_end(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct inode *inode = req->inode;\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tmapping_set_error(inode->i_mapping, req->out.h.error);\n\tspin_lock(&fc->lock);\n\twhile (req->misc.write.next) {\n\t\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\t\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\t\tstruct fuse_req *next = req->misc.write.next;\n\t\treq->misc.write.next = next->misc.write.next;\n\t\tnext->misc.write.next = NULL;\n\t\tnext->ff = fuse_file_get(req->ff);\n\t\tlist_add(&next->writepages_entry, &fi->writepages);\n\n\t\t/*\n\t\t * Skip fuse_flush_writepages() to make it easy to crop requests\n\t\t * based on primary request size.\n\t\t *\n\t\t * 1st case (trivial): there are no concurrent activities using\n\t\t * fuse_set/release_nowrite.  Then we're on safe side because\n\t\t * fuse_flush_writepages() would call fuse_send_writepage()\n\t\t * anyway.\n\t\t *\n\t\t * 2nd case: someone called fuse_set_nowrite and it is waiting\n\t\t * now for completion of all in-flight requests.  This happens\n\t\t * rarely and no more than once per page, so this should be\n\t\t * okay.\n\t\t *\n\t\t * 3rd case: someone (e.g. fuse_do_setattr()) is in the middle\n\t\t * of fuse_set_nowrite..fuse_release_nowrite section.  The fact\n\t\t * that fuse_set_nowrite returned implies that all in-flight\n\t\t * requests were completed along with all of their secondary\n\t\t * requests.  Further primary requests are blocked by negative\n\t\t * writectr.  Hence there cannot be any in-flight requests and\n\t\t * no invocations of fuse_writepage_end() while we're in\n\t\t * fuse_set_nowrite..fuse_release_nowrite section.\n\t\t */\n\t\tfuse_send_writepage(fc, next, inarg->offset + inarg->size);\n\t}\n\tfi->writectr--;\n\tfuse_writepage_finish(fc, req);\n\tspin_unlock(&fc->lock);\n\tfuse_writepage_free(fc, req);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_writepage_free",
          "args": [
            "fc",
            "req"
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_writepage_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1452-1461",
          "snippet": "static void fuse_writepage_free(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tint i;\n\n\tfor (i = 0; i < req->num_pages; i++)\n\t\t__free_page(req->pages[i]);\n\n\tif (req->ff)\n\t\tfuse_file_put(req->ff, false);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_writepage_free(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tint i;\n\n\tfor (i = 0; i < req->num_pages; i++)\n\t\t__free_page(req->pages[i]);\n\n\tif (req->ff)\n\t\tfuse_file_put(req->ff, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_writepage_finish",
          "args": [
            "fc",
            "req"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_writepage_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1463-1477",
          "snippet": "static void fuse_writepage_finish(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct inode *inode = req->inode;\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\tint i;\n\n\tlist_del(&req->writepages_entry);\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tdec_bdi_stat(bdi, BDI_WRITEBACK);\n\t\tdec_zone_page_state(req->pages[i], NR_WRITEBACK_TEMP);\n\t\tbdi_writeout_inc(bdi);\n\t}\n\twake_up(&fi->page_waitq);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_writepage_finish(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct inode *inode = req->inode;\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\tint i;\n\n\tlist_del(&req->writepages_entry);\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tdec_bdi_stat(bdi, BDI_WRITEBACK);\n\t\tdec_zone_page_state(req->pages[i], NR_WRITEBACK_TEMP);\n\t\tbdi_writeout_inc(bdi);\n\t}\n\twake_up(&fi->page_waitq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_send_writepage",
          "args": [
            "fc",
            "next",
            "inarg->offset + inarg->size"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_send_writepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1480-1512",
          "snippet": "static void fuse_send_writepage(struct fuse_conn *fc, struct fuse_req *req,\n\t\t\t\tloff_t size)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(req->inode);\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\t__u64 data_size = req->num_pages * PAGE_CACHE_SIZE;\n\n\tif (!fc->connected)\n\t\tgoto out_free;\n\n\tif (inarg->offset + data_size <= size) {\n\t\tinarg->size = data_size;\n\t} else if (inarg->offset < size) {\n\t\tinarg->size = size - inarg->offset;\n\t} else {\n\t\t/* Got truncated off completely */\n\t\tgoto out_free;\n\t}\n\n\treq->in.args[1].size = inarg->size;\n\tfi->writectr++;\n\tfuse_request_send_background_locked(fc, req);\n\treturn;\n\n out_free:\n\tfuse_writepage_finish(fc, req);\n\tspin_unlock(&fc->lock);\n\tfuse_writepage_free(fc, req);\n\tfuse_put_request(fc, req);\n\tspin_lock(&fc->lock);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_send_writepage(struct fuse_conn *fc, struct fuse_req *req,\n\t\t\t\tloff_t size)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(req->inode);\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\t__u64 data_size = req->num_pages * PAGE_CACHE_SIZE;\n\n\tif (!fc->connected)\n\t\tgoto out_free;\n\n\tif (inarg->offset + data_size <= size) {\n\t\tinarg->size = data_size;\n\t} else if (inarg->offset < size) {\n\t\tinarg->size = size - inarg->offset;\n\t} else {\n\t\t/* Got truncated off completely */\n\t\tgoto out_free;\n\t}\n\n\treq->in.args[1].size = inarg->size;\n\tfi->writectr++;\n\tfuse_request_send_background_locked(fc, req);\n\treturn;\n\n out_free:\n\tfuse_writepage_finish(fc, req);\n\tspin_unlock(&fc->lock);\n\tfuse_writepage_free(fc, req);\n\tfuse_put_request(fc, req);\n\tspin_lock(&fc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&next->writepages_entry",
            "&fi->writepages"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_file_get",
          "args": [
            "req->ff"
          ],
          "line": 1549
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_file_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "78-82",
          "snippet": "struct fuse_file *fuse_file_get(struct fuse_file *ff)\n{\n\tatomic_inc(&ff->count);\n\treturn ff;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstruct fuse_file *fuse_file_get(struct fuse_file *ff)\n{\n\tatomic_inc(&ff->count);\n\treturn ff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "inode->i_mapping",
            "req->out.h.error"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_writepage_end(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct inode *inode = req->inode;\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tmapping_set_error(inode->i_mapping, req->out.h.error);\n\tspin_lock(&fc->lock);\n\twhile (req->misc.write.next) {\n\t\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\t\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\t\tstruct fuse_req *next = req->misc.write.next;\n\t\treq->misc.write.next = next->misc.write.next;\n\t\tnext->misc.write.next = NULL;\n\t\tnext->ff = fuse_file_get(req->ff);\n\t\tlist_add(&next->writepages_entry, &fi->writepages);\n\n\t\t/*\n\t\t * Skip fuse_flush_writepages() to make it easy to crop requests\n\t\t * based on primary request size.\n\t\t *\n\t\t * 1st case (trivial): there are no concurrent activities using\n\t\t * fuse_set/release_nowrite.  Then we're on safe side because\n\t\t * fuse_flush_writepages() would call fuse_send_writepage()\n\t\t * anyway.\n\t\t *\n\t\t * 2nd case: someone called fuse_set_nowrite and it is waiting\n\t\t * now for completion of all in-flight requests.  This happens\n\t\t * rarely and no more than once per page, so this should be\n\t\t * okay.\n\t\t *\n\t\t * 3rd case: someone (e.g. fuse_do_setattr()) is in the middle\n\t\t * of fuse_set_nowrite..fuse_release_nowrite section.  The fact\n\t\t * that fuse_set_nowrite returned implies that all in-flight\n\t\t * requests were completed along with all of their secondary\n\t\t * requests.  Further primary requests are blocked by negative\n\t\t * writectr.  Hence there cannot be any in-flight requests and\n\t\t * no invocations of fuse_writepage_end() while we're in\n\t\t * fuse_set_nowrite..fuse_release_nowrite section.\n\t\t */\n\t\tfuse_send_writepage(fc, next, inarg->offset + inarg->size);\n\t}\n\tfi->writectr--;\n\tfuse_writepage_finish(fc, req);\n\tspin_unlock(&fc->lock);\n\tfuse_writepage_free(fc, req);\n}"
  },
  {
    "function_name": "fuse_flush_writepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1520-1534",
    "snippet": "void fuse_flush_writepages(struct inode *inode)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tsize_t crop = i_size_read(inode);\n\tstruct fuse_req *req;\n\n\twhile (fi->writectr >= 0 && !list_empty(&fi->queued_writes)) {\n\t\treq = list_entry(fi->queued_writes.next, struct fuse_req, list);\n\t\tlist_del_init(&req->list);\n\t\tfuse_send_writepage(fc, req, crop);\n\t}\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_send_writepage",
          "args": [
            "fc",
            "req",
            "crop"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_send_writepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1480-1512",
          "snippet": "static void fuse_send_writepage(struct fuse_conn *fc, struct fuse_req *req,\n\t\t\t\tloff_t size)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(req->inode);\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\t__u64 data_size = req->num_pages * PAGE_CACHE_SIZE;\n\n\tif (!fc->connected)\n\t\tgoto out_free;\n\n\tif (inarg->offset + data_size <= size) {\n\t\tinarg->size = data_size;\n\t} else if (inarg->offset < size) {\n\t\tinarg->size = size - inarg->offset;\n\t} else {\n\t\t/* Got truncated off completely */\n\t\tgoto out_free;\n\t}\n\n\treq->in.args[1].size = inarg->size;\n\tfi->writectr++;\n\tfuse_request_send_background_locked(fc, req);\n\treturn;\n\n out_free:\n\tfuse_writepage_finish(fc, req);\n\tspin_unlock(&fc->lock);\n\tfuse_writepage_free(fc, req);\n\tfuse_put_request(fc, req);\n\tspin_lock(&fc->lock);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_send_writepage(struct fuse_conn *fc, struct fuse_req *req,\n\t\t\t\tloff_t size)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(req->inode);\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\t__u64 data_size = req->num_pages * PAGE_CACHE_SIZE;\n\n\tif (!fc->connected)\n\t\tgoto out_free;\n\n\tif (inarg->offset + data_size <= size) {\n\t\tinarg->size = data_size;\n\t} else if (inarg->offset < size) {\n\t\tinarg->size = size - inarg->offset;\n\t} else {\n\t\t/* Got truncated off completely */\n\t\tgoto out_free;\n\t}\n\n\treq->in.args[1].size = inarg->size;\n\tfi->writectr++;\n\tfuse_request_send_background_locked(fc, req);\n\treturn;\n\n out_free:\n\tfuse_writepage_finish(fc, req);\n\tspin_unlock(&fc->lock);\n\tfuse_writepage_free(fc, req);\n\tfuse_put_request(fc, req);\n\tspin_lock(&fc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&req->list"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "fi->queued_writes.next",
            "structfuse_req",
            "list"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fi->queued_writes"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "fc->lock"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "fc->lock"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_flush_writepages(struct inode *inode)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tsize_t crop = i_size_read(inode);\n\tstruct fuse_req *req;\n\n\twhile (fi->writectr >= 0 && !list_empty(&fi->queued_writes)) {\n\t\treq = list_entry(fi->queued_writes.next, struct fuse_req, list);\n\t\tlist_del_init(&req->list);\n\t\tfuse_send_writepage(fc, req, crop);\n\t}\n}"
  },
  {
    "function_name": "fuse_send_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1480-1512",
    "snippet": "static void fuse_send_writepage(struct fuse_conn *fc, struct fuse_req *req,\n\t\t\t\tloff_t size)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(req->inode);\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\t__u64 data_size = req->num_pages * PAGE_CACHE_SIZE;\n\n\tif (!fc->connected)\n\t\tgoto out_free;\n\n\tif (inarg->offset + data_size <= size) {\n\t\tinarg->size = data_size;\n\t} else if (inarg->offset < size) {\n\t\tinarg->size = size - inarg->offset;\n\t} else {\n\t\t/* Got truncated off completely */\n\t\tgoto out_free;\n\t}\n\n\treq->in.args[1].size = inarg->size;\n\tfi->writectr++;\n\tfuse_request_send_background_locked(fc, req);\n\treturn;\n\n out_free:\n\tfuse_writepage_finish(fc, req);\n\tspin_unlock(&fc->lock);\n\tfuse_writepage_free(fc, req);\n\tfuse_put_request(fc, req);\n\tspin_lock(&fc->lock);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_put_request",
          "args": [
            "fc",
            "req"
          ],
          "line": 1510
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "277-299",
          "snippet": "void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_writepage_free",
          "args": [
            "fc",
            "req"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_writepage_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1452-1461",
          "snippet": "static void fuse_writepage_free(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tint i;\n\n\tfor (i = 0; i < req->num_pages; i++)\n\t\t__free_page(req->pages[i]);\n\n\tif (req->ff)\n\t\tfuse_file_put(req->ff, false);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_writepage_free(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tint i;\n\n\tfor (i = 0; i < req->num_pages; i++)\n\t\t__free_page(req->pages[i]);\n\n\tif (req->ff)\n\t\tfuse_file_put(req->ff, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_writepage_finish",
          "args": [
            "fc",
            "req"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_writepage_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1463-1477",
          "snippet": "static void fuse_writepage_finish(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct inode *inode = req->inode;\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\tint i;\n\n\tlist_del(&req->writepages_entry);\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tdec_bdi_stat(bdi, BDI_WRITEBACK);\n\t\tdec_zone_page_state(req->pages[i], NR_WRITEBACK_TEMP);\n\t\tbdi_writeout_inc(bdi);\n\t}\n\twake_up(&fi->page_waitq);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_writepage_finish(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct inode *inode = req->inode;\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\tint i;\n\n\tlist_del(&req->writepages_entry);\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tdec_bdi_stat(bdi, BDI_WRITEBACK);\n\t\tdec_zone_page_state(req->pages[i], NR_WRITEBACK_TEMP);\n\t\tbdi_writeout_inc(bdi);\n\t}\n\twake_up(&fi->page_waitq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_request_send_background_locked",
          "args": [
            "fc",
            "req"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_send_background_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "647-652",
          "snippet": "void fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "req->inode"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "fc->lock"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "fc->lock"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_send_writepage(struct fuse_conn *fc, struct fuse_req *req,\n\t\t\t\tloff_t size)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(req->inode);\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\t__u64 data_size = req->num_pages * PAGE_CACHE_SIZE;\n\n\tif (!fc->connected)\n\t\tgoto out_free;\n\n\tif (inarg->offset + data_size <= size) {\n\t\tinarg->size = data_size;\n\t} else if (inarg->offset < size) {\n\t\tinarg->size = size - inarg->offset;\n\t} else {\n\t\t/* Got truncated off completely */\n\t\tgoto out_free;\n\t}\n\n\treq->in.args[1].size = inarg->size;\n\tfi->writectr++;\n\tfuse_request_send_background_locked(fc, req);\n\treturn;\n\n out_free:\n\tfuse_writepage_finish(fc, req);\n\tspin_unlock(&fc->lock);\n\tfuse_writepage_free(fc, req);\n\tfuse_put_request(fc, req);\n\tspin_lock(&fc->lock);\n}"
  },
  {
    "function_name": "fuse_writepage_finish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1463-1477",
    "snippet": "static void fuse_writepage_finish(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct inode *inode = req->inode;\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\tint i;\n\n\tlist_del(&req->writepages_entry);\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tdec_bdi_stat(bdi, BDI_WRITEBACK);\n\t\tdec_zone_page_state(req->pages[i], NR_WRITEBACK_TEMP);\n\t\tbdi_writeout_inc(bdi);\n\t}\n\twake_up(&fi->page_waitq);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&fi->page_waitq"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdi_writeout_inc",
          "args": [
            "bdi"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_zone_page_state",
          "args": [
            "req->pages[i]",
            "NR_WRITEBACK_TEMP"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_bdi_stat",
          "args": [
            "bdi",
            "BDI_WRITEBACK"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&req->writepages_entry"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "inode"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_bdi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "69-82",
          "snippet": "struct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_writepage_finish(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct inode *inode = req->inode;\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\tint i;\n\n\tlist_del(&req->writepages_entry);\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tdec_bdi_stat(bdi, BDI_WRITEBACK);\n\t\tdec_zone_page_state(req->pages[i], NR_WRITEBACK_TEMP);\n\t\tbdi_writeout_inc(bdi);\n\t}\n\twake_up(&fi->page_waitq);\n}"
  },
  {
    "function_name": "fuse_writepage_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1452-1461",
    "snippet": "static void fuse_writepage_free(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tint i;\n\n\tfor (i = 0; i < req->num_pages; i++)\n\t\t__free_page(req->pages[i]);\n\n\tif (req->ff)\n\t\tfuse_file_put(req->ff, false);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_file_put",
          "args": [
            "req->ff",
            "false"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_file_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "89-114",
          "snippet": "static void fuse_file_put(struct fuse_file *ff, bool sync)\n{\n\tif (atomic_dec_and_test(&ff->count)) {\n\t\tstruct fuse_req *req = ff->reserved_req;\n\n\t\tif (ff->fc->no_open) {\n\t\t\t/*\n\t\t\t * Drop the release request when client does not\n\t\t\t * implement 'open'\n\t\t\t */\n\t\t\treq->background = 0;\n\t\t\tiput(req->misc.release.inode);\n\t\t\tfuse_put_request(ff->fc, req);\n\t\t} else if (sync) {\n\t\t\treq->background = 0;\n\t\t\tfuse_request_send(ff->fc, req);\n\t\t\tiput(req->misc.release.inode);\n\t\t\tfuse_put_request(ff->fc, req);\n\t\t} else {\n\t\t\treq->end = fuse_release_end;\n\t\t\treq->background = 1;\n\t\t\tfuse_request_send_background(ff->fc, req);\n\t\t}\n\t\tkfree(ff);\n\t}\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_file_put(struct fuse_file *ff, bool sync)\n{\n\tif (atomic_dec_and_test(&ff->count)) {\n\t\tstruct fuse_req *req = ff->reserved_req;\n\n\t\tif (ff->fc->no_open) {\n\t\t\t/*\n\t\t\t * Drop the release request when client does not\n\t\t\t * implement 'open'\n\t\t\t */\n\t\t\treq->background = 0;\n\t\t\tiput(req->misc.release.inode);\n\t\t\tfuse_put_request(ff->fc, req);\n\t\t} else if (sync) {\n\t\t\treq->background = 0;\n\t\t\tfuse_request_send(ff->fc, req);\n\t\t\tiput(req->misc.release.inode);\n\t\t\tfuse_put_request(ff->fc, req);\n\t\t} else {\n\t\t\treq->end = fuse_release_end;\n\t\t\treq->background = 1;\n\t\t\tfuse_request_send_background(ff->fc, req);\n\t\t}\n\t\tkfree(ff);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "req->pages[i]"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_writepage_free(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tint i;\n\n\tfor (i = 0; i < req->num_pages; i++)\n\t\t__free_page(req->pages[i]);\n\n\tif (req->ff)\n\t\tfuse_file_put(req->ff, false);\n}"
  },
  {
    "function_name": "fuse_direct_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1429-1450",
    "snippet": "static ssize_t fuse_direct_write(struct file *file, const char __user *buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = count };\n\tstruct inode *inode = file_inode(file);\n\tssize_t res;\n\tstruct fuse_io_priv io = { .async = 0, .file = file };\n\tstruct iov_iter ii;\n\tiov_iter_init(&ii, WRITE, &iov, 1, count);\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\t/* Don't allow parallel writes to the same file */\n\tmutex_lock(&inode->i_mutex);\n\tres = __fuse_direct_write(&io, &ii, ppos);\n\tif (res > 0)\n\t\tfuse_write_update_size(inode, *ppos);\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn res;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_write_update_size",
          "args": [
            "inode",
            "*ppos"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_write_update_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "957-972",
          "snippet": "bool fuse_write_update_size(struct inode *inode, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tbool ret = false;\n\n\tspin_lock(&fc->lock);\n\tfi->attr_version = ++fc->attr_version;\n\tif (pos > inode->i_size) {\n\t\ti_size_write(inode, pos);\n\t\tret = true;\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nbool fuse_write_update_size(struct inode *inode, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tbool ret = false;\n\n\tspin_lock(&fc->lock);\n\tfi->attr_version = ++fc->attr_version;\n\tif (pos > inode->i_size) {\n\t\ti_size_write(inode, pos);\n\t\tret = true;\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fuse_direct_write",
          "args": [
            "&io",
            "&ii",
            "ppos"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "__fuse_direct_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1408-1427",
          "snippet": "static ssize_t __fuse_direct_write(struct fuse_io_priv *io,\n\t\t\t\t   struct iov_iter *iter,\n\t\t\t\t   loff_t *ppos)\n{\n\tstruct file *file = io->file;\n\tstruct inode *inode = file_inode(file);\n\tsize_t count = iov_iter_count(iter);\n\tssize_t res;\n\n\n\tres = generic_write_checks(file, ppos, &count, 0);\n\tif (!res) {\n\t\tiov_iter_truncate(iter, count);\n\t\tres = fuse_direct_io(io, iter, ppos, FUSE_DIO_WRITE);\n\t}\n\n\tfuse_invalidate_attr(inode);\n\n\treturn res;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t __fuse_direct_write(struct fuse_io_priv *io,\n\t\t\t\t   struct iov_iter *iter,\n\t\t\t\t   loff_t *ppos)\n{\n\tstruct file *file = io->file;\n\tstruct inode *inode = file_inode(file);\n\tsize_t count = iov_iter_count(iter);\n\tssize_t res;\n\n\n\tres = generic_write_checks(file, ppos, &count, 0);\n\tif (!res) {\n\t\tiov_iter_truncate(iter, count);\n\t\tres = fuse_direct_io(io, iter, ppos, FUSE_DIO_WRITE);\n\t}\n\n\tfuse_invalidate_attr(inode);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_init",
          "args": [
            "&ii",
            "WRITE",
            "&iov",
            "1",
            "count"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_direct_write(struct file *file, const char __user *buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = count };\n\tstruct inode *inode = file_inode(file);\n\tssize_t res;\n\tstruct fuse_io_priv io = { .async = 0, .file = file };\n\tstruct iov_iter ii;\n\tiov_iter_init(&ii, WRITE, &iov, 1, count);\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\t/* Don't allow parallel writes to the same file */\n\tmutex_lock(&inode->i_mutex);\n\tres = __fuse_direct_write(&io, &ii, ppos);\n\tif (res > 0)\n\t\tfuse_write_update_size(inode, *ppos);\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn res;\n}"
  },
  {
    "function_name": "__fuse_direct_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1408-1427",
    "snippet": "static ssize_t __fuse_direct_write(struct fuse_io_priv *io,\n\t\t\t\t   struct iov_iter *iter,\n\t\t\t\t   loff_t *ppos)\n{\n\tstruct file *file = io->file;\n\tstruct inode *inode = file_inode(file);\n\tsize_t count = iov_iter_count(iter);\n\tssize_t res;\n\n\n\tres = generic_write_checks(file, ppos, &count, 0);\n\tif (!res) {\n\t\tiov_iter_truncate(iter, count);\n\t\tres = fuse_direct_io(io, iter, ppos, FUSE_DIO_WRITE);\n\t}\n\n\tfuse_invalidate_attr(inode);\n\n\treturn res;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_invalidate_attr",
          "args": [
            "inode"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "110-113",
          "snippet": "void fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_direct_io",
          "args": [
            "io",
            "iter",
            "ppos",
            "FUSE_DIO_WRITE"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_direct_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1298-1377",
          "snippet": "ssize_t fuse_direct_io(struct fuse_io_priv *io, struct iov_iter *iter,\n\t\t       loff_t *ppos, int flags)\n{\n\tint write = flags & FUSE_DIO_WRITE;\n\tint cuse = flags & FUSE_DIO_CUSE;\n\tstruct file *file = io->file;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tsize_t nmax = write ? fc->max_write : fc->max_read;\n\tloff_t pos = *ppos;\n\tsize_t count = iov_iter_count(iter);\n\tpgoff_t idx_from = pos >> PAGE_CACHE_SHIFT;\n\tpgoff_t idx_to = (pos + count - 1) >> PAGE_CACHE_SHIFT;\n\tssize_t res = 0;\n\tstruct fuse_req *req;\n\n\tif (io->async)\n\t\treq = fuse_get_req_for_background(fc, fuse_iter_npages(iter));\n\telse\n\t\treq = fuse_get_req(fc, fuse_iter_npages(iter));\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tif (!cuse && fuse_range_is_writeback(inode, idx_from, idx_to)) {\n\t\tif (!write)\n\t\t\tmutex_lock(&inode->i_mutex);\n\t\tfuse_sync_writes(inode);\n\t\tif (!write)\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\n\twhile (count) {\n\t\tsize_t nres;\n\t\tfl_owner_t owner = current->files;\n\t\tsize_t nbytes = min(count, nmax);\n\t\tint err = fuse_get_user_pages(req, iter, &nbytes, write);\n\t\tif (err) {\n\t\t\tres = err;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (write)\n\t\t\tnres = fuse_send_write(req, io, pos, nbytes, owner);\n\t\telse\n\t\t\tnres = fuse_send_read(req, io, pos, nbytes, owner);\n\n\t\tif (!io->async)\n\t\t\tfuse_release_user_pages(req, !write);\n\t\tif (req->out.h.error) {\n\t\t\tif (!res)\n\t\t\t\tres = req->out.h.error;\n\t\t\tbreak;\n\t\t} else if (nres > nbytes) {\n\t\t\tres = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tcount -= nres;\n\t\tres += nres;\n\t\tpos += nres;\n\t\tif (nres != nbytes)\n\t\t\tbreak;\n\t\tif (count) {\n\t\t\tfuse_put_request(fc, req);\n\t\t\tif (io->async)\n\t\t\t\treq = fuse_get_req_for_background(fc,\n\t\t\t\t\tfuse_iter_npages(iter));\n\t\t\telse\n\t\t\t\treq = fuse_get_req(fc, fuse_iter_npages(iter));\n\t\t\tif (IS_ERR(req))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (!IS_ERR(req))\n\t\tfuse_put_request(fc, req);\n\tif (res > 0)\n\t\t*ppos = pos;\n\n\treturn res;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_direct_io(struct fuse_io_priv *io, struct iov_iter *iter,\n\t\t       loff_t *ppos, int flags)\n{\n\tint write = flags & FUSE_DIO_WRITE;\n\tint cuse = flags & FUSE_DIO_CUSE;\n\tstruct file *file = io->file;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tsize_t nmax = write ? fc->max_write : fc->max_read;\n\tloff_t pos = *ppos;\n\tsize_t count = iov_iter_count(iter);\n\tpgoff_t idx_from = pos >> PAGE_CACHE_SHIFT;\n\tpgoff_t idx_to = (pos + count - 1) >> PAGE_CACHE_SHIFT;\n\tssize_t res = 0;\n\tstruct fuse_req *req;\n\n\tif (io->async)\n\t\treq = fuse_get_req_for_background(fc, fuse_iter_npages(iter));\n\telse\n\t\treq = fuse_get_req(fc, fuse_iter_npages(iter));\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tif (!cuse && fuse_range_is_writeback(inode, idx_from, idx_to)) {\n\t\tif (!write)\n\t\t\tmutex_lock(&inode->i_mutex);\n\t\tfuse_sync_writes(inode);\n\t\tif (!write)\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\n\twhile (count) {\n\t\tsize_t nres;\n\t\tfl_owner_t owner = current->files;\n\t\tsize_t nbytes = min(count, nmax);\n\t\tint err = fuse_get_user_pages(req, iter, &nbytes, write);\n\t\tif (err) {\n\t\t\tres = err;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (write)\n\t\t\tnres = fuse_send_write(req, io, pos, nbytes, owner);\n\t\telse\n\t\t\tnres = fuse_send_read(req, io, pos, nbytes, owner);\n\n\t\tif (!io->async)\n\t\t\tfuse_release_user_pages(req, !write);\n\t\tif (req->out.h.error) {\n\t\t\tif (!res)\n\t\t\t\tres = req->out.h.error;\n\t\t\tbreak;\n\t\t} else if (nres > nbytes) {\n\t\t\tres = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tcount -= nres;\n\t\tres += nres;\n\t\tpos += nres;\n\t\tif (nres != nbytes)\n\t\t\tbreak;\n\t\tif (count) {\n\t\t\tfuse_put_request(fc, req);\n\t\t\tif (io->async)\n\t\t\t\treq = fuse_get_req_for_background(fc,\n\t\t\t\t\tfuse_iter_npages(iter));\n\t\t\telse\n\t\t\t\treq = fuse_get_req(fc, fuse_iter_npages(iter));\n\t\t\tif (IS_ERR(req))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (!IS_ERR(req))\n\t\tfuse_put_request(fc, req);\n\tif (res > 0)\n\t\t*ppos = pos;\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_truncate",
          "args": [
            "iter",
            "count"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_write_checks",
          "args": [
            "file",
            "ppos",
            "&count",
            "0"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t __fuse_direct_write(struct fuse_io_priv *io,\n\t\t\t\t   struct iov_iter *iter,\n\t\t\t\t   loff_t *ppos)\n{\n\tstruct file *file = io->file;\n\tstruct inode *inode = file_inode(file);\n\tsize_t count = iov_iter_count(iter);\n\tssize_t res;\n\n\n\tres = generic_write_checks(file, ppos, &count, 0);\n\tif (!res) {\n\t\tiov_iter_truncate(iter, count);\n\t\tres = fuse_direct_io(io, iter, ppos, FUSE_DIO_WRITE);\n\t}\n\n\tfuse_invalidate_attr(inode);\n\n\treturn res;\n}"
  },
  {
    "function_name": "fuse_direct_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1398-1406",
    "snippet": "static ssize_t fuse_direct_read(struct file *file, char __user *buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct fuse_io_priv io = { .async = 0, .file = file };\n\tstruct iovec iov = { .iov_base = buf, .iov_len = count };\n\tstruct iov_iter ii;\n\tiov_iter_init(&ii, READ, &iov, 1, count);\n\treturn __fuse_direct_read(&io, &ii, ppos);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fuse_direct_read",
          "args": [
            "&io",
            "&ii",
            "ppos"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "__fuse_direct_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1380-1396",
          "snippet": "static ssize_t __fuse_direct_read(struct fuse_io_priv *io,\n\t\t\t\t  struct iov_iter *iter,\n\t\t\t\t  loff_t *ppos)\n{\n\tssize_t res;\n\tstruct file *file = io->file;\n\tstruct inode *inode = file_inode(file);\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tres = fuse_direct_io(io, iter, ppos, 0);\n\n\tfuse_invalidate_attr(inode);\n\n\treturn res;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t __fuse_direct_read(struct fuse_io_priv *io,\n\t\t\t\t  struct iov_iter *iter,\n\t\t\t\t  loff_t *ppos)\n{\n\tssize_t res;\n\tstruct file *file = io->file;\n\tstruct inode *inode = file_inode(file);\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tres = fuse_direct_io(io, iter, ppos, 0);\n\n\tfuse_invalidate_attr(inode);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_init",
          "args": [
            "&ii",
            "READ",
            "&iov",
            "1",
            "count"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_direct_read(struct file *file, char __user *buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct fuse_io_priv io = { .async = 0, .file = file };\n\tstruct iovec iov = { .iov_base = buf, .iov_len = count };\n\tstruct iov_iter ii;\n\tiov_iter_init(&ii, READ, &iov, 1, count);\n\treturn __fuse_direct_read(&io, &ii, ppos);\n}"
  },
  {
    "function_name": "__fuse_direct_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1380-1396",
    "snippet": "static ssize_t __fuse_direct_read(struct fuse_io_priv *io,\n\t\t\t\t  struct iov_iter *iter,\n\t\t\t\t  loff_t *ppos)\n{\n\tssize_t res;\n\tstruct file *file = io->file;\n\tstruct inode *inode = file_inode(file);\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tres = fuse_direct_io(io, iter, ppos, 0);\n\n\tfuse_invalidate_attr(inode);\n\n\treturn res;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_invalidate_attr",
          "args": [
            "inode"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "110-113",
          "snippet": "void fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_direct_io",
          "args": [
            "io",
            "iter",
            "ppos",
            "0"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_direct_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1298-1377",
          "snippet": "ssize_t fuse_direct_io(struct fuse_io_priv *io, struct iov_iter *iter,\n\t\t       loff_t *ppos, int flags)\n{\n\tint write = flags & FUSE_DIO_WRITE;\n\tint cuse = flags & FUSE_DIO_CUSE;\n\tstruct file *file = io->file;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tsize_t nmax = write ? fc->max_write : fc->max_read;\n\tloff_t pos = *ppos;\n\tsize_t count = iov_iter_count(iter);\n\tpgoff_t idx_from = pos >> PAGE_CACHE_SHIFT;\n\tpgoff_t idx_to = (pos + count - 1) >> PAGE_CACHE_SHIFT;\n\tssize_t res = 0;\n\tstruct fuse_req *req;\n\n\tif (io->async)\n\t\treq = fuse_get_req_for_background(fc, fuse_iter_npages(iter));\n\telse\n\t\treq = fuse_get_req(fc, fuse_iter_npages(iter));\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tif (!cuse && fuse_range_is_writeback(inode, idx_from, idx_to)) {\n\t\tif (!write)\n\t\t\tmutex_lock(&inode->i_mutex);\n\t\tfuse_sync_writes(inode);\n\t\tif (!write)\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\n\twhile (count) {\n\t\tsize_t nres;\n\t\tfl_owner_t owner = current->files;\n\t\tsize_t nbytes = min(count, nmax);\n\t\tint err = fuse_get_user_pages(req, iter, &nbytes, write);\n\t\tif (err) {\n\t\t\tres = err;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (write)\n\t\t\tnres = fuse_send_write(req, io, pos, nbytes, owner);\n\t\telse\n\t\t\tnres = fuse_send_read(req, io, pos, nbytes, owner);\n\n\t\tif (!io->async)\n\t\t\tfuse_release_user_pages(req, !write);\n\t\tif (req->out.h.error) {\n\t\t\tif (!res)\n\t\t\t\tres = req->out.h.error;\n\t\t\tbreak;\n\t\t} else if (nres > nbytes) {\n\t\t\tres = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tcount -= nres;\n\t\tres += nres;\n\t\tpos += nres;\n\t\tif (nres != nbytes)\n\t\t\tbreak;\n\t\tif (count) {\n\t\t\tfuse_put_request(fc, req);\n\t\t\tif (io->async)\n\t\t\t\treq = fuse_get_req_for_background(fc,\n\t\t\t\t\tfuse_iter_npages(iter));\n\t\t\telse\n\t\t\t\treq = fuse_get_req(fc, fuse_iter_npages(iter));\n\t\t\tif (IS_ERR(req))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (!IS_ERR(req))\n\t\tfuse_put_request(fc, req);\n\tif (res > 0)\n\t\t*ppos = pos;\n\n\treturn res;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_direct_io(struct fuse_io_priv *io, struct iov_iter *iter,\n\t\t       loff_t *ppos, int flags)\n{\n\tint write = flags & FUSE_DIO_WRITE;\n\tint cuse = flags & FUSE_DIO_CUSE;\n\tstruct file *file = io->file;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tsize_t nmax = write ? fc->max_write : fc->max_read;\n\tloff_t pos = *ppos;\n\tsize_t count = iov_iter_count(iter);\n\tpgoff_t idx_from = pos >> PAGE_CACHE_SHIFT;\n\tpgoff_t idx_to = (pos + count - 1) >> PAGE_CACHE_SHIFT;\n\tssize_t res = 0;\n\tstruct fuse_req *req;\n\n\tif (io->async)\n\t\treq = fuse_get_req_for_background(fc, fuse_iter_npages(iter));\n\telse\n\t\treq = fuse_get_req(fc, fuse_iter_npages(iter));\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tif (!cuse && fuse_range_is_writeback(inode, idx_from, idx_to)) {\n\t\tif (!write)\n\t\t\tmutex_lock(&inode->i_mutex);\n\t\tfuse_sync_writes(inode);\n\t\tif (!write)\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\n\twhile (count) {\n\t\tsize_t nres;\n\t\tfl_owner_t owner = current->files;\n\t\tsize_t nbytes = min(count, nmax);\n\t\tint err = fuse_get_user_pages(req, iter, &nbytes, write);\n\t\tif (err) {\n\t\t\tres = err;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (write)\n\t\t\tnres = fuse_send_write(req, io, pos, nbytes, owner);\n\t\telse\n\t\t\tnres = fuse_send_read(req, io, pos, nbytes, owner);\n\n\t\tif (!io->async)\n\t\t\tfuse_release_user_pages(req, !write);\n\t\tif (req->out.h.error) {\n\t\t\tif (!res)\n\t\t\t\tres = req->out.h.error;\n\t\t\tbreak;\n\t\t} else if (nres > nbytes) {\n\t\t\tres = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tcount -= nres;\n\t\tres += nres;\n\t\tpos += nres;\n\t\tif (nres != nbytes)\n\t\t\tbreak;\n\t\tif (count) {\n\t\t\tfuse_put_request(fc, req);\n\t\t\tif (io->async)\n\t\t\t\treq = fuse_get_req_for_background(fc,\n\t\t\t\t\tfuse_iter_npages(iter));\n\t\t\telse\n\t\t\t\treq = fuse_get_req(fc, fuse_iter_npages(iter));\n\t\t\tif (IS_ERR(req))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (!IS_ERR(req))\n\t\tfuse_put_request(fc, req);\n\tif (res > 0)\n\t\t*ppos = pos;\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t __fuse_direct_read(struct fuse_io_priv *io,\n\t\t\t\t  struct iov_iter *iter,\n\t\t\t\t  loff_t *ppos)\n{\n\tssize_t res;\n\tstruct file *file = io->file;\n\tstruct inode *inode = file_inode(file);\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tres = fuse_direct_io(io, iter, ppos, 0);\n\n\tfuse_invalidate_attr(inode);\n\n\treturn res;\n}"
  },
  {
    "function_name": "fuse_direct_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1298-1377",
    "snippet": "ssize_t fuse_direct_io(struct fuse_io_priv *io, struct iov_iter *iter,\n\t\t       loff_t *ppos, int flags)\n{\n\tint write = flags & FUSE_DIO_WRITE;\n\tint cuse = flags & FUSE_DIO_CUSE;\n\tstruct file *file = io->file;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tsize_t nmax = write ? fc->max_write : fc->max_read;\n\tloff_t pos = *ppos;\n\tsize_t count = iov_iter_count(iter);\n\tpgoff_t idx_from = pos >> PAGE_CACHE_SHIFT;\n\tpgoff_t idx_to = (pos + count - 1) >> PAGE_CACHE_SHIFT;\n\tssize_t res = 0;\n\tstruct fuse_req *req;\n\n\tif (io->async)\n\t\treq = fuse_get_req_for_background(fc, fuse_iter_npages(iter));\n\telse\n\t\treq = fuse_get_req(fc, fuse_iter_npages(iter));\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tif (!cuse && fuse_range_is_writeback(inode, idx_from, idx_to)) {\n\t\tif (!write)\n\t\t\tmutex_lock(&inode->i_mutex);\n\t\tfuse_sync_writes(inode);\n\t\tif (!write)\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\n\twhile (count) {\n\t\tsize_t nres;\n\t\tfl_owner_t owner = current->files;\n\t\tsize_t nbytes = min(count, nmax);\n\t\tint err = fuse_get_user_pages(req, iter, &nbytes, write);\n\t\tif (err) {\n\t\t\tres = err;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (write)\n\t\t\tnres = fuse_send_write(req, io, pos, nbytes, owner);\n\t\telse\n\t\t\tnres = fuse_send_read(req, io, pos, nbytes, owner);\n\n\t\tif (!io->async)\n\t\t\tfuse_release_user_pages(req, !write);\n\t\tif (req->out.h.error) {\n\t\t\tif (!res)\n\t\t\t\tres = req->out.h.error;\n\t\t\tbreak;\n\t\t} else if (nres > nbytes) {\n\t\t\tres = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tcount -= nres;\n\t\tres += nres;\n\t\tpos += nres;\n\t\tif (nres != nbytes)\n\t\t\tbreak;\n\t\tif (count) {\n\t\t\tfuse_put_request(fc, req);\n\t\t\tif (io->async)\n\t\t\t\treq = fuse_get_req_for_background(fc,\n\t\t\t\t\tfuse_iter_npages(iter));\n\t\t\telse\n\t\t\t\treq = fuse_get_req(fc, fuse_iter_npages(iter));\n\t\t\tif (IS_ERR(req))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (!IS_ERR(req))\n\t\tfuse_put_request(fc, req);\n\tif (res > 0)\n\t\t*ppos = pos;\n\n\treturn res;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_put_request",
          "args": [
            "fc",
            "req"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "277-299",
          "snippet": "void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_get_req",
          "args": [
            "fc",
            "fuse_iter_npages(iter)"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_req_nofail_nopages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "258-275",
          "snippet": "struct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc,\n\t\t\t\t\t     struct file *file)\n{\n\tstruct fuse_req *req;\n\n\tatomic_inc(&fc->num_waiting);\n\twait_event(fc->blocked_waitq, fc->initialized);\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\treq = fuse_request_alloc(0);\n\tif (!req)\n\t\treq = get_reserved_req(fc, file);\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = 0;\n\treturn req;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstruct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc,\n\t\t\t\t\t     struct file *file)\n{\n\tstruct fuse_req *req;\n\n\tatomic_inc(&fc->num_waiting);\n\twait_event(fc->blocked_waitq, fc->initialized);\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\treq = fuse_request_alloc(0);\n\tif (!req)\n\t\treq = get_reserved_req(fc, file);\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = 0;\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_iter_npages",
          "args": [
            "iter"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_iter_npages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1293-1296",
          "snippet": "static inline int fuse_iter_npages(const struct iov_iter *ii_p)\n{\n\treturn iov_iter_npages(ii_p, FUSE_MAX_PAGES_PER_REQ);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline int fuse_iter_npages(const struct iov_iter *ii_p)\n{\n\treturn iov_iter_npages(ii_p, FUSE_MAX_PAGES_PER_REQ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_get_req_for_background",
          "args": [
            "fc",
            "fuse_iter_npages(iter)"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_req_for_background",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "196-200",
          "snippet": "struct fuse_req *fuse_get_req_for_background(struct fuse_conn *fc,\n\t\t\t\t\t     unsigned npages)\n{\n\treturn __fuse_get_req(fc, npages, true);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstruct fuse_req *fuse_get_req_for_background(struct fuse_conn *fc,\n\t\t\t\t\t     unsigned npages)\n{\n\treturn __fuse_get_req(fc, npages, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_release_user_pages",
          "args": [
            "req",
            "!write"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_release_user_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "519-529",
          "snippet": "static void fuse_release_user_pages(struct fuse_req *req, int write)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tstruct page *page = req->pages[i];\n\t\tif (write)\n\t\t\tset_page_dirty_lock(page);\n\t\tput_page(page);\n\t}\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_release_user_pages(struct fuse_req *req, int write)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tstruct page *page = req->pages[i];\n\t\tif (write)\n\t\t\tset_page_dirty_lock(page);\n\t\tput_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_send_read",
          "args": [
            "req",
            "io",
            "pos",
            "nbytes",
            "owner"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_send_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "623-643",
          "snippet": "static size_t fuse_send_read(struct fuse_req *req, struct fuse_io_priv *io,\n\t\t\t     loff_t pos, size_t count, fl_owner_t owner)\n{\n\tstruct file *file = io->file;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\n\tfuse_read_fill(req, file, pos, count, FUSE_READ);\n\tif (owner != NULL) {\n\t\tstruct fuse_read_in *inarg = &req->misc.read.in;\n\n\t\tinarg->read_flags |= FUSE_READ_LOCKOWNER;\n\t\tinarg->lock_owner = fuse_lock_owner_id(fc, owner);\n\t}\n\n\tif (io->async)\n\t\treturn fuse_async_req_send(fc, req, count, io);\n\n\tfuse_request_send(fc, req);\n\treturn req->out.args[0].size;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic size_t fuse_send_read(struct fuse_req *req, struct fuse_io_priv *io,\n\t\t\t     loff_t pos, size_t count, fl_owner_t owner)\n{\n\tstruct file *file = io->file;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\n\tfuse_read_fill(req, file, pos, count, FUSE_READ);\n\tif (owner != NULL) {\n\t\tstruct fuse_read_in *inarg = &req->misc.read.in;\n\n\t\tinarg->read_flags |= FUSE_READ_LOCKOWNER;\n\t\tinarg->lock_owner = fuse_lock_owner_id(fc, owner);\n\t}\n\n\tif (io->async)\n\t\treturn fuse_async_req_send(fc, req, count, io);\n\n\tfuse_request_send(fc, req);\n\treturn req->out.args[0].size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_send_write",
          "args": [
            "req",
            "io",
            "pos",
            "nbytes",
            "owner"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_send_write_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "974-1007",
          "snippet": "static size_t fuse_send_write_pages(struct fuse_req *req, struct file *file,\n\t\t\t\t    struct inode *inode, loff_t pos,\n\t\t\t\t    size_t count)\n{\n\tsize_t res;\n\tunsigned offset;\n\tunsigned i;\n\tstruct fuse_io_priv io = { .async = 0, .file = file };\n\n\tfor (i = 0; i < req->num_pages; i++)\n\t\tfuse_wait_on_page_writeback(inode, req->pages[i]->index);\n\n\tres = fuse_send_write(req, &io, pos, count, NULL);\n\n\toffset = req->page_descs[0].offset;\n\tcount = res;\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tstruct page *page = req->pages[i];\n\n\t\tif (!req->out.h.error && !offset && count >= PAGE_CACHE_SIZE)\n\t\t\tSetPageUptodate(page);\n\n\t\tif (count > PAGE_CACHE_SIZE - offset)\n\t\t\tcount -= PAGE_CACHE_SIZE - offset;\n\t\telse\n\t\t\tcount = 0;\n\t\toffset = 0;\n\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic size_t fuse_send_write_pages(struct fuse_req *req, struct file *file,\n\t\t\t\t    struct inode *inode, loff_t pos,\n\t\t\t\t    size_t count)\n{\n\tsize_t res;\n\tunsigned offset;\n\tunsigned i;\n\tstruct fuse_io_priv io = { .async = 0, .file = file };\n\n\tfor (i = 0; i < req->num_pages; i++)\n\t\tfuse_wait_on_page_writeback(inode, req->pages[i]->index);\n\n\tres = fuse_send_write(req, &io, pos, count, NULL);\n\n\toffset = req->page_descs[0].offset;\n\tcount = res;\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tstruct page *page = req->pages[i];\n\n\t\tif (!req->out.h.error && !offset && count >= PAGE_CACHE_SIZE)\n\t\t\tSetPageUptodate(page);\n\n\t\tif (count > PAGE_CACHE_SIZE - offset)\n\t\t\tcount -= PAGE_CACHE_SIZE - offset;\n\t\telse\n\t\t\tcount = 0;\n\t\toffset = 0;\n\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_get_user_pages",
          "args": [
            "req",
            "iter",
            "&nbytes",
            "write"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_user_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1238-1291",
          "snippet": "static int fuse_get_user_pages(struct fuse_req *req, struct iov_iter *ii,\n\t\t\t       size_t *nbytesp, int write)\n{\n\tsize_t nbytes = 0;  /* # bytes already packed in req */\n\n\t/* Special case for kernel I/O: can copy directly into the buffer */\n\tif (ii->type & ITER_KVEC) {\n\t\tunsigned long user_addr = fuse_get_user_addr(ii);\n\t\tsize_t frag_size = fuse_get_frag_size(ii, *nbytesp);\n\n\t\tif (write)\n\t\t\treq->in.args[1].value = (void *) user_addr;\n\t\telse\n\t\t\treq->out.args[0].value = (void *) user_addr;\n\n\t\tiov_iter_advance(ii, frag_size);\n\t\t*nbytesp = frag_size;\n\t\treturn 0;\n\t}\n\n\twhile (nbytes < *nbytesp && req->num_pages < req->max_pages) {\n\t\tunsigned npages;\n\t\tsize_t start;\n\t\tssize_t ret = iov_iter_get_pages(ii,\n\t\t\t\t\t&req->pages[req->num_pages],\n\t\t\t\t\t*nbytesp - nbytes,\n\t\t\t\t\treq->max_pages - req->num_pages,\n\t\t\t\t\t&start);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tiov_iter_advance(ii, ret);\n\t\tnbytes += ret;\n\n\t\tret += start;\n\t\tnpages = (ret + PAGE_SIZE - 1) / PAGE_SIZE;\n\n\t\treq->page_descs[req->num_pages].offset = start;\n\t\tfuse_page_descs_length_init(req, req->num_pages, npages);\n\n\t\treq->num_pages += npages;\n\t\treq->page_descs[req->num_pages - 1].length -=\n\t\t\t(PAGE_SIZE - ret) & (PAGE_SIZE - 1);\n\t}\n\n\tif (write)\n\t\treq->in.argpages = 1;\n\telse\n\t\treq->out.argpages = 1;\n\n\t*nbytesp = nbytes;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_get_user_pages(struct fuse_req *req, struct iov_iter *ii,\n\t\t\t       size_t *nbytesp, int write)\n{\n\tsize_t nbytes = 0;  /* # bytes already packed in req */\n\n\t/* Special case for kernel I/O: can copy directly into the buffer */\n\tif (ii->type & ITER_KVEC) {\n\t\tunsigned long user_addr = fuse_get_user_addr(ii);\n\t\tsize_t frag_size = fuse_get_frag_size(ii, *nbytesp);\n\n\t\tif (write)\n\t\t\treq->in.args[1].value = (void *) user_addr;\n\t\telse\n\t\t\treq->out.args[0].value = (void *) user_addr;\n\n\t\tiov_iter_advance(ii, frag_size);\n\t\t*nbytesp = frag_size;\n\t\treturn 0;\n\t}\n\n\twhile (nbytes < *nbytesp && req->num_pages < req->max_pages) {\n\t\tunsigned npages;\n\t\tsize_t start;\n\t\tssize_t ret = iov_iter_get_pages(ii,\n\t\t\t\t\t&req->pages[req->num_pages],\n\t\t\t\t\t*nbytesp - nbytes,\n\t\t\t\t\treq->max_pages - req->num_pages,\n\t\t\t\t\t&start);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tiov_iter_advance(ii, ret);\n\t\tnbytes += ret;\n\n\t\tret += start;\n\t\tnpages = (ret + PAGE_SIZE - 1) / PAGE_SIZE;\n\n\t\treq->page_descs[req->num_pages].offset = start;\n\t\tfuse_page_descs_length_init(req, req->num_pages, npages);\n\n\t\treq->num_pages += npages;\n\t\treq->page_descs[req->num_pages - 1].length -=\n\t\t\t(PAGE_SIZE - ret) & (PAGE_SIZE - 1);\n\t}\n\n\tif (write)\n\t\treq->in.argpages = 1;\n\telse\n\t\treq->out.argpages = 1;\n\n\t*nbytesp = nbytes;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "count",
            "nmax"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "minix_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/file.c",
          "lines": "26-48",
          "snippet": "static int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"minix.h\"\n\nstatic int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_sync_writes",
          "args": [
            "inode"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_sync_writes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "391-395",
          "snippet": "static void fuse_sync_writes(struct inode *inode)\n{\n\tfuse_set_nowrite(inode);\n\tfuse_release_nowrite(inode);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_sync_writes(struct inode *inode)\n{\n\tfuse_set_nowrite(inode);\n\tfuse_release_nowrite(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_range_is_writeback",
          "args": [
            "inode",
            "idx_from",
            "idx_to"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_range_is_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "338-361",
          "snippet": "static bool fuse_range_is_writeback(struct inode *inode, pgoff_t idx_from,\n\t\t\t\t   pgoff_t idx_to)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_req *req;\n\tbool found = false;\n\n\tspin_lock(&fc->lock);\n\tlist_for_each_entry(req, &fi->writepages, writepages_entry) {\n\t\tpgoff_t curr_index;\n\n\t\tBUG_ON(req->inode != inode);\n\t\tcurr_index = req->misc.write.in.offset >> PAGE_CACHE_SHIFT;\n\t\tif (idx_from < curr_index + req->num_pages &&\n\t\t    curr_index <= idx_to) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn found;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic bool fuse_range_is_writeback(struct inode *inode, pgoff_t idx_from,\n\t\t\t\t   pgoff_t idx_to)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_req *req;\n\tbool found = false;\n\n\tspin_lock(&fc->lock);\n\tlist_for_each_entry(req, &fi->writepages, writepages_entry) {\n\t\tpgoff_t curr_index;\n\n\t\tBUG_ON(req->inode != inode);\n\t\tcurr_index = req->misc.write.in.offset >> PAGE_CACHE_SHIFT;\n\t\tif (idx_from < curr_index + req->num_pages &&\n\t\t    curr_index <= idx_to) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_direct_io(struct fuse_io_priv *io, struct iov_iter *iter,\n\t\t       loff_t *ppos, int flags)\n{\n\tint write = flags & FUSE_DIO_WRITE;\n\tint cuse = flags & FUSE_DIO_CUSE;\n\tstruct file *file = io->file;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tsize_t nmax = write ? fc->max_write : fc->max_read;\n\tloff_t pos = *ppos;\n\tsize_t count = iov_iter_count(iter);\n\tpgoff_t idx_from = pos >> PAGE_CACHE_SHIFT;\n\tpgoff_t idx_to = (pos + count - 1) >> PAGE_CACHE_SHIFT;\n\tssize_t res = 0;\n\tstruct fuse_req *req;\n\n\tif (io->async)\n\t\treq = fuse_get_req_for_background(fc, fuse_iter_npages(iter));\n\telse\n\t\treq = fuse_get_req(fc, fuse_iter_npages(iter));\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tif (!cuse && fuse_range_is_writeback(inode, idx_from, idx_to)) {\n\t\tif (!write)\n\t\t\tmutex_lock(&inode->i_mutex);\n\t\tfuse_sync_writes(inode);\n\t\tif (!write)\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\n\twhile (count) {\n\t\tsize_t nres;\n\t\tfl_owner_t owner = current->files;\n\t\tsize_t nbytes = min(count, nmax);\n\t\tint err = fuse_get_user_pages(req, iter, &nbytes, write);\n\t\tif (err) {\n\t\t\tres = err;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (write)\n\t\t\tnres = fuse_send_write(req, io, pos, nbytes, owner);\n\t\telse\n\t\t\tnres = fuse_send_read(req, io, pos, nbytes, owner);\n\n\t\tif (!io->async)\n\t\t\tfuse_release_user_pages(req, !write);\n\t\tif (req->out.h.error) {\n\t\t\tif (!res)\n\t\t\t\tres = req->out.h.error;\n\t\t\tbreak;\n\t\t} else if (nres > nbytes) {\n\t\t\tres = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tcount -= nres;\n\t\tres += nres;\n\t\tpos += nres;\n\t\tif (nres != nbytes)\n\t\t\tbreak;\n\t\tif (count) {\n\t\t\tfuse_put_request(fc, req);\n\t\t\tif (io->async)\n\t\t\t\treq = fuse_get_req_for_background(fc,\n\t\t\t\t\tfuse_iter_npages(iter));\n\t\t\telse\n\t\t\t\treq = fuse_get_req(fc, fuse_iter_npages(iter));\n\t\t\tif (IS_ERR(req))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (!IS_ERR(req))\n\t\tfuse_put_request(fc, req);\n\tif (res > 0)\n\t\t*ppos = pos;\n\n\treturn res;\n}"
  },
  {
    "function_name": "fuse_iter_npages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1293-1296",
    "snippet": "static inline int fuse_iter_npages(const struct iov_iter *ii_p)\n{\n\treturn iov_iter_npages(ii_p, FUSE_MAX_PAGES_PER_REQ);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iov_iter_npages",
          "args": [
            "ii_p",
            "FUSE_MAX_PAGES_PER_REQ"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline int fuse_iter_npages(const struct iov_iter *ii_p)\n{\n\treturn iov_iter_npages(ii_p, FUSE_MAX_PAGES_PER_REQ);\n}"
  },
  {
    "function_name": "fuse_get_user_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1238-1291",
    "snippet": "static int fuse_get_user_pages(struct fuse_req *req, struct iov_iter *ii,\n\t\t\t       size_t *nbytesp, int write)\n{\n\tsize_t nbytes = 0;  /* # bytes already packed in req */\n\n\t/* Special case for kernel I/O: can copy directly into the buffer */\n\tif (ii->type & ITER_KVEC) {\n\t\tunsigned long user_addr = fuse_get_user_addr(ii);\n\t\tsize_t frag_size = fuse_get_frag_size(ii, *nbytesp);\n\n\t\tif (write)\n\t\t\treq->in.args[1].value = (void *) user_addr;\n\t\telse\n\t\t\treq->out.args[0].value = (void *) user_addr;\n\n\t\tiov_iter_advance(ii, frag_size);\n\t\t*nbytesp = frag_size;\n\t\treturn 0;\n\t}\n\n\twhile (nbytes < *nbytesp && req->num_pages < req->max_pages) {\n\t\tunsigned npages;\n\t\tsize_t start;\n\t\tssize_t ret = iov_iter_get_pages(ii,\n\t\t\t\t\t&req->pages[req->num_pages],\n\t\t\t\t\t*nbytesp - nbytes,\n\t\t\t\t\treq->max_pages - req->num_pages,\n\t\t\t\t\t&start);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tiov_iter_advance(ii, ret);\n\t\tnbytes += ret;\n\n\t\tret += start;\n\t\tnpages = (ret + PAGE_SIZE - 1) / PAGE_SIZE;\n\n\t\treq->page_descs[req->num_pages].offset = start;\n\t\tfuse_page_descs_length_init(req, req->num_pages, npages);\n\n\t\treq->num_pages += npages;\n\t\treq->page_descs[req->num_pages - 1].length -=\n\t\t\t(PAGE_SIZE - ret) & (PAGE_SIZE - 1);\n\t}\n\n\tif (write)\n\t\treq->in.argpages = 1;\n\telse\n\t\treq->out.argpages = 1;\n\n\t*nbytesp = nbytes;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_page_descs_length_init",
          "args": [
            "req",
            "req->num_pages",
            "npages"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_page_descs_length_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1217-1225",
          "snippet": "static inline void fuse_page_descs_length_init(struct fuse_req *req,\n\t\tunsigned index, unsigned nr_pages)\n{\n\tint i;\n\n\tfor (i = index; i < index + nr_pages; i++)\n\t\treq->page_descs[i].length = PAGE_SIZE -\n\t\t\treq->page_descs[i].offset;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline void fuse_page_descs_length_init(struct fuse_req *req,\n\t\tunsigned index, unsigned nr_pages)\n{\n\tint i;\n\n\tfor (i = index; i < index + nr_pages; i++)\n\t\treq->page_descs[i].length = PAGE_SIZE -\n\t\t\treq->page_descs[i].offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_advance",
          "args": [
            "ii",
            "ret"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_get_pages",
          "args": [
            "ii",
            "&req->pages[req->num_pages]",
            "*nbytesp - nbytes",
            "req->max_pages - req->num_pages",
            "&start"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_advance",
          "args": [
            "ii",
            "frag_size"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_get_frag_size",
          "args": [
            "ii",
            "*nbytesp"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_frag_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1232-1236",
          "snippet": "static inline size_t fuse_get_frag_size(const struct iov_iter *ii,\n\t\t\t\t\tsize_t max_size)\n{\n\treturn min(iov_iter_single_seg_count(ii), max_size);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline size_t fuse_get_frag_size(const struct iov_iter *ii,\n\t\t\t\t\tsize_t max_size)\n{\n\treturn min(iov_iter_single_seg_count(ii), max_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_get_user_addr",
          "args": [
            "ii"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_user_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1227-1230",
          "snippet": "static inline unsigned long fuse_get_user_addr(const struct iov_iter *ii)\n{\n\treturn (unsigned long)ii->iov->iov_base + ii->iov_offset;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline unsigned long fuse_get_user_addr(const struct iov_iter *ii)\n{\n\treturn (unsigned long)ii->iov->iov_base + ii->iov_offset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_get_user_pages(struct fuse_req *req, struct iov_iter *ii,\n\t\t\t       size_t *nbytesp, int write)\n{\n\tsize_t nbytes = 0;  /* # bytes already packed in req */\n\n\t/* Special case for kernel I/O: can copy directly into the buffer */\n\tif (ii->type & ITER_KVEC) {\n\t\tunsigned long user_addr = fuse_get_user_addr(ii);\n\t\tsize_t frag_size = fuse_get_frag_size(ii, *nbytesp);\n\n\t\tif (write)\n\t\t\treq->in.args[1].value = (void *) user_addr;\n\t\telse\n\t\t\treq->out.args[0].value = (void *) user_addr;\n\n\t\tiov_iter_advance(ii, frag_size);\n\t\t*nbytesp = frag_size;\n\t\treturn 0;\n\t}\n\n\twhile (nbytes < *nbytesp && req->num_pages < req->max_pages) {\n\t\tunsigned npages;\n\t\tsize_t start;\n\t\tssize_t ret = iov_iter_get_pages(ii,\n\t\t\t\t\t&req->pages[req->num_pages],\n\t\t\t\t\t*nbytesp - nbytes,\n\t\t\t\t\treq->max_pages - req->num_pages,\n\t\t\t\t\t&start);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tiov_iter_advance(ii, ret);\n\t\tnbytes += ret;\n\n\t\tret += start;\n\t\tnpages = (ret + PAGE_SIZE - 1) / PAGE_SIZE;\n\n\t\treq->page_descs[req->num_pages].offset = start;\n\t\tfuse_page_descs_length_init(req, req->num_pages, npages);\n\n\t\treq->num_pages += npages;\n\t\treq->page_descs[req->num_pages - 1].length -=\n\t\t\t(PAGE_SIZE - ret) & (PAGE_SIZE - 1);\n\t}\n\n\tif (write)\n\t\treq->in.argpages = 1;\n\telse\n\t\treq->out.argpages = 1;\n\n\t*nbytesp = nbytes;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fuse_get_frag_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1232-1236",
    "snippet": "static inline size_t fuse_get_frag_size(const struct iov_iter *ii,\n\t\t\t\t\tsize_t max_size)\n{\n\treturn min(iov_iter_single_seg_count(ii), max_size);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "iov_iter_single_seg_count(ii)",
            "max_size"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "minix_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/file.c",
          "lines": "26-48",
          "snippet": "static int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"minix.h\"\n\nstatic int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_single_seg_count",
          "args": [
            "ii"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline size_t fuse_get_frag_size(const struct iov_iter *ii,\n\t\t\t\t\tsize_t max_size)\n{\n\treturn min(iov_iter_single_seg_count(ii), max_size);\n}"
  },
  {
    "function_name": "fuse_get_user_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1227-1230",
    "snippet": "static inline unsigned long fuse_get_user_addr(const struct iov_iter *ii)\n{\n\treturn (unsigned long)ii->iov->iov_base + ii->iov_offset;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline unsigned long fuse_get_user_addr(const struct iov_iter *ii)\n{\n\treturn (unsigned long)ii->iov->iov_base + ii->iov_offset;\n}"
  },
  {
    "function_name": "fuse_page_descs_length_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1217-1225",
    "snippet": "static inline void fuse_page_descs_length_init(struct fuse_req *req,\n\t\tunsigned index, unsigned nr_pages)\n{\n\tint i;\n\n\tfor (i = index; i < index + nr_pages; i++)\n\t\treq->page_descs[i].length = PAGE_SIZE -\n\t\t\treq->page_descs[i].offset;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline void fuse_page_descs_length_init(struct fuse_req *req,\n\t\tunsigned index, unsigned nr_pages)\n{\n\tint i;\n\n\tfor (i = index; i < index + nr_pages; i++)\n\t\treq->page_descs[i].length = PAGE_SIZE -\n\t\t\treq->page_descs[i].offset;\n}"
  },
  {
    "function_name": "fuse_file_write_iter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1138-1215",
    "snippet": "static ssize_t fuse_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tsize_t count = iov_iter_count(from);\n\tssize_t written = 0;\n\tssize_t written_buffered = 0;\n\tstruct inode *inode = mapping->host;\n\tssize_t err;\n\tloff_t endbyte = 0;\n\tloff_t pos = iocb->ki_pos;\n\n\tif (get_fuse_conn(inode)->writeback_cache) {\n\t\t/* Update size (EOF optimization) and mode (SUID clearing) */\n\t\terr = fuse_update_attributes(mapping->host, NULL, file, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn generic_file_write_iter(iocb, from);\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/* We can write back this queue in page reclaim */\n\tcurrent->backing_dev_info = inode_to_bdi(inode);\n\n\terr = generic_write_checks(file, &pos, &count, S_ISBLK(inode->i_mode));\n\tif (err)\n\t\tgoto out;\n\n\tif (count == 0)\n\t\tgoto out;\n\n\tiov_iter_truncate(from, count);\n\terr = file_remove_suid(file);\n\tif (err)\n\t\tgoto out;\n\n\terr = file_update_time(file);\n\tif (err)\n\t\tgoto out;\n\n\tif (file->f_flags & O_DIRECT) {\n\t\twritten = generic_file_direct_write(iocb, from, pos);\n\t\tif (written < 0 || !iov_iter_count(from))\n\t\t\tgoto out;\n\n\t\tpos += written;\n\n\t\twritten_buffered = fuse_perform_write(file, mapping, from, pos);\n\t\tif (written_buffered < 0) {\n\t\t\terr = written_buffered;\n\t\t\tgoto out;\n\t\t}\n\t\tendbyte = pos + written_buffered - 1;\n\n\t\terr = filemap_write_and_wait_range(file->f_mapping, pos,\n\t\t\t\t\t\t   endbyte);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tinvalidate_mapping_pages(file->f_mapping,\n\t\t\t\t\t pos >> PAGE_CACHE_SHIFT,\n\t\t\t\t\t endbyte >> PAGE_CACHE_SHIFT);\n\n\t\twritten += written_buffered;\n\t\tiocb->ki_pos = pos + written_buffered;\n\t} else {\n\t\twritten = fuse_perform_write(file, mapping, from, pos);\n\t\tif (written >= 0)\n\t\t\tiocb->ki_pos = pos + written;\n\t}\nout:\n\tcurrent->backing_dev_info = NULL;\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn written ? written : err;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_perform_write",
          "args": [
            "file",
            "mapping",
            "from",
            "pos"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_perform_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1081-1136",
          "snippet": "static ssize_t fuse_perform_write(struct file *file,\n\t\t\t\t  struct address_space *mapping,\n\t\t\t\t  struct iov_iter *ii, loff_t pos)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tint err = 0;\n\tssize_t res = 0;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tif (inode->i_size < pos + iov_iter_count(ii))\n\t\tset_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\n\tdo {\n\t\tstruct fuse_req *req;\n\t\tssize_t count;\n\t\tunsigned nr_pages = fuse_wr_pages(pos, iov_iter_count(ii));\n\n\t\treq = fuse_get_req(fc, nr_pages);\n\t\tif (IS_ERR(req)) {\n\t\t\terr = PTR_ERR(req);\n\t\t\tbreak;\n\t\t}\n\n\t\tcount = fuse_fill_write_pages(req, mapping, ii, pos);\n\t\tif (count <= 0) {\n\t\t\terr = count;\n\t\t} else {\n\t\t\tsize_t num_written;\n\n\t\t\tnum_written = fuse_send_write_pages(req, file, inode,\n\t\t\t\t\t\t\t    pos, count);\n\t\t\terr = req->out.h.error;\n\t\t\tif (!err) {\n\t\t\t\tres += num_written;\n\t\t\t\tpos += num_written;\n\n\t\t\t\t/* break out of the loop on short write */\n\t\t\t\tif (num_written != count)\n\t\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t\tfuse_put_request(fc, req);\n\t} while (!err && iov_iter_count(ii));\n\n\tif (res > 0)\n\t\tfuse_write_update_size(inode, pos);\n\n\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\tfuse_invalidate_attr(inode);\n\n\treturn res > 0 ? res : err;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_perform_write(struct file *file,\n\t\t\t\t  struct address_space *mapping,\n\t\t\t\t  struct iov_iter *ii, loff_t pos)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tint err = 0;\n\tssize_t res = 0;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tif (inode->i_size < pos + iov_iter_count(ii))\n\t\tset_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\n\tdo {\n\t\tstruct fuse_req *req;\n\t\tssize_t count;\n\t\tunsigned nr_pages = fuse_wr_pages(pos, iov_iter_count(ii));\n\n\t\treq = fuse_get_req(fc, nr_pages);\n\t\tif (IS_ERR(req)) {\n\t\t\terr = PTR_ERR(req);\n\t\t\tbreak;\n\t\t}\n\n\t\tcount = fuse_fill_write_pages(req, mapping, ii, pos);\n\t\tif (count <= 0) {\n\t\t\terr = count;\n\t\t} else {\n\t\t\tsize_t num_written;\n\n\t\t\tnum_written = fuse_send_write_pages(req, file, inode,\n\t\t\t\t\t\t\t    pos, count);\n\t\t\terr = req->out.h.error;\n\t\t\tif (!err) {\n\t\t\t\tres += num_written;\n\t\t\t\tpos += num_written;\n\n\t\t\t\t/* break out of the loop on short write */\n\t\t\t\tif (num_written != count)\n\t\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t\tfuse_put_request(fc, req);\n\t} while (!err && iov_iter_count(ii));\n\n\tif (res > 0)\n\t\tfuse_write_update_size(inode, pos);\n\n\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\tfuse_invalidate_attr(inode);\n\n\treturn res > 0 ? res : err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_mapping_pages",
          "args": [
            "file->f_mapping",
            "pos >> PAGE_CACHE_SHIFT",
            "endbyte >> PAGE_CACHE_SHIFT"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "file->f_mapping",
            "pos",
            "endbyte"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_file_direct_write",
          "args": [
            "iocb",
            "from",
            "pos"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_update_time",
          "args": [
            "file"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "file_update_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1716-1748",
          "snippet": "int file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_remove_suid",
          "args": [
            "file"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "file_remove_suid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1675-1700",
          "snippet": "int file_remove_suid(struct file *file)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tint killsuid;\n\tint killpriv;\n\tint error = 0;\n\n\t/* Fast path for nothing security related */\n\tif (IS_NOSEC(inode))\n\t\treturn 0;\n\n\tkillsuid = should_remove_suid(dentry);\n\tkillpriv = security_inode_need_killpriv(dentry);\n\n\tif (killpriv < 0)\n\t\treturn killpriv;\n\tif (killpriv)\n\t\terror = security_inode_killpriv(dentry);\n\tif (!error && killsuid)\n\t\terror = __remove_suid(dentry, killsuid);\n\tif (!error && (inode->i_sb->s_flags & MS_NOSEC))\n\t\tinode->i_flags |= S_NOSEC;\n\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_remove_suid(struct file *file)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tint killsuid;\n\tint killpriv;\n\tint error = 0;\n\n\t/* Fast path for nothing security related */\n\tif (IS_NOSEC(inode))\n\t\treturn 0;\n\n\tkillsuid = should_remove_suid(dentry);\n\tkillpriv = security_inode_need_killpriv(dentry);\n\n\tif (killpriv < 0)\n\t\treturn killpriv;\n\tif (killpriv)\n\t\terror = security_inode_killpriv(dentry);\n\tif (!error && killsuid)\n\t\terror = __remove_suid(dentry, killsuid);\n\tif (!error && (inode->i_sb->s_flags & MS_NOSEC))\n\t\tinode->i_flags |= S_NOSEC;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_truncate",
          "args": [
            "from",
            "count"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_write_checks",
          "args": [
            "file",
            "&pos",
            "&count",
            "S_ISBLK(inode->i_mode)"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "inode"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_bdi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "69-82",
          "snippet": "struct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_file_write_iter",
          "args": [
            "iocb",
            "from"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_update_attributes",
          "args": [
            "mapping->host",
            "NULL",
            "file",
            "NULL"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_update_attributes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "909-933",
          "snippet": "int fuse_update_attributes(struct inode *inode, struct kstat *stat,\n\t\t\t   struct file *file, bool *refreshed)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tint err;\n\tbool r;\n\n\tif (time_before64(fi->i_time, get_jiffies_64())) {\n\t\tr = true;\n\t\terr = fuse_do_getattr(inode, stat, file);\n\t} else {\n\t\tr = false;\n\t\terr = 0;\n\t\tif (stat) {\n\t\t\tgeneric_fillattr(inode, stat);\n\t\t\tstat->mode = fi->orig_i_mode;\n\t\t\tstat->ino = fi->orig_ino;\n\t\t}\n\t}\n\n\tif (refreshed != NULL)\n\t\t*refreshed = r;\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_update_attributes(struct inode *inode, struct kstat *stat,\n\t\t\t   struct file *file, bool *refreshed)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tint err;\n\tbool r;\n\n\tif (time_before64(fi->i_time, get_jiffies_64())) {\n\t\tr = true;\n\t\terr = fuse_do_getattr(inode, stat, file);\n\t} else {\n\t\tr = false;\n\t\terr = 0;\n\t\tif (stat) {\n\t\t\tgeneric_fillattr(inode, stat);\n\t\t\tstat->mode = fi->orig_i_mode;\n\t\t\tstat->ino = fi->orig_ino;\n\t\t}\n\t}\n\n\tif (refreshed != NULL)\n\t\t*refreshed = r;\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tsize_t count = iov_iter_count(from);\n\tssize_t written = 0;\n\tssize_t written_buffered = 0;\n\tstruct inode *inode = mapping->host;\n\tssize_t err;\n\tloff_t endbyte = 0;\n\tloff_t pos = iocb->ki_pos;\n\n\tif (get_fuse_conn(inode)->writeback_cache) {\n\t\t/* Update size (EOF optimization) and mode (SUID clearing) */\n\t\terr = fuse_update_attributes(mapping->host, NULL, file, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn generic_file_write_iter(iocb, from);\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/* We can write back this queue in page reclaim */\n\tcurrent->backing_dev_info = inode_to_bdi(inode);\n\n\terr = generic_write_checks(file, &pos, &count, S_ISBLK(inode->i_mode));\n\tif (err)\n\t\tgoto out;\n\n\tif (count == 0)\n\t\tgoto out;\n\n\tiov_iter_truncate(from, count);\n\terr = file_remove_suid(file);\n\tif (err)\n\t\tgoto out;\n\n\terr = file_update_time(file);\n\tif (err)\n\t\tgoto out;\n\n\tif (file->f_flags & O_DIRECT) {\n\t\twritten = generic_file_direct_write(iocb, from, pos);\n\t\tif (written < 0 || !iov_iter_count(from))\n\t\t\tgoto out;\n\n\t\tpos += written;\n\n\t\twritten_buffered = fuse_perform_write(file, mapping, from, pos);\n\t\tif (written_buffered < 0) {\n\t\t\terr = written_buffered;\n\t\t\tgoto out;\n\t\t}\n\t\tendbyte = pos + written_buffered - 1;\n\n\t\terr = filemap_write_and_wait_range(file->f_mapping, pos,\n\t\t\t\t\t\t   endbyte);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tinvalidate_mapping_pages(file->f_mapping,\n\t\t\t\t\t pos >> PAGE_CACHE_SHIFT,\n\t\t\t\t\t endbyte >> PAGE_CACHE_SHIFT);\n\n\t\twritten += written_buffered;\n\t\tiocb->ki_pos = pos + written_buffered;\n\t} else {\n\t\twritten = fuse_perform_write(file, mapping, from, pos);\n\t\tif (written >= 0)\n\t\t\tiocb->ki_pos = pos + written;\n\t}\nout:\n\tcurrent->backing_dev_info = NULL;\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn written ? written : err;\n}"
  },
  {
    "function_name": "fuse_perform_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1081-1136",
    "snippet": "static ssize_t fuse_perform_write(struct file *file,\n\t\t\t\t  struct address_space *mapping,\n\t\t\t\t  struct iov_iter *ii, loff_t pos)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tint err = 0;\n\tssize_t res = 0;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tif (inode->i_size < pos + iov_iter_count(ii))\n\t\tset_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\n\tdo {\n\t\tstruct fuse_req *req;\n\t\tssize_t count;\n\t\tunsigned nr_pages = fuse_wr_pages(pos, iov_iter_count(ii));\n\n\t\treq = fuse_get_req(fc, nr_pages);\n\t\tif (IS_ERR(req)) {\n\t\t\terr = PTR_ERR(req);\n\t\t\tbreak;\n\t\t}\n\n\t\tcount = fuse_fill_write_pages(req, mapping, ii, pos);\n\t\tif (count <= 0) {\n\t\t\terr = count;\n\t\t} else {\n\t\t\tsize_t num_written;\n\n\t\t\tnum_written = fuse_send_write_pages(req, file, inode,\n\t\t\t\t\t\t\t    pos, count);\n\t\t\terr = req->out.h.error;\n\t\t\tif (!err) {\n\t\t\t\tres += num_written;\n\t\t\t\tpos += num_written;\n\n\t\t\t\t/* break out of the loop on short write */\n\t\t\t\tif (num_written != count)\n\t\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t\tfuse_put_request(fc, req);\n\t} while (!err && iov_iter_count(ii));\n\n\tif (res > 0)\n\t\tfuse_write_update_size(inode, pos);\n\n\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\tfuse_invalidate_attr(inode);\n\n\treturn res > 0 ? res : err;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_invalidate_attr",
          "args": [
            "inode"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "110-113",
          "snippet": "void fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "FUSE_I_SIZE_UNSTABLE",
            "&fi->state"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_write_update_size",
          "args": [
            "inode",
            "pos"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_write_update_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "957-972",
          "snippet": "bool fuse_write_update_size(struct inode *inode, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tbool ret = false;\n\n\tspin_lock(&fc->lock);\n\tfi->attr_version = ++fc->attr_version;\n\tif (pos > inode->i_size) {\n\t\ti_size_write(inode, pos);\n\t\tret = true;\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nbool fuse_write_update_size(struct inode *inode, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tbool ret = false;\n\n\tspin_lock(&fc->lock);\n\tfi->attr_version = ++fc->attr_version;\n\tif (pos > inode->i_size) {\n\t\ti_size_write(inode, pos);\n\t\tret = true;\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "ii"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_put_request",
          "args": [
            "fc",
            "req"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "277-299",
          "snippet": "void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_send_write_pages",
          "args": [
            "req",
            "file",
            "inode",
            "pos",
            "count"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_send_write_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "974-1007",
          "snippet": "static size_t fuse_send_write_pages(struct fuse_req *req, struct file *file,\n\t\t\t\t    struct inode *inode, loff_t pos,\n\t\t\t\t    size_t count)\n{\n\tsize_t res;\n\tunsigned offset;\n\tunsigned i;\n\tstruct fuse_io_priv io = { .async = 0, .file = file };\n\n\tfor (i = 0; i < req->num_pages; i++)\n\t\tfuse_wait_on_page_writeback(inode, req->pages[i]->index);\n\n\tres = fuse_send_write(req, &io, pos, count, NULL);\n\n\toffset = req->page_descs[0].offset;\n\tcount = res;\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tstruct page *page = req->pages[i];\n\n\t\tif (!req->out.h.error && !offset && count >= PAGE_CACHE_SIZE)\n\t\t\tSetPageUptodate(page);\n\n\t\tif (count > PAGE_CACHE_SIZE - offset)\n\t\t\tcount -= PAGE_CACHE_SIZE - offset;\n\t\telse\n\t\t\tcount = 0;\n\t\toffset = 0;\n\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic size_t fuse_send_write_pages(struct fuse_req *req, struct file *file,\n\t\t\t\t    struct inode *inode, loff_t pos,\n\t\t\t\t    size_t count)\n{\n\tsize_t res;\n\tunsigned offset;\n\tunsigned i;\n\tstruct fuse_io_priv io = { .async = 0, .file = file };\n\n\tfor (i = 0; i < req->num_pages; i++)\n\t\tfuse_wait_on_page_writeback(inode, req->pages[i]->index);\n\n\tres = fuse_send_write(req, &io, pos, count, NULL);\n\n\toffset = req->page_descs[0].offset;\n\tcount = res;\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tstruct page *page = req->pages[i];\n\n\t\tif (!req->out.h.error && !offset && count >= PAGE_CACHE_SIZE)\n\t\t\tSetPageUptodate(page);\n\n\t\tif (count > PAGE_CACHE_SIZE - offset)\n\t\t\tcount -= PAGE_CACHE_SIZE - offset;\n\t\telse\n\t\t\tcount = 0;\n\t\toffset = 0;\n\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_fill_write_pages",
          "args": [
            "req",
            "mapping",
            "ii",
            "pos"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_fill_write_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1009-1071",
          "snippet": "static ssize_t fuse_fill_write_pages(struct fuse_req *req,\n\t\t\t       struct address_space *mapping,\n\t\t\t       struct iov_iter *ii, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(mapping->host);\n\tunsigned offset = pos & (PAGE_CACHE_SIZE - 1);\n\tsize_t count = 0;\n\tint err;\n\n\treq->in.argpages = 1;\n\treq->page_descs[0].offset = offset;\n\n\tdo {\n\t\tsize_t tmp;\n\t\tstruct page *page;\n\t\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\t\tsize_t bytes = min_t(size_t, PAGE_CACHE_SIZE - offset,\n\t\t\t\t     iov_iter_count(ii));\n\n\t\tbytes = min_t(size_t, bytes, fc->max_write - count);\n\n again:\n\t\terr = -EFAULT;\n\t\tif (iov_iter_fault_in_readable(ii, bytes))\n\t\t\tbreak;\n\n\t\terr = -ENOMEM;\n\t\tpage = grab_cache_page_write_begin(mapping, index, 0);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\n\t\ttmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);\n\t\tflush_dcache_page(page);\n\n\t\tif (!tmp) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbytes = min(bytes, iov_iter_single_seg_count(ii));\n\t\t\tgoto again;\n\t\t}\n\n\t\terr = 0;\n\t\treq->pages[req->num_pages] = page;\n\t\treq->page_descs[req->num_pages].length = tmp;\n\t\treq->num_pages++;\n\n\t\tiov_iter_advance(ii, tmp);\n\t\tcount += tmp;\n\t\tpos += tmp;\n\t\toffset += tmp;\n\t\tif (offset == PAGE_CACHE_SIZE)\n\t\t\toffset = 0;\n\n\t\tif (!fc->big_writes)\n\t\t\tbreak;\n\t} while (iov_iter_count(ii) && count < fc->max_write &&\n\t\t req->num_pages < req->max_pages && offset == 0);\n\n\treturn count > 0 ? count : err;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_fill_write_pages(struct fuse_req *req,\n\t\t\t       struct address_space *mapping,\n\t\t\t       struct iov_iter *ii, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(mapping->host);\n\tunsigned offset = pos & (PAGE_CACHE_SIZE - 1);\n\tsize_t count = 0;\n\tint err;\n\n\treq->in.argpages = 1;\n\treq->page_descs[0].offset = offset;\n\n\tdo {\n\t\tsize_t tmp;\n\t\tstruct page *page;\n\t\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\t\tsize_t bytes = min_t(size_t, PAGE_CACHE_SIZE - offset,\n\t\t\t\t     iov_iter_count(ii));\n\n\t\tbytes = min_t(size_t, bytes, fc->max_write - count);\n\n again:\n\t\terr = -EFAULT;\n\t\tif (iov_iter_fault_in_readable(ii, bytes))\n\t\t\tbreak;\n\n\t\terr = -ENOMEM;\n\t\tpage = grab_cache_page_write_begin(mapping, index, 0);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\n\t\ttmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);\n\t\tflush_dcache_page(page);\n\n\t\tif (!tmp) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbytes = min(bytes, iov_iter_single_seg_count(ii));\n\t\t\tgoto again;\n\t\t}\n\n\t\terr = 0;\n\t\treq->pages[req->num_pages] = page;\n\t\treq->page_descs[req->num_pages].length = tmp;\n\t\treq->num_pages++;\n\n\t\tiov_iter_advance(ii, tmp);\n\t\tcount += tmp;\n\t\tpos += tmp;\n\t\toffset += tmp;\n\t\tif (offset == PAGE_CACHE_SIZE)\n\t\t\toffset = 0;\n\n\t\tif (!fc->big_writes)\n\t\t\tbreak;\n\t} while (iov_iter_count(ii) && count < fc->max_write &&\n\t\t req->num_pages < req->max_pages && offset == 0);\n\n\treturn count > 0 ? count : err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_get_req",
          "args": [
            "fc",
            "nr_pages"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_req_nofail_nopages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "258-275",
          "snippet": "struct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc,\n\t\t\t\t\t     struct file *file)\n{\n\tstruct fuse_req *req;\n\n\tatomic_inc(&fc->num_waiting);\n\twait_event(fc->blocked_waitq, fc->initialized);\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\treq = fuse_request_alloc(0);\n\tif (!req)\n\t\treq = get_reserved_req(fc, file);\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = 0;\n\treturn req;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstruct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc,\n\t\t\t\t\t     struct file *file)\n{\n\tstruct fuse_req *req;\n\n\tatomic_inc(&fc->num_waiting);\n\twait_event(fc->blocked_waitq, fc->initialized);\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\treq = fuse_request_alloc(0);\n\tif (!req)\n\t\treq = get_reserved_req(fc, file);\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = 0;\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_wr_pages",
          "args": [
            "pos",
            "iov_iter_count(ii)"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_wr_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1073-1079",
          "snippet": "static inline unsigned fuse_wr_pages(loff_t pos, size_t len)\n{\n\treturn min_t(unsigned,\n\t\t     ((pos + len - 1) >> PAGE_CACHE_SHIFT) -\n\t\t     (pos >> PAGE_CACHE_SHIFT) + 1,\n\t\t     FUSE_MAX_PAGES_PER_REQ);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline unsigned fuse_wr_pages(loff_t pos, size_t len)\n{\n\treturn min_t(unsigned,\n\t\t     ((pos + len - 1) >> PAGE_CACHE_SHIFT) -\n\t\t     (pos >> PAGE_CACHE_SHIFT) + 1,\n\t\t     FUSE_MAX_PAGES_PER_REQ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "ii"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "FUSE_I_SIZE_UNSTABLE",
            "&fi->state"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "ii"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_perform_write(struct file *file,\n\t\t\t\t  struct address_space *mapping,\n\t\t\t\t  struct iov_iter *ii, loff_t pos)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tint err = 0;\n\tssize_t res = 0;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tif (inode->i_size < pos + iov_iter_count(ii))\n\t\tset_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\n\tdo {\n\t\tstruct fuse_req *req;\n\t\tssize_t count;\n\t\tunsigned nr_pages = fuse_wr_pages(pos, iov_iter_count(ii));\n\n\t\treq = fuse_get_req(fc, nr_pages);\n\t\tif (IS_ERR(req)) {\n\t\t\terr = PTR_ERR(req);\n\t\t\tbreak;\n\t\t}\n\n\t\tcount = fuse_fill_write_pages(req, mapping, ii, pos);\n\t\tif (count <= 0) {\n\t\t\terr = count;\n\t\t} else {\n\t\t\tsize_t num_written;\n\n\t\t\tnum_written = fuse_send_write_pages(req, file, inode,\n\t\t\t\t\t\t\t    pos, count);\n\t\t\terr = req->out.h.error;\n\t\t\tif (!err) {\n\t\t\t\tres += num_written;\n\t\t\t\tpos += num_written;\n\n\t\t\t\t/* break out of the loop on short write */\n\t\t\t\tif (num_written != count)\n\t\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t\tfuse_put_request(fc, req);\n\t} while (!err && iov_iter_count(ii));\n\n\tif (res > 0)\n\t\tfuse_write_update_size(inode, pos);\n\n\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\tfuse_invalidate_attr(inode);\n\n\treturn res > 0 ? res : err;\n}"
  },
  {
    "function_name": "fuse_wr_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1073-1079",
    "snippet": "static inline unsigned fuse_wr_pages(loff_t pos, size_t len)\n{\n\treturn min_t(unsigned,\n\t\t     ((pos + len - 1) >> PAGE_CACHE_SHIFT) -\n\t\t     (pos >> PAGE_CACHE_SHIFT) + 1,\n\t\t     FUSE_MAX_PAGES_PER_REQ);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsigned",
            "((pos + len - 1) >> PAGE_CACHE_SHIFT) -\n\t\t     (pos >> PAGE_CACHE_SHIFT) + 1",
            "FUSE_MAX_PAGES_PER_REQ"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline unsigned fuse_wr_pages(loff_t pos, size_t len)\n{\n\treturn min_t(unsigned,\n\t\t     ((pos + len - 1) >> PAGE_CACHE_SHIFT) -\n\t\t     (pos >> PAGE_CACHE_SHIFT) + 1,\n\t\t     FUSE_MAX_PAGES_PER_REQ);\n}"
  },
  {
    "function_name": "fuse_fill_write_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "1009-1071",
    "snippet": "static ssize_t fuse_fill_write_pages(struct fuse_req *req,\n\t\t\t       struct address_space *mapping,\n\t\t\t       struct iov_iter *ii, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(mapping->host);\n\tunsigned offset = pos & (PAGE_CACHE_SIZE - 1);\n\tsize_t count = 0;\n\tint err;\n\n\treq->in.argpages = 1;\n\treq->page_descs[0].offset = offset;\n\n\tdo {\n\t\tsize_t tmp;\n\t\tstruct page *page;\n\t\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\t\tsize_t bytes = min_t(size_t, PAGE_CACHE_SIZE - offset,\n\t\t\t\t     iov_iter_count(ii));\n\n\t\tbytes = min_t(size_t, bytes, fc->max_write - count);\n\n again:\n\t\terr = -EFAULT;\n\t\tif (iov_iter_fault_in_readable(ii, bytes))\n\t\t\tbreak;\n\n\t\terr = -ENOMEM;\n\t\tpage = grab_cache_page_write_begin(mapping, index, 0);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\n\t\ttmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);\n\t\tflush_dcache_page(page);\n\n\t\tif (!tmp) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbytes = min(bytes, iov_iter_single_seg_count(ii));\n\t\t\tgoto again;\n\t\t}\n\n\t\terr = 0;\n\t\treq->pages[req->num_pages] = page;\n\t\treq->page_descs[req->num_pages].length = tmp;\n\t\treq->num_pages++;\n\n\t\tiov_iter_advance(ii, tmp);\n\t\tcount += tmp;\n\t\tpos += tmp;\n\t\toffset += tmp;\n\t\tif (offset == PAGE_CACHE_SIZE)\n\t\t\toffset = 0;\n\n\t\tif (!fc->big_writes)\n\t\t\tbreak;\n\t} while (iov_iter_count(ii) && count < fc->max_write &&\n\t\t req->num_pages < req->max_pages && offset == 0);\n\n\treturn count > 0 ? count : err;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "ii"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_advance",
          "args": [
            "ii",
            "tmp"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "bytes",
            "iov_iter_single_seg_count(ii)"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "minix_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/file.c",
          "lines": "26-48",
          "snippet": "static int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"minix.h\"\n\nstatic int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_single_seg_count",
          "args": [
            "ii"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_copy_from_user_atomic",
          "args": [
            "page",
            "ii",
            "offset",
            "bytes"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_writably_mapped",
          "args": [
            "mapping"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "mapping",
            "index",
            "0"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_fault_in_readable",
          "args": [
            "ii",
            "bytes"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "bytes",
            "fc->max_write - count"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "PAGE_CACHE_SIZE - offset",
            "iov_iter_count(ii)"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "ii"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "mapping->host"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_fill_write_pages(struct fuse_req *req,\n\t\t\t       struct address_space *mapping,\n\t\t\t       struct iov_iter *ii, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(mapping->host);\n\tunsigned offset = pos & (PAGE_CACHE_SIZE - 1);\n\tsize_t count = 0;\n\tint err;\n\n\treq->in.argpages = 1;\n\treq->page_descs[0].offset = offset;\n\n\tdo {\n\t\tsize_t tmp;\n\t\tstruct page *page;\n\t\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\t\tsize_t bytes = min_t(size_t, PAGE_CACHE_SIZE - offset,\n\t\t\t\t     iov_iter_count(ii));\n\n\t\tbytes = min_t(size_t, bytes, fc->max_write - count);\n\n again:\n\t\terr = -EFAULT;\n\t\tif (iov_iter_fault_in_readable(ii, bytes))\n\t\t\tbreak;\n\n\t\terr = -ENOMEM;\n\t\tpage = grab_cache_page_write_begin(mapping, index, 0);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\n\t\ttmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);\n\t\tflush_dcache_page(page);\n\n\t\tif (!tmp) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbytes = min(bytes, iov_iter_single_seg_count(ii));\n\t\t\tgoto again;\n\t\t}\n\n\t\terr = 0;\n\t\treq->pages[req->num_pages] = page;\n\t\treq->page_descs[req->num_pages].length = tmp;\n\t\treq->num_pages++;\n\n\t\tiov_iter_advance(ii, tmp);\n\t\tcount += tmp;\n\t\tpos += tmp;\n\t\toffset += tmp;\n\t\tif (offset == PAGE_CACHE_SIZE)\n\t\t\toffset = 0;\n\n\t\tif (!fc->big_writes)\n\t\t\tbreak;\n\t} while (iov_iter_count(ii) && count < fc->max_write &&\n\t\t req->num_pages < req->max_pages && offset == 0);\n\n\treturn count > 0 ? count : err;\n}"
  },
  {
    "function_name": "fuse_send_write_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "974-1007",
    "snippet": "static size_t fuse_send_write_pages(struct fuse_req *req, struct file *file,\n\t\t\t\t    struct inode *inode, loff_t pos,\n\t\t\t\t    size_t count)\n{\n\tsize_t res;\n\tunsigned offset;\n\tunsigned i;\n\tstruct fuse_io_priv io = { .async = 0, .file = file };\n\n\tfor (i = 0; i < req->num_pages; i++)\n\t\tfuse_wait_on_page_writeback(inode, req->pages[i]->index);\n\n\tres = fuse_send_write(req, &io, pos, count, NULL);\n\n\toffset = req->page_descs[0].offset;\n\tcount = res;\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tstruct page *page = req->pages[i];\n\n\t\tif (!req->out.h.error && !offset && count >= PAGE_CACHE_SIZE)\n\t\t\tSetPageUptodate(page);\n\n\t\tif (count > PAGE_CACHE_SIZE - offset)\n\t\t\tcount -= PAGE_CACHE_SIZE - offset;\n\t\telse\n\t\t\tcount = 0;\n\t\toffset = 0;\n\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treturn res;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_send_write",
          "args": [
            "req",
            "&io",
            "pos",
            "count",
            "NULL"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_send_write_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "974-1007",
          "snippet": "static size_t fuse_send_write_pages(struct fuse_req *req, struct file *file,\n\t\t\t\t    struct inode *inode, loff_t pos,\n\t\t\t\t    size_t count)\n{\n\tsize_t res;\n\tunsigned offset;\n\tunsigned i;\n\tstruct fuse_io_priv io = { .async = 0, .file = file };\n\n\tfor (i = 0; i < req->num_pages; i++)\n\t\tfuse_wait_on_page_writeback(inode, req->pages[i]->index);\n\n\tres = fuse_send_write(req, &io, pos, count, NULL);\n\n\toffset = req->page_descs[0].offset;\n\tcount = res;\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tstruct page *page = req->pages[i];\n\n\t\tif (!req->out.h.error && !offset && count >= PAGE_CACHE_SIZE)\n\t\t\tSetPageUptodate(page);\n\n\t\tif (count > PAGE_CACHE_SIZE - offset)\n\t\t\tcount -= PAGE_CACHE_SIZE - offset;\n\t\telse\n\t\t\tcount = 0;\n\t\toffset = 0;\n\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treturn res;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "fuse_wait_on_page_writeback",
          "args": [
            "inode",
            "req->pages[i]->index"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "374-380",
          "snippet": "static int fuse_wait_on_page_writeback(struct inode *inode, pgoff_t index)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\twait_event(fi->page_waitq, !fuse_page_is_writeback(inode, index));\n\treturn 0;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_wait_on_page_writeback(struct inode *inode, pgoff_t index)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\twait_event(fi->page_waitq, !fuse_page_is_writeback(inode, index));\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic size_t fuse_send_write_pages(struct fuse_req *req, struct file *file,\n\t\t\t\t    struct inode *inode, loff_t pos,\n\t\t\t\t    size_t count)\n{\n\tsize_t res;\n\tunsigned offset;\n\tunsigned i;\n\tstruct fuse_io_priv io = { .async = 0, .file = file };\n\n\tfor (i = 0; i < req->num_pages; i++)\n\t\tfuse_wait_on_page_writeback(inode, req->pages[i]->index);\n\n\tres = fuse_send_write(req, &io, pos, count, NULL);\n\n\toffset = req->page_descs[0].offset;\n\tcount = res;\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tstruct page *page = req->pages[i];\n\n\t\tif (!req->out.h.error && !offset && count >= PAGE_CACHE_SIZE)\n\t\t\tSetPageUptodate(page);\n\n\t\tif (count > PAGE_CACHE_SIZE - offset)\n\t\t\tcount -= PAGE_CACHE_SIZE - offset;\n\t\telse\n\t\t\tcount = 0;\n\t\toffset = 0;\n\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treturn res;\n}"
  },
  {
    "function_name": "fuse_write_update_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "957-972",
    "snippet": "bool fuse_write_update_size(struct inode *inode, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tbool ret = false;\n\n\tspin_lock(&fc->lock);\n\tfi->attr_version = ++fc->attr_version;\n\tif (pos > inode->i_size) {\n\t\ti_size_write(inode, pos);\n\t\tret = true;\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "pos"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nbool fuse_write_update_size(struct inode *inode, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tbool ret = false;\n\n\tspin_lock(&fc->lock);\n\tfi->attr_version = ++fc->attr_version;\n\tif (pos > inode->i_size) {\n\t\ti_size_write(inode, pos);\n\t\tret = true;\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fuse_send_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "935-955",
    "snippet": "static size_t fuse_send_write(struct fuse_req *req, struct fuse_io_priv *io,\n\t\t\t      loff_t pos, size_t count, fl_owner_t owner)\n{\n\tstruct file *file = io->file;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\n\tfuse_write_fill(req, ff, pos, count);\n\tinarg->flags = file->f_flags;\n\tif (owner != NULL) {\n\t\tinarg->write_flags |= FUSE_WRITE_LOCKOWNER;\n\t\tinarg->lock_owner = fuse_lock_owner_id(fc, owner);\n\t}\n\n\tif (io->async)\n\t\treturn fuse_async_req_send(fc, req, count, io);\n\n\tfuse_request_send(fc, req);\n\treturn req->misc.write.out.size;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_request_send",
          "args": [
            "fc",
            "req"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_send_background_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "647-652",
          "snippet": "void fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_async_req_send",
          "args": [
            "fc",
            "req",
            "count",
            "io"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_async_req_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "606-621",
          "snippet": "static size_t fuse_async_req_send(struct fuse_conn *fc, struct fuse_req *req,\n\t\tsize_t num_bytes, struct fuse_io_priv *io)\n{\n\tspin_lock(&io->lock);\n\tio->size += num_bytes;\n\tio->reqs++;\n\tspin_unlock(&io->lock);\n\n\treq->io = io;\n\treq->end = fuse_aio_complete_req;\n\n\t__fuse_get_request(req);\n\tfuse_request_send_background(fc, req);\n\n\treturn num_bytes;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic size_t fuse_async_req_send(struct fuse_conn *fc, struct fuse_req *req,\n\t\tsize_t num_bytes, struct fuse_io_priv *io)\n{\n\tspin_lock(&io->lock);\n\tio->size += num_bytes;\n\tio->reqs++;\n\tspin_unlock(&io->lock);\n\n\treq->io = io;\n\treq->end = fuse_aio_complete_req;\n\n\t__fuse_get_request(req);\n\tfuse_request_send_background(fc, req);\n\n\treturn num_bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_lock_owner_id",
          "args": [
            "fc",
            "owner"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lock_owner_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "314-330",
          "snippet": "u64 fuse_lock_owner_id(struct fuse_conn *fc, fl_owner_t id)\n{\n\tu32 *k = fc->scramble_key;\n\tu64 v = (unsigned long) id;\n\tu32 v0 = v;\n\tu32 v1 = v >> 32;\n\tu32 sum = 0;\n\tint i;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tv0 += ((v1 << 4 ^ v1 >> 5) + v1) ^ (sum + k[sum & 3]);\n\t\tsum += 0x9E3779B9;\n\t\tv1 += ((v0 << 4 ^ v0 >> 5) + v0) ^ (sum + k[sum>>11 & 3]);\n\t}\n\n\treturn (u64) v0 + ((u64) v1 << 32);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nu64 fuse_lock_owner_id(struct fuse_conn *fc, fl_owner_t id)\n{\n\tu32 *k = fc->scramble_key;\n\tu64 v = (unsigned long) id;\n\tu32 v0 = v;\n\tu32 v1 = v >> 32;\n\tu32 sum = 0;\n\tint i;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tv0 += ((v1 << 4 ^ v1 >> 5) + v1) ^ (sum + k[sum & 3]);\n\t\tsum += 0x9E3779B9;\n\t\tv1 += ((v0 << 4 ^ v0 >> 5) + v0) ^ (sum + k[sum>>11 & 3]);\n\t}\n\n\treturn (u64) v0 + ((u64) v1 << 32);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_write_fill",
          "args": [
            "req",
            "ff",
            "pos",
            "count"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_write_fill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "912-933",
          "snippet": "static void fuse_write_fill(struct fuse_req *req, struct fuse_file *ff,\n\t\t\t    loff_t pos, size_t count)\n{\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\tstruct fuse_write_out *outarg = &req->misc.write.out;\n\n\tinarg->fh = ff->fh;\n\tinarg->offset = pos;\n\tinarg->size = count;\n\treq->in.h.opcode = FUSE_WRITE;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 2;\n\tif (ff->fc->minor < 9)\n\t\treq->in.args[0].size = FUSE_COMPAT_WRITE_IN_SIZE;\n\telse\n\t\treq->in.args[0].size = sizeof(struct fuse_write_in);\n\treq->in.args[0].value = inarg;\n\treq->in.args[1].size = count;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = sizeof(struct fuse_write_out);\n\treq->out.args[0].value = outarg;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_write_fill(struct fuse_req *req, struct fuse_file *ff,\n\t\t\t    loff_t pos, size_t count)\n{\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\tstruct fuse_write_out *outarg = &req->misc.write.out;\n\n\tinarg->fh = ff->fh;\n\tinarg->offset = pos;\n\tinarg->size = count;\n\treq->in.h.opcode = FUSE_WRITE;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 2;\n\tif (ff->fc->minor < 9)\n\t\treq->in.args[0].size = FUSE_COMPAT_WRITE_IN_SIZE;\n\telse\n\t\treq->in.args[0].size = sizeof(struct fuse_write_in);\n\treq->in.args[0].value = inarg;\n\treq->in.args[1].size = count;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = sizeof(struct fuse_write_out);\n\treq->out.args[0].value = outarg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic size_t fuse_send_write(struct fuse_req *req, struct fuse_io_priv *io,\n\t\t\t      loff_t pos, size_t count, fl_owner_t owner)\n{\n\tstruct file *file = io->file;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\n\tfuse_write_fill(req, ff, pos, count);\n\tinarg->flags = file->f_flags;\n\tif (owner != NULL) {\n\t\tinarg->write_flags |= FUSE_WRITE_LOCKOWNER;\n\t\tinarg->lock_owner = fuse_lock_owner_id(fc, owner);\n\t}\n\n\tif (io->async)\n\t\treturn fuse_async_req_send(fc, req, count, io);\n\n\tfuse_request_send(fc, req);\n\treturn req->misc.write.out.size;\n}"
  },
  {
    "function_name": "fuse_write_fill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "912-933",
    "snippet": "static void fuse_write_fill(struct fuse_req *req, struct fuse_file *ff,\n\t\t\t    loff_t pos, size_t count)\n{\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\tstruct fuse_write_out *outarg = &req->misc.write.out;\n\n\tinarg->fh = ff->fh;\n\tinarg->offset = pos;\n\tinarg->size = count;\n\treq->in.h.opcode = FUSE_WRITE;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 2;\n\tif (ff->fc->minor < 9)\n\t\treq->in.args[0].size = FUSE_COMPAT_WRITE_IN_SIZE;\n\telse\n\t\treq->in.args[0].size = sizeof(struct fuse_write_in);\n\treq->in.args[0].value = inarg;\n\treq->in.args[1].size = count;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = sizeof(struct fuse_write_out);\n\treq->out.args[0].value = outarg;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_write_fill(struct fuse_req *req, struct fuse_file *ff,\n\t\t\t    loff_t pos, size_t count)\n{\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\tstruct fuse_write_out *outarg = &req->misc.write.out;\n\n\tinarg->fh = ff->fh;\n\tinarg->offset = pos;\n\tinarg->size = count;\n\treq->in.h.opcode = FUSE_WRITE;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 2;\n\tif (ff->fc->minor < 9)\n\t\treq->in.args[0].size = FUSE_COMPAT_WRITE_IN_SIZE;\n\telse\n\t\treq->in.args[0].size = sizeof(struct fuse_write_in);\n\treq->in.args[0].value = inarg;\n\treq->in.args[1].size = count;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = sizeof(struct fuse_write_out);\n\treq->out.args[0].value = outarg;\n}"
  },
  {
    "function_name": "fuse_file_read_iter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "891-910",
    "snippet": "static ssize_t fuse_file_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct inode *inode = iocb->ki_filp->f_mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\t/*\n\t * In auto invalidate mode, always update attributes on read.\n\t * Otherwise, only update if we attempt to read past EOF (to ensure\n\t * i_size is up to date).\n\t */\n\tif (fc->auto_inval_data ||\n\t    (iocb->ki_pos + iov_iter_count(to) > i_size_read(inode))) {\n\t\tint err;\n\t\terr = fuse_update_attributes(inode, NULL, iocb->ki_filp, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn generic_file_read_iter(iocb, to);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_file_read_iter",
          "args": [
            "iocb",
            "to"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_update_attributes",
          "args": [
            "inode",
            "NULL",
            "iocb->ki_filp",
            "NULL"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_update_attributes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "909-933",
          "snippet": "int fuse_update_attributes(struct inode *inode, struct kstat *stat,\n\t\t\t   struct file *file, bool *refreshed)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tint err;\n\tbool r;\n\n\tif (time_before64(fi->i_time, get_jiffies_64())) {\n\t\tr = true;\n\t\terr = fuse_do_getattr(inode, stat, file);\n\t} else {\n\t\tr = false;\n\t\terr = 0;\n\t\tif (stat) {\n\t\t\tgeneric_fillattr(inode, stat);\n\t\t\tstat->mode = fi->orig_i_mode;\n\t\t\tstat->ino = fi->orig_ino;\n\t\t}\n\t}\n\n\tif (refreshed != NULL)\n\t\t*refreshed = r;\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_update_attributes(struct inode *inode, struct kstat *stat,\n\t\t\t   struct file *file, bool *refreshed)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tint err;\n\tbool r;\n\n\tif (time_before64(fi->i_time, get_jiffies_64())) {\n\t\tr = true;\n\t\terr = fuse_do_getattr(inode, stat, file);\n\t} else {\n\t\tr = false;\n\t\terr = 0;\n\t\tif (stat) {\n\t\t\tgeneric_fillattr(inode, stat);\n\t\t\tstat->mode = fi->orig_i_mode;\n\t\t\tstat->ino = fi->orig_ino;\n\t\t}\n\t}\n\n\tif (refreshed != NULL)\n\t\t*refreshed = r;\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "to"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_file_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct inode *inode = iocb->ki_filp->f_mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\t/*\n\t * In auto invalidate mode, always update attributes on read.\n\t * Otherwise, only update if we attempt to read past EOF (to ensure\n\t * i_size is up to date).\n\t */\n\tif (fc->auto_inval_data ||\n\t    (iocb->ki_pos + iov_iter_count(to) > i_size_read(inode))) {\n\t\tint err;\n\t\terr = fuse_update_attributes(inode, NULL, iocb->ki_filp, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn generic_file_read_iter(iocb, to);\n}"
  },
  {
    "function_name": "fuse_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "856-889",
    "snippet": "static int fuse_readpages(struct file *file, struct address_space *mapping,\n\t\t\t  struct list_head *pages, unsigned nr_pages)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_fill_data data;\n\tint err;\n\tint nr_alloc = min_t(unsigned, nr_pages, FUSE_MAX_PAGES_PER_REQ);\n\n\terr = -EIO;\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\n\tdata.file = file;\n\tdata.inode = inode;\n\tif (fc->async_read)\n\t\tdata.req = fuse_get_req_for_background(fc, nr_alloc);\n\telse\n\t\tdata.req = fuse_get_req(fc, nr_alloc);\n\tdata.nr_pages = nr_pages;\n\terr = PTR_ERR(data.req);\n\tif (IS_ERR(data.req))\n\t\tgoto out;\n\n\terr = read_cache_pages(mapping, pages, fuse_readpages_fill, &data);\n\tif (!err) {\n\t\tif (data.req->num_pages)\n\t\t\tfuse_send_readpages(data.req, file);\n\t\telse\n\t\t\tfuse_put_request(fc, data.req);\n\t}\nout:\n\treturn err;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_put_request",
          "args": [
            "fc",
            "data.req"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "277-299",
          "snippet": "void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_send_readpages",
          "args": [
            "data.req",
            "file"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_send_readpages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "785-806",
          "snippet": "static void fuse_send_readpages(struct fuse_req *req, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tloff_t pos = page_offset(req->pages[0]);\n\tsize_t count = req->num_pages << PAGE_CACHE_SHIFT;\n\n\treq->out.argpages = 1;\n\treq->out.page_zeroing = 1;\n\treq->out.page_replace = 1;\n\tfuse_read_fill(req, file, pos, count, FUSE_READ);\n\treq->misc.read.attr_ver = fuse_get_attr_version(fc);\n\tif (fc->async_read) {\n\t\treq->ff = fuse_file_get(ff);\n\t\treq->end = fuse_readpages_end;\n\t\tfuse_request_send_background(fc, req);\n\t} else {\n\t\tfuse_request_send(fc, req);\n\t\tfuse_readpages_end(fc, req);\n\t\tfuse_put_request(fc, req);\n\t}\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_send_readpages(struct fuse_req *req, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tloff_t pos = page_offset(req->pages[0]);\n\tsize_t count = req->num_pages << PAGE_CACHE_SHIFT;\n\n\treq->out.argpages = 1;\n\treq->out.page_zeroing = 1;\n\treq->out.page_replace = 1;\n\tfuse_read_fill(req, file, pos, count, FUSE_READ);\n\treq->misc.read.attr_ver = fuse_get_attr_version(fc);\n\tif (fc->async_read) {\n\t\treq->ff = fuse_file_get(ff);\n\t\treq->end = fuse_readpages_end;\n\t\tfuse_request_send_background(fc, req);\n\t} else {\n\t\tfuse_request_send(fc, req);\n\t\tfuse_readpages_end(fc, req);\n\t\tfuse_put_request(fc, req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_cache_pages",
          "args": [
            "mapping",
            "pages",
            "fuse_readpages_fill",
            "&data"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data.req"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "data.req"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_get_req",
          "args": [
            "fc",
            "nr_alloc"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_req_nofail_nopages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "258-275",
          "snippet": "struct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc,\n\t\t\t\t\t     struct file *file)\n{\n\tstruct fuse_req *req;\n\n\tatomic_inc(&fc->num_waiting);\n\twait_event(fc->blocked_waitq, fc->initialized);\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\treq = fuse_request_alloc(0);\n\tif (!req)\n\t\treq = get_reserved_req(fc, file);\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = 0;\n\treturn req;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstruct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc,\n\t\t\t\t\t     struct file *file)\n{\n\tstruct fuse_req *req;\n\n\tatomic_inc(&fc->num_waiting);\n\twait_event(fc->blocked_waitq, fc->initialized);\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\treq = fuse_request_alloc(0);\n\tif (!req)\n\t\treq = get_reserved_req(fc, file);\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = 0;\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_get_req_for_background",
          "args": [
            "fc",
            "nr_alloc"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_req_for_background",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "196-200",
          "snippet": "struct fuse_req *fuse_get_req_for_background(struct fuse_conn *fc,\n\t\t\t\t\t     unsigned npages)\n{\n\treturn __fuse_get_req(fc, npages, true);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstruct fuse_req *fuse_get_req_for_background(struct fuse_conn *fc,\n\t\t\t\t\t     unsigned npages)\n{\n\treturn __fuse_get_req(fc, npages, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsigned",
            "nr_pages",
            "FUSE_MAX_PAGES_PER_REQ"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_readpages(struct file *file, struct address_space *mapping,\n\t\t\t  struct list_head *pages, unsigned nr_pages)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_fill_data data;\n\tint err;\n\tint nr_alloc = min_t(unsigned, nr_pages, FUSE_MAX_PAGES_PER_REQ);\n\n\terr = -EIO;\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\n\tdata.file = file;\n\tdata.inode = inode;\n\tif (fc->async_read)\n\t\tdata.req = fuse_get_req_for_background(fc, nr_alloc);\n\telse\n\t\tdata.req = fuse_get_req(fc, nr_alloc);\n\tdata.nr_pages = nr_pages;\n\terr = PTR_ERR(data.req);\n\tif (IS_ERR(data.req))\n\t\tgoto out;\n\n\terr = read_cache_pages(mapping, pages, fuse_readpages_fill, &data);\n\tif (!err) {\n\t\tif (data.req->num_pages)\n\t\t\tfuse_send_readpages(data.req, file);\n\t\telse\n\t\t\tfuse_put_request(fc, data.req);\n\t}\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_readpages_fill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "815-854",
    "snippet": "static int fuse_readpages_fill(void *_data, struct page *page)\n{\n\tstruct fuse_fill_data *data = _data;\n\tstruct fuse_req *req = data->req;\n\tstruct inode *inode = data->inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tfuse_wait_on_page_writeback(inode, page->index);\n\n\tif (req->num_pages &&\n\t    (req->num_pages == FUSE_MAX_PAGES_PER_REQ ||\n\t     (req->num_pages + 1) * PAGE_CACHE_SIZE > fc->max_read ||\n\t     req->pages[req->num_pages - 1]->index + 1 != page->index)) {\n\t\tint nr_alloc = min_t(unsigned, data->nr_pages,\n\t\t\t\t     FUSE_MAX_PAGES_PER_REQ);\n\t\tfuse_send_readpages(req, data->file);\n\t\tif (fc->async_read)\n\t\t\treq = fuse_get_req_for_background(fc, nr_alloc);\n\t\telse\n\t\t\treq = fuse_get_req(fc, nr_alloc);\n\n\t\tdata->req = req;\n\t\tif (IS_ERR(req)) {\n\t\t\tunlock_page(page);\n\t\t\treturn PTR_ERR(req);\n\t\t}\n\t}\n\n\tif (WARN_ON(req->num_pages >= req->max_pages)) {\n\t\tfuse_put_request(fc, req);\n\t\treturn -EIO;\n\t}\n\n\tpage_cache_get(page);\n\treq->pages[req->num_pages] = page;\n\treq->page_descs[req->num_pages].length = PAGE_SIZE;\n\treq->num_pages++;\n\tdata->nr_pages--;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_get",
          "args": [
            "page"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_put_request",
          "args": [
            "fc",
            "req"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "277-299",
          "snippet": "void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "req->num_pages >= req->max_pages"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_get_req",
          "args": [
            "fc",
            "nr_alloc"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_req_nofail_nopages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "258-275",
          "snippet": "struct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc,\n\t\t\t\t\t     struct file *file)\n{\n\tstruct fuse_req *req;\n\n\tatomic_inc(&fc->num_waiting);\n\twait_event(fc->blocked_waitq, fc->initialized);\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\treq = fuse_request_alloc(0);\n\tif (!req)\n\t\treq = get_reserved_req(fc, file);\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = 0;\n\treturn req;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstruct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc,\n\t\t\t\t\t     struct file *file)\n{\n\tstruct fuse_req *req;\n\n\tatomic_inc(&fc->num_waiting);\n\twait_event(fc->blocked_waitq, fc->initialized);\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\treq = fuse_request_alloc(0);\n\tif (!req)\n\t\treq = get_reserved_req(fc, file);\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = 0;\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_get_req_for_background",
          "args": [
            "fc",
            "nr_alloc"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_req_for_background",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "196-200",
          "snippet": "struct fuse_req *fuse_get_req_for_background(struct fuse_conn *fc,\n\t\t\t\t\t     unsigned npages)\n{\n\treturn __fuse_get_req(fc, npages, true);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstruct fuse_req *fuse_get_req_for_background(struct fuse_conn *fc,\n\t\t\t\t\t     unsigned npages)\n{\n\treturn __fuse_get_req(fc, npages, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_send_readpages",
          "args": [
            "req",
            "data->file"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_send_readpages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "785-806",
          "snippet": "static void fuse_send_readpages(struct fuse_req *req, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tloff_t pos = page_offset(req->pages[0]);\n\tsize_t count = req->num_pages << PAGE_CACHE_SHIFT;\n\n\treq->out.argpages = 1;\n\treq->out.page_zeroing = 1;\n\treq->out.page_replace = 1;\n\tfuse_read_fill(req, file, pos, count, FUSE_READ);\n\treq->misc.read.attr_ver = fuse_get_attr_version(fc);\n\tif (fc->async_read) {\n\t\treq->ff = fuse_file_get(ff);\n\t\treq->end = fuse_readpages_end;\n\t\tfuse_request_send_background(fc, req);\n\t} else {\n\t\tfuse_request_send(fc, req);\n\t\tfuse_readpages_end(fc, req);\n\t\tfuse_put_request(fc, req);\n\t}\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_send_readpages(struct fuse_req *req, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tloff_t pos = page_offset(req->pages[0]);\n\tsize_t count = req->num_pages << PAGE_CACHE_SHIFT;\n\n\treq->out.argpages = 1;\n\treq->out.page_zeroing = 1;\n\treq->out.page_replace = 1;\n\tfuse_read_fill(req, file, pos, count, FUSE_READ);\n\treq->misc.read.attr_ver = fuse_get_attr_version(fc);\n\tif (fc->async_read) {\n\t\treq->ff = fuse_file_get(ff);\n\t\treq->end = fuse_readpages_end;\n\t\tfuse_request_send_background(fc, req);\n\t} else {\n\t\tfuse_request_send(fc, req);\n\t\tfuse_readpages_end(fc, req);\n\t\tfuse_put_request(fc, req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsigned",
            "data->nr_pages",
            "FUSE_MAX_PAGES_PER_REQ"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_wait_on_page_writeback",
          "args": [
            "inode",
            "page->index"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "374-380",
          "snippet": "static int fuse_wait_on_page_writeback(struct inode *inode, pgoff_t index)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\twait_event(fi->page_waitq, !fuse_page_is_writeback(inode, index));\n\treturn 0;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_wait_on_page_writeback(struct inode *inode, pgoff_t index)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\twait_event(fi->page_waitq, !fuse_page_is_writeback(inode, index));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_readpages_fill(void *_data, struct page *page)\n{\n\tstruct fuse_fill_data *data = _data;\n\tstruct fuse_req *req = data->req;\n\tstruct inode *inode = data->inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tfuse_wait_on_page_writeback(inode, page->index);\n\n\tif (req->num_pages &&\n\t    (req->num_pages == FUSE_MAX_PAGES_PER_REQ ||\n\t     (req->num_pages + 1) * PAGE_CACHE_SIZE > fc->max_read ||\n\t     req->pages[req->num_pages - 1]->index + 1 != page->index)) {\n\t\tint nr_alloc = min_t(unsigned, data->nr_pages,\n\t\t\t\t     FUSE_MAX_PAGES_PER_REQ);\n\t\tfuse_send_readpages(req, data->file);\n\t\tif (fc->async_read)\n\t\t\treq = fuse_get_req_for_background(fc, nr_alloc);\n\t\telse\n\t\t\treq = fuse_get_req(fc, nr_alloc);\n\n\t\tdata->req = req;\n\t\tif (IS_ERR(req)) {\n\t\t\tunlock_page(page);\n\t\t\treturn PTR_ERR(req);\n\t\t}\n\t}\n\n\tif (WARN_ON(req->num_pages >= req->max_pages)) {\n\t\tfuse_put_request(fc, req);\n\t\treturn -EIO;\n\t}\n\n\tpage_cache_get(page);\n\treq->pages[req->num_pages] = page;\n\treq->page_descs[req->num_pages].length = PAGE_SIZE;\n\treq->num_pages++;\n\tdata->nr_pages--;\n\treturn 0;\n}"
  },
  {
    "function_name": "fuse_send_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "785-806",
    "snippet": "static void fuse_send_readpages(struct fuse_req *req, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tloff_t pos = page_offset(req->pages[0]);\n\tsize_t count = req->num_pages << PAGE_CACHE_SHIFT;\n\n\treq->out.argpages = 1;\n\treq->out.page_zeroing = 1;\n\treq->out.page_replace = 1;\n\tfuse_read_fill(req, file, pos, count, FUSE_READ);\n\treq->misc.read.attr_ver = fuse_get_attr_version(fc);\n\tif (fc->async_read) {\n\t\treq->ff = fuse_file_get(ff);\n\t\treq->end = fuse_readpages_end;\n\t\tfuse_request_send_background(fc, req);\n\t} else {\n\t\tfuse_request_send(fc, req);\n\t\tfuse_readpages_end(fc, req);\n\t\tfuse_put_request(fc, req);\n\t}\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_put_request",
          "args": [
            "fc",
            "req"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "277-299",
          "snippet": "void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_readpages_end",
          "args": [
            "fc",
            "req"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_readpages_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "750-783",
          "snippet": "static void fuse_readpages_end(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tint i;\n\tsize_t count = req->misc.read.in.size;\n\tsize_t num_read = req->out.args[0].size;\n\tstruct address_space *mapping = NULL;\n\n\tfor (i = 0; mapping == NULL && i < req->num_pages; i++)\n\t\tmapping = req->pages[i]->mapping;\n\n\tif (mapping) {\n\t\tstruct inode *inode = mapping->host;\n\n\t\t/*\n\t\t * Short read means EOF. If file size is larger, truncate it\n\t\t */\n\t\tif (!req->out.h.error && num_read < count)\n\t\t\tfuse_short_read(req, inode, req->misc.read.attr_ver);\n\n\t\tfuse_invalidate_atime(inode);\n\t}\n\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tstruct page *page = req->pages[i];\n\t\tif (!req->out.h.error)\n\t\t\tSetPageUptodate(page);\n\t\telse\n\t\t\tSetPageError(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\tif (req->ff)\n\t\tfuse_file_put(req->ff, false);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_readpages_end(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tint i;\n\tsize_t count = req->misc.read.in.size;\n\tsize_t num_read = req->out.args[0].size;\n\tstruct address_space *mapping = NULL;\n\n\tfor (i = 0; mapping == NULL && i < req->num_pages; i++)\n\t\tmapping = req->pages[i]->mapping;\n\n\tif (mapping) {\n\t\tstruct inode *inode = mapping->host;\n\n\t\t/*\n\t\t * Short read means EOF. If file size is larger, truncate it\n\t\t */\n\t\tif (!req->out.h.error && num_read < count)\n\t\t\tfuse_short_read(req, inode, req->misc.read.attr_ver);\n\n\t\tfuse_invalidate_atime(inode);\n\t}\n\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tstruct page *page = req->pages[i];\n\t\tif (!req->out.h.error)\n\t\t\tSetPageUptodate(page);\n\t\telse\n\t\t\tSetPageError(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\tif (req->ff)\n\t\tfuse_file_put(req->ff, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_request_send",
          "args": [
            "fc",
            "req"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_send_background_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "647-652",
          "snippet": "void fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_file_get",
          "args": [
            "ff"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_file_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "78-82",
          "snippet": "struct fuse_file *fuse_file_get(struct fuse_file *ff)\n{\n\tatomic_inc(&ff->count);\n\treturn ff;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstruct fuse_file *fuse_file_get(struct fuse_file *ff)\n{\n\tatomic_inc(&ff->count);\n\treturn ff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_get_attr_version",
          "args": [
            "fc"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_attr_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "163-176",
          "snippet": "u64 fuse_get_attr_version(struct fuse_conn *fc)\n{\n\tu64 curr_version;\n\n\t/*\n\t * The spin lock isn't actually needed on 64bit archs, but we\n\t * don't yet care too much about such optimizations.\n\t */\n\tspin_lock(&fc->lock);\n\tcurr_version = fc->attr_version;\n\tspin_unlock(&fc->lock);\n\n\treturn curr_version;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nu64 fuse_get_attr_version(struct fuse_conn *fc)\n{\n\tu64 curr_version;\n\n\t/*\n\t * The spin lock isn't actually needed on 64bit archs, but we\n\t * don't yet care too much about such optimizations.\n\t */\n\tspin_lock(&fc->lock);\n\tcurr_version = fc->attr_version;\n\tspin_unlock(&fc->lock);\n\n\treturn curr_version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_read_fill",
          "args": [
            "req",
            "file",
            "pos",
            "count",
            "FUSE_READ"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_read_fill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "499-517",
          "snippet": "void fuse_read_fill(struct fuse_req *req, struct file *file, loff_t pos,\n\t\t    size_t count, int opcode)\n{\n\tstruct fuse_read_in *inarg = &req->misc.read.in;\n\tstruct fuse_file *ff = file->private_data;\n\n\tinarg->fh = ff->fh;\n\tinarg->offset = pos;\n\tinarg->size = count;\n\tinarg->flags = file->f_flags;\n\treq->in.h.opcode = opcode;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(struct fuse_read_in);\n\treq->in.args[0].value = inarg;\n\treq->out.argvar = 1;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = count;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_read_fill(struct fuse_req *req, struct file *file, loff_t pos,\n\t\t    size_t count, int opcode)\n{\n\tstruct fuse_read_in *inarg = &req->misc.read.in;\n\tstruct fuse_file *ff = file->private_data;\n\n\tinarg->fh = ff->fh;\n\tinarg->offset = pos;\n\tinarg->size = count;\n\tinarg->flags = file->f_flags;\n\treq->in.h.opcode = opcode;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(struct fuse_read_in);\n\treq->in.args[0].value = inarg;\n\treq->out.argvar = 1;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "req->pages[0]"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_send_readpages(struct fuse_req *req, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tloff_t pos = page_offset(req->pages[0]);\n\tsize_t count = req->num_pages << PAGE_CACHE_SHIFT;\n\n\treq->out.argpages = 1;\n\treq->out.page_zeroing = 1;\n\treq->out.page_replace = 1;\n\tfuse_read_fill(req, file, pos, count, FUSE_READ);\n\treq->misc.read.attr_ver = fuse_get_attr_version(fc);\n\tif (fc->async_read) {\n\t\treq->ff = fuse_file_get(ff);\n\t\treq->end = fuse_readpages_end;\n\t\tfuse_request_send_background(fc, req);\n\t} else {\n\t\tfuse_request_send(fc, req);\n\t\tfuse_readpages_end(fc, req);\n\t\tfuse_put_request(fc, req);\n\t}\n}"
  },
  {
    "function_name": "fuse_readpages_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "750-783",
    "snippet": "static void fuse_readpages_end(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tint i;\n\tsize_t count = req->misc.read.in.size;\n\tsize_t num_read = req->out.args[0].size;\n\tstruct address_space *mapping = NULL;\n\n\tfor (i = 0; mapping == NULL && i < req->num_pages; i++)\n\t\tmapping = req->pages[i]->mapping;\n\n\tif (mapping) {\n\t\tstruct inode *inode = mapping->host;\n\n\t\t/*\n\t\t * Short read means EOF. If file size is larger, truncate it\n\t\t */\n\t\tif (!req->out.h.error && num_read < count)\n\t\t\tfuse_short_read(req, inode, req->misc.read.attr_ver);\n\n\t\tfuse_invalidate_atime(inode);\n\t}\n\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tstruct page *page = req->pages[i];\n\t\tif (!req->out.h.error)\n\t\t\tSetPageUptodate(page);\n\t\telse\n\t\t\tSetPageError(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\tif (req->ff)\n\t\tfuse_file_put(req->ff, false);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_file_put",
          "args": [
            "req->ff",
            "false"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_file_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "89-114",
          "snippet": "static void fuse_file_put(struct fuse_file *ff, bool sync)\n{\n\tif (atomic_dec_and_test(&ff->count)) {\n\t\tstruct fuse_req *req = ff->reserved_req;\n\n\t\tif (ff->fc->no_open) {\n\t\t\t/*\n\t\t\t * Drop the release request when client does not\n\t\t\t * implement 'open'\n\t\t\t */\n\t\t\treq->background = 0;\n\t\t\tiput(req->misc.release.inode);\n\t\t\tfuse_put_request(ff->fc, req);\n\t\t} else if (sync) {\n\t\t\treq->background = 0;\n\t\t\tfuse_request_send(ff->fc, req);\n\t\t\tiput(req->misc.release.inode);\n\t\t\tfuse_put_request(ff->fc, req);\n\t\t} else {\n\t\t\treq->end = fuse_release_end;\n\t\t\treq->background = 1;\n\t\t\tfuse_request_send_background(ff->fc, req);\n\t\t}\n\t\tkfree(ff);\n\t}\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_file_put(struct fuse_file *ff, bool sync)\n{\n\tif (atomic_dec_and_test(&ff->count)) {\n\t\tstruct fuse_req *req = ff->reserved_req;\n\n\t\tif (ff->fc->no_open) {\n\t\t\t/*\n\t\t\t * Drop the release request when client does not\n\t\t\t * implement 'open'\n\t\t\t */\n\t\t\treq->background = 0;\n\t\t\tiput(req->misc.release.inode);\n\t\t\tfuse_put_request(ff->fc, req);\n\t\t} else if (sync) {\n\t\t\treq->background = 0;\n\t\t\tfuse_request_send(ff->fc, req);\n\t\t\tiput(req->misc.release.inode);\n\t\t\tfuse_put_request(ff->fc, req);\n\t\t} else {\n\t\t\treq->end = fuse_release_end;\n\t\t\treq->background = 1;\n\t\t\tfuse_request_send_background(ff->fc, req);\n\t\t}\n\t\tkfree(ff);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_invalidate_atime",
          "args": [
            "inode"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "119-123",
          "snippet": "void fuse_invalidate_atime(struct inode *inode)\n{\n\tif (!IS_RDONLY(inode))\n\t\tfuse_invalidate_attr(inode);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_atime(struct inode *inode)\n{\n\tif (!IS_RDONLY(inode))\n\t\tfuse_invalidate_attr(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_short_read",
          "args": [
            "req",
            "inode",
            "req->misc.read.attr_ver"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_short_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "660-684",
          "snippet": "static void fuse_short_read(struct fuse_req *req, struct inode *inode,\n\t\t\t    u64 attr_ver)\n{\n\tsize_t num_read = req->out.args[0].size;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (fc->writeback_cache) {\n\t\t/*\n\t\t * A hole in a file. Some data after the hole are in page cache,\n\t\t * but have not reached the client fs yet. So, the hole is not\n\t\t * present there.\n\t\t */\n\t\tint i;\n\t\tint start_idx = num_read >> PAGE_CACHE_SHIFT;\n\t\tsize_t off = num_read & (PAGE_CACHE_SIZE - 1);\n\n\t\tfor (i = start_idx; i < req->num_pages; i++) {\n\t\t\tzero_user_segment(req->pages[i], off, PAGE_CACHE_SIZE);\n\t\t\toff = 0;\n\t\t}\n\t} else {\n\t\tloff_t pos = page_offset(req->pages[0]) + num_read;\n\t\tfuse_read_update_size(inode, pos, attr_ver);\n\t}\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_short_read(struct fuse_req *req, struct inode *inode,\n\t\t\t    u64 attr_ver)\n{\n\tsize_t num_read = req->out.args[0].size;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (fc->writeback_cache) {\n\t\t/*\n\t\t * A hole in a file. Some data after the hole are in page cache,\n\t\t * but have not reached the client fs yet. So, the hole is not\n\t\t * present there.\n\t\t */\n\t\tint i;\n\t\tint start_idx = num_read >> PAGE_CACHE_SHIFT;\n\t\tsize_t off = num_read & (PAGE_CACHE_SIZE - 1);\n\n\t\tfor (i = start_idx; i < req->num_pages; i++) {\n\t\t\tzero_user_segment(req->pages[i], off, PAGE_CACHE_SIZE);\n\t\t\toff = 0;\n\t\t}\n\t} else {\n\t\tloff_t pos = page_offset(req->pages[0]) + num_read;\n\t\tfuse_read_update_size(inode, pos, attr_ver);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_readpages_end(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tint i;\n\tsize_t count = req->misc.read.in.size;\n\tsize_t num_read = req->out.args[0].size;\n\tstruct address_space *mapping = NULL;\n\n\tfor (i = 0; mapping == NULL && i < req->num_pages; i++)\n\t\tmapping = req->pages[i]->mapping;\n\n\tif (mapping) {\n\t\tstruct inode *inode = mapping->host;\n\n\t\t/*\n\t\t * Short read means EOF. If file size is larger, truncate it\n\t\t */\n\t\tif (!req->out.h.error && num_read < count)\n\t\t\tfuse_short_read(req, inode, req->misc.read.attr_ver);\n\n\t\tfuse_invalidate_atime(inode);\n\t}\n\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tstruct page *page = req->pages[i];\n\t\tif (!req->out.h.error)\n\t\t\tSetPageUptodate(page);\n\t\telse\n\t\t\tSetPageError(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\tif (req->ff)\n\t\tfuse_file_put(req->ff, false);\n}"
  },
  {
    "function_name": "fuse_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "734-748",
    "snippet": "static int fuse_readpage(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint err;\n\n\terr = -EIO;\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\n\terr = fuse_do_readpage(file, page);\n\tfuse_invalidate_atime(inode);\n out:\n\tunlock_page(page);\n\treturn err;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_invalidate_atime",
          "args": [
            "inode"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "119-123",
          "snippet": "void fuse_invalidate_atime(struct inode *inode)\n{\n\tif (!IS_RDONLY(inode))\n\t\tfuse_invalidate_attr(inode);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_atime(struct inode *inode)\n{\n\tif (!IS_RDONLY(inode))\n\t\tfuse_invalidate_attr(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_do_readpage",
          "args": [
            "file",
            "page"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_do_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "686-732",
          "snippet": "static int fuse_do_readpage(struct file *file, struct page *page)\n{\n\tstruct fuse_io_priv io = { .async = 0, .file = file };\n\tstruct inode *inode = page->mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_req *req;\n\tsize_t num_read;\n\tloff_t pos = page_offset(page);\n\tsize_t count = PAGE_CACHE_SIZE;\n\tu64 attr_ver;\n\tint err;\n\n\t/*\n\t * Page writeback can extend beyond the lifetime of the\n\t * page-cache page, so make sure we read a properly synced\n\t * page.\n\t */\n\tfuse_wait_on_page_writeback(inode, page->index);\n\n\treq = fuse_get_req(fc, 1);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tattr_ver = fuse_get_attr_version(fc);\n\n\treq->out.page_zeroing = 1;\n\treq->out.argpages = 1;\n\treq->num_pages = 1;\n\treq->pages[0] = page;\n\treq->page_descs[0].length = count;\n\tnum_read = fuse_send_read(req, &io, pos, count, NULL);\n\terr = req->out.h.error;\n\n\tif (!err) {\n\t\t/*\n\t\t * Short read means EOF.  If file size is larger, truncate it\n\t\t */\n\t\tif (num_read < count)\n\t\t\tfuse_short_read(req, inode, attr_ver);\n\n\t\tSetPageUptodate(page);\n\t}\n\n\tfuse_put_request(fc, req);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_do_readpage(struct file *file, struct page *page)\n{\n\tstruct fuse_io_priv io = { .async = 0, .file = file };\n\tstruct inode *inode = page->mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_req *req;\n\tsize_t num_read;\n\tloff_t pos = page_offset(page);\n\tsize_t count = PAGE_CACHE_SIZE;\n\tu64 attr_ver;\n\tint err;\n\n\t/*\n\t * Page writeback can extend beyond the lifetime of the\n\t * page-cache page, so make sure we read a properly synced\n\t * page.\n\t */\n\tfuse_wait_on_page_writeback(inode, page->index);\n\n\treq = fuse_get_req(fc, 1);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tattr_ver = fuse_get_attr_version(fc);\n\n\treq->out.page_zeroing = 1;\n\treq->out.argpages = 1;\n\treq->num_pages = 1;\n\treq->pages[0] = page;\n\treq->page_descs[0].length = count;\n\tnum_read = fuse_send_read(req, &io, pos, count, NULL);\n\terr = req->out.h.error;\n\n\tif (!err) {\n\t\t/*\n\t\t * Short read means EOF.  If file size is larger, truncate it\n\t\t */\n\t\tif (num_read < count)\n\t\t\tfuse_short_read(req, inode, attr_ver);\n\n\t\tSetPageUptodate(page);\n\t}\n\n\tfuse_put_request(fc, req);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_readpage(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint err;\n\n\terr = -EIO;\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\n\terr = fuse_do_readpage(file, page);\n\tfuse_invalidate_atime(inode);\n out:\n\tunlock_page(page);\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_do_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "686-732",
    "snippet": "static int fuse_do_readpage(struct file *file, struct page *page)\n{\n\tstruct fuse_io_priv io = { .async = 0, .file = file };\n\tstruct inode *inode = page->mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_req *req;\n\tsize_t num_read;\n\tloff_t pos = page_offset(page);\n\tsize_t count = PAGE_CACHE_SIZE;\n\tu64 attr_ver;\n\tint err;\n\n\t/*\n\t * Page writeback can extend beyond the lifetime of the\n\t * page-cache page, so make sure we read a properly synced\n\t * page.\n\t */\n\tfuse_wait_on_page_writeback(inode, page->index);\n\n\treq = fuse_get_req(fc, 1);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tattr_ver = fuse_get_attr_version(fc);\n\n\treq->out.page_zeroing = 1;\n\treq->out.argpages = 1;\n\treq->num_pages = 1;\n\treq->pages[0] = page;\n\treq->page_descs[0].length = count;\n\tnum_read = fuse_send_read(req, &io, pos, count, NULL);\n\terr = req->out.h.error;\n\n\tif (!err) {\n\t\t/*\n\t\t * Short read means EOF.  If file size is larger, truncate it\n\t\t */\n\t\tif (num_read < count)\n\t\t\tfuse_short_read(req, inode, attr_ver);\n\n\t\tSetPageUptodate(page);\n\t}\n\n\tfuse_put_request(fc, req);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_put_request",
          "args": [
            "fc",
            "req"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "277-299",
          "snippet": "void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_short_read",
          "args": [
            "req",
            "inode",
            "attr_ver"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_short_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "660-684",
          "snippet": "static void fuse_short_read(struct fuse_req *req, struct inode *inode,\n\t\t\t    u64 attr_ver)\n{\n\tsize_t num_read = req->out.args[0].size;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (fc->writeback_cache) {\n\t\t/*\n\t\t * A hole in a file. Some data after the hole are in page cache,\n\t\t * but have not reached the client fs yet. So, the hole is not\n\t\t * present there.\n\t\t */\n\t\tint i;\n\t\tint start_idx = num_read >> PAGE_CACHE_SHIFT;\n\t\tsize_t off = num_read & (PAGE_CACHE_SIZE - 1);\n\n\t\tfor (i = start_idx; i < req->num_pages; i++) {\n\t\t\tzero_user_segment(req->pages[i], off, PAGE_CACHE_SIZE);\n\t\t\toff = 0;\n\t\t}\n\t} else {\n\t\tloff_t pos = page_offset(req->pages[0]) + num_read;\n\t\tfuse_read_update_size(inode, pos, attr_ver);\n\t}\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_short_read(struct fuse_req *req, struct inode *inode,\n\t\t\t    u64 attr_ver)\n{\n\tsize_t num_read = req->out.args[0].size;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (fc->writeback_cache) {\n\t\t/*\n\t\t * A hole in a file. Some data after the hole are in page cache,\n\t\t * but have not reached the client fs yet. So, the hole is not\n\t\t * present there.\n\t\t */\n\t\tint i;\n\t\tint start_idx = num_read >> PAGE_CACHE_SHIFT;\n\t\tsize_t off = num_read & (PAGE_CACHE_SIZE - 1);\n\n\t\tfor (i = start_idx; i < req->num_pages; i++) {\n\t\t\tzero_user_segment(req->pages[i], off, PAGE_CACHE_SIZE);\n\t\t\toff = 0;\n\t\t}\n\t} else {\n\t\tloff_t pos = page_offset(req->pages[0]) + num_read;\n\t\tfuse_read_update_size(inode, pos, attr_ver);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_send_read",
          "args": [
            "req",
            "&io",
            "pos",
            "count",
            "NULL"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_send_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "623-643",
          "snippet": "static size_t fuse_send_read(struct fuse_req *req, struct fuse_io_priv *io,\n\t\t\t     loff_t pos, size_t count, fl_owner_t owner)\n{\n\tstruct file *file = io->file;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\n\tfuse_read_fill(req, file, pos, count, FUSE_READ);\n\tif (owner != NULL) {\n\t\tstruct fuse_read_in *inarg = &req->misc.read.in;\n\n\t\tinarg->read_flags |= FUSE_READ_LOCKOWNER;\n\t\tinarg->lock_owner = fuse_lock_owner_id(fc, owner);\n\t}\n\n\tif (io->async)\n\t\treturn fuse_async_req_send(fc, req, count, io);\n\n\tfuse_request_send(fc, req);\n\treturn req->out.args[0].size;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic size_t fuse_send_read(struct fuse_req *req, struct fuse_io_priv *io,\n\t\t\t     loff_t pos, size_t count, fl_owner_t owner)\n{\n\tstruct file *file = io->file;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\n\tfuse_read_fill(req, file, pos, count, FUSE_READ);\n\tif (owner != NULL) {\n\t\tstruct fuse_read_in *inarg = &req->misc.read.in;\n\n\t\tinarg->read_flags |= FUSE_READ_LOCKOWNER;\n\t\tinarg->lock_owner = fuse_lock_owner_id(fc, owner);\n\t}\n\n\tif (io->async)\n\t\treturn fuse_async_req_send(fc, req, count, io);\n\n\tfuse_request_send(fc, req);\n\treturn req->out.args[0].size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_get_attr_version",
          "args": [
            "fc"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_attr_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "163-176",
          "snippet": "u64 fuse_get_attr_version(struct fuse_conn *fc)\n{\n\tu64 curr_version;\n\n\t/*\n\t * The spin lock isn't actually needed on 64bit archs, but we\n\t * don't yet care too much about such optimizations.\n\t */\n\tspin_lock(&fc->lock);\n\tcurr_version = fc->attr_version;\n\tspin_unlock(&fc->lock);\n\n\treturn curr_version;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nu64 fuse_get_attr_version(struct fuse_conn *fc)\n{\n\tu64 curr_version;\n\n\t/*\n\t * The spin lock isn't actually needed on 64bit archs, but we\n\t * don't yet care too much about such optimizations.\n\t */\n\tspin_lock(&fc->lock);\n\tcurr_version = fc->attr_version;\n\tspin_unlock(&fc->lock);\n\n\treturn curr_version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_get_req",
          "args": [
            "fc",
            "1"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_req_nofail_nopages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "258-275",
          "snippet": "struct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc,\n\t\t\t\t\t     struct file *file)\n{\n\tstruct fuse_req *req;\n\n\tatomic_inc(&fc->num_waiting);\n\twait_event(fc->blocked_waitq, fc->initialized);\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\treq = fuse_request_alloc(0);\n\tif (!req)\n\t\treq = get_reserved_req(fc, file);\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = 0;\n\treturn req;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstruct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc,\n\t\t\t\t\t     struct file *file)\n{\n\tstruct fuse_req *req;\n\n\tatomic_inc(&fc->num_waiting);\n\twait_event(fc->blocked_waitq, fc->initialized);\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\treq = fuse_request_alloc(0);\n\tif (!req)\n\t\treq = get_reserved_req(fc, file);\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = 0;\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_wait_on_page_writeback",
          "args": [
            "inode",
            "page->index"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "374-380",
          "snippet": "static int fuse_wait_on_page_writeback(struct inode *inode, pgoff_t index)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\twait_event(fi->page_waitq, !fuse_page_is_writeback(inode, index));\n\treturn 0;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_wait_on_page_writeback(struct inode *inode, pgoff_t index)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\twait_event(fi->page_waitq, !fuse_page_is_writeback(inode, index));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_do_readpage(struct file *file, struct page *page)\n{\n\tstruct fuse_io_priv io = { .async = 0, .file = file };\n\tstruct inode *inode = page->mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_req *req;\n\tsize_t num_read;\n\tloff_t pos = page_offset(page);\n\tsize_t count = PAGE_CACHE_SIZE;\n\tu64 attr_ver;\n\tint err;\n\n\t/*\n\t * Page writeback can extend beyond the lifetime of the\n\t * page-cache page, so make sure we read a properly synced\n\t * page.\n\t */\n\tfuse_wait_on_page_writeback(inode, page->index);\n\n\treq = fuse_get_req(fc, 1);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tattr_ver = fuse_get_attr_version(fc);\n\n\treq->out.page_zeroing = 1;\n\treq->out.argpages = 1;\n\treq->num_pages = 1;\n\treq->pages[0] = page;\n\treq->page_descs[0].length = count;\n\tnum_read = fuse_send_read(req, &io, pos, count, NULL);\n\terr = req->out.h.error;\n\n\tif (!err) {\n\t\t/*\n\t\t * Short read means EOF.  If file size is larger, truncate it\n\t\t */\n\t\tif (num_read < count)\n\t\t\tfuse_short_read(req, inode, attr_ver);\n\n\t\tSetPageUptodate(page);\n\t}\n\n\tfuse_put_request(fc, req);\n\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_short_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "660-684",
    "snippet": "static void fuse_short_read(struct fuse_req *req, struct inode *inode,\n\t\t\t    u64 attr_ver)\n{\n\tsize_t num_read = req->out.args[0].size;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (fc->writeback_cache) {\n\t\t/*\n\t\t * A hole in a file. Some data after the hole are in page cache,\n\t\t * but have not reached the client fs yet. So, the hole is not\n\t\t * present there.\n\t\t */\n\t\tint i;\n\t\tint start_idx = num_read >> PAGE_CACHE_SHIFT;\n\t\tsize_t off = num_read & (PAGE_CACHE_SIZE - 1);\n\n\t\tfor (i = start_idx; i < req->num_pages; i++) {\n\t\t\tzero_user_segment(req->pages[i], off, PAGE_CACHE_SIZE);\n\t\t\toff = 0;\n\t\t}\n\t} else {\n\t\tloff_t pos = page_offset(req->pages[0]) + num_read;\n\t\tfuse_read_update_size(inode, pos, attr_ver);\n\t}\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_read_update_size",
          "args": [
            "inode",
            "pos",
            "attr_ver"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_read_update_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "645-658",
          "snippet": "static void fuse_read_update_size(struct inode *inode, loff_t size,\n\t\t\t\t  u64 attr_ver)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tspin_lock(&fc->lock);\n\tif (attr_ver == fi->attr_version && size < inode->i_size &&\n\t    !test_bit(FUSE_I_SIZE_UNSTABLE, &fi->state)) {\n\t\tfi->attr_version = ++fc->attr_version;\n\t\ti_size_write(inode, size);\n\t}\n\tspin_unlock(&fc->lock);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_read_update_size(struct inode *inode, loff_t size,\n\t\t\t\t  u64 attr_ver)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tspin_lock(&fc->lock);\n\tif (attr_ver == fi->attr_version && size < inode->i_size &&\n\t    !test_bit(FUSE_I_SIZE_UNSTABLE, &fi->state)) {\n\t\tfi->attr_version = ++fc->attr_version;\n\t\ti_size_write(inode, size);\n\t}\n\tspin_unlock(&fc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "req->pages[0]"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "req->pages[i]",
            "off",
            "PAGE_CACHE_SIZE"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_short_read(struct fuse_req *req, struct inode *inode,\n\t\t\t    u64 attr_ver)\n{\n\tsize_t num_read = req->out.args[0].size;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (fc->writeback_cache) {\n\t\t/*\n\t\t * A hole in a file. Some data after the hole are in page cache,\n\t\t * but have not reached the client fs yet. So, the hole is not\n\t\t * present there.\n\t\t */\n\t\tint i;\n\t\tint start_idx = num_read >> PAGE_CACHE_SHIFT;\n\t\tsize_t off = num_read & (PAGE_CACHE_SIZE - 1);\n\n\t\tfor (i = start_idx; i < req->num_pages; i++) {\n\t\t\tzero_user_segment(req->pages[i], off, PAGE_CACHE_SIZE);\n\t\t\toff = 0;\n\t\t}\n\t} else {\n\t\tloff_t pos = page_offset(req->pages[0]) + num_read;\n\t\tfuse_read_update_size(inode, pos, attr_ver);\n\t}\n}"
  },
  {
    "function_name": "fuse_read_update_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "645-658",
    "snippet": "static void fuse_read_update_size(struct inode *inode, loff_t size,\n\t\t\t\t  u64 attr_ver)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tspin_lock(&fc->lock);\n\tif (attr_ver == fi->attr_version && size < inode->i_size &&\n\t    !test_bit(FUSE_I_SIZE_UNSTABLE, &fi->state)) {\n\t\tfi->attr_version = ++fc->attr_version;\n\t\ti_size_write(inode, size);\n\t}\n\tspin_unlock(&fc->lock);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "size"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "FUSE_I_SIZE_UNSTABLE",
            "&fi->state"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_read_update_size(struct inode *inode, loff_t size,\n\t\t\t\t  u64 attr_ver)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tspin_lock(&fc->lock);\n\tif (attr_ver == fi->attr_version && size < inode->i_size &&\n\t    !test_bit(FUSE_I_SIZE_UNSTABLE, &fi->state)) {\n\t\tfi->attr_version = ++fc->attr_version;\n\t\ti_size_write(inode, size);\n\t}\n\tspin_unlock(&fc->lock);\n}"
  },
  {
    "function_name": "fuse_send_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "623-643",
    "snippet": "static size_t fuse_send_read(struct fuse_req *req, struct fuse_io_priv *io,\n\t\t\t     loff_t pos, size_t count, fl_owner_t owner)\n{\n\tstruct file *file = io->file;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\n\tfuse_read_fill(req, file, pos, count, FUSE_READ);\n\tif (owner != NULL) {\n\t\tstruct fuse_read_in *inarg = &req->misc.read.in;\n\n\t\tinarg->read_flags |= FUSE_READ_LOCKOWNER;\n\t\tinarg->lock_owner = fuse_lock_owner_id(fc, owner);\n\t}\n\n\tif (io->async)\n\t\treturn fuse_async_req_send(fc, req, count, io);\n\n\tfuse_request_send(fc, req);\n\treturn req->out.args[0].size;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_request_send",
          "args": [
            "fc",
            "req"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_send_background_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "647-652",
          "snippet": "void fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_async_req_send",
          "args": [
            "fc",
            "req",
            "count",
            "io"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_async_req_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "606-621",
          "snippet": "static size_t fuse_async_req_send(struct fuse_conn *fc, struct fuse_req *req,\n\t\tsize_t num_bytes, struct fuse_io_priv *io)\n{\n\tspin_lock(&io->lock);\n\tio->size += num_bytes;\n\tio->reqs++;\n\tspin_unlock(&io->lock);\n\n\treq->io = io;\n\treq->end = fuse_aio_complete_req;\n\n\t__fuse_get_request(req);\n\tfuse_request_send_background(fc, req);\n\n\treturn num_bytes;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic size_t fuse_async_req_send(struct fuse_conn *fc, struct fuse_req *req,\n\t\tsize_t num_bytes, struct fuse_io_priv *io)\n{\n\tspin_lock(&io->lock);\n\tio->size += num_bytes;\n\tio->reqs++;\n\tspin_unlock(&io->lock);\n\n\treq->io = io;\n\treq->end = fuse_aio_complete_req;\n\n\t__fuse_get_request(req);\n\tfuse_request_send_background(fc, req);\n\n\treturn num_bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_lock_owner_id",
          "args": [
            "fc",
            "owner"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lock_owner_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "314-330",
          "snippet": "u64 fuse_lock_owner_id(struct fuse_conn *fc, fl_owner_t id)\n{\n\tu32 *k = fc->scramble_key;\n\tu64 v = (unsigned long) id;\n\tu32 v0 = v;\n\tu32 v1 = v >> 32;\n\tu32 sum = 0;\n\tint i;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tv0 += ((v1 << 4 ^ v1 >> 5) + v1) ^ (sum + k[sum & 3]);\n\t\tsum += 0x9E3779B9;\n\t\tv1 += ((v0 << 4 ^ v0 >> 5) + v0) ^ (sum + k[sum>>11 & 3]);\n\t}\n\n\treturn (u64) v0 + ((u64) v1 << 32);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nu64 fuse_lock_owner_id(struct fuse_conn *fc, fl_owner_t id)\n{\n\tu32 *k = fc->scramble_key;\n\tu64 v = (unsigned long) id;\n\tu32 v0 = v;\n\tu32 v1 = v >> 32;\n\tu32 sum = 0;\n\tint i;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tv0 += ((v1 << 4 ^ v1 >> 5) + v1) ^ (sum + k[sum & 3]);\n\t\tsum += 0x9E3779B9;\n\t\tv1 += ((v0 << 4 ^ v0 >> 5) + v0) ^ (sum + k[sum>>11 & 3]);\n\t}\n\n\treturn (u64) v0 + ((u64) v1 << 32);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_read_fill",
          "args": [
            "req",
            "file",
            "pos",
            "count",
            "FUSE_READ"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_read_fill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "499-517",
          "snippet": "void fuse_read_fill(struct fuse_req *req, struct file *file, loff_t pos,\n\t\t    size_t count, int opcode)\n{\n\tstruct fuse_read_in *inarg = &req->misc.read.in;\n\tstruct fuse_file *ff = file->private_data;\n\n\tinarg->fh = ff->fh;\n\tinarg->offset = pos;\n\tinarg->size = count;\n\tinarg->flags = file->f_flags;\n\treq->in.h.opcode = opcode;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(struct fuse_read_in);\n\treq->in.args[0].value = inarg;\n\treq->out.argvar = 1;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = count;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_read_fill(struct fuse_req *req, struct file *file, loff_t pos,\n\t\t    size_t count, int opcode)\n{\n\tstruct fuse_read_in *inarg = &req->misc.read.in;\n\tstruct fuse_file *ff = file->private_data;\n\n\tinarg->fh = ff->fh;\n\tinarg->offset = pos;\n\tinarg->size = count;\n\tinarg->flags = file->f_flags;\n\treq->in.h.opcode = opcode;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(struct fuse_read_in);\n\treq->in.args[0].value = inarg;\n\treq->out.argvar = 1;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic size_t fuse_send_read(struct fuse_req *req, struct fuse_io_priv *io,\n\t\t\t     loff_t pos, size_t count, fl_owner_t owner)\n{\n\tstruct file *file = io->file;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\n\tfuse_read_fill(req, file, pos, count, FUSE_READ);\n\tif (owner != NULL) {\n\t\tstruct fuse_read_in *inarg = &req->misc.read.in;\n\n\t\tinarg->read_flags |= FUSE_READ_LOCKOWNER;\n\t\tinarg->lock_owner = fuse_lock_owner_id(fc, owner);\n\t}\n\n\tif (io->async)\n\t\treturn fuse_async_req_send(fc, req, count, io);\n\n\tfuse_request_send(fc, req);\n\treturn req->out.args[0].size;\n}"
  },
  {
    "function_name": "fuse_async_req_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "606-621",
    "snippet": "static size_t fuse_async_req_send(struct fuse_conn *fc, struct fuse_req *req,\n\t\tsize_t num_bytes, struct fuse_io_priv *io)\n{\n\tspin_lock(&io->lock);\n\tio->size += num_bytes;\n\tio->reqs++;\n\tspin_unlock(&io->lock);\n\n\treq->io = io;\n\treq->end = fuse_aio_complete_req;\n\n\t__fuse_get_request(req);\n\tfuse_request_send_background(fc, req);\n\n\treturn num_bytes;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_request_send_background",
          "args": [
            "fc",
            "req"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_send_background_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "647-652",
          "snippet": "void fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fuse_get_request",
          "args": [
            "req"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "__fuse_get_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "115-118",
          "snippet": "void __fuse_get_request(struct fuse_req *req)\n{\n\tatomic_inc(&req->count);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid __fuse_get_request(struct fuse_req *req)\n{\n\tatomic_inc(&req->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&io->lock"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&io->lock"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic size_t fuse_async_req_send(struct fuse_conn *fc, struct fuse_req *req,\n\t\tsize_t num_bytes, struct fuse_io_priv *io)\n{\n\tspin_lock(&io->lock);\n\tio->size += num_bytes;\n\tio->reqs++;\n\tspin_unlock(&io->lock);\n\n\treq->io = io;\n\treq->end = fuse_aio_complete_req;\n\n\t__fuse_get_request(req);\n\tfuse_request_send_background(fc, req);\n\n\treturn num_bytes;\n}"
  },
  {
    "function_name": "fuse_aio_complete_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "586-604",
    "snippet": "static void fuse_aio_complete_req(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct fuse_io_priv *io = req->io;\n\tssize_t pos = -1;\n\n\tfuse_release_user_pages(req, !io->write);\n\n\tif (io->write) {\n\t\tif (req->misc.write.in.size != req->misc.write.out.size)\n\t\t\tpos = req->misc.write.in.offset - io->offset +\n\t\t\t\treq->misc.write.out.size;\n\t} else {\n\t\tif (req->misc.read.in.size != req->out.args[0].size)\n\t\t\tpos = req->misc.read.in.offset - io->offset +\n\t\t\t\treq->out.args[0].size;\n\t}\n\n\tfuse_aio_complete(io, req->out.h.error, pos);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_aio_complete",
          "args": [
            "io",
            "req->out.h.error",
            "pos"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_aio_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "547-584",
          "snippet": "static void fuse_aio_complete(struct fuse_io_priv *io, int err, ssize_t pos)\n{\n\tint left;\n\n\tspin_lock(&io->lock);\n\tif (err)\n\t\tio->err = io->err ? : err;\n\telse if (pos >= 0 && (io->bytes < 0 || pos < io->bytes))\n\t\tio->bytes = pos;\n\n\tleft = --io->reqs;\n\tspin_unlock(&io->lock);\n\n\tif (!left) {\n\t\tlong res;\n\n\t\tif (io->err)\n\t\t\tres = io->err;\n\t\telse if (io->bytes >= 0 && io->write)\n\t\t\tres = -EIO;\n\t\telse {\n\t\t\tres = io->bytes < 0 ? io->size : io->bytes;\n\n\t\t\tif (!is_sync_kiocb(io->iocb)) {\n\t\t\t\tstruct inode *inode = file_inode(io->iocb->ki_filp);\n\t\t\t\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\t\t\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\t\t\tspin_lock(&fc->lock);\n\t\t\t\tfi->attr_version = ++fc->attr_version;\n\t\t\t\tspin_unlock(&fc->lock);\n\t\t\t}\n\t\t}\n\n\t\taio_complete(io->iocb, res, 0);\n\t\tkfree(io);\n\t}\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_aio_complete(struct fuse_io_priv *io, int err, ssize_t pos)\n{\n\tint left;\n\n\tspin_lock(&io->lock);\n\tif (err)\n\t\tio->err = io->err ? : err;\n\telse if (pos >= 0 && (io->bytes < 0 || pos < io->bytes))\n\t\tio->bytes = pos;\n\n\tleft = --io->reqs;\n\tspin_unlock(&io->lock);\n\n\tif (!left) {\n\t\tlong res;\n\n\t\tif (io->err)\n\t\t\tres = io->err;\n\t\telse if (io->bytes >= 0 && io->write)\n\t\t\tres = -EIO;\n\t\telse {\n\t\t\tres = io->bytes < 0 ? io->size : io->bytes;\n\n\t\t\tif (!is_sync_kiocb(io->iocb)) {\n\t\t\t\tstruct inode *inode = file_inode(io->iocb->ki_filp);\n\t\t\t\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\t\t\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\t\t\tspin_lock(&fc->lock);\n\t\t\t\tfi->attr_version = ++fc->attr_version;\n\t\t\t\tspin_unlock(&fc->lock);\n\t\t\t}\n\t\t}\n\n\t\taio_complete(io->iocb, res, 0);\n\t\tkfree(io);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_release_user_pages",
          "args": [
            "req",
            "!io->write"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_release_user_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "519-529",
          "snippet": "static void fuse_release_user_pages(struct fuse_req *req, int write)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tstruct page *page = req->pages[i];\n\t\tif (write)\n\t\t\tset_page_dirty_lock(page);\n\t\tput_page(page);\n\t}\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_release_user_pages(struct fuse_req *req, int write)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tstruct page *page = req->pages[i];\n\t\tif (write)\n\t\t\tset_page_dirty_lock(page);\n\t\tput_page(page);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_aio_complete_req(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct fuse_io_priv *io = req->io;\n\tssize_t pos = -1;\n\n\tfuse_release_user_pages(req, !io->write);\n\n\tif (io->write) {\n\t\tif (req->misc.write.in.size != req->misc.write.out.size)\n\t\t\tpos = req->misc.write.in.offset - io->offset +\n\t\t\t\treq->misc.write.out.size;\n\t} else {\n\t\tif (req->misc.read.in.size != req->out.args[0].size)\n\t\t\tpos = req->misc.read.in.offset - io->offset +\n\t\t\t\treq->out.args[0].size;\n\t}\n\n\tfuse_aio_complete(io, req->out.h.error, pos);\n}"
  },
  {
    "function_name": "fuse_aio_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "547-584",
    "snippet": "static void fuse_aio_complete(struct fuse_io_priv *io, int err, ssize_t pos)\n{\n\tint left;\n\n\tspin_lock(&io->lock);\n\tif (err)\n\t\tio->err = io->err ? : err;\n\telse if (pos >= 0 && (io->bytes < 0 || pos < io->bytes))\n\t\tio->bytes = pos;\n\n\tleft = --io->reqs;\n\tspin_unlock(&io->lock);\n\n\tif (!left) {\n\t\tlong res;\n\n\t\tif (io->err)\n\t\t\tres = io->err;\n\t\telse if (io->bytes >= 0 && io->write)\n\t\t\tres = -EIO;\n\t\telse {\n\t\t\tres = io->bytes < 0 ? io->size : io->bytes;\n\n\t\t\tif (!is_sync_kiocb(io->iocb)) {\n\t\t\t\tstruct inode *inode = file_inode(io->iocb->ki_filp);\n\t\t\t\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\t\t\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\t\t\tspin_lock(&fc->lock);\n\t\t\t\tfi->attr_version = ++fc->attr_version;\n\t\t\t\tspin_unlock(&fc->lock);\n\t\t\t}\n\t\t}\n\n\t\taio_complete(io->iocb, res, 0);\n\t\tkfree(io);\n\t}\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "io"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aio_complete",
          "args": [
            "io->iocb",
            "res",
            "0"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_aio_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "547-584",
          "snippet": "static void fuse_aio_complete(struct fuse_io_priv *io, int err, ssize_t pos)\n{\n\tint left;\n\n\tspin_lock(&io->lock);\n\tif (err)\n\t\tio->err = io->err ? : err;\n\telse if (pos >= 0 && (io->bytes < 0 || pos < io->bytes))\n\t\tio->bytes = pos;\n\n\tleft = --io->reqs;\n\tspin_unlock(&io->lock);\n\n\tif (!left) {\n\t\tlong res;\n\n\t\tif (io->err)\n\t\t\tres = io->err;\n\t\telse if (io->bytes >= 0 && io->write)\n\t\t\tres = -EIO;\n\t\telse {\n\t\t\tres = io->bytes < 0 ? io->size : io->bytes;\n\n\t\t\tif (!is_sync_kiocb(io->iocb)) {\n\t\t\t\tstruct inode *inode = file_inode(io->iocb->ki_filp);\n\t\t\t\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\t\t\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\t\t\tspin_lock(&fc->lock);\n\t\t\t\tfi->attr_version = ++fc->attr_version;\n\t\t\t\tspin_unlock(&fc->lock);\n\t\t\t}\n\t\t}\n\n\t\taio_complete(io->iocb, res, 0);\n\t\tkfree(io);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "io->iocb->ki_filp"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_sync_kiocb",
          "args": [
            "io->iocb"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_aio_complete(struct fuse_io_priv *io, int err, ssize_t pos)\n{\n\tint left;\n\n\tspin_lock(&io->lock);\n\tif (err)\n\t\tio->err = io->err ? : err;\n\telse if (pos >= 0 && (io->bytes < 0 || pos < io->bytes))\n\t\tio->bytes = pos;\n\n\tleft = --io->reqs;\n\tspin_unlock(&io->lock);\n\n\tif (!left) {\n\t\tlong res;\n\n\t\tif (io->err)\n\t\t\tres = io->err;\n\t\telse if (io->bytes >= 0 && io->write)\n\t\t\tres = -EIO;\n\t\telse {\n\t\t\tres = io->bytes < 0 ? io->size : io->bytes;\n\n\t\t\tif (!is_sync_kiocb(io->iocb)) {\n\t\t\t\tstruct inode *inode = file_inode(io->iocb->ki_filp);\n\t\t\t\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\t\t\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\t\t\tspin_lock(&fc->lock);\n\t\t\t\tfi->attr_version = ++fc->attr_version;\n\t\t\t\tspin_unlock(&fc->lock);\n\t\t\t}\n\t\t}\n\n\t\taio_complete(io->iocb, res, 0);\n\t\tkfree(io);\n\t}\n}"
  },
  {
    "function_name": "fuse_release_user_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "519-529",
    "snippet": "static void fuse_release_user_pages(struct fuse_req *req, int write)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tstruct page *page = req->pages[i];\n\t\tif (write)\n\t\t\tset_page_dirty_lock(page);\n\t\tput_page(page);\n\t}\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "181-185",
          "snippet": "static inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty_lock",
          "args": [
            "page"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_release_user_pages(struct fuse_req *req, int write)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tstruct page *page = req->pages[i];\n\t\tif (write)\n\t\t\tset_page_dirty_lock(page);\n\t\tput_page(page);\n\t}\n}"
  },
  {
    "function_name": "fuse_read_fill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "499-517",
    "snippet": "void fuse_read_fill(struct fuse_req *req, struct file *file, loff_t pos,\n\t\t    size_t count, int opcode)\n{\n\tstruct fuse_read_in *inarg = &req->misc.read.in;\n\tstruct fuse_file *ff = file->private_data;\n\n\tinarg->fh = ff->fh;\n\tinarg->offset = pos;\n\tinarg->size = count;\n\tinarg->flags = file->f_flags;\n\treq->in.h.opcode = opcode;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(struct fuse_read_in);\n\treq->in.args[0].value = inarg;\n\treq->out.argvar = 1;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = count;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_read_fill(struct fuse_req *req, struct file *file, loff_t pos,\n\t\t    size_t count, int opcode)\n{\n\tstruct fuse_read_in *inarg = &req->misc.read.in;\n\tstruct fuse_file *ff = file->private_data;\n\n\tinarg->fh = ff->fh;\n\tinarg->offset = pos;\n\tinarg->size = count;\n\tinarg->flags = file->f_flags;\n\treq->in.h.opcode = opcode;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(struct fuse_read_in);\n\treq->in.args[0].value = inarg;\n\treq->out.argvar = 1;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = count;\n}"
  },
  {
    "function_name": "fuse_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "493-497",
    "snippet": "static int fuse_fsync(struct file *file, loff_t start, loff_t end,\n\t\t      int datasync)\n{\n\treturn fuse_fsync_common(file, start, end, datasync, 0);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_fsync_common",
          "args": [
            "file",
            "start",
            "end",
            "datasync",
            "0"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_fsync_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "440-491",
          "snippet": "int fuse_fsync_common(struct file *file, loff_t start, loff_t end,\n\t\t      int datasync, int isdir)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_file *ff = file->private_data;\n\tFUSE_ARGS(args);\n\tstruct fuse_fsync_in inarg;\n\tint err;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * Start writeback against all dirty pages of the inode, then\n\t * wait for all outstanding writes, before sending the FSYNC\n\t * request.\n\t */\n\terr = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (err)\n\t\tgoto out;\n\n\tfuse_sync_writes(inode);\n\terr = sync_inode_metadata(inode, 1);\n\tif (err)\n\t\tgoto out;\n\n\tif ((!isdir && fc->no_fsync) || (isdir && fc->no_fsyncdir))\n\t\tgoto out;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.fh = ff->fh;\n\tinarg.fsync_flags = datasync ? 1 : 0;\n\targs.in.h.opcode = isdir ? FUSE_FSYNCDIR : FUSE_FSYNC;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (err == -ENOSYS) {\n\t\tif (isdir)\n\t\t\tfc->no_fsyncdir = 1;\n\t\telse\n\t\t\tfc->no_fsync = 1;\n\t\terr = 0;\n\t}\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn err;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_fsync_common(struct file *file, loff_t start, loff_t end,\n\t\t      int datasync, int isdir)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_file *ff = file->private_data;\n\tFUSE_ARGS(args);\n\tstruct fuse_fsync_in inarg;\n\tint err;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * Start writeback against all dirty pages of the inode, then\n\t * wait for all outstanding writes, before sending the FSYNC\n\t * request.\n\t */\n\terr = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (err)\n\t\tgoto out;\n\n\tfuse_sync_writes(inode);\n\terr = sync_inode_metadata(inode, 1);\n\tif (err)\n\t\tgoto out;\n\n\tif ((!isdir && fc->no_fsync) || (isdir && fc->no_fsyncdir))\n\t\tgoto out;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.fh = ff->fh;\n\tinarg.fsync_flags = datasync ? 1 : 0;\n\targs.in.h.opcode = isdir ? FUSE_FSYNCDIR : FUSE_FSYNC;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (err == -ENOSYS) {\n\t\tif (isdir)\n\t\t\tfc->no_fsyncdir = 1;\n\t\telse\n\t\t\tfc->no_fsync = 1;\n\t\terr = 0;\n\t}\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_fsync(struct file *file, loff_t start, loff_t end,\n\t\t      int datasync)\n{\n\treturn fuse_fsync_common(file, start, end, datasync, 0);\n}"
  },
  {
    "function_name": "fuse_fsync_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "440-491",
    "snippet": "int fuse_fsync_common(struct file *file, loff_t start, loff_t end,\n\t\t      int datasync, int isdir)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_file *ff = file->private_data;\n\tFUSE_ARGS(args);\n\tstruct fuse_fsync_in inarg;\n\tint err;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * Start writeback against all dirty pages of the inode, then\n\t * wait for all outstanding writes, before sending the FSYNC\n\t * request.\n\t */\n\terr = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (err)\n\t\tgoto out;\n\n\tfuse_sync_writes(inode);\n\terr = sync_inode_metadata(inode, 1);\n\tif (err)\n\t\tgoto out;\n\n\tif ((!isdir && fc->no_fsync) || (isdir && fc->no_fsyncdir))\n\t\tgoto out;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.fh = ff->fh;\n\tinarg.fsync_flags = datasync ? 1 : 0;\n\targs.in.h.opcode = isdir ? FUSE_FSYNCDIR : FUSE_FSYNC;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (err == -ENOSYS) {\n\t\tif (isdir)\n\t\t\tfc->no_fsyncdir = 1;\n\t\telse\n\t\t\tfc->no_fsync = 1;\n\t\terr = 0;\n\t}\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn err;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_simple_request",
          "args": [
            "fc",
            "&args"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_simple_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "558-588",
          "snippet": "ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_id",
          "args": [
            "inode"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "633-636",
          "snippet": "static inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&inarg",
            "0",
            "sizeof(inarg)"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_inode_metadata",
          "args": [
            "inode",
            "1"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "sync_inode_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1513-1521",
          "snippet": "int sync_inode_metadata(struct inode *inode, int wait)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = wait ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.nr_to_write = 0, /* metadata-only */\n\t};\n\n\treturn sync_inode(inode, &wbc);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint sync_inode_metadata(struct inode *inode, int wait)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = wait ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.nr_to_write = 0, /* metadata-only */\n\t};\n\n\treturn sync_inode(inode, &wbc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_sync_writes",
          "args": [
            "inode"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_sync_writes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "391-395",
          "snippet": "static void fuse_sync_writes(struct inode *inode)\n{\n\tfuse_set_nowrite(inode);\n\tfuse_release_nowrite(inode);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_sync_writes(struct inode *inode)\n{\n\tfuse_set_nowrite(inode);\n\tfuse_release_nowrite(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "inode->i_mapping",
            "start",
            "end"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUSE_ARGS",
          "args": [
            "args"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_fsync_common(struct file *file, loff_t start, loff_t end,\n\t\t      int datasync, int isdir)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_file *ff = file->private_data;\n\tFUSE_ARGS(args);\n\tstruct fuse_fsync_in inarg;\n\tint err;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * Start writeback against all dirty pages of the inode, then\n\t * wait for all outstanding writes, before sending the FSYNC\n\t * request.\n\t */\n\terr = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (err)\n\t\tgoto out;\n\n\tfuse_sync_writes(inode);\n\terr = sync_inode_metadata(inode, 1);\n\tif (err)\n\t\tgoto out;\n\n\tif ((!isdir && fc->no_fsync) || (isdir && fc->no_fsyncdir))\n\t\tgoto out;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.fh = ff->fh;\n\tinarg.fsync_flags = datasync ? 1 : 0;\n\targs.in.h.opcode = isdir ? FUSE_FSYNCDIR : FUSE_FSYNC;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (err == -ENOSYS) {\n\t\tif (isdir)\n\t\t\tfc->no_fsyncdir = 1;\n\t\telse\n\t\t\tfc->no_fsync = 1;\n\t\terr = 0;\n\t}\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "397-438",
    "snippet": "static int fuse_flush(struct file *file, fl_owner_t id)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_req *req;\n\tstruct fuse_flush_in inarg;\n\tint err;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tif (fc->no_flush)\n\t\treturn 0;\n\n\terr = write_inode_now(inode, 1);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&inode->i_mutex);\n\tfuse_sync_writes(inode);\n\tmutex_unlock(&inode->i_mutex);\n\n\treq = fuse_get_req_nofail_nopages(fc, file);\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.fh = ff->fh;\n\tinarg.lock_owner = fuse_lock_owner_id(fc, id);\n\treq->in.h.opcode = FUSE_FLUSH;\n\treq->in.h.nodeid = get_node_id(inode);\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\treq->force = 1;\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\tfuse_put_request(fc, req);\n\tif (err == -ENOSYS) {\n\t\tfc->no_flush = 1;\n\t\terr = 0;\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_put_request",
          "args": [
            "fc",
            "req"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "277-299",
          "snippet": "void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_request_send",
          "args": [
            "fc",
            "req"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_send_background_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "647-652",
          "snippet": "void fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_id",
          "args": [
            "inode"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "633-636",
          "snippet": "static inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_lock_owner_id",
          "args": [
            "fc",
            "id"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lock_owner_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "314-330",
          "snippet": "u64 fuse_lock_owner_id(struct fuse_conn *fc, fl_owner_t id)\n{\n\tu32 *k = fc->scramble_key;\n\tu64 v = (unsigned long) id;\n\tu32 v0 = v;\n\tu32 v1 = v >> 32;\n\tu32 sum = 0;\n\tint i;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tv0 += ((v1 << 4 ^ v1 >> 5) + v1) ^ (sum + k[sum & 3]);\n\t\tsum += 0x9E3779B9;\n\t\tv1 += ((v0 << 4 ^ v0 >> 5) + v0) ^ (sum + k[sum>>11 & 3]);\n\t}\n\n\treturn (u64) v0 + ((u64) v1 << 32);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nu64 fuse_lock_owner_id(struct fuse_conn *fc, fl_owner_t id)\n{\n\tu32 *k = fc->scramble_key;\n\tu64 v = (unsigned long) id;\n\tu32 v0 = v;\n\tu32 v1 = v >> 32;\n\tu32 sum = 0;\n\tint i;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tv0 += ((v1 << 4 ^ v1 >> 5) + v1) ^ (sum + k[sum & 3]);\n\t\tsum += 0x9E3779B9;\n\t\tv1 += ((v0 << 4 ^ v0 >> 5) + v0) ^ (sum + k[sum>>11 & 3]);\n\t}\n\n\treturn (u64) v0 + ((u64) v1 << 32);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&inarg",
            "0",
            "sizeof(inarg)"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_get_req_nofail_nopages",
          "args": [
            "fc",
            "file"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_req_nofail_nopages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "258-275",
          "snippet": "struct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc,\n\t\t\t\t\t     struct file *file)\n{\n\tstruct fuse_req *req;\n\n\tatomic_inc(&fc->num_waiting);\n\twait_event(fc->blocked_waitq, fc->initialized);\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\treq = fuse_request_alloc(0);\n\tif (!req)\n\t\treq = get_reserved_req(fc, file);\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = 0;\n\treturn req;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstruct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc,\n\t\t\t\t\t     struct file *file)\n{\n\tstruct fuse_req *req;\n\n\tatomic_inc(&fc->num_waiting);\n\twait_event(fc->blocked_waitq, fc->initialized);\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\treq = fuse_request_alloc(0);\n\tif (!req)\n\t\treq = get_reserved_req(fc, file);\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = 0;\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_sync_writes",
          "args": [
            "inode"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_sync_writes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "391-395",
          "snippet": "static void fuse_sync_writes(struct inode *inode)\n{\n\tfuse_set_nowrite(inode);\n\tfuse_release_nowrite(inode);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_sync_writes(struct inode *inode)\n{\n\tfuse_set_nowrite(inode);\n\tfuse_release_nowrite(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_inode_now",
          "args": [
            "inode",
            "1"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "write_inode_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1469-1484",
          "snippet": "int write_inode_now(struct inode *inode, int sync)\n{\n\tstruct bdi_writeback *wb = &inode_to_bdi(inode)->wb;\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, wb, &wbc);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint write_inode_now(struct inode *inode, int sync)\n{\n\tstruct bdi_writeback *wb = &inode_to_bdi(inode)->wb;\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, wb, &wbc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_flush(struct file *file, fl_owner_t id)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_req *req;\n\tstruct fuse_flush_in inarg;\n\tint err;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tif (fc->no_flush)\n\t\treturn 0;\n\n\terr = write_inode_now(inode, 1);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&inode->i_mutex);\n\tfuse_sync_writes(inode);\n\tmutex_unlock(&inode->i_mutex);\n\n\treq = fuse_get_req_nofail_nopages(fc, file);\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.fh = ff->fh;\n\tinarg.lock_owner = fuse_lock_owner_id(fc, id);\n\treq->in.h.opcode = FUSE_FLUSH;\n\treq->in.h.nodeid = get_node_id(inode);\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\treq->force = 1;\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\tfuse_put_request(fc, req);\n\tif (err == -ENOSYS) {\n\t\tfc->no_flush = 1;\n\t\terr = 0;\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_sync_writes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "391-395",
    "snippet": "static void fuse_sync_writes(struct inode *inode)\n{\n\tfuse_set_nowrite(inode);\n\tfuse_release_nowrite(inode);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_release_nowrite",
          "args": [
            "inode"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_release_nowrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "1543-1550",
          "snippet": "void fuse_release_nowrite(struct inode *inode)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tspin_lock(&fc->lock);\n\t__fuse_release_nowrite(inode);\n\tspin_unlock(&fc->lock);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_release_nowrite(struct inode *inode)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tspin_lock(&fc->lock);\n\t__fuse_release_nowrite(inode);\n\tspin_unlock(&fc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_set_nowrite",
          "args": [
            "inode"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_set_nowrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "1514-1526",
          "snippet": "void fuse_set_nowrite(struct inode *inode)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tBUG_ON(!mutex_is_locked(&inode->i_mutex));\n\n\tspin_lock(&fc->lock);\n\tBUG_ON(fi->writectr < 0);\n\tfi->writectr += FUSE_NOWRITE;\n\tspin_unlock(&fc->lock);\n\twait_event(fi->page_waitq, fi->writectr == FUSE_NOWRITE);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_set_nowrite(struct inode *inode)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tBUG_ON(!mutex_is_locked(&inode->i_mutex));\n\n\tspin_lock(&fc->lock);\n\tBUG_ON(fi->writectr < 0);\n\tfi->writectr += FUSE_NOWRITE;\n\tspin_unlock(&fc->lock);\n\twait_event(fi->page_waitq, fi->writectr == FUSE_NOWRITE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_sync_writes(struct inode *inode)\n{\n\tfuse_set_nowrite(inode);\n\tfuse_release_nowrite(inode);\n}"
  },
  {
    "function_name": "fuse_wait_on_page_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "374-380",
    "snippet": "static int fuse_wait_on_page_writeback(struct inode *inode, pgoff_t index)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\twait_event(fi->page_waitq, !fuse_page_is_writeback(inode, index));\n\treturn 0;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "fi->page_waitq",
            "!fuse_page_is_writeback(inode, index)"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_page_is_writeback",
          "args": [
            "inode",
            "index"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_page_is_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "363-366",
          "snippet": "static inline bool fuse_page_is_writeback(struct inode *inode, pgoff_t index)\n{\n\treturn fuse_range_is_writeback(inode, index, index);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline bool fuse_page_is_writeback(struct inode *inode, pgoff_t index)\n{\n\treturn fuse_range_is_writeback(inode, index, index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_wait_on_page_writeback(struct inode *inode, pgoff_t index)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\twait_event(fi->page_waitq, !fuse_page_is_writeback(inode, index));\n\treturn 0;\n}"
  },
  {
    "function_name": "fuse_page_is_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "363-366",
    "snippet": "static inline bool fuse_page_is_writeback(struct inode *inode, pgoff_t index)\n{\n\treturn fuse_range_is_writeback(inode, index, index);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_range_is_writeback",
          "args": [
            "inode",
            "index",
            "index"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_range_is_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "338-361",
          "snippet": "static bool fuse_range_is_writeback(struct inode *inode, pgoff_t idx_from,\n\t\t\t\t   pgoff_t idx_to)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_req *req;\n\tbool found = false;\n\n\tspin_lock(&fc->lock);\n\tlist_for_each_entry(req, &fi->writepages, writepages_entry) {\n\t\tpgoff_t curr_index;\n\n\t\tBUG_ON(req->inode != inode);\n\t\tcurr_index = req->misc.write.in.offset >> PAGE_CACHE_SHIFT;\n\t\tif (idx_from < curr_index + req->num_pages &&\n\t\t    curr_index <= idx_to) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn found;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic bool fuse_range_is_writeback(struct inode *inode, pgoff_t idx_from,\n\t\t\t\t   pgoff_t idx_to)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_req *req;\n\tbool found = false;\n\n\tspin_lock(&fc->lock);\n\tlist_for_each_entry(req, &fi->writepages, writepages_entry) {\n\t\tpgoff_t curr_index;\n\n\t\tBUG_ON(req->inode != inode);\n\t\tcurr_index = req->misc.write.in.offset >> PAGE_CACHE_SHIFT;\n\t\tif (idx_from < curr_index + req->num_pages &&\n\t\t    curr_index <= idx_to) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline bool fuse_page_is_writeback(struct inode *inode, pgoff_t index)\n{\n\treturn fuse_range_is_writeback(inode, index, index);\n}"
  },
  {
    "function_name": "fuse_range_is_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "338-361",
    "snippet": "static bool fuse_range_is_writeback(struct inode *inode, pgoff_t idx_from,\n\t\t\t\t   pgoff_t idx_to)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_req *req;\n\tbool found = false;\n\n\tspin_lock(&fc->lock);\n\tlist_for_each_entry(req, &fi->writepages, writepages_entry) {\n\t\tpgoff_t curr_index;\n\n\t\tBUG_ON(req->inode != inode);\n\t\tcurr_index = req->misc.write.in.offset >> PAGE_CACHE_SHIFT;\n\t\tif (idx_from < curr_index + req->num_pages &&\n\t\t    curr_index <= idx_to) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn found;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "req->inode != inode"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "req",
            "&fi->writepages",
            "writepages_entry"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic bool fuse_range_is_writeback(struct inode *inode, pgoff_t idx_from,\n\t\t\t\t   pgoff_t idx_to)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_req *req;\n\tbool found = false;\n\n\tspin_lock(&fc->lock);\n\tlist_for_each_entry(req, &fi->writepages, writepages_entry) {\n\t\tpgoff_t curr_index;\n\n\t\tBUG_ON(req->inode != inode);\n\t\tcurr_index = req->misc.write.in.offset >> PAGE_CACHE_SHIFT;\n\t\tif (idx_from < curr_index + req->num_pages &&\n\t\t    curr_index <= idx_to) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn found;\n}"
  },
  {
    "function_name": "fuse_lock_owner_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "314-330",
    "snippet": "u64 fuse_lock_owner_id(struct fuse_conn *fc, fl_owner_t id)\n{\n\tu32 *k = fc->scramble_key;\n\tu64 v = (unsigned long) id;\n\tu32 v0 = v;\n\tu32 v1 = v >> 32;\n\tu32 sum = 0;\n\tint i;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tv0 += ((v1 << 4 ^ v1 >> 5) + v1) ^ (sum + k[sum & 3]);\n\t\tsum += 0x9E3779B9;\n\t\tv1 += ((v0 << 4 ^ v0 >> 5) + v0) ^ (sum + k[sum>>11 & 3]);\n\t}\n\n\treturn (u64) v0 + ((u64) v1 << 32);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nu64 fuse_lock_owner_id(struct fuse_conn *fc, fl_owner_t id)\n{\n\tu32 *k = fc->scramble_key;\n\tu64 v = (unsigned long) id;\n\tu32 v0 = v;\n\tu32 v1 = v >> 32;\n\tu32 sum = 0;\n\tint i;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tv0 += ((v1 << 4 ^ v1 >> 5) + v1) ^ (sum + k[sum & 3]);\n\t\tsum += 0x9E3779B9;\n\t\tv1 += ((v0 << 4 ^ v0 >> 5) + v0) ^ (sum + k[sum>>11 & 3]);\n\t}\n\n\treturn (u64) v0 + ((u64) v1 << 32);\n}"
  },
  {
    "function_name": "fuse_sync_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "298-307",
    "snippet": "void fuse_sync_release(struct fuse_file *ff, int flags)\n{\n\tWARN_ON(atomic_read(&ff->count) > 1);\n\tfuse_prepare_release(ff, flags, FUSE_RELEASE);\n\tff->reserved_req->force = 1;\n\tff->reserved_req->background = 0;\n\tfuse_request_send(ff->fc, ff->reserved_req);\n\tfuse_put_request(ff->fc, ff->reserved_req);\n\tkfree(ff);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ff"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_put_request",
          "args": [
            "ff->fc",
            "ff->reserved_req"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "277-299",
          "snippet": "void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_request_send",
          "args": [
            "ff->fc",
            "ff->reserved_req"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_send_background_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "647-652",
          "snippet": "void fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_prepare_release",
          "args": [
            "ff",
            "flags",
            "FUSE_RELEASE"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_prepare_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "223-244",
          "snippet": "static void fuse_prepare_release(struct fuse_file *ff, int flags, int opcode)\n{\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_req *req = ff->reserved_req;\n\tstruct fuse_release_in *inarg = &req->misc.release.in;\n\n\tspin_lock(&fc->lock);\n\tlist_del(&ff->write_entry);\n\tif (!RB_EMPTY_NODE(&ff->polled_node))\n\t\trb_erase(&ff->polled_node, &fc->polled_files);\n\tspin_unlock(&fc->lock);\n\n\twake_up_interruptible_all(&ff->poll_wait);\n\n\tinarg->fh = ff->fh;\n\tinarg->flags = flags;\n\treq->in.h.opcode = opcode;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(struct fuse_release_in);\n\treq->in.args[0].value = inarg;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_prepare_release(struct fuse_file *ff, int flags, int opcode)\n{\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_req *req = ff->reserved_req;\n\tstruct fuse_release_in *inarg = &req->misc.release.in;\n\n\tspin_lock(&fc->lock);\n\tlist_del(&ff->write_entry);\n\tif (!RB_EMPTY_NODE(&ff->polled_node))\n\t\trb_erase(&ff->polled_node, &fc->polled_files);\n\tspin_unlock(&fc->lock);\n\n\twake_up_interruptible_all(&ff->poll_wait);\n\n\tinarg->fh = ff->fh;\n\tinarg->flags = flags;\n\treq->in.h.opcode = opcode;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(struct fuse_release_in);\n\treq->in.args[0].value = inarg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_read(&ff->count) > 1"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ff->count"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_sync_release(struct fuse_file *ff, int flags)\n{\n\tWARN_ON(atomic_read(&ff->count) > 1);\n\tfuse_prepare_release(ff, flags, FUSE_RELEASE);\n\tff->reserved_req->force = 1;\n\tff->reserved_req->background = 0;\n\tfuse_request_send(ff->fc, ff->reserved_req);\n\tfuse_put_request(ff->fc, ff->reserved_req);\n\tkfree(ff);\n}"
  },
  {
    "function_name": "fuse_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "284-296",
    "snippet": "static int fuse_release(struct inode *inode, struct file *file)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\t/* see fuse_vma_close() for !writeback_cache case */\n\tif (fc->writeback_cache)\n\t\twrite_inode_now(inode, 1);\n\n\tfuse_release_common(file, FUSE_RELEASE);\n\n\t/* return value is ignored by VFS */\n\treturn 0;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_release_common",
          "args": [
            "file",
            "FUSE_RELEASE"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_release_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "246-277",
          "snippet": "void fuse_release_common(struct file *file, int opcode)\n{\n\tstruct fuse_file *ff;\n\tstruct fuse_req *req;\n\n\tff = file->private_data;\n\tif (unlikely(!ff))\n\t\treturn;\n\n\treq = ff->reserved_req;\n\tfuse_prepare_release(ff, file->f_flags, opcode);\n\n\tif (ff->flock) {\n\t\tstruct fuse_release_in *inarg = &req->misc.release.in;\n\t\tinarg->release_flags |= FUSE_RELEASE_FLOCK_UNLOCK;\n\t\tinarg->lock_owner = fuse_lock_owner_id(ff->fc,\n\t\t\t\t\t\t       (fl_owner_t) file);\n\t}\n\t/* Hold inode until release is finished */\n\treq->misc.release.inode = igrab(file_inode(file));\n\n\t/*\n\t * Normally this will send the RELEASE request, however if\n\t * some asynchronous READ or WRITE requests are outstanding,\n\t * the sending will be delayed.\n\t *\n\t * Make the release synchronous if this is a fuseblk mount,\n\t * synchronous RELEASE is allowed (and desirable) in this case\n\t * because the server can be trusted not to screw up.\n\t */\n\tfuse_file_put(ff, ff->fc->destroy_req != NULL);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_release_common(struct file *file, int opcode)\n{\n\tstruct fuse_file *ff;\n\tstruct fuse_req *req;\n\n\tff = file->private_data;\n\tif (unlikely(!ff))\n\t\treturn;\n\n\treq = ff->reserved_req;\n\tfuse_prepare_release(ff, file->f_flags, opcode);\n\n\tif (ff->flock) {\n\t\tstruct fuse_release_in *inarg = &req->misc.release.in;\n\t\tinarg->release_flags |= FUSE_RELEASE_FLOCK_UNLOCK;\n\t\tinarg->lock_owner = fuse_lock_owner_id(ff->fc,\n\t\t\t\t\t\t       (fl_owner_t) file);\n\t}\n\t/* Hold inode until release is finished */\n\treq->misc.release.inode = igrab(file_inode(file));\n\n\t/*\n\t * Normally this will send the RELEASE request, however if\n\t * some asynchronous READ or WRITE requests are outstanding,\n\t * the sending will be delayed.\n\t *\n\t * Make the release synchronous if this is a fuseblk mount,\n\t * synchronous RELEASE is allowed (and desirable) in this case\n\t * because the server can be trusted not to screw up.\n\t */\n\tfuse_file_put(ff, ff->fc->destroy_req != NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_inode_now",
          "args": [
            "inode",
            "1"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "write_inode_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1469-1484",
          "snippet": "int write_inode_now(struct inode *inode, int sync)\n{\n\tstruct bdi_writeback *wb = &inode_to_bdi(inode)->wb;\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, wb, &wbc);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint write_inode_now(struct inode *inode, int sync)\n{\n\tstruct bdi_writeback *wb = &inode_to_bdi(inode)->wb;\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, wb, &wbc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_release(struct inode *inode, struct file *file)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\t/* see fuse_vma_close() for !writeback_cache case */\n\tif (fc->writeback_cache)\n\t\twrite_inode_now(inode, 1);\n\n\tfuse_release_common(file, FUSE_RELEASE);\n\n\t/* return value is ignored by VFS */\n\treturn 0;\n}"
  },
  {
    "function_name": "fuse_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "279-282",
    "snippet": "static int fuse_open(struct inode *inode, struct file *file)\n{\n\treturn fuse_open_common(inode, file, false);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_open_common",
          "args": [
            "inode",
            "file",
            "false"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_open_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "197-221",
          "snippet": "int fuse_open_common(struct inode *inode, struct file *file, bool isdir)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tint err;\n\tbool lock_inode = (file->f_flags & O_TRUNC) &&\n\t\t\t  fc->atomic_o_trunc &&\n\t\t\t  fc->writeback_cache;\n\n\terr = generic_file_open(inode, file);\n\tif (err)\n\t\treturn err;\n\n\tif (lock_inode)\n\t\tmutex_lock(&inode->i_mutex);\n\n\terr = fuse_do_open(fc, get_node_id(inode), file, isdir);\n\n\tif (!err)\n\t\tfuse_finish_open(inode, file);\n\n\tif (lock_inode)\n\t\tmutex_unlock(&inode->i_mutex);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_open_common(struct inode *inode, struct file *file, bool isdir)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tint err;\n\tbool lock_inode = (file->f_flags & O_TRUNC) &&\n\t\t\t  fc->atomic_o_trunc &&\n\t\t\t  fc->writeback_cache;\n\n\terr = generic_file_open(inode, file);\n\tif (err)\n\t\treturn err;\n\n\tif (lock_inode)\n\t\tmutex_lock(&inode->i_mutex);\n\n\terr = fuse_do_open(fc, get_node_id(inode), file, isdir);\n\n\tif (!err)\n\t\tfuse_finish_open(inode, file);\n\n\tif (lock_inode)\n\t\tmutex_unlock(&inode->i_mutex);\n\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_open(struct inode *inode, struct file *file)\n{\n\treturn fuse_open_common(inode, file, false);\n}"
  },
  {
    "function_name": "fuse_release_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "246-277",
    "snippet": "void fuse_release_common(struct file *file, int opcode)\n{\n\tstruct fuse_file *ff;\n\tstruct fuse_req *req;\n\n\tff = file->private_data;\n\tif (unlikely(!ff))\n\t\treturn;\n\n\treq = ff->reserved_req;\n\tfuse_prepare_release(ff, file->f_flags, opcode);\n\n\tif (ff->flock) {\n\t\tstruct fuse_release_in *inarg = &req->misc.release.in;\n\t\tinarg->release_flags |= FUSE_RELEASE_FLOCK_UNLOCK;\n\t\tinarg->lock_owner = fuse_lock_owner_id(ff->fc,\n\t\t\t\t\t\t       (fl_owner_t) file);\n\t}\n\t/* Hold inode until release is finished */\n\treq->misc.release.inode = igrab(file_inode(file));\n\n\t/*\n\t * Normally this will send the RELEASE request, however if\n\t * some asynchronous READ or WRITE requests are outstanding,\n\t * the sending will be delayed.\n\t *\n\t * Make the release synchronous if this is a fuseblk mount,\n\t * synchronous RELEASE is allowed (and desirable) in this case\n\t * because the server can be trusted not to screw up.\n\t */\n\tfuse_file_put(ff, ff->fc->destroy_req != NULL);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_file_put",
          "args": [
            "ff",
            "ff->fc->destroy_req != NULL"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_file_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "89-114",
          "snippet": "static void fuse_file_put(struct fuse_file *ff, bool sync)\n{\n\tif (atomic_dec_and_test(&ff->count)) {\n\t\tstruct fuse_req *req = ff->reserved_req;\n\n\t\tif (ff->fc->no_open) {\n\t\t\t/*\n\t\t\t * Drop the release request when client does not\n\t\t\t * implement 'open'\n\t\t\t */\n\t\t\treq->background = 0;\n\t\t\tiput(req->misc.release.inode);\n\t\t\tfuse_put_request(ff->fc, req);\n\t\t} else if (sync) {\n\t\t\treq->background = 0;\n\t\t\tfuse_request_send(ff->fc, req);\n\t\t\tiput(req->misc.release.inode);\n\t\t\tfuse_put_request(ff->fc, req);\n\t\t} else {\n\t\t\treq->end = fuse_release_end;\n\t\t\treq->background = 1;\n\t\t\tfuse_request_send_background(ff->fc, req);\n\t\t}\n\t\tkfree(ff);\n\t}\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_file_put(struct fuse_file *ff, bool sync)\n{\n\tif (atomic_dec_and_test(&ff->count)) {\n\t\tstruct fuse_req *req = ff->reserved_req;\n\n\t\tif (ff->fc->no_open) {\n\t\t\t/*\n\t\t\t * Drop the release request when client does not\n\t\t\t * implement 'open'\n\t\t\t */\n\t\t\treq->background = 0;\n\t\t\tiput(req->misc.release.inode);\n\t\t\tfuse_put_request(ff->fc, req);\n\t\t} else if (sync) {\n\t\t\treq->background = 0;\n\t\t\tfuse_request_send(ff->fc, req);\n\t\t\tiput(req->misc.release.inode);\n\t\t\tfuse_put_request(ff->fc, req);\n\t\t} else {\n\t\t\treq->end = fuse_release_end;\n\t\t\treq->background = 1;\n\t\t\tfuse_request_send_background(ff->fc, req);\n\t\t}\n\t\tkfree(ff);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "file_inode(file)"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_lock_owner_id",
          "args": [
            "ff->fc",
            "(fl_owner_t) file"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lock_owner_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "314-330",
          "snippet": "u64 fuse_lock_owner_id(struct fuse_conn *fc, fl_owner_t id)\n{\n\tu32 *k = fc->scramble_key;\n\tu64 v = (unsigned long) id;\n\tu32 v0 = v;\n\tu32 v1 = v >> 32;\n\tu32 sum = 0;\n\tint i;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tv0 += ((v1 << 4 ^ v1 >> 5) + v1) ^ (sum + k[sum & 3]);\n\t\tsum += 0x9E3779B9;\n\t\tv1 += ((v0 << 4 ^ v0 >> 5) + v0) ^ (sum + k[sum>>11 & 3]);\n\t}\n\n\treturn (u64) v0 + ((u64) v1 << 32);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nu64 fuse_lock_owner_id(struct fuse_conn *fc, fl_owner_t id)\n{\n\tu32 *k = fc->scramble_key;\n\tu64 v = (unsigned long) id;\n\tu32 v0 = v;\n\tu32 v1 = v >> 32;\n\tu32 sum = 0;\n\tint i;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tv0 += ((v1 << 4 ^ v1 >> 5) + v1) ^ (sum + k[sum & 3]);\n\t\tsum += 0x9E3779B9;\n\t\tv1 += ((v0 << 4 ^ v0 >> 5) + v0) ^ (sum + k[sum>>11 & 3]);\n\t}\n\n\treturn (u64) v0 + ((u64) v1 << 32);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_prepare_release",
          "args": [
            "ff",
            "file->f_flags",
            "opcode"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_prepare_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "223-244",
          "snippet": "static void fuse_prepare_release(struct fuse_file *ff, int flags, int opcode)\n{\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_req *req = ff->reserved_req;\n\tstruct fuse_release_in *inarg = &req->misc.release.in;\n\n\tspin_lock(&fc->lock);\n\tlist_del(&ff->write_entry);\n\tif (!RB_EMPTY_NODE(&ff->polled_node))\n\t\trb_erase(&ff->polled_node, &fc->polled_files);\n\tspin_unlock(&fc->lock);\n\n\twake_up_interruptible_all(&ff->poll_wait);\n\n\tinarg->fh = ff->fh;\n\tinarg->flags = flags;\n\treq->in.h.opcode = opcode;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(struct fuse_release_in);\n\treq->in.args[0].value = inarg;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_prepare_release(struct fuse_file *ff, int flags, int opcode)\n{\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_req *req = ff->reserved_req;\n\tstruct fuse_release_in *inarg = &req->misc.release.in;\n\n\tspin_lock(&fc->lock);\n\tlist_del(&ff->write_entry);\n\tif (!RB_EMPTY_NODE(&ff->polled_node))\n\t\trb_erase(&ff->polled_node, &fc->polled_files);\n\tspin_unlock(&fc->lock);\n\n\twake_up_interruptible_all(&ff->poll_wait);\n\n\tinarg->fh = ff->fh;\n\tinarg->flags = flags;\n\treq->in.h.opcode = opcode;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(struct fuse_release_in);\n\treq->in.args[0].value = inarg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ff"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_release_common(struct file *file, int opcode)\n{\n\tstruct fuse_file *ff;\n\tstruct fuse_req *req;\n\n\tff = file->private_data;\n\tif (unlikely(!ff))\n\t\treturn;\n\n\treq = ff->reserved_req;\n\tfuse_prepare_release(ff, file->f_flags, opcode);\n\n\tif (ff->flock) {\n\t\tstruct fuse_release_in *inarg = &req->misc.release.in;\n\t\tinarg->release_flags |= FUSE_RELEASE_FLOCK_UNLOCK;\n\t\tinarg->lock_owner = fuse_lock_owner_id(ff->fc,\n\t\t\t\t\t\t       (fl_owner_t) file);\n\t}\n\t/* Hold inode until release is finished */\n\treq->misc.release.inode = igrab(file_inode(file));\n\n\t/*\n\t * Normally this will send the RELEASE request, however if\n\t * some asynchronous READ or WRITE requests are outstanding,\n\t * the sending will be delayed.\n\t *\n\t * Make the release synchronous if this is a fuseblk mount,\n\t * synchronous RELEASE is allowed (and desirable) in this case\n\t * because the server can be trusted not to screw up.\n\t */\n\tfuse_file_put(ff, ff->fc->destroy_req != NULL);\n}"
  },
  {
    "function_name": "fuse_prepare_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "223-244",
    "snippet": "static void fuse_prepare_release(struct fuse_file *ff, int flags, int opcode)\n{\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_req *req = ff->reserved_req;\n\tstruct fuse_release_in *inarg = &req->misc.release.in;\n\n\tspin_lock(&fc->lock);\n\tlist_del(&ff->write_entry);\n\tif (!RB_EMPTY_NODE(&ff->polled_node))\n\t\trb_erase(&ff->polled_node, &fc->polled_files);\n\tspin_unlock(&fc->lock);\n\n\twake_up_interruptible_all(&ff->poll_wait);\n\n\tinarg->fh = ff->fh;\n\tinarg->flags = flags;\n\treq->in.h.opcode = opcode;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(struct fuse_release_in);\n\treq->in.args[0].value = inarg;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_interruptible_all",
          "args": [
            "&ff->poll_wait"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&ff->polled_node",
            "&fc->polled_files"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&ff->polled_node"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ff->write_entry"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_prepare_release(struct fuse_file *ff, int flags, int opcode)\n{\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_req *req = ff->reserved_req;\n\tstruct fuse_release_in *inarg = &req->misc.release.in;\n\n\tspin_lock(&fc->lock);\n\tlist_del(&ff->write_entry);\n\tif (!RB_EMPTY_NODE(&ff->polled_node))\n\t\trb_erase(&ff->polled_node, &fc->polled_files);\n\tspin_unlock(&fc->lock);\n\n\twake_up_interruptible_all(&ff->poll_wait);\n\n\tinarg->fh = ff->fh;\n\tinarg->flags = flags;\n\treq->in.h.opcode = opcode;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(struct fuse_release_in);\n\treq->in.args[0].value = inarg;\n}"
  },
  {
    "function_name": "fuse_open_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "197-221",
    "snippet": "int fuse_open_common(struct inode *inode, struct file *file, bool isdir)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tint err;\n\tbool lock_inode = (file->f_flags & O_TRUNC) &&\n\t\t\t  fc->atomic_o_trunc &&\n\t\t\t  fc->writeback_cache;\n\n\terr = generic_file_open(inode, file);\n\tif (err)\n\t\treturn err;\n\n\tif (lock_inode)\n\t\tmutex_lock(&inode->i_mutex);\n\n\terr = fuse_do_open(fc, get_node_id(inode), file, isdir);\n\n\tif (!err)\n\t\tfuse_finish_open(inode, file);\n\n\tif (lock_inode)\n\t\tmutex_unlock(&inode->i_mutex);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_finish_open",
          "args": [
            "inode",
            "file"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_finish_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "171-195",
          "snippet": "void fuse_finish_open(struct inode *inode, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (ff->open_flags & FOPEN_DIRECT_IO)\n\t\tfile->f_op = &fuse_direct_io_file_operations;\n\tif (!(ff->open_flags & FOPEN_KEEP_CACHE))\n\t\tinvalidate_inode_pages2(inode->i_mapping);\n\tif (ff->open_flags & FOPEN_NONSEEKABLE)\n\t\tnonseekable_open(inode, file);\n\tif (fc->atomic_o_trunc && (file->f_flags & O_TRUNC)) {\n\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\tspin_lock(&fc->lock);\n\t\tfi->attr_version = ++fc->attr_version;\n\t\ti_size_write(inode, 0);\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_invalidate_attr(inode);\n\t\tif (fc->writeback_cache)\n\t\t\tfile_update_time(file);\n\t}\n\tif ((file->f_mode & FMODE_WRITE) && fc->writeback_cache)\n\t\tfuse_link_write_file(file);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_direct_io_file_operations;",
            "static const struct file_operations fuse_direct_io_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= fuse_direct_read,\n\t.write\t\t= fuse_direct_write,\n\t.mmap\t\t= fuse_direct_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n\t/* no splice_read */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_direct_io_file_operations;\nstatic const struct file_operations fuse_direct_io_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= fuse_direct_read,\n\t.write\t\t= fuse_direct_write,\n\t.mmap\t\t= fuse_direct_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n\t/* no splice_read */\n};\n\nvoid fuse_finish_open(struct inode *inode, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (ff->open_flags & FOPEN_DIRECT_IO)\n\t\tfile->f_op = &fuse_direct_io_file_operations;\n\tif (!(ff->open_flags & FOPEN_KEEP_CACHE))\n\t\tinvalidate_inode_pages2(inode->i_mapping);\n\tif (ff->open_flags & FOPEN_NONSEEKABLE)\n\t\tnonseekable_open(inode, file);\n\tif (fc->atomic_o_trunc && (file->f_flags & O_TRUNC)) {\n\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\tspin_lock(&fc->lock);\n\t\tfi->attr_version = ++fc->attr_version;\n\t\ti_size_write(inode, 0);\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_invalidate_attr(inode);\n\t\tif (fc->writeback_cache)\n\t\t\tfile_update_time(file);\n\t}\n\tif ((file->f_mode & FMODE_WRITE) && fc->writeback_cache)\n\t\tfuse_link_write_file(file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_do_open",
          "args": [
            "fc",
            "get_node_id(inode)",
            "file",
            "isdir"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_do_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "116-152",
          "snippet": "int fuse_do_open(struct fuse_conn *fc, u64 nodeid, struct file *file,\n\t\t bool isdir)\n{\n\tstruct fuse_file *ff;\n\tint opcode = isdir ? FUSE_OPENDIR : FUSE_OPEN;\n\n\tff = fuse_file_alloc(fc);\n\tif (!ff)\n\t\treturn -ENOMEM;\n\n\tff->fh = 0;\n\tff->open_flags = FOPEN_KEEP_CACHE; /* Default for no-open */\n\tif (!fc->no_open || isdir) {\n\t\tstruct fuse_open_out outarg;\n\t\tint err;\n\n\t\terr = fuse_send_open(fc, nodeid, file, opcode, &outarg);\n\t\tif (!err) {\n\t\t\tff->fh = outarg.fh;\n\t\t\tff->open_flags = outarg.open_flags;\n\n\t\t} else if (err != -ENOSYS || isdir) {\n\t\t\tfuse_file_free(ff);\n\t\t\treturn err;\n\t\t} else {\n\t\t\tfc->no_open = 1;\n\t\t}\n\t}\n\n\tif (isdir)\n\t\tff->open_flags &= ~FOPEN_DIRECT_IO;\n\n\tff->nodeid = nodeid;\n\tfile->private_data = fuse_file_get(ff);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_do_open(struct fuse_conn *fc, u64 nodeid, struct file *file,\n\t\t bool isdir)\n{\n\tstruct fuse_file *ff;\n\tint opcode = isdir ? FUSE_OPENDIR : FUSE_OPEN;\n\n\tff = fuse_file_alloc(fc);\n\tif (!ff)\n\t\treturn -ENOMEM;\n\n\tff->fh = 0;\n\tff->open_flags = FOPEN_KEEP_CACHE; /* Default for no-open */\n\tif (!fc->no_open || isdir) {\n\t\tstruct fuse_open_out outarg;\n\t\tint err;\n\n\t\terr = fuse_send_open(fc, nodeid, file, opcode, &outarg);\n\t\tif (!err) {\n\t\t\tff->fh = outarg.fh;\n\t\t\tff->open_flags = outarg.open_flags;\n\n\t\t} else if (err != -ENOSYS || isdir) {\n\t\t\tfuse_file_free(ff);\n\t\t\treturn err;\n\t\t} else {\n\t\t\tfc->no_open = 1;\n\t\t}\n\t}\n\n\tif (isdir)\n\t\tff->open_flags &= ~FOPEN_DIRECT_IO;\n\n\tff->nodeid = nodeid;\n\tfile->private_data = fuse_file_get(ff);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_id",
          "args": [
            "inode"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "633-636",
          "snippet": "static inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_file_open",
          "args": [
            "inode",
            "file"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "1121-1126",
          "snippet": "int generic_file_open(struct inode * inode, struct file * filp)\n{\n\tif (!(filp->f_flags & O_LARGEFILE) && i_size_read(inode) > MAX_NON_LFS)\n\t\treturn -EOVERFLOW;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint generic_file_open(struct inode * inode, struct file * filp)\n{\n\tif (!(filp->f_flags & O_LARGEFILE) && i_size_read(inode) > MAX_NON_LFS)\n\t\treturn -EOVERFLOW;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_open_common(struct inode *inode, struct file *file, bool isdir)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tint err;\n\tbool lock_inode = (file->f_flags & O_TRUNC) &&\n\t\t\t  fc->atomic_o_trunc &&\n\t\t\t  fc->writeback_cache;\n\n\terr = generic_file_open(inode, file);\n\tif (err)\n\t\treturn err;\n\n\tif (lock_inode)\n\t\tmutex_lock(&inode->i_mutex);\n\n\terr = fuse_do_open(fc, get_node_id(inode), file, isdir);\n\n\tif (!err)\n\t\tfuse_finish_open(inode, file);\n\n\tif (lock_inode)\n\t\tmutex_unlock(&inode->i_mutex);\n\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_finish_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "171-195",
    "snippet": "void fuse_finish_open(struct inode *inode, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (ff->open_flags & FOPEN_DIRECT_IO)\n\t\tfile->f_op = &fuse_direct_io_file_operations;\n\tif (!(ff->open_flags & FOPEN_KEEP_CACHE))\n\t\tinvalidate_inode_pages2(inode->i_mapping);\n\tif (ff->open_flags & FOPEN_NONSEEKABLE)\n\t\tnonseekable_open(inode, file);\n\tif (fc->atomic_o_trunc && (file->f_flags & O_TRUNC)) {\n\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\tspin_lock(&fc->lock);\n\t\tfi->attr_version = ++fc->attr_version;\n\t\ti_size_write(inode, 0);\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_invalidate_attr(inode);\n\t\tif (fc->writeback_cache)\n\t\t\tfile_update_time(file);\n\t}\n\tif ((file->f_mode & FMODE_WRITE) && fc->writeback_cache)\n\t\tfuse_link_write_file(file);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations fuse_direct_io_file_operations;",
      "static const struct file_operations fuse_direct_io_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= fuse_direct_read,\n\t.write\t\t= fuse_direct_write,\n\t.mmap\t\t= fuse_direct_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n\t/* no splice_read */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_link_write_file",
          "args": [
            "file"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_link_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "155-169",
          "snippet": "static void fuse_link_write_file(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_file *ff = file->private_data;\n\t/*\n\t * file may be written through mmap, so chain it onto the\n\t * inodes's write_file list\n\t */\n\tspin_lock(&fc->lock);\n\tif (list_empty(&ff->write_entry))\n\t\tlist_add(&ff->write_entry, &fi->write_files);\n\tspin_unlock(&fc->lock);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_link_write_file(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_file *ff = file->private_data;\n\t/*\n\t * file may be written through mmap, so chain it onto the\n\t * inodes's write_file list\n\t */\n\tspin_lock(&fc->lock);\n\tif (list_empty(&ff->write_entry))\n\t\tlist_add(&ff->write_entry, &fi->write_files);\n\tspin_unlock(&fc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_update_time",
          "args": [
            "file"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "file_update_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1716-1748",
          "snippet": "int file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_invalidate_attr",
          "args": [
            "inode"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "110-113",
          "snippet": "void fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "0"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nonseekable_open",
          "args": [
            "inode",
            "file"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "nonseekable_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "1136-1140",
          "snippet": "int nonseekable_open(struct inode *inode, struct file *filp)\n{\n\tfilp->f_mode &= ~(FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint nonseekable_open(struct inode *inode, struct file *filp)\n{\n\tfilp->f_mode &= ~(FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_inode_pages2",
          "args": [
            "inode->i_mapping"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_direct_io_file_operations;\nstatic const struct file_operations fuse_direct_io_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= fuse_direct_read,\n\t.write\t\t= fuse_direct_write,\n\t.mmap\t\t= fuse_direct_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n\t/* no splice_read */\n};\n\nvoid fuse_finish_open(struct inode *inode, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (ff->open_flags & FOPEN_DIRECT_IO)\n\t\tfile->f_op = &fuse_direct_io_file_operations;\n\tif (!(ff->open_flags & FOPEN_KEEP_CACHE))\n\t\tinvalidate_inode_pages2(inode->i_mapping);\n\tif (ff->open_flags & FOPEN_NONSEEKABLE)\n\t\tnonseekable_open(inode, file);\n\tif (fc->atomic_o_trunc && (file->f_flags & O_TRUNC)) {\n\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\tspin_lock(&fc->lock);\n\t\tfi->attr_version = ++fc->attr_version;\n\t\ti_size_write(inode, 0);\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_invalidate_attr(inode);\n\t\tif (fc->writeback_cache)\n\t\t\tfile_update_time(file);\n\t}\n\tif ((file->f_mode & FMODE_WRITE) && fc->writeback_cache)\n\t\tfuse_link_write_file(file);\n}"
  },
  {
    "function_name": "fuse_link_write_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "155-169",
    "snippet": "static void fuse_link_write_file(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_file *ff = file->private_data;\n\t/*\n\t * file may be written through mmap, so chain it onto the\n\t * inodes's write_file list\n\t */\n\tspin_lock(&fc->lock);\n\tif (list_empty(&ff->write_entry))\n\t\tlist_add(&ff->write_entry, &fi->write_files);\n\tspin_unlock(&fc->lock);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ff->write_entry",
            "&fi->write_files"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ff->write_entry"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_link_write_file(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_file *ff = file->private_data;\n\t/*\n\t * file may be written through mmap, so chain it onto the\n\t * inodes's write_file list\n\t */\n\tspin_lock(&fc->lock);\n\tif (list_empty(&ff->write_entry))\n\t\tlist_add(&ff->write_entry, &fi->write_files);\n\tspin_unlock(&fc->lock);\n}"
  },
  {
    "function_name": "fuse_do_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "116-152",
    "snippet": "int fuse_do_open(struct fuse_conn *fc, u64 nodeid, struct file *file,\n\t\t bool isdir)\n{\n\tstruct fuse_file *ff;\n\tint opcode = isdir ? FUSE_OPENDIR : FUSE_OPEN;\n\n\tff = fuse_file_alloc(fc);\n\tif (!ff)\n\t\treturn -ENOMEM;\n\n\tff->fh = 0;\n\tff->open_flags = FOPEN_KEEP_CACHE; /* Default for no-open */\n\tif (!fc->no_open || isdir) {\n\t\tstruct fuse_open_out outarg;\n\t\tint err;\n\n\t\terr = fuse_send_open(fc, nodeid, file, opcode, &outarg);\n\t\tif (!err) {\n\t\t\tff->fh = outarg.fh;\n\t\t\tff->open_flags = outarg.open_flags;\n\n\t\t} else if (err != -ENOSYS || isdir) {\n\t\t\tfuse_file_free(ff);\n\t\t\treturn err;\n\t\t} else {\n\t\t\tfc->no_open = 1;\n\t\t}\n\t}\n\n\tif (isdir)\n\t\tff->open_flags &= ~FOPEN_DIRECT_IO;\n\n\tff->nodeid = nodeid;\n\tfile->private_data = fuse_file_get(ff);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_file_get",
          "args": [
            "ff"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_file_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "78-82",
          "snippet": "struct fuse_file *fuse_file_get(struct fuse_file *ff)\n{\n\tatomic_inc(&ff->count);\n\treturn ff;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstruct fuse_file *fuse_file_get(struct fuse_file *ff)\n{\n\tatomic_inc(&ff->count);\n\treturn ff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_file_free",
          "args": [
            "ff"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_file_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "72-76",
          "snippet": "void fuse_file_free(struct fuse_file *ff)\n{\n\tfuse_request_free(ff->reserved_req);\n\tkfree(ff);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_file_free(struct fuse_file *ff)\n{\n\tfuse_request_free(ff->reserved_req);\n\tkfree(ff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_send_open",
          "args": [
            "fc",
            "nodeid",
            "file",
            "opcode",
            "&outarg"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_send_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "23-43",
          "snippet": "static int fuse_send_open(struct fuse_conn *fc, u64 nodeid, struct file *file,\n\t\t\t  int opcode, struct fuse_open_out *outargp)\n{\n\tstruct fuse_open_in inarg;\n\tFUSE_ARGS(args);\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.flags = file->f_flags & ~(O_CREAT | O_EXCL | O_NOCTTY);\n\tif (!fc->atomic_o_trunc)\n\t\tinarg.flags &= ~O_TRUNC;\n\targs.in.h.opcode = opcode;\n\targs.in.h.nodeid = nodeid;\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.out.numargs = 1;\n\targs.out.args[0].size = sizeof(*outargp);\n\targs.out.args[0].value = outargp;\n\n\treturn fuse_simple_request(fc, &args);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_send_open(struct fuse_conn *fc, u64 nodeid, struct file *file,\n\t\t\t  int opcode, struct fuse_open_out *outargp)\n{\n\tstruct fuse_open_in inarg;\n\tFUSE_ARGS(args);\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.flags = file->f_flags & ~(O_CREAT | O_EXCL | O_NOCTTY);\n\tif (!fc->atomic_o_trunc)\n\t\tinarg.flags &= ~O_TRUNC;\n\targs.in.h.opcode = opcode;\n\targs.in.h.nodeid = nodeid;\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.out.numargs = 1;\n\targs.out.args[0].size = sizeof(*outargp);\n\targs.out.args[0].value = outargp;\n\n\treturn fuse_simple_request(fc, &args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_file_alloc",
          "args": [
            "fc"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_file_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "45-70",
          "snippet": "struct fuse_file *fuse_file_alloc(struct fuse_conn *fc)\n{\n\tstruct fuse_file *ff;\n\n\tff = kmalloc(sizeof(struct fuse_file), GFP_KERNEL);\n\tif (unlikely(!ff))\n\t\treturn NULL;\n\n\tff->fc = fc;\n\tff->reserved_req = fuse_request_alloc(0);\n\tif (unlikely(!ff->reserved_req)) {\n\t\tkfree(ff);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&ff->write_entry);\n\tatomic_set(&ff->count, 0);\n\tRB_CLEAR_NODE(&ff->polled_node);\n\tinit_waitqueue_head(&ff->poll_wait);\n\n\tspin_lock(&fc->lock);\n\tff->kh = ++fc->khctr;\n\tspin_unlock(&fc->lock);\n\n\treturn ff;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstruct fuse_file *fuse_file_alloc(struct fuse_conn *fc)\n{\n\tstruct fuse_file *ff;\n\n\tff = kmalloc(sizeof(struct fuse_file), GFP_KERNEL);\n\tif (unlikely(!ff))\n\t\treturn NULL;\n\n\tff->fc = fc;\n\tff->reserved_req = fuse_request_alloc(0);\n\tif (unlikely(!ff->reserved_req)) {\n\t\tkfree(ff);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&ff->write_entry);\n\tatomic_set(&ff->count, 0);\n\tRB_CLEAR_NODE(&ff->polled_node);\n\tinit_waitqueue_head(&ff->poll_wait);\n\n\tspin_lock(&fc->lock);\n\tff->kh = ++fc->khctr;\n\tspin_unlock(&fc->lock);\n\n\treturn ff;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_do_open(struct fuse_conn *fc, u64 nodeid, struct file *file,\n\t\t bool isdir)\n{\n\tstruct fuse_file *ff;\n\tint opcode = isdir ? FUSE_OPENDIR : FUSE_OPEN;\n\n\tff = fuse_file_alloc(fc);\n\tif (!ff)\n\t\treturn -ENOMEM;\n\n\tff->fh = 0;\n\tff->open_flags = FOPEN_KEEP_CACHE; /* Default for no-open */\n\tif (!fc->no_open || isdir) {\n\t\tstruct fuse_open_out outarg;\n\t\tint err;\n\n\t\terr = fuse_send_open(fc, nodeid, file, opcode, &outarg);\n\t\tif (!err) {\n\t\t\tff->fh = outarg.fh;\n\t\t\tff->open_flags = outarg.open_flags;\n\n\t\t} else if (err != -ENOSYS || isdir) {\n\t\t\tfuse_file_free(ff);\n\t\t\treturn err;\n\t\t} else {\n\t\t\tfc->no_open = 1;\n\t\t}\n\t}\n\n\tif (isdir)\n\t\tff->open_flags &= ~FOPEN_DIRECT_IO;\n\n\tff->nodeid = nodeid;\n\tfile->private_data = fuse_file_get(ff);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fuse_file_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "89-114",
    "snippet": "static void fuse_file_put(struct fuse_file *ff, bool sync)\n{\n\tif (atomic_dec_and_test(&ff->count)) {\n\t\tstruct fuse_req *req = ff->reserved_req;\n\n\t\tif (ff->fc->no_open) {\n\t\t\t/*\n\t\t\t * Drop the release request when client does not\n\t\t\t * implement 'open'\n\t\t\t */\n\t\t\treq->background = 0;\n\t\t\tiput(req->misc.release.inode);\n\t\t\tfuse_put_request(ff->fc, req);\n\t\t} else if (sync) {\n\t\t\treq->background = 0;\n\t\t\tfuse_request_send(ff->fc, req);\n\t\t\tiput(req->misc.release.inode);\n\t\t\tfuse_put_request(ff->fc, req);\n\t\t} else {\n\t\t\treq->end = fuse_release_end;\n\t\t\treq->background = 1;\n\t\t\tfuse_request_send_background(ff->fc, req);\n\t\t}\n\t\tkfree(ff);\n\t}\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ff"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_request_send_background",
          "args": [
            "ff->fc",
            "req"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_send_background_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "647-652",
          "snippet": "void fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_put_request",
          "args": [
            "ff->fc",
            "req"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "277-299",
          "snippet": "void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "req->misc.release.inode"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&ff->count"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_file_put(struct fuse_file *ff, bool sync)\n{\n\tif (atomic_dec_and_test(&ff->count)) {\n\t\tstruct fuse_req *req = ff->reserved_req;\n\n\t\tif (ff->fc->no_open) {\n\t\t\t/*\n\t\t\t * Drop the release request when client does not\n\t\t\t * implement 'open'\n\t\t\t */\n\t\t\treq->background = 0;\n\t\t\tiput(req->misc.release.inode);\n\t\t\tfuse_put_request(ff->fc, req);\n\t\t} else if (sync) {\n\t\t\treq->background = 0;\n\t\t\tfuse_request_send(ff->fc, req);\n\t\t\tiput(req->misc.release.inode);\n\t\t\tfuse_put_request(ff->fc, req);\n\t\t} else {\n\t\t\treq->end = fuse_release_end;\n\t\t\treq->background = 1;\n\t\t\tfuse_request_send_background(ff->fc, req);\n\t\t}\n\t\tkfree(ff);\n\t}\n}"
  },
  {
    "function_name": "fuse_release_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "84-87",
    "snippet": "static void fuse_release_end(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tiput(req->misc.release.inode);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "req->misc.release.inode"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_release_end(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tiput(req->misc.release.inode);\n}"
  },
  {
    "function_name": "fuse_file_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "78-82",
    "snippet": "struct fuse_file *fuse_file_get(struct fuse_file *ff)\n{\n\tatomic_inc(&ff->count);\n\treturn ff;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ff->count"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstruct fuse_file *fuse_file_get(struct fuse_file *ff)\n{\n\tatomic_inc(&ff->count);\n\treturn ff;\n}"
  },
  {
    "function_name": "fuse_file_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "72-76",
    "snippet": "void fuse_file_free(struct fuse_file *ff)\n{\n\tfuse_request_free(ff->reserved_req);\n\tkfree(ff);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ff"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_request_free",
          "args": [
            "ff->reserved_req"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "93-100",
          "snippet": "void fuse_request_free(struct fuse_req *req)\n{\n\tif (req->pages != req->inline_pages) {\n\t\tkfree(req->pages);\n\t\tkfree(req->page_descs);\n\t}\n\tkmem_cache_free(fuse_req_cachep, req);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fuse_req_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct kmem_cache *fuse_req_cachep;\n\nvoid fuse_request_free(struct fuse_req *req)\n{\n\tif (req->pages != req->inline_pages) {\n\t\tkfree(req->pages);\n\t\tkfree(req->page_descs);\n\t}\n\tkmem_cache_free(fuse_req_cachep, req);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_file_free(struct fuse_file *ff)\n{\n\tfuse_request_free(ff->reserved_req);\n\tkfree(ff);\n}"
  },
  {
    "function_name": "fuse_file_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "45-70",
    "snippet": "struct fuse_file *fuse_file_alloc(struct fuse_conn *fc)\n{\n\tstruct fuse_file *ff;\n\n\tff = kmalloc(sizeof(struct fuse_file), GFP_KERNEL);\n\tif (unlikely(!ff))\n\t\treturn NULL;\n\n\tff->fc = fc;\n\tff->reserved_req = fuse_request_alloc(0);\n\tif (unlikely(!ff->reserved_req)) {\n\t\tkfree(ff);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&ff->write_entry);\n\tatomic_set(&ff->count, 0);\n\tRB_CLEAR_NODE(&ff->polled_node);\n\tinit_waitqueue_head(&ff->poll_wait);\n\n\tspin_lock(&fc->lock);\n\tff->kh = ++fc->khctr;\n\tspin_unlock(&fc->lock);\n\n\treturn ff;\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&ff->poll_wait"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&ff->polled_node"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ff->count",
            "0"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ff->write_entry"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ff"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ff->reserved_req"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_request_alloc",
          "args": [
            "0"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_alloc_nofs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "88-91",
          "snippet": "struct fuse_req *fuse_request_alloc_nofs(unsigned npages)\n{\n\treturn __fuse_request_alloc(npages, GFP_NOFS);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstruct fuse_req *fuse_request_alloc_nofs(unsigned npages)\n{\n\treturn __fuse_request_alloc(npages, GFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ff"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct fuse_file)",
            "GFP_KERNEL"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstruct fuse_file *fuse_file_alloc(struct fuse_conn *fc)\n{\n\tstruct fuse_file *ff;\n\n\tff = kmalloc(sizeof(struct fuse_file), GFP_KERNEL);\n\tif (unlikely(!ff))\n\t\treturn NULL;\n\n\tff->fc = fc;\n\tff->reserved_req = fuse_request_alloc(0);\n\tif (unlikely(!ff->reserved_req)) {\n\t\tkfree(ff);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&ff->write_entry);\n\tatomic_set(&ff->count, 0);\n\tRB_CLEAR_NODE(&ff->polled_node);\n\tinit_waitqueue_head(&ff->poll_wait);\n\n\tspin_lock(&fc->lock);\n\tff->kh = ++fc->khctr;\n\tspin_unlock(&fc->lock);\n\n\treturn ff;\n}"
  },
  {
    "function_name": "fuse_send_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
    "lines": "23-43",
    "snippet": "static int fuse_send_open(struct fuse_conn *fc, u64 nodeid, struct file *file,\n\t\t\t  int opcode, struct fuse_open_out *outargp)\n{\n\tstruct fuse_open_in inarg;\n\tFUSE_ARGS(args);\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.flags = file->f_flags & ~(O_CREAT | O_EXCL | O_NOCTTY);\n\tif (!fc->atomic_o_trunc)\n\t\tinarg.flags &= ~O_TRUNC;\n\targs.in.h.opcode = opcode;\n\targs.in.h.nodeid = nodeid;\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.out.numargs = 1;\n\targs.out.args[0].size = sizeof(*outargp);\n\targs.out.args[0].value = outargp;\n\n\treturn fuse_simple_request(fc, &args);\n}",
    "includes": [
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_simple_request",
          "args": [
            "fc",
            "&args"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_simple_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "558-588",
          "snippet": "ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&inarg",
            "0",
            "sizeof(inarg)"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUSE_ARGS",
          "args": [
            "args"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_send_open(struct fuse_conn *fc, u64 nodeid, struct file *file,\n\t\t\t  int opcode, struct fuse_open_out *outargp)\n{\n\tstruct fuse_open_in inarg;\n\tFUSE_ARGS(args);\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.flags = file->f_flags & ~(O_CREAT | O_EXCL | O_NOCTTY);\n\tif (!fc->atomic_o_trunc)\n\t\tinarg.flags &= ~O_TRUNC;\n\targs.in.h.opcode = opcode;\n\targs.in.h.nodeid = nodeid;\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.out.numargs = 1;\n\targs.out.args[0].size = sizeof(*outargp);\n\targs.out.args[0].value = outargp;\n\n\treturn fuse_simple_request(fc, &args);\n}"
  }
]