[
  {
    "function_name": "kernfs_dir_fop_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "1403-1414",
    "snippet": "static loff_t kernfs_dir_fop_llseek(struct file *file, loff_t offset,\n\t\t\t\t    int whence)\n{\n\tstruct inode *inode = file_inode(file);\n\tloff_t ret;\n\n\tmutex_lock(&inode->i_mutex);\n\tret = generic_file_llseek(file, offset, whence);\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_file_llseek",
          "args": [
            "file",
            "offset",
            "whence"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_llseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "147-154",
          "snippet": "loff_t generic_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\tinode->i_sb->s_maxbytes,\n\t\t\t\t\ti_size_read(inode));\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t generic_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\tinode->i_sb->s_maxbytes,\n\t\t\t\t\ti_size_read(inode));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic loff_t kernfs_dir_fop_llseek(struct file *file, loff_t offset,\n\t\t\t\t    int whence)\n{\n\tstruct inode *inode = file_inode(file);\n\tloff_t ret;\n\n\tmutex_lock(&inode->i_mutex);\n\tret = generic_file_llseek(file, offset, whence);\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "kernfs_fop_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "1366-1401",
    "snippet": "static int kernfs_fop_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct kernfs_node *parent = dentry->d_fsdata;\n\tstruct kernfs_node *pos = file->private_data;\n\tconst void *ns = NULL;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\tmutex_lock(&kernfs_mutex);\n\n\tif (kernfs_ns_enabled(parent))\n\t\tns = kernfs_info(dentry->d_sb)->ns;\n\n\tfor (pos = kernfs_dir_pos(ns, parent, ctx->pos, pos);\n\t     pos;\n\t     pos = kernfs_dir_next_pos(ns, parent, ctx->pos, pos)) {\n\t\tconst char *name = pos->name;\n\t\tunsigned int type = dt_type(pos);\n\t\tint len = strlen(name);\n\t\tino_t ino = pos->ino;\n\n\t\tctx->pos = pos->hash;\n\t\tfile->private_data = pos;\n\t\tkernfs_get(pos);\n\n\t\tmutex_unlock(&kernfs_mutex);\n\t\tif (!dir_emit(ctx, name, len, ino, type))\n\t\t\treturn 0;\n\t\tmutex_lock(&kernfs_mutex);\n\t}\n\tmutex_unlock(&kernfs_mutex);\n\tfile->private_data = NULL;\n\tctx->pos = INT_MAX;\n\treturn 0;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "name",
            "len",
            "ino",
            "type"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_get",
          "args": [
            "pos"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "378-384",
          "snippet": "void kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dt_type",
          "args": [
            "pos"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "dt_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "1305-1308",
          "snippet": "static inline unsigned char dt_type(struct kernfs_node *kn)\n{\n\treturn (kn->mode >> 12) & 15;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic inline unsigned char dt_type(struct kernfs_node *kn)\n{\n\treturn (kn->mode >> 12) & 15;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_dir_next_pos",
          "args": [
            "ns",
            "parent",
            "ctx->pos",
            "pos"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_dir_next_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "1350-1364",
          "snippet": "static struct kernfs_node *kernfs_dir_next_pos(const void *ns,\n\tstruct kernfs_node *parent, ino_t ino, struct kernfs_node *pos)\n{\n\tpos = kernfs_dir_pos(ns, parent, ino, pos);\n\tif (pos) {\n\t\tdo {\n\t\t\tstruct rb_node *node = rb_next(&pos->rb);\n\t\t\tif (!node)\n\t\t\t\tpos = NULL;\n\t\t\telse\n\t\t\t\tpos = rb_to_kn(node);\n\t\t} while (pos && (!kernfs_active(pos) || pos->ns != ns));\n\t}\n\treturn pos;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic struct kernfs_node *kernfs_dir_next_pos(const void *ns,\n\tstruct kernfs_node *parent, ino_t ino, struct kernfs_node *pos)\n{\n\tpos = kernfs_dir_pos(ns, parent, ino, pos);\n\tif (pos) {\n\t\tdo {\n\t\t\tstruct rb_node *node = rb_next(&pos->rb);\n\t\t\tif (!node)\n\t\t\t\tpos = NULL;\n\t\t\telse\n\t\t\t\tpos = rb_to_kn(node);\n\t\t} while (pos && (!kernfs_active(pos) || pos->ns != ns));\n\t}\n\treturn pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_dir_pos",
          "args": [
            "ns",
            "parent",
            "ctx->pos",
            "pos"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_dir_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "1316-1348",
          "snippet": "static struct kernfs_node *kernfs_dir_pos(const void *ns,\n\tstruct kernfs_node *parent, loff_t hash, struct kernfs_node *pos)\n{\n\tif (pos) {\n\t\tint valid = kernfs_active(pos) &&\n\t\t\tpos->parent == parent && hash == pos->hash;\n\t\tkernfs_put(pos);\n\t\tif (!valid)\n\t\t\tpos = NULL;\n\t}\n\tif (!pos && (hash > 1) && (hash < INT_MAX)) {\n\t\tstruct rb_node *node = parent->dir.children.rb_node;\n\t\twhile (node) {\n\t\t\tpos = rb_to_kn(node);\n\n\t\t\tif (hash < pos->hash)\n\t\t\t\tnode = node->rb_left;\n\t\t\telse if (hash > pos->hash)\n\t\t\t\tnode = node->rb_right;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* Skip over entries which are dying/dead or in the wrong namespace */\n\twhile (pos && (!kernfs_active(pos) || pos->ns != ns)) {\n\t\tstruct rb_node *node = rb_next(&pos->rb);\n\t\tif (!node)\n\t\t\tpos = NULL;\n\t\telse\n\t\t\tpos = rb_to_kn(node);\n\t}\n\treturn pos;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic struct kernfs_node *kernfs_dir_pos(const void *ns,\n\tstruct kernfs_node *parent, loff_t hash, struct kernfs_node *pos)\n{\n\tif (pos) {\n\t\tint valid = kernfs_active(pos) &&\n\t\t\tpos->parent == parent && hash == pos->hash;\n\t\tkernfs_put(pos);\n\t\tif (!valid)\n\t\t\tpos = NULL;\n\t}\n\tif (!pos && (hash > 1) && (hash < INT_MAX)) {\n\t\tstruct rb_node *node = parent->dir.children.rb_node;\n\t\twhile (node) {\n\t\t\tpos = rb_to_kn(node);\n\n\t\t\tif (hash < pos->hash)\n\t\t\t\tnode = node->rb_left;\n\t\t\telse if (hash > pos->hash)\n\t\t\t\tnode = node->rb_right;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* Skip over entries which are dying/dead or in the wrong namespace */\n\twhile (pos && (!kernfs_active(pos) || pos->ns != ns)) {\n\t\tstruct rb_node *node = rb_next(&pos->rb);\n\t\tif (!node)\n\t\t\tpos = NULL;\n\t\telse\n\t\t\tpos = rb_to_kn(node);\n\t}\n\treturn pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_info",
          "args": [
            "dentry->d_sb"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_ns_enabled",
          "args": [
            "parent"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit_dots",
          "args": [
            "file",
            "ctx"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic int kernfs_fop_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct kernfs_node *parent = dentry->d_fsdata;\n\tstruct kernfs_node *pos = file->private_data;\n\tconst void *ns = NULL;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\tmutex_lock(&kernfs_mutex);\n\n\tif (kernfs_ns_enabled(parent))\n\t\tns = kernfs_info(dentry->d_sb)->ns;\n\n\tfor (pos = kernfs_dir_pos(ns, parent, ctx->pos, pos);\n\t     pos;\n\t     pos = kernfs_dir_next_pos(ns, parent, ctx->pos, pos)) {\n\t\tconst char *name = pos->name;\n\t\tunsigned int type = dt_type(pos);\n\t\tint len = strlen(name);\n\t\tino_t ino = pos->ino;\n\n\t\tctx->pos = pos->hash;\n\t\tfile->private_data = pos;\n\t\tkernfs_get(pos);\n\n\t\tmutex_unlock(&kernfs_mutex);\n\t\tif (!dir_emit(ctx, name, len, ino, type))\n\t\t\treturn 0;\n\t\tmutex_lock(&kernfs_mutex);\n\t}\n\tmutex_unlock(&kernfs_mutex);\n\tfile->private_data = NULL;\n\tctx->pos = INT_MAX;\n\treturn 0;\n}"
  },
  {
    "function_name": "kernfs_dir_next_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "1350-1364",
    "snippet": "static struct kernfs_node *kernfs_dir_next_pos(const void *ns,\n\tstruct kernfs_node *parent, ino_t ino, struct kernfs_node *pos)\n{\n\tpos = kernfs_dir_pos(ns, parent, ino, pos);\n\tif (pos) {\n\t\tdo {\n\t\t\tstruct rb_node *node = rb_next(&pos->rb);\n\t\t\tif (!node)\n\t\t\t\tpos = NULL;\n\t\t\telse\n\t\t\t\tpos = rb_to_kn(node);\n\t\t} while (pos && (!kernfs_active(pos) || pos->ns != ns));\n\t}\n\treturn pos;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_active",
          "args": [
            "pos"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "27-31",
          "snippet": "static bool kernfs_active(struct kernfs_node *kn)\n{\n\tlockdep_assert_held(&kernfs_mutex);\n\treturn atomic_read(&kn->active) >= 0;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic bool kernfs_active(struct kernfs_node *kn)\n{\n\tlockdep_assert_held(&kernfs_mutex);\n\treturn atomic_read(&kn->active) >= 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_to_kn",
          "args": [
            "node"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&pos->rb"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_dir_pos",
          "args": [
            "ns",
            "parent",
            "ino",
            "pos"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_dir_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "1316-1348",
          "snippet": "static struct kernfs_node *kernfs_dir_pos(const void *ns,\n\tstruct kernfs_node *parent, loff_t hash, struct kernfs_node *pos)\n{\n\tif (pos) {\n\t\tint valid = kernfs_active(pos) &&\n\t\t\tpos->parent == parent && hash == pos->hash;\n\t\tkernfs_put(pos);\n\t\tif (!valid)\n\t\t\tpos = NULL;\n\t}\n\tif (!pos && (hash > 1) && (hash < INT_MAX)) {\n\t\tstruct rb_node *node = parent->dir.children.rb_node;\n\t\twhile (node) {\n\t\t\tpos = rb_to_kn(node);\n\n\t\t\tif (hash < pos->hash)\n\t\t\t\tnode = node->rb_left;\n\t\t\telse if (hash > pos->hash)\n\t\t\t\tnode = node->rb_right;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* Skip over entries which are dying/dead or in the wrong namespace */\n\twhile (pos && (!kernfs_active(pos) || pos->ns != ns)) {\n\t\tstruct rb_node *node = rb_next(&pos->rb);\n\t\tif (!node)\n\t\t\tpos = NULL;\n\t\telse\n\t\t\tpos = rb_to_kn(node);\n\t}\n\treturn pos;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic struct kernfs_node *kernfs_dir_pos(const void *ns,\n\tstruct kernfs_node *parent, loff_t hash, struct kernfs_node *pos)\n{\n\tif (pos) {\n\t\tint valid = kernfs_active(pos) &&\n\t\t\tpos->parent == parent && hash == pos->hash;\n\t\tkernfs_put(pos);\n\t\tif (!valid)\n\t\t\tpos = NULL;\n\t}\n\tif (!pos && (hash > 1) && (hash < INT_MAX)) {\n\t\tstruct rb_node *node = parent->dir.children.rb_node;\n\t\twhile (node) {\n\t\t\tpos = rb_to_kn(node);\n\n\t\t\tif (hash < pos->hash)\n\t\t\t\tnode = node->rb_left;\n\t\t\telse if (hash > pos->hash)\n\t\t\t\tnode = node->rb_right;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* Skip over entries which are dying/dead or in the wrong namespace */\n\twhile (pos && (!kernfs_active(pos) || pos->ns != ns)) {\n\t\tstruct rb_node *node = rb_next(&pos->rb);\n\t\tif (!node)\n\t\t\tpos = NULL;\n\t\telse\n\t\t\tpos = rb_to_kn(node);\n\t}\n\treturn pos;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic struct kernfs_node *kernfs_dir_next_pos(const void *ns,\n\tstruct kernfs_node *parent, ino_t ino, struct kernfs_node *pos)\n{\n\tpos = kernfs_dir_pos(ns, parent, ino, pos);\n\tif (pos) {\n\t\tdo {\n\t\t\tstruct rb_node *node = rb_next(&pos->rb);\n\t\t\tif (!node)\n\t\t\t\tpos = NULL;\n\t\t\telse\n\t\t\t\tpos = rb_to_kn(node);\n\t\t} while (pos && (!kernfs_active(pos) || pos->ns != ns));\n\t}\n\treturn pos;\n}"
  },
  {
    "function_name": "kernfs_dir_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "1316-1348",
    "snippet": "static struct kernfs_node *kernfs_dir_pos(const void *ns,\n\tstruct kernfs_node *parent, loff_t hash, struct kernfs_node *pos)\n{\n\tif (pos) {\n\t\tint valid = kernfs_active(pos) &&\n\t\t\tpos->parent == parent && hash == pos->hash;\n\t\tkernfs_put(pos);\n\t\tif (!valid)\n\t\t\tpos = NULL;\n\t}\n\tif (!pos && (hash > 1) && (hash < INT_MAX)) {\n\t\tstruct rb_node *node = parent->dir.children.rb_node;\n\t\twhile (node) {\n\t\t\tpos = rb_to_kn(node);\n\n\t\t\tif (hash < pos->hash)\n\t\t\t\tnode = node->rb_left;\n\t\t\telse if (hash > pos->hash)\n\t\t\t\tnode = node->rb_right;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* Skip over entries which are dying/dead or in the wrong namespace */\n\twhile (pos && (!kernfs_active(pos) || pos->ns != ns)) {\n\t\tstruct rb_node *node = rb_next(&pos->rb);\n\t\tif (!node)\n\t\t\tpos = NULL;\n\t\telse\n\t\t\tpos = rb_to_kn(node);\n\t}\n\treturn pos;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_to_kn",
          "args": [
            "node"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&pos->rb"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_active",
          "args": [
            "pos"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "27-31",
          "snippet": "static bool kernfs_active(struct kernfs_node *kn)\n{\n\tlockdep_assert_held(&kernfs_mutex);\n\treturn atomic_read(&kn->active) >= 0;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic bool kernfs_active(struct kernfs_node *kn)\n{\n\tlockdep_assert_held(&kernfs_mutex);\n\treturn atomic_read(&kn->active) >= 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_to_kn",
          "args": [
            "node"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "pos"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "393-436",
          "snippet": "void kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic struct kernfs_node *kernfs_dir_pos(const void *ns,\n\tstruct kernfs_node *parent, loff_t hash, struct kernfs_node *pos)\n{\n\tif (pos) {\n\t\tint valid = kernfs_active(pos) &&\n\t\t\tpos->parent == parent && hash == pos->hash;\n\t\tkernfs_put(pos);\n\t\tif (!valid)\n\t\t\tpos = NULL;\n\t}\n\tif (!pos && (hash > 1) && (hash < INT_MAX)) {\n\t\tstruct rb_node *node = parent->dir.children.rb_node;\n\t\twhile (node) {\n\t\t\tpos = rb_to_kn(node);\n\n\t\t\tif (hash < pos->hash)\n\t\t\t\tnode = node->rb_left;\n\t\t\telse if (hash > pos->hash)\n\t\t\t\tnode = node->rb_right;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* Skip over entries which are dying/dead or in the wrong namespace */\n\twhile (pos && (!kernfs_active(pos) || pos->ns != ns)) {\n\t\tstruct rb_node *node = rb_next(&pos->rb);\n\t\tif (!node)\n\t\t\tpos = NULL;\n\t\telse\n\t\t\tpos = rb_to_kn(node);\n\t}\n\treturn pos;\n}"
  },
  {
    "function_name": "kernfs_dir_fop_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "1310-1314",
    "snippet": "static int kernfs_dir_fop_release(struct inode *inode, struct file *filp)\n{\n\tkernfs_put(filp->private_data);\n\treturn 0;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "filp->private_data"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "393-436",
          "snippet": "void kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic int kernfs_dir_fop_release(struct inode *inode, struct file *filp)\n{\n\tkernfs_put(filp->private_data);\n\treturn 0;\n}"
  },
  {
    "function_name": "dt_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "1305-1308",
    "snippet": "static inline unsigned char dt_type(struct kernfs_node *kn)\n{\n\treturn (kn->mode >> 12) & 15;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic inline unsigned char dt_type(struct kernfs_node *kn)\n{\n\treturn (kn->mode >> 12) & 15;\n}"
  },
  {
    "function_name": "kernfs_rename_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "1236-1302",
    "snippet": "int kernfs_rename_ns(struct kernfs_node *kn, struct kernfs_node *new_parent,\n\t\t     const char *new_name, const void *new_ns)\n{\n\tstruct kernfs_node *old_parent;\n\tconst char *old_name = NULL;\n\tint error;\n\n\t/* can't move or rename root */\n\tif (!kn->parent)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kernfs_mutex);\n\n\terror = -ENOENT;\n\tif (!kernfs_active(kn) || !kernfs_active(new_parent))\n\t\tgoto out;\n\n\terror = 0;\n\tif ((kn->parent == new_parent) && (kn->ns == new_ns) &&\n\t    (strcmp(kn->name, new_name) == 0))\n\t\tgoto out;\t/* nothing to rename */\n\n\terror = -EEXIST;\n\tif (kernfs_find_ns(new_parent, new_name, new_ns))\n\t\tgoto out;\n\n\t/* rename kernfs_node */\n\tif (strcmp(kn->name, new_name) != 0) {\n\t\terror = -ENOMEM;\n\t\tnew_name = kstrdup_const(new_name, GFP_KERNEL);\n\t\tif (!new_name)\n\t\t\tgoto out;\n\t} else {\n\t\tnew_name = NULL;\n\t}\n\n\t/*\n\t * Move to the appropriate place in the appropriate directories rbtree.\n\t */\n\tkernfs_unlink_sibling(kn);\n\tkernfs_get(new_parent);\n\n\t/* rename_lock protects ->parent and ->name accessors */\n\tspin_lock_irq(&kernfs_rename_lock);\n\n\told_parent = kn->parent;\n\tkn->parent = new_parent;\n\n\tkn->ns = new_ns;\n\tif (new_name) {\n\t\told_name = kn->name;\n\t\tkn->name = new_name;\n\t}\n\n\tspin_unlock_irq(&kernfs_rename_lock);\n\n\tkn->hash = kernfs_name_hash(kn->name, kn->ns);\n\tkernfs_link_sibling(kn);\n\n\tkernfs_put(old_parent);\n\tkfree_const(old_name);\n\n\terror = 0;\n out:\n\tmutex_unlock(&kernfs_mutex);\n\treturn error;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(kernfs_rename_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree_const",
          "args": [
            "old_name"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "old_parent"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "393-436",
          "snippet": "void kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_link_sibling",
          "args": [
            "kn"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_link_sibling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "234-263",
          "snippet": "static int kernfs_link_sibling(struct kernfs_node *kn)\n{\n\tstruct rb_node **node = &kn->parent->dir.children.rb_node;\n\tstruct rb_node *parent = NULL;\n\n\twhile (*node) {\n\t\tstruct kernfs_node *pos;\n\t\tint result;\n\n\t\tpos = rb_to_kn(*node);\n\t\tparent = *node;\n\t\tresult = kernfs_sd_compare(kn, pos);\n\t\tif (result < 0)\n\t\t\tnode = &pos->rb.rb_left;\n\t\telse if (result > 0)\n\t\t\tnode = &pos->rb.rb_right;\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\t/* add new node and rebalance the tree */\n\trb_link_node(&kn->rb, parent, node);\n\trb_insert_color(&kn->rb, &kn->parent->dir.children);\n\n\t/* successfully added, account subdir number */\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tkn->parent->dir.subdirs++;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic int kernfs_link_sibling(struct kernfs_node *kn)\n{\n\tstruct rb_node **node = &kn->parent->dir.children.rb_node;\n\tstruct rb_node *parent = NULL;\n\n\twhile (*node) {\n\t\tstruct kernfs_node *pos;\n\t\tint result;\n\n\t\tpos = rb_to_kn(*node);\n\t\tparent = *node;\n\t\tresult = kernfs_sd_compare(kn, pos);\n\t\tif (result < 0)\n\t\t\tnode = &pos->rb.rb_left;\n\t\telse if (result > 0)\n\t\t\tnode = &pos->rb.rb_right;\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\t/* add new node and rebalance the tree */\n\trb_link_node(&kn->rb, parent, node);\n\trb_insert_color(&kn->rb, &kn->parent->dir.children);\n\n\t/* successfully added, account subdir number */\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tkn->parent->dir.subdirs++;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_name_hash",
          "args": [
            "kn->name",
            "kn->ns"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "185-199",
          "snippet": "static unsigned int kernfs_name_hash(const char *name, const void *ns)\n{\n\tunsigned long hash = init_name_hash();\n\tunsigned int len = strlen(name);\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\thash = (end_name_hash(hash) ^ hash_ptr((void *)ns, 31));\n\thash &= 0x7fffffffU;\n\t/* Reserve hash numbers 0, 1 and INT_MAX for magic directory entries */\n\tif (hash < 2)\n\t\thash += 2;\n\tif (hash >= INT_MAX)\n\t\thash = INT_MAX - 1;\n\treturn hash;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic unsigned int kernfs_name_hash(const char *name, const void *ns)\n{\n\tunsigned long hash = init_name_hash();\n\tunsigned int len = strlen(name);\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\thash = (end_name_hash(hash) ^ hash_ptr((void *)ns, 31));\n\thash &= 0x7fffffffU;\n\t/* Reserve hash numbers 0, 1 and INT_MAX for magic directory entries */\n\tif (hash < 2)\n\t\thash += 2;\n\tif (hash >= INT_MAX)\n\t\thash = INT_MAX - 1;\n\treturn hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&kernfs_rename_lock"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&kernfs_rename_lock"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_get",
          "args": [
            "new_parent"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "378-384",
          "snippet": "void kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_unlink_sibling",
          "args": [
            "kn"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_unlink_sibling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "276-287",
          "snippet": "static bool kernfs_unlink_sibling(struct kernfs_node *kn)\n{\n\tif (RB_EMPTY_NODE(&kn->rb))\n\t\treturn false;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tkn->parent->dir.subdirs--;\n\n\trb_erase(&kn->rb, &kn->parent->dir.children);\n\tRB_CLEAR_NODE(&kn->rb);\n\treturn true;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic bool kernfs_unlink_sibling(struct kernfs_node *kn)\n{\n\tif (RB_EMPTY_NODE(&kn->rb))\n\t\treturn false;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tkn->parent->dir.subdirs--;\n\n\trb_erase(&kn->rb, &kn->parent->dir.children);\n\tRB_CLEAR_NODE(&kn->rb);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup_const",
          "args": [
            "new_name",
            "GFP_KERNEL"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "kn->name",
            "new_name"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_find_ns",
          "args": [
            "new_parent",
            "new_name",
            "new_ns"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_find_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "631-662",
          "snippet": "static struct kernfs_node *kernfs_find_ns(struct kernfs_node *parent,\n\t\t\t\t\t  const unsigned char *name,\n\t\t\t\t\t  const void *ns)\n{\n\tstruct rb_node *node = parent->dir.children.rb_node;\n\tbool has_ns = kernfs_ns_enabled(parent);\n\tunsigned int hash;\n\n\tlockdep_assert_held(&kernfs_mutex);\n\n\tif (has_ns != (bool)ns) {\n\t\tWARN(1, KERN_WARNING \"kernfs: ns %s in '%s' for '%s'\\n\",\n\t\t     has_ns ? \"required\" : \"invalid\", parent->name, name);\n\t\treturn NULL;\n\t}\n\n\thash = kernfs_name_hash(name, ns);\n\twhile (node) {\n\t\tstruct kernfs_node *kn;\n\t\tint result;\n\n\t\tkn = rb_to_kn(node);\n\t\tresult = kernfs_name_compare(hash, name, ns, kn);\n\t\tif (result < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (result > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn kn;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic struct kernfs_node *kernfs_find_ns(struct kernfs_node *parent,\n\t\t\t\t\t  const unsigned char *name,\n\t\t\t\t\t  const void *ns)\n{\n\tstruct rb_node *node = parent->dir.children.rb_node;\n\tbool has_ns = kernfs_ns_enabled(parent);\n\tunsigned int hash;\n\n\tlockdep_assert_held(&kernfs_mutex);\n\n\tif (has_ns != (bool)ns) {\n\t\tWARN(1, KERN_WARNING \"kernfs: ns %s in '%s' for '%s'\\n\",\n\t\t     has_ns ? \"required\" : \"invalid\", parent->name, name);\n\t\treturn NULL;\n\t}\n\n\thash = kernfs_name_hash(name, ns);\n\twhile (node) {\n\t\tstruct kernfs_node *kn;\n\t\tint result;\n\n\t\tkn = rb_to_kn(node);\n\t\tresult = kernfs_name_compare(hash, name, ns, kn);\n\t\tif (result < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (result > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn kn;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_active",
          "args": [
            "new_parent"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "27-31",
          "snippet": "static bool kernfs_active(struct kernfs_node *kn)\n{\n\tlockdep_assert_held(&kernfs_mutex);\n\treturn atomic_read(&kn->active) >= 0;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic bool kernfs_active(struct kernfs_node *kn)\n{\n\tlockdep_assert_held(&kernfs_mutex);\n\treturn atomic_read(&kn->active) >= 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(kernfs_rename_lock);\n\nint kernfs_rename_ns(struct kernfs_node *kn, struct kernfs_node *new_parent,\n\t\t     const char *new_name, const void *new_ns)\n{\n\tstruct kernfs_node *old_parent;\n\tconst char *old_name = NULL;\n\tint error;\n\n\t/* can't move or rename root */\n\tif (!kn->parent)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kernfs_mutex);\n\n\terror = -ENOENT;\n\tif (!kernfs_active(kn) || !kernfs_active(new_parent))\n\t\tgoto out;\n\n\terror = 0;\n\tif ((kn->parent == new_parent) && (kn->ns == new_ns) &&\n\t    (strcmp(kn->name, new_name) == 0))\n\t\tgoto out;\t/* nothing to rename */\n\n\terror = -EEXIST;\n\tif (kernfs_find_ns(new_parent, new_name, new_ns))\n\t\tgoto out;\n\n\t/* rename kernfs_node */\n\tif (strcmp(kn->name, new_name) != 0) {\n\t\terror = -ENOMEM;\n\t\tnew_name = kstrdup_const(new_name, GFP_KERNEL);\n\t\tif (!new_name)\n\t\t\tgoto out;\n\t} else {\n\t\tnew_name = NULL;\n\t}\n\n\t/*\n\t * Move to the appropriate place in the appropriate directories rbtree.\n\t */\n\tkernfs_unlink_sibling(kn);\n\tkernfs_get(new_parent);\n\n\t/* rename_lock protects ->parent and ->name accessors */\n\tspin_lock_irq(&kernfs_rename_lock);\n\n\told_parent = kn->parent;\n\tkn->parent = new_parent;\n\n\tkn->ns = new_ns;\n\tif (new_name) {\n\t\told_name = kn->name;\n\t\tkn->name = new_name;\n\t}\n\n\tspin_unlock_irq(&kernfs_rename_lock);\n\n\tkn->hash = kernfs_name_hash(kn->name, kn->ns);\n\tkernfs_link_sibling(kn);\n\n\tkernfs_put(old_parent);\n\tkfree_const(old_name);\n\n\terror = 0;\n out:\n\tmutex_unlock(&kernfs_mutex);\n\treturn error;\n}"
  },
  {
    "function_name": "kernfs_remove_by_name_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "1204-1227",
    "snippet": "int kernfs_remove_by_name_ns(struct kernfs_node *parent, const char *name,\n\t\t\t     const void *ns)\n{\n\tstruct kernfs_node *kn;\n\n\tif (!parent) {\n\t\tWARN(1, KERN_WARNING \"kernfs: can not remove '%s', no directory\\n\",\n\t\t\tname);\n\t\treturn -ENOENT;\n\t}\n\n\tmutex_lock(&kernfs_mutex);\n\n\tkn = kernfs_find_ns(parent, name, ns);\n\tif (kn)\n\t\t__kernfs_remove(kn);\n\n\tmutex_unlock(&kernfs_mutex);\n\n\tif (kn)\n\t\treturn 0;\n\telse\n\t\treturn -ENOENT;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kernfs_remove",
          "args": [
            "kn"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "__kernfs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "985-1049",
          "snippet": "static void __kernfs_remove(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *pos;\n\n\tlockdep_assert_held(&kernfs_mutex);\n\n\t/*\n\t * Short-circuit if non-root @kn has already finished removal.\n\t * This is for kernfs_remove_self() which plays with active ref\n\t * after removal.\n\t */\n\tif (!kn || (kn->parent && RB_EMPTY_NODE(&kn->rb)))\n\t\treturn;\n\n\tpr_debug(\"kernfs %s: removing\\n\", kn->name);\n\n\t/* prevent any new usage under @kn by deactivating all nodes */\n\tpos = NULL;\n\twhile ((pos = kernfs_next_descendant_post(pos, kn)))\n\t\tif (kernfs_active(pos))\n\t\t\tatomic_add(KN_DEACTIVATED_BIAS, &pos->active);\n\n\t/* deactivate and unlink the subtree node-by-node */\n\tdo {\n\t\tpos = kernfs_leftmost_descendant(kn);\n\n\t\t/*\n\t\t * kernfs_drain() drops kernfs_mutex temporarily and @pos's\n\t\t * base ref could have been put by someone else by the time\n\t\t * the function returns.  Make sure it doesn't go away\n\t\t * underneath us.\n\t\t */\n\t\tkernfs_get(pos);\n\n\t\t/*\n\t\t * Drain iff @kn was activated.  This avoids draining and\n\t\t * its lockdep annotations for nodes which have never been\n\t\t * activated and allows embedding kernfs_remove() in create\n\t\t * error paths without worrying about draining.\n\t\t */\n\t\tif (kn->flags & KERNFS_ACTIVATED)\n\t\t\tkernfs_drain(pos);\n\t\telse\n\t\t\tWARN_ON_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS);\n\n\t\t/*\n\t\t * kernfs_unlink_sibling() succeeds once per node.  Use it\n\t\t * to decide who's responsible for cleanups.\n\t\t */\n\t\tif (!pos->parent || kernfs_unlink_sibling(pos)) {\n\t\t\tstruct kernfs_iattrs *ps_iattr =\n\t\t\t\tpos->parent ? pos->parent->iattr : NULL;\n\n\t\t\t/* update timestamps on the parent */\n\t\t\tif (ps_iattr) {\n\t\t\t\tps_iattr->ia_iattr.ia_ctime = CURRENT_TIME;\n\t\t\t\tps_iattr->ia_iattr.ia_mtime = CURRENT_TIME;\n\t\t\t}\n\n\t\t\tkernfs_put(pos);\n\t\t}\n\n\t\tkernfs_put(pos);\n\t} while (pos != kn);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic void __kernfs_remove(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *pos;\n\n\tlockdep_assert_held(&kernfs_mutex);\n\n\t/*\n\t * Short-circuit if non-root @kn has already finished removal.\n\t * This is for kernfs_remove_self() which plays with active ref\n\t * after removal.\n\t */\n\tif (!kn || (kn->parent && RB_EMPTY_NODE(&kn->rb)))\n\t\treturn;\n\n\tpr_debug(\"kernfs %s: removing\\n\", kn->name);\n\n\t/* prevent any new usage under @kn by deactivating all nodes */\n\tpos = NULL;\n\twhile ((pos = kernfs_next_descendant_post(pos, kn)))\n\t\tif (kernfs_active(pos))\n\t\t\tatomic_add(KN_DEACTIVATED_BIAS, &pos->active);\n\n\t/* deactivate and unlink the subtree node-by-node */\n\tdo {\n\t\tpos = kernfs_leftmost_descendant(kn);\n\n\t\t/*\n\t\t * kernfs_drain() drops kernfs_mutex temporarily and @pos's\n\t\t * base ref could have been put by someone else by the time\n\t\t * the function returns.  Make sure it doesn't go away\n\t\t * underneath us.\n\t\t */\n\t\tkernfs_get(pos);\n\n\t\t/*\n\t\t * Drain iff @kn was activated.  This avoids draining and\n\t\t * its lockdep annotations for nodes which have never been\n\t\t * activated and allows embedding kernfs_remove() in create\n\t\t * error paths without worrying about draining.\n\t\t */\n\t\tif (kn->flags & KERNFS_ACTIVATED)\n\t\t\tkernfs_drain(pos);\n\t\telse\n\t\t\tWARN_ON_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS);\n\n\t\t/*\n\t\t * kernfs_unlink_sibling() succeeds once per node.  Use it\n\t\t * to decide who's responsible for cleanups.\n\t\t */\n\t\tif (!pos->parent || kernfs_unlink_sibling(pos)) {\n\t\t\tstruct kernfs_iattrs *ps_iattr =\n\t\t\t\tpos->parent ? pos->parent->iattr : NULL;\n\n\t\t\t/* update timestamps on the parent */\n\t\t\tif (ps_iattr) {\n\t\t\t\tps_iattr->ia_iattr.ia_ctime = CURRENT_TIME;\n\t\t\t\tps_iattr->ia_iattr.ia_mtime = CURRENT_TIME;\n\t\t\t}\n\n\t\t\tkernfs_put(pos);\n\t\t}\n\n\t\tkernfs_put(pos);\n\t} while (pos != kn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_find_ns",
          "args": [
            "parent",
            "name",
            "ns"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_find_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "631-662",
          "snippet": "static struct kernfs_node *kernfs_find_ns(struct kernfs_node *parent,\n\t\t\t\t\t  const unsigned char *name,\n\t\t\t\t\t  const void *ns)\n{\n\tstruct rb_node *node = parent->dir.children.rb_node;\n\tbool has_ns = kernfs_ns_enabled(parent);\n\tunsigned int hash;\n\n\tlockdep_assert_held(&kernfs_mutex);\n\n\tif (has_ns != (bool)ns) {\n\t\tWARN(1, KERN_WARNING \"kernfs: ns %s in '%s' for '%s'\\n\",\n\t\t     has_ns ? \"required\" : \"invalid\", parent->name, name);\n\t\treturn NULL;\n\t}\n\n\thash = kernfs_name_hash(name, ns);\n\twhile (node) {\n\t\tstruct kernfs_node *kn;\n\t\tint result;\n\n\t\tkn = rb_to_kn(node);\n\t\tresult = kernfs_name_compare(hash, name, ns, kn);\n\t\tif (result < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (result > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn kn;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic struct kernfs_node *kernfs_find_ns(struct kernfs_node *parent,\n\t\t\t\t\t  const unsigned char *name,\n\t\t\t\t\t  const void *ns)\n{\n\tstruct rb_node *node = parent->dir.children.rb_node;\n\tbool has_ns = kernfs_ns_enabled(parent);\n\tunsigned int hash;\n\n\tlockdep_assert_held(&kernfs_mutex);\n\n\tif (has_ns != (bool)ns) {\n\t\tWARN(1, KERN_WARNING \"kernfs: ns %s in '%s' for '%s'\\n\",\n\t\t     has_ns ? \"required\" : \"invalid\", parent->name, name);\n\t\treturn NULL;\n\t}\n\n\thash = kernfs_name_hash(name, ns);\n\twhile (node) {\n\t\tstruct kernfs_node *kn;\n\t\tint result;\n\n\t\tkn = rb_to_kn(node);\n\t\tresult = kernfs_name_compare(hash, name, ns, kn);\n\t\tif (result < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (result > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn kn;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "KERN_WARNING \"kernfs: can not remove '%s', no directory\\n\"",
            "name"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nint kernfs_remove_by_name_ns(struct kernfs_node *parent, const char *name,\n\t\t\t     const void *ns)\n{\n\tstruct kernfs_node *kn;\n\n\tif (!parent) {\n\t\tWARN(1, KERN_WARNING \"kernfs: can not remove '%s', no directory\\n\",\n\t\t\tname);\n\t\treturn -ENOENT;\n\t}\n\n\tmutex_lock(&kernfs_mutex);\n\n\tkn = kernfs_find_ns(parent, name, ns);\n\tif (kn)\n\t\t__kernfs_remove(kn);\n\n\tmutex_unlock(&kernfs_mutex);\n\n\tif (kn)\n\t\treturn 0;\n\telse\n\t\treturn -ENOENT;\n}"
  },
  {
    "function_name": "kernfs_remove_self",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "1144-1193",
    "snippet": "bool kernfs_remove_self(struct kernfs_node *kn)\n{\n\tbool ret;\n\n\tmutex_lock(&kernfs_mutex);\n\tkernfs_break_active_protection(kn);\n\n\t/*\n\t * SUICIDAL is used to arbitrate among competing invocations.  Only\n\t * the first one will actually perform removal.  When the removal\n\t * is complete, SUICIDED is set and the active ref is restored\n\t * while holding kernfs_mutex.  The ones which lost arbitration\n\t * waits for SUICDED && drained which can happen only after the\n\t * enclosing kernfs operation which executed the winning instance\n\t * of kernfs_remove_self() finished.\n\t */\n\tif (!(kn->flags & KERNFS_SUICIDAL)) {\n\t\tkn->flags |= KERNFS_SUICIDAL;\n\t\t__kernfs_remove(kn);\n\t\tkn->flags |= KERNFS_SUICIDED;\n\t\tret = true;\n\t} else {\n\t\twait_queue_head_t *waitq = &kernfs_root(kn)->deactivate_waitq;\n\t\tDEFINE_WAIT(wait);\n\n\t\twhile (true) {\n\t\t\tprepare_to_wait(waitq, &wait, TASK_UNINTERRUPTIBLE);\n\n\t\t\tif ((kn->flags & KERNFS_SUICIDED) &&\n\t\t\t    atomic_read(&kn->active) == KN_DEACTIVATED_BIAS)\n\t\t\t\tbreak;\n\n\t\t\tmutex_unlock(&kernfs_mutex);\n\t\t\tschedule();\n\t\t\tmutex_lock(&kernfs_mutex);\n\t\t}\n\t\tfinish_wait(waitq, &wait);\n\t\tWARN_ON_ONCE(!RB_EMPTY_NODE(&kn->rb));\n\t\tret = false;\n\t}\n\n\t/*\n\t * This must be done while holding kernfs_mutex; otherwise, waiting\n\t * for SUICIDED && deactivated could finish prematurely.\n\t */\n\tkernfs_unbreak_active_protection(kn);\n\n\tmutex_unlock(&kernfs_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_unbreak_active_protection",
          "args": [
            "kn"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_unbreak_active_protection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "1102-1116",
          "snippet": "void kernfs_unbreak_active_protection(struct kernfs_node *kn)\n{\n\t/*\n\t * @kn->active could be in any state; however, the increment we do\n\t * here will be undone as soon as the enclosing kernfs operation\n\t * finishes and this temporary bump can't break anything.  If @kn\n\t * is alive, nothing changes.  If @kn is being deactivated, the\n\t * soon-to-follow put will either finish deactivation or restore\n\t * deactivated state.  If @kn is already removed, the temporary\n\t * bump is guaranteed to be gone before @kn is released.\n\t */\n\tatomic_inc(&kn->active);\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire(&kn->dep_map, 0, 1, _RET_IP_);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_unbreak_active_protection(struct kernfs_node *kn)\n{\n\t/*\n\t * @kn->active could be in any state; however, the increment we do\n\t * here will be undone as soon as the enclosing kernfs operation\n\t * finishes and this temporary bump can't break anything.  If @kn\n\t * is alive, nothing changes.  If @kn is being deactivated, the\n\t * soon-to-follow put will either finish deactivation or restore\n\t * deactivated state.  If @kn is already removed, the temporary\n\t * bump is guaranteed to be gone before @kn is released.\n\t */\n\tatomic_inc(&kn->active);\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire(&kn->dep_map, 0, 1, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!RB_EMPTY_NODE(&kn->rb)"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&kn->rb"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "waitq",
            "&wait"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kn->active"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "waitq",
            "&wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_root",
          "args": [
            "kn"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/kernfs-internal.h",
          "lines": "40-46",
          "snippet": "static inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)\n{\n\t/* if parent exists, it's always a dir; otherwise, @sd is a dir */\n\tif (kn->parent)\n\t\tkn = kn->parent;\n\treturn kn->dir.root;\n}",
          "includes": [
            "#include <linux/kernfs.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernfs.h>\n#include <linux/xattr.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/lockdep.h>\n\nstatic inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)\n{\n\t/* if parent exists, it's always a dir; otherwise, @sd is a dir */\n\tif (kn->parent)\n\t\tkn = kn->parent;\n\treturn kn->dir.root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kernfs_remove",
          "args": [
            "kn"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "__kernfs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "985-1049",
          "snippet": "static void __kernfs_remove(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *pos;\n\n\tlockdep_assert_held(&kernfs_mutex);\n\n\t/*\n\t * Short-circuit if non-root @kn has already finished removal.\n\t * This is for kernfs_remove_self() which plays with active ref\n\t * after removal.\n\t */\n\tif (!kn || (kn->parent && RB_EMPTY_NODE(&kn->rb)))\n\t\treturn;\n\n\tpr_debug(\"kernfs %s: removing\\n\", kn->name);\n\n\t/* prevent any new usage under @kn by deactivating all nodes */\n\tpos = NULL;\n\twhile ((pos = kernfs_next_descendant_post(pos, kn)))\n\t\tif (kernfs_active(pos))\n\t\t\tatomic_add(KN_DEACTIVATED_BIAS, &pos->active);\n\n\t/* deactivate and unlink the subtree node-by-node */\n\tdo {\n\t\tpos = kernfs_leftmost_descendant(kn);\n\n\t\t/*\n\t\t * kernfs_drain() drops kernfs_mutex temporarily and @pos's\n\t\t * base ref could have been put by someone else by the time\n\t\t * the function returns.  Make sure it doesn't go away\n\t\t * underneath us.\n\t\t */\n\t\tkernfs_get(pos);\n\n\t\t/*\n\t\t * Drain iff @kn was activated.  This avoids draining and\n\t\t * its lockdep annotations for nodes which have never been\n\t\t * activated and allows embedding kernfs_remove() in create\n\t\t * error paths without worrying about draining.\n\t\t */\n\t\tif (kn->flags & KERNFS_ACTIVATED)\n\t\t\tkernfs_drain(pos);\n\t\telse\n\t\t\tWARN_ON_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS);\n\n\t\t/*\n\t\t * kernfs_unlink_sibling() succeeds once per node.  Use it\n\t\t * to decide who's responsible for cleanups.\n\t\t */\n\t\tif (!pos->parent || kernfs_unlink_sibling(pos)) {\n\t\t\tstruct kernfs_iattrs *ps_iattr =\n\t\t\t\tpos->parent ? pos->parent->iattr : NULL;\n\n\t\t\t/* update timestamps on the parent */\n\t\t\tif (ps_iattr) {\n\t\t\t\tps_iattr->ia_iattr.ia_ctime = CURRENT_TIME;\n\t\t\t\tps_iattr->ia_iattr.ia_mtime = CURRENT_TIME;\n\t\t\t}\n\n\t\t\tkernfs_put(pos);\n\t\t}\n\n\t\tkernfs_put(pos);\n\t} while (pos != kn);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic void __kernfs_remove(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *pos;\n\n\tlockdep_assert_held(&kernfs_mutex);\n\n\t/*\n\t * Short-circuit if non-root @kn has already finished removal.\n\t * This is for kernfs_remove_self() which plays with active ref\n\t * after removal.\n\t */\n\tif (!kn || (kn->parent && RB_EMPTY_NODE(&kn->rb)))\n\t\treturn;\n\n\tpr_debug(\"kernfs %s: removing\\n\", kn->name);\n\n\t/* prevent any new usage under @kn by deactivating all nodes */\n\tpos = NULL;\n\twhile ((pos = kernfs_next_descendant_post(pos, kn)))\n\t\tif (kernfs_active(pos))\n\t\t\tatomic_add(KN_DEACTIVATED_BIAS, &pos->active);\n\n\t/* deactivate and unlink the subtree node-by-node */\n\tdo {\n\t\tpos = kernfs_leftmost_descendant(kn);\n\n\t\t/*\n\t\t * kernfs_drain() drops kernfs_mutex temporarily and @pos's\n\t\t * base ref could have been put by someone else by the time\n\t\t * the function returns.  Make sure it doesn't go away\n\t\t * underneath us.\n\t\t */\n\t\tkernfs_get(pos);\n\n\t\t/*\n\t\t * Drain iff @kn was activated.  This avoids draining and\n\t\t * its lockdep annotations for nodes which have never been\n\t\t * activated and allows embedding kernfs_remove() in create\n\t\t * error paths without worrying about draining.\n\t\t */\n\t\tif (kn->flags & KERNFS_ACTIVATED)\n\t\t\tkernfs_drain(pos);\n\t\telse\n\t\t\tWARN_ON_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS);\n\n\t\t/*\n\t\t * kernfs_unlink_sibling() succeeds once per node.  Use it\n\t\t * to decide who's responsible for cleanups.\n\t\t */\n\t\tif (!pos->parent || kernfs_unlink_sibling(pos)) {\n\t\t\tstruct kernfs_iattrs *ps_iattr =\n\t\t\t\tpos->parent ? pos->parent->iattr : NULL;\n\n\t\t\t/* update timestamps on the parent */\n\t\t\tif (ps_iattr) {\n\t\t\t\tps_iattr->ia_iattr.ia_ctime = CURRENT_TIME;\n\t\t\t\tps_iattr->ia_iattr.ia_mtime = CURRENT_TIME;\n\t\t\t}\n\n\t\t\tkernfs_put(pos);\n\t\t}\n\n\t\tkernfs_put(pos);\n\t} while (pos != kn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_break_active_protection",
          "args": [
            "kn"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_break_active_protection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "1078-1085",
          "snippet": "void kernfs_break_active_protection(struct kernfs_node *kn)\n{\n\t/*\n\t * Take out ourself out of the active ref dependency chain.  If\n\t * we're called without an active ref, lockdep will complain.\n\t */\n\tkernfs_put_active(kn);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_break_active_protection(struct kernfs_node *kn)\n{\n\t/*\n\t * Take out ourself out of the active ref dependency chain.  If\n\t * we're called without an active ref, lockdep will complain.\n\t */\n\tkernfs_put_active(kn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nbool kernfs_remove_self(struct kernfs_node *kn)\n{\n\tbool ret;\n\n\tmutex_lock(&kernfs_mutex);\n\tkernfs_break_active_protection(kn);\n\n\t/*\n\t * SUICIDAL is used to arbitrate among competing invocations.  Only\n\t * the first one will actually perform removal.  When the removal\n\t * is complete, SUICIDED is set and the active ref is restored\n\t * while holding kernfs_mutex.  The ones which lost arbitration\n\t * waits for SUICDED && drained which can happen only after the\n\t * enclosing kernfs operation which executed the winning instance\n\t * of kernfs_remove_self() finished.\n\t */\n\tif (!(kn->flags & KERNFS_SUICIDAL)) {\n\t\tkn->flags |= KERNFS_SUICIDAL;\n\t\t__kernfs_remove(kn);\n\t\tkn->flags |= KERNFS_SUICIDED;\n\t\tret = true;\n\t} else {\n\t\twait_queue_head_t *waitq = &kernfs_root(kn)->deactivate_waitq;\n\t\tDEFINE_WAIT(wait);\n\n\t\twhile (true) {\n\t\t\tprepare_to_wait(waitq, &wait, TASK_UNINTERRUPTIBLE);\n\n\t\t\tif ((kn->flags & KERNFS_SUICIDED) &&\n\t\t\t    atomic_read(&kn->active) == KN_DEACTIVATED_BIAS)\n\t\t\t\tbreak;\n\n\t\t\tmutex_unlock(&kernfs_mutex);\n\t\t\tschedule();\n\t\t\tmutex_lock(&kernfs_mutex);\n\t\t}\n\t\tfinish_wait(waitq, &wait);\n\t\tWARN_ON_ONCE(!RB_EMPTY_NODE(&kn->rb));\n\t\tret = false;\n\t}\n\n\t/*\n\t * This must be done while holding kernfs_mutex; otherwise, waiting\n\t * for SUICIDED && deactivated could finish prematurely.\n\t */\n\tkernfs_unbreak_active_protection(kn);\n\n\tmutex_unlock(&kernfs_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "kernfs_unbreak_active_protection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "1102-1116",
    "snippet": "void kernfs_unbreak_active_protection(struct kernfs_node *kn)\n{\n\t/*\n\t * @kn->active could be in any state; however, the increment we do\n\t * here will be undone as soon as the enclosing kernfs operation\n\t * finishes and this temporary bump can't break anything.  If @kn\n\t * is alive, nothing changes.  If @kn is being deactivated, the\n\t * soon-to-follow put will either finish deactivation or restore\n\t * deactivated state.  If @kn is already removed, the temporary\n\t * bump is guaranteed to be gone before @kn is released.\n\t */\n\tatomic_inc(&kn->active);\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire(&kn->dep_map, 0, 1, _RET_IP_);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rwsem_acquire",
          "args": [
            "&kn->dep_map",
            "0",
            "1",
            "_RET_IP_"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_lockdep",
          "args": [
            "kn"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_lockdep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "33-40",
          "snippet": "static bool kernfs_lockdep(struct kernfs_node *kn)\n{\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\treturn kn->flags & KERNFS_LOCKDEP;\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic bool kernfs_lockdep(struct kernfs_node *kn)\n{\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\treturn kn->flags & KERNFS_LOCKDEP;\n#else\n\treturn false;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&kn->active"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_unbreak_active_protection(struct kernfs_node *kn)\n{\n\t/*\n\t * @kn->active could be in any state; however, the increment we do\n\t * here will be undone as soon as the enclosing kernfs operation\n\t * finishes and this temporary bump can't break anything.  If @kn\n\t * is alive, nothing changes.  If @kn is being deactivated, the\n\t * soon-to-follow put will either finish deactivation or restore\n\t * deactivated state.  If @kn is already removed, the temporary\n\t * bump is guaranteed to be gone before @kn is released.\n\t */\n\tatomic_inc(&kn->active);\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire(&kn->dep_map, 0, 1, _RET_IP_);\n}"
  },
  {
    "function_name": "kernfs_break_active_protection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "1078-1085",
    "snippet": "void kernfs_break_active_protection(struct kernfs_node *kn)\n{\n\t/*\n\t * Take out ourself out of the active ref dependency chain.  If\n\t * we're called without an active ref, lockdep will complain.\n\t */\n\tkernfs_put_active(kn);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put_active",
          "args": [
            "kn"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "319-334",
          "snippet": "void kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_break_active_protection(struct kernfs_node *kn)\n{\n\t/*\n\t * Take out ourself out of the active ref dependency chain.  If\n\t * we're called without an active ref, lockdep will complain.\n\t */\n\tkernfs_put_active(kn);\n}"
  },
  {
    "function_name": "kernfs_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "1057-1062",
    "snippet": "void kernfs_remove(struct kernfs_node *kn)\n{\n\tmutex_lock(&kernfs_mutex);\n\t__kernfs_remove(kn);\n\tmutex_unlock(&kernfs_mutex);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kernfs_remove",
          "args": [
            "kn"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "__kernfs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "985-1049",
          "snippet": "static void __kernfs_remove(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *pos;\n\n\tlockdep_assert_held(&kernfs_mutex);\n\n\t/*\n\t * Short-circuit if non-root @kn has already finished removal.\n\t * This is for kernfs_remove_self() which plays with active ref\n\t * after removal.\n\t */\n\tif (!kn || (kn->parent && RB_EMPTY_NODE(&kn->rb)))\n\t\treturn;\n\n\tpr_debug(\"kernfs %s: removing\\n\", kn->name);\n\n\t/* prevent any new usage under @kn by deactivating all nodes */\n\tpos = NULL;\n\twhile ((pos = kernfs_next_descendant_post(pos, kn)))\n\t\tif (kernfs_active(pos))\n\t\t\tatomic_add(KN_DEACTIVATED_BIAS, &pos->active);\n\n\t/* deactivate and unlink the subtree node-by-node */\n\tdo {\n\t\tpos = kernfs_leftmost_descendant(kn);\n\n\t\t/*\n\t\t * kernfs_drain() drops kernfs_mutex temporarily and @pos's\n\t\t * base ref could have been put by someone else by the time\n\t\t * the function returns.  Make sure it doesn't go away\n\t\t * underneath us.\n\t\t */\n\t\tkernfs_get(pos);\n\n\t\t/*\n\t\t * Drain iff @kn was activated.  This avoids draining and\n\t\t * its lockdep annotations for nodes which have never been\n\t\t * activated and allows embedding kernfs_remove() in create\n\t\t * error paths without worrying about draining.\n\t\t */\n\t\tif (kn->flags & KERNFS_ACTIVATED)\n\t\t\tkernfs_drain(pos);\n\t\telse\n\t\t\tWARN_ON_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS);\n\n\t\t/*\n\t\t * kernfs_unlink_sibling() succeeds once per node.  Use it\n\t\t * to decide who's responsible for cleanups.\n\t\t */\n\t\tif (!pos->parent || kernfs_unlink_sibling(pos)) {\n\t\t\tstruct kernfs_iattrs *ps_iattr =\n\t\t\t\tpos->parent ? pos->parent->iattr : NULL;\n\n\t\t\t/* update timestamps on the parent */\n\t\t\tif (ps_iattr) {\n\t\t\t\tps_iattr->ia_iattr.ia_ctime = CURRENT_TIME;\n\t\t\t\tps_iattr->ia_iattr.ia_mtime = CURRENT_TIME;\n\t\t\t}\n\n\t\t\tkernfs_put(pos);\n\t\t}\n\n\t\tkernfs_put(pos);\n\t} while (pos != kn);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic void __kernfs_remove(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *pos;\n\n\tlockdep_assert_held(&kernfs_mutex);\n\n\t/*\n\t * Short-circuit if non-root @kn has already finished removal.\n\t * This is for kernfs_remove_self() which plays with active ref\n\t * after removal.\n\t */\n\tif (!kn || (kn->parent && RB_EMPTY_NODE(&kn->rb)))\n\t\treturn;\n\n\tpr_debug(\"kernfs %s: removing\\n\", kn->name);\n\n\t/* prevent any new usage under @kn by deactivating all nodes */\n\tpos = NULL;\n\twhile ((pos = kernfs_next_descendant_post(pos, kn)))\n\t\tif (kernfs_active(pos))\n\t\t\tatomic_add(KN_DEACTIVATED_BIAS, &pos->active);\n\n\t/* deactivate and unlink the subtree node-by-node */\n\tdo {\n\t\tpos = kernfs_leftmost_descendant(kn);\n\n\t\t/*\n\t\t * kernfs_drain() drops kernfs_mutex temporarily and @pos's\n\t\t * base ref could have been put by someone else by the time\n\t\t * the function returns.  Make sure it doesn't go away\n\t\t * underneath us.\n\t\t */\n\t\tkernfs_get(pos);\n\n\t\t/*\n\t\t * Drain iff @kn was activated.  This avoids draining and\n\t\t * its lockdep annotations for nodes which have never been\n\t\t * activated and allows embedding kernfs_remove() in create\n\t\t * error paths without worrying about draining.\n\t\t */\n\t\tif (kn->flags & KERNFS_ACTIVATED)\n\t\t\tkernfs_drain(pos);\n\t\telse\n\t\t\tWARN_ON_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS);\n\n\t\t/*\n\t\t * kernfs_unlink_sibling() succeeds once per node.  Use it\n\t\t * to decide who's responsible for cleanups.\n\t\t */\n\t\tif (!pos->parent || kernfs_unlink_sibling(pos)) {\n\t\t\tstruct kernfs_iattrs *ps_iattr =\n\t\t\t\tpos->parent ? pos->parent->iattr : NULL;\n\n\t\t\t/* update timestamps on the parent */\n\t\t\tif (ps_iattr) {\n\t\t\t\tps_iattr->ia_iattr.ia_ctime = CURRENT_TIME;\n\t\t\t\tps_iattr->ia_iattr.ia_mtime = CURRENT_TIME;\n\t\t\t}\n\n\t\t\tkernfs_put(pos);\n\t\t}\n\n\t\tkernfs_put(pos);\n\t} while (pos != kn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_remove(struct kernfs_node *kn)\n{\n\tmutex_lock(&kernfs_mutex);\n\t__kernfs_remove(kn);\n\tmutex_unlock(&kernfs_mutex);\n}"
  },
  {
    "function_name": "__kernfs_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "985-1049",
    "snippet": "static void __kernfs_remove(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *pos;\n\n\tlockdep_assert_held(&kernfs_mutex);\n\n\t/*\n\t * Short-circuit if non-root @kn has already finished removal.\n\t * This is for kernfs_remove_self() which plays with active ref\n\t * after removal.\n\t */\n\tif (!kn || (kn->parent && RB_EMPTY_NODE(&kn->rb)))\n\t\treturn;\n\n\tpr_debug(\"kernfs %s: removing\\n\", kn->name);\n\n\t/* prevent any new usage under @kn by deactivating all nodes */\n\tpos = NULL;\n\twhile ((pos = kernfs_next_descendant_post(pos, kn)))\n\t\tif (kernfs_active(pos))\n\t\t\tatomic_add(KN_DEACTIVATED_BIAS, &pos->active);\n\n\t/* deactivate and unlink the subtree node-by-node */\n\tdo {\n\t\tpos = kernfs_leftmost_descendant(kn);\n\n\t\t/*\n\t\t * kernfs_drain() drops kernfs_mutex temporarily and @pos's\n\t\t * base ref could have been put by someone else by the time\n\t\t * the function returns.  Make sure it doesn't go away\n\t\t * underneath us.\n\t\t */\n\t\tkernfs_get(pos);\n\n\t\t/*\n\t\t * Drain iff @kn was activated.  This avoids draining and\n\t\t * its lockdep annotations for nodes which have never been\n\t\t * activated and allows embedding kernfs_remove() in create\n\t\t * error paths without worrying about draining.\n\t\t */\n\t\tif (kn->flags & KERNFS_ACTIVATED)\n\t\t\tkernfs_drain(pos);\n\t\telse\n\t\t\tWARN_ON_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS);\n\n\t\t/*\n\t\t * kernfs_unlink_sibling() succeeds once per node.  Use it\n\t\t * to decide who's responsible for cleanups.\n\t\t */\n\t\tif (!pos->parent || kernfs_unlink_sibling(pos)) {\n\t\t\tstruct kernfs_iattrs *ps_iattr =\n\t\t\t\tpos->parent ? pos->parent->iattr : NULL;\n\n\t\t\t/* update timestamps on the parent */\n\t\t\tif (ps_iattr) {\n\t\t\t\tps_iattr->ia_iattr.ia_ctime = CURRENT_TIME;\n\t\t\t\tps_iattr->ia_iattr.ia_mtime = CURRENT_TIME;\n\t\t\t}\n\n\t\t\tkernfs_put(pos);\n\t\t}\n\n\t\tkernfs_put(pos);\n\t} while (pos != kn);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "pos"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "393-436",
          "snippet": "void kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_unlink_sibling",
          "args": [
            "pos"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_unlink_sibling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "276-287",
          "snippet": "static bool kernfs_unlink_sibling(struct kernfs_node *kn)\n{\n\tif (RB_EMPTY_NODE(&kn->rb))\n\t\treturn false;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tkn->parent->dir.subdirs--;\n\n\trb_erase(&kn->rb, &kn->parent->dir.children);\n\tRB_CLEAR_NODE(&kn->rb);\n\treturn true;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic bool kernfs_unlink_sibling(struct kernfs_node *kn)\n{\n\tif (RB_EMPTY_NODE(&kn->rb))\n\t\treturn false;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tkn->parent->dir.subdirs--;\n\n\trb_erase(&kn->rb, &kn->parent->dir.children);\n\tRB_CLEAR_NODE(&kn->rb);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "atomic_read(&kn->active) != KN_DEACTIVATED_BIAS"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kn->active"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_drain",
          "args": [
            "pos"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_drain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "344-372",
          "snippet": "static void kernfs_drain(struct kernfs_node *kn)\n\t__releases(&kernfs_mutex) __acquires(&kernfs_mutex)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\n\tlockdep_assert_held(&kernfs_mutex);\n\tWARN_ON_ONCE(kernfs_active(kn));\n\n\tmutex_unlock(&kernfs_mutex);\n\n\tif (kernfs_lockdep(kn)) {\n\t\trwsem_acquire(&kn->dep_map, 0, 0, _RET_IP_);\n\t\tif (atomic_read(&kn->active) != KN_DEACTIVATED_BIAS)\n\t\t\tlock_contended(&kn->dep_map, _RET_IP_);\n\t}\n\n\t/* but everyone should wait for draining */\n\twait_event(root->deactivate_waitq,\n\t\t   atomic_read(&kn->active) == KN_DEACTIVATED_BIAS);\n\n\tif (kernfs_lockdep(kn)) {\n\t\tlock_acquired(&kn->dep_map, _RET_IP_);\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\t}\n\n\tkernfs_unmap_bin_file(kn);\n\n\tmutex_lock(&kernfs_mutex);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic void kernfs_drain(struct kernfs_node *kn)\n\t__releases(&kernfs_mutex) __acquires(&kernfs_mutex)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\n\tlockdep_assert_held(&kernfs_mutex);\n\tWARN_ON_ONCE(kernfs_active(kn));\n\n\tmutex_unlock(&kernfs_mutex);\n\n\tif (kernfs_lockdep(kn)) {\n\t\trwsem_acquire(&kn->dep_map, 0, 0, _RET_IP_);\n\t\tif (atomic_read(&kn->active) != KN_DEACTIVATED_BIAS)\n\t\t\tlock_contended(&kn->dep_map, _RET_IP_);\n\t}\n\n\t/* but everyone should wait for draining */\n\twait_event(root->deactivate_waitq,\n\t\t   atomic_read(&kn->active) == KN_DEACTIVATED_BIAS);\n\n\tif (kernfs_lockdep(kn)) {\n\t\tlock_acquired(&kn->dep_map, _RET_IP_);\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\t}\n\n\tkernfs_unmap_bin_file(kn);\n\n\tmutex_lock(&kernfs_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_get",
          "args": [
            "pos"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "378-384",
          "snippet": "void kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_leftmost_descendant",
          "args": [
            "kn"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_leftmost_descendant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "896-916",
          "snippet": "static struct kernfs_node *kernfs_leftmost_descendant(struct kernfs_node *pos)\n{\n\tstruct kernfs_node *last;\n\n\twhile (true) {\n\t\tstruct rb_node *rbn;\n\n\t\tlast = pos;\n\n\t\tif (kernfs_type(pos) != KERNFS_DIR)\n\t\t\tbreak;\n\n\t\trbn = rb_first(&pos->dir.children);\n\t\tif (!rbn)\n\t\t\tbreak;\n\n\t\tpos = rb_to_kn(rbn);\n\t}\n\n\treturn last;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic struct kernfs_node *kernfs_leftmost_descendant(struct kernfs_node *pos)\n{\n\tstruct kernfs_node *last;\n\n\twhile (true) {\n\t\tstruct rb_node *rbn;\n\n\t\tlast = pos;\n\n\t\tif (kernfs_type(pos) != KERNFS_DIR)\n\t\t\tbreak;\n\n\t\trbn = rb_first(&pos->dir.children);\n\t\tif (!rbn)\n\t\t\tbreak;\n\n\t\tpos = rb_to_kn(rbn);\n\t}\n\n\treturn last;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "KN_DEACTIVATED_BIAS",
            "&pos->active"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_active",
          "args": [
            "pos"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "27-31",
          "snippet": "static bool kernfs_active(struct kernfs_node *kn)\n{\n\tlockdep_assert_held(&kernfs_mutex);\n\treturn atomic_read(&kn->active) >= 0;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic bool kernfs_active(struct kernfs_node *kn)\n{\n\tlockdep_assert_held(&kernfs_mutex);\n\treturn atomic_read(&kn->active) >= 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_next_descendant_post",
          "args": [
            "pos",
            "kn"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_next_descendant_post",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "927-949",
          "snippet": "static struct kernfs_node *kernfs_next_descendant_post(struct kernfs_node *pos,\n\t\t\t\t\t\t       struct kernfs_node *root)\n{\n\tstruct rb_node *rbn;\n\n\tlockdep_assert_held(&kernfs_mutex);\n\n\t/* if first iteration, visit leftmost descendant which may be root */\n\tif (!pos)\n\t\treturn kernfs_leftmost_descendant(root);\n\n\t/* if we visited @root, we're done */\n\tif (pos == root)\n\t\treturn NULL;\n\n\t/* if there's an unvisited sibling, visit its leftmost descendant */\n\trbn = rb_next(&pos->rb);\n\tif (rbn)\n\t\treturn kernfs_leftmost_descendant(rb_to_kn(rbn));\n\n\t/* no sibling left, visit parent */\n\treturn pos->parent;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic struct kernfs_node *kernfs_next_descendant_post(struct kernfs_node *pos,\n\t\t\t\t\t\t       struct kernfs_node *root)\n{\n\tstruct rb_node *rbn;\n\n\tlockdep_assert_held(&kernfs_mutex);\n\n\t/* if first iteration, visit leftmost descendant which may be root */\n\tif (!pos)\n\t\treturn kernfs_leftmost_descendant(root);\n\n\t/* if we visited @root, we're done */\n\tif (pos == root)\n\t\treturn NULL;\n\n\t/* if there's an unvisited sibling, visit its leftmost descendant */\n\trbn = rb_next(&pos->rb);\n\tif (rbn)\n\t\treturn kernfs_leftmost_descendant(rb_to_kn(rbn));\n\n\t/* no sibling left, visit parent */\n\treturn pos->parent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"kernfs %s: removing\\n\"",
            "kn->name"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&kn->rb"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic void __kernfs_remove(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *pos;\n\n\tlockdep_assert_held(&kernfs_mutex);\n\n\t/*\n\t * Short-circuit if non-root @kn has already finished removal.\n\t * This is for kernfs_remove_self() which plays with active ref\n\t * after removal.\n\t */\n\tif (!kn || (kn->parent && RB_EMPTY_NODE(&kn->rb)))\n\t\treturn;\n\n\tpr_debug(\"kernfs %s: removing\\n\", kn->name);\n\n\t/* prevent any new usage under @kn by deactivating all nodes */\n\tpos = NULL;\n\twhile ((pos = kernfs_next_descendant_post(pos, kn)))\n\t\tif (kernfs_active(pos))\n\t\t\tatomic_add(KN_DEACTIVATED_BIAS, &pos->active);\n\n\t/* deactivate and unlink the subtree node-by-node */\n\tdo {\n\t\tpos = kernfs_leftmost_descendant(kn);\n\n\t\t/*\n\t\t * kernfs_drain() drops kernfs_mutex temporarily and @pos's\n\t\t * base ref could have been put by someone else by the time\n\t\t * the function returns.  Make sure it doesn't go away\n\t\t * underneath us.\n\t\t */\n\t\tkernfs_get(pos);\n\n\t\t/*\n\t\t * Drain iff @kn was activated.  This avoids draining and\n\t\t * its lockdep annotations for nodes which have never been\n\t\t * activated and allows embedding kernfs_remove() in create\n\t\t * error paths without worrying about draining.\n\t\t */\n\t\tif (kn->flags & KERNFS_ACTIVATED)\n\t\t\tkernfs_drain(pos);\n\t\telse\n\t\t\tWARN_ON_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS);\n\n\t\t/*\n\t\t * kernfs_unlink_sibling() succeeds once per node.  Use it\n\t\t * to decide who's responsible for cleanups.\n\t\t */\n\t\tif (!pos->parent || kernfs_unlink_sibling(pos)) {\n\t\t\tstruct kernfs_iattrs *ps_iattr =\n\t\t\t\tpos->parent ? pos->parent->iattr : NULL;\n\n\t\t\t/* update timestamps on the parent */\n\t\t\tif (ps_iattr) {\n\t\t\t\tps_iattr->ia_iattr.ia_ctime = CURRENT_TIME;\n\t\t\t\tps_iattr->ia_iattr.ia_mtime = CURRENT_TIME;\n\t\t\t}\n\n\t\t\tkernfs_put(pos);\n\t\t}\n\n\t\tkernfs_put(pos);\n\t} while (pos != kn);\n}"
  },
  {
    "function_name": "kernfs_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "964-983",
    "snippet": "void kernfs_activate(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *pos;\n\n\tmutex_lock(&kernfs_mutex);\n\n\tpos = NULL;\n\twhile ((pos = kernfs_next_descendant_post(pos, kn))) {\n\t\tif (!pos || (pos->flags & KERNFS_ACTIVATED))\n\t\t\tcontinue;\n\n\t\tWARN_ON_ONCE(pos->parent && RB_EMPTY_NODE(&pos->rb));\n\t\tWARN_ON_ONCE(atomic_read(&pos->active) != KN_DEACTIVATED_BIAS);\n\n\t\tatomic_sub(KN_DEACTIVATED_BIAS, &pos->active);\n\t\tpos->flags |= KERNFS_ACTIVATED;\n\t}\n\n\tmutex_unlock(&kernfs_mutex);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_sub",
          "args": [
            "KN_DEACTIVATED_BIAS",
            "&pos->active"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "atomic_read(&pos->active) != KN_DEACTIVATED_BIAS"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&pos->active"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "pos->parent && RB_EMPTY_NODE(&pos->rb)"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&pos->rb"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_next_descendant_post",
          "args": [
            "pos",
            "kn"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_next_descendant_post",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "927-949",
          "snippet": "static struct kernfs_node *kernfs_next_descendant_post(struct kernfs_node *pos,\n\t\t\t\t\t\t       struct kernfs_node *root)\n{\n\tstruct rb_node *rbn;\n\n\tlockdep_assert_held(&kernfs_mutex);\n\n\t/* if first iteration, visit leftmost descendant which may be root */\n\tif (!pos)\n\t\treturn kernfs_leftmost_descendant(root);\n\n\t/* if we visited @root, we're done */\n\tif (pos == root)\n\t\treturn NULL;\n\n\t/* if there's an unvisited sibling, visit its leftmost descendant */\n\trbn = rb_next(&pos->rb);\n\tif (rbn)\n\t\treturn kernfs_leftmost_descendant(rb_to_kn(rbn));\n\n\t/* no sibling left, visit parent */\n\treturn pos->parent;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic struct kernfs_node *kernfs_next_descendant_post(struct kernfs_node *pos,\n\t\t\t\t\t\t       struct kernfs_node *root)\n{\n\tstruct rb_node *rbn;\n\n\tlockdep_assert_held(&kernfs_mutex);\n\n\t/* if first iteration, visit leftmost descendant which may be root */\n\tif (!pos)\n\t\treturn kernfs_leftmost_descendant(root);\n\n\t/* if we visited @root, we're done */\n\tif (pos == root)\n\t\treturn NULL;\n\n\t/* if there's an unvisited sibling, visit its leftmost descendant */\n\trbn = rb_next(&pos->rb);\n\tif (rbn)\n\t\treturn kernfs_leftmost_descendant(rb_to_kn(rbn));\n\n\t/* no sibling left, visit parent */\n\treturn pos->parent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_activate(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *pos;\n\n\tmutex_lock(&kernfs_mutex);\n\n\tpos = NULL;\n\twhile ((pos = kernfs_next_descendant_post(pos, kn))) {\n\t\tif (!pos || (pos->flags & KERNFS_ACTIVATED))\n\t\t\tcontinue;\n\n\t\tWARN_ON_ONCE(pos->parent && RB_EMPTY_NODE(&pos->rb));\n\t\tWARN_ON_ONCE(atomic_read(&pos->active) != KN_DEACTIVATED_BIAS);\n\n\t\tatomic_sub(KN_DEACTIVATED_BIAS, &pos->active);\n\t\tpos->flags |= KERNFS_ACTIVATED;\n\t}\n\n\tmutex_unlock(&kernfs_mutex);\n}"
  },
  {
    "function_name": "kernfs_next_descendant_post",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "927-949",
    "snippet": "static struct kernfs_node *kernfs_next_descendant_post(struct kernfs_node *pos,\n\t\t\t\t\t\t       struct kernfs_node *root)\n{\n\tstruct rb_node *rbn;\n\n\tlockdep_assert_held(&kernfs_mutex);\n\n\t/* if first iteration, visit leftmost descendant which may be root */\n\tif (!pos)\n\t\treturn kernfs_leftmost_descendant(root);\n\n\t/* if we visited @root, we're done */\n\tif (pos == root)\n\t\treturn NULL;\n\n\t/* if there's an unvisited sibling, visit its leftmost descendant */\n\trbn = rb_next(&pos->rb);\n\tif (rbn)\n\t\treturn kernfs_leftmost_descendant(rb_to_kn(rbn));\n\n\t/* no sibling left, visit parent */\n\treturn pos->parent;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_leftmost_descendant",
          "args": [
            "rb_to_kn(rbn)"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_leftmost_descendant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "896-916",
          "snippet": "static struct kernfs_node *kernfs_leftmost_descendant(struct kernfs_node *pos)\n{\n\tstruct kernfs_node *last;\n\n\twhile (true) {\n\t\tstruct rb_node *rbn;\n\n\t\tlast = pos;\n\n\t\tif (kernfs_type(pos) != KERNFS_DIR)\n\t\t\tbreak;\n\n\t\trbn = rb_first(&pos->dir.children);\n\t\tif (!rbn)\n\t\t\tbreak;\n\n\t\tpos = rb_to_kn(rbn);\n\t}\n\n\treturn last;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic struct kernfs_node *kernfs_leftmost_descendant(struct kernfs_node *pos)\n{\n\tstruct kernfs_node *last;\n\n\twhile (true) {\n\t\tstruct rb_node *rbn;\n\n\t\tlast = pos;\n\n\t\tif (kernfs_type(pos) != KERNFS_DIR)\n\t\t\tbreak;\n\n\t\trbn = rb_first(&pos->dir.children);\n\t\tif (!rbn)\n\t\t\tbreak;\n\n\t\tpos = rb_to_kn(rbn);\n\t}\n\n\treturn last;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_to_kn",
          "args": [
            "rbn"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&pos->rb"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic struct kernfs_node *kernfs_next_descendant_post(struct kernfs_node *pos,\n\t\t\t\t\t\t       struct kernfs_node *root)\n{\n\tstruct rb_node *rbn;\n\n\tlockdep_assert_held(&kernfs_mutex);\n\n\t/* if first iteration, visit leftmost descendant which may be root */\n\tif (!pos)\n\t\treturn kernfs_leftmost_descendant(root);\n\n\t/* if we visited @root, we're done */\n\tif (pos == root)\n\t\treturn NULL;\n\n\t/* if there's an unvisited sibling, visit its leftmost descendant */\n\trbn = rb_next(&pos->rb);\n\tif (rbn)\n\t\treturn kernfs_leftmost_descendant(rb_to_kn(rbn));\n\n\t/* no sibling left, visit parent */\n\treturn pos->parent;\n}"
  },
  {
    "function_name": "kernfs_leftmost_descendant",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "896-916",
    "snippet": "static struct kernfs_node *kernfs_leftmost_descendant(struct kernfs_node *pos)\n{\n\tstruct kernfs_node *last;\n\n\twhile (true) {\n\t\tstruct rb_node *rbn;\n\n\t\tlast = pos;\n\n\t\tif (kernfs_type(pos) != KERNFS_DIR)\n\t\t\tbreak;\n\n\t\trbn = rb_first(&pos->dir.children);\n\t\tif (!rbn)\n\t\t\tbreak;\n\n\t\tpos = rb_to_kn(rbn);\n\t}\n\n\treturn last;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_to_kn",
          "args": [
            "rbn"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&pos->dir.children"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_type",
          "args": [
            "pos"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic struct kernfs_node *kernfs_leftmost_descendant(struct kernfs_node *pos)\n{\n\tstruct kernfs_node *last;\n\n\twhile (true) {\n\t\tstruct rb_node *rbn;\n\n\t\tlast = pos;\n\n\t\tif (kernfs_type(pos) != KERNFS_DIR)\n\t\t\tbreak;\n\n\t\trbn = rb_first(&pos->dir.children);\n\t\tif (!rbn)\n\t\t\tbreak;\n\n\t\tpos = rb_to_kn(rbn);\n\t}\n\n\treturn last;\n}"
  },
  {
    "function_name": "kernfs_iop_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "855-879",
    "snippet": "static int kernfs_iop_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t     struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct kernfs_node *kn  = old_dentry->d_fsdata;\n\tstruct kernfs_node *new_parent = new_dir->i_private;\n\tstruct kernfs_syscall_ops *scops = kernfs_root(kn)->syscall_ops;\n\tint ret;\n\n\tif (!scops || !scops->rename)\n\t\treturn -EPERM;\n\n\tif (!kernfs_get_active(kn))\n\t\treturn -ENODEV;\n\n\tif (!kernfs_get_active(new_parent)) {\n\t\tkernfs_put_active(kn);\n\t\treturn -ENODEV;\n\t}\n\n\tret = scops->rename(kn, new_parent, new_dentry->d_name.name);\n\n\tkernfs_put_active(new_parent);\n\tkernfs_put_active(kn);\n\treturn ret;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put_active",
          "args": [
            "kn"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "319-334",
          "snippet": "void kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scops->rename",
          "args": [
            "kn",
            "new_parent",
            "new_dentry->d_name.name"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_get_active",
          "args": [
            "new_parent"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "299-310",
          "snippet": "struct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstruct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_root",
          "args": [
            "kn"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/kernfs-internal.h",
          "lines": "40-46",
          "snippet": "static inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)\n{\n\t/* if parent exists, it's always a dir; otherwise, @sd is a dir */\n\tif (kn->parent)\n\t\tkn = kn->parent;\n\treturn kn->dir.root;\n}",
          "includes": [
            "#include <linux/kernfs.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernfs.h>\n#include <linux/xattr.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/lockdep.h>\n\nstatic inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)\n{\n\t/* if parent exists, it's always a dir; otherwise, @sd is a dir */\n\tif (kn->parent)\n\t\tkn = kn->parent;\n\treturn kn->dir.root;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic int kernfs_iop_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t     struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct kernfs_node *kn  = old_dentry->d_fsdata;\n\tstruct kernfs_node *new_parent = new_dir->i_private;\n\tstruct kernfs_syscall_ops *scops = kernfs_root(kn)->syscall_ops;\n\tint ret;\n\n\tif (!scops || !scops->rename)\n\t\treturn -EPERM;\n\n\tif (!kernfs_get_active(kn))\n\t\treturn -ENODEV;\n\n\tif (!kernfs_get_active(new_parent)) {\n\t\tkernfs_put_active(kn);\n\t\treturn -ENODEV;\n\t}\n\n\tret = scops->rename(kn, new_parent, new_dentry->d_name.name);\n\n\tkernfs_put_active(new_parent);\n\tkernfs_put_active(kn);\n\treturn ret;\n}"
  },
  {
    "function_name": "kernfs_iop_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "837-853",
    "snippet": "static int kernfs_iop_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct kernfs_node *kn  = dentry->d_fsdata;\n\tstruct kernfs_syscall_ops *scops = kernfs_root(kn)->syscall_ops;\n\tint ret;\n\n\tif (!scops || !scops->rmdir)\n\t\treturn -EPERM;\n\n\tif (!kernfs_get_active(kn))\n\t\treturn -ENODEV;\n\n\tret = scops->rmdir(kn);\n\n\tkernfs_put_active(kn);\n\treturn ret;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put_active",
          "args": [
            "kn"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "319-334",
          "snippet": "void kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scops->rmdir",
          "args": [
            "kn"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_get_active",
          "args": [
            "kn"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "299-310",
          "snippet": "struct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstruct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_root",
          "args": [
            "kn"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/kernfs-internal.h",
          "lines": "40-46",
          "snippet": "static inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)\n{\n\t/* if parent exists, it's always a dir; otherwise, @sd is a dir */\n\tif (kn->parent)\n\t\tkn = kn->parent;\n\treturn kn->dir.root;\n}",
          "includes": [
            "#include <linux/kernfs.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernfs.h>\n#include <linux/xattr.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/lockdep.h>\n\nstatic inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)\n{\n\t/* if parent exists, it's always a dir; otherwise, @sd is a dir */\n\tif (kn->parent)\n\t\tkn = kn->parent;\n\treturn kn->dir.root;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic int kernfs_iop_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct kernfs_node *kn  = dentry->d_fsdata;\n\tstruct kernfs_syscall_ops *scops = kernfs_root(kn)->syscall_ops;\n\tint ret;\n\n\tif (!scops || !scops->rmdir)\n\t\treturn -EPERM;\n\n\tif (!kernfs_get_active(kn))\n\t\treturn -ENODEV;\n\n\tret = scops->rmdir(kn);\n\n\tkernfs_put_active(kn);\n\treturn ret;\n}"
  },
  {
    "function_name": "kernfs_iop_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "818-835",
    "snippet": "static int kernfs_iop_mkdir(struct inode *dir, struct dentry *dentry,\n\t\t\t    umode_t mode)\n{\n\tstruct kernfs_node *parent = dir->i_private;\n\tstruct kernfs_syscall_ops *scops = kernfs_root(parent)->syscall_ops;\n\tint ret;\n\n\tif (!scops || !scops->mkdir)\n\t\treturn -EPERM;\n\n\tif (!kernfs_get_active(parent))\n\t\treturn -ENODEV;\n\n\tret = scops->mkdir(parent, dentry->d_name.name, mode);\n\n\tkernfs_put_active(parent);\n\treturn ret;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put_active",
          "args": [
            "parent"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "319-334",
          "snippet": "void kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scops->mkdir",
          "args": [
            "parent",
            "dentry->d_name.name",
            "mode"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_get_active",
          "args": [
            "parent"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "299-310",
          "snippet": "struct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstruct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_root",
          "args": [
            "parent"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/kernfs-internal.h",
          "lines": "40-46",
          "snippet": "static inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)\n{\n\t/* if parent exists, it's always a dir; otherwise, @sd is a dir */\n\tif (kn->parent)\n\t\tkn = kn->parent;\n\treturn kn->dir.root;\n}",
          "includes": [
            "#include <linux/kernfs.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernfs.h>\n#include <linux/xattr.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/lockdep.h>\n\nstatic inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)\n{\n\t/* if parent exists, it's always a dir; otherwise, @sd is a dir */\n\tif (kn->parent)\n\t\tkn = kn->parent;\n\treturn kn->dir.root;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic int kernfs_iop_mkdir(struct inode *dir, struct dentry *dentry,\n\t\t\t    umode_t mode)\n{\n\tstruct kernfs_node *parent = dir->i_private;\n\tstruct kernfs_syscall_ops *scops = kernfs_root(parent)->syscall_ops;\n\tint ret;\n\n\tif (!scops || !scops->mkdir)\n\t\treturn -EPERM;\n\n\tif (!kernfs_get_active(parent))\n\t\treturn -ENODEV;\n\n\tret = scops->mkdir(parent, dentry->d_name.name, mode);\n\n\tkernfs_put_active(parent);\n\treturn ret;\n}"
  },
  {
    "function_name": "kernfs_iop_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "779-816",
    "snippet": "static struct dentry *kernfs_iop_lookup(struct inode *dir,\n\t\t\t\t\tstruct dentry *dentry,\n\t\t\t\t\tunsigned int flags)\n{\n\tstruct dentry *ret;\n\tstruct kernfs_node *parent = dentry->d_parent->d_fsdata;\n\tstruct kernfs_node *kn;\n\tstruct inode *inode;\n\tconst void *ns = NULL;\n\n\tmutex_lock(&kernfs_mutex);\n\n\tif (kernfs_ns_enabled(parent))\n\t\tns = kernfs_info(dir->i_sb)->ns;\n\n\tkn = kernfs_find_ns(parent, dentry->d_name.name, ns);\n\n\t/* no such entry */\n\tif (!kn || !kernfs_active(kn)) {\n\t\tret = NULL;\n\t\tgoto out_unlock;\n\t}\n\tkernfs_get(kn);\n\tdentry->d_fsdata = kn;\n\n\t/* attach dentry and inode */\n\tinode = kernfs_get_inode(dir->i_sb, kn);\n\tif (!inode) {\n\t\tret = ERR_PTR(-ENOMEM);\n\t\tgoto out_unlock;\n\t}\n\n\t/* instantiate and hash dentry */\n\tret = d_splice_alias(inode, dentry);\n out_unlock:\n\tmutex_unlock(&kernfs_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_splice_alias",
          "args": [
            "inode",
            "dentry"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "d_splice_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2741-2792",
          "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_get_inode",
          "args": [
            "dir->i_sb",
            "kn"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/inode.c",
          "lines": "329-338",
          "snippet": "struct inode *kernfs_get_inode(struct super_block *sb, struct kernfs_node *kn)\n{\n\tstruct inode *inode;\n\n\tinode = iget_locked(sb, kn->ino);\n\tif (inode && (inode->i_state & I_NEW))\n\t\tkernfs_init_inode(kn, inode);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n\nstruct inode *kernfs_get_inode(struct super_block *sb, struct kernfs_node *kn)\n{\n\tstruct inode *inode;\n\n\tinode = iget_locked(sb, kn->ino);\n\tif (inode && (inode->i_state & I_NEW))\n\t\tkernfs_init_inode(kn, inode);\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_get",
          "args": [
            "kn"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "378-384",
          "snippet": "void kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_active",
          "args": [
            "kn"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "27-31",
          "snippet": "static bool kernfs_active(struct kernfs_node *kn)\n{\n\tlockdep_assert_held(&kernfs_mutex);\n\treturn atomic_read(&kn->active) >= 0;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic bool kernfs_active(struct kernfs_node *kn)\n{\n\tlockdep_assert_held(&kernfs_mutex);\n\treturn atomic_read(&kn->active) >= 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_find_ns",
          "args": [
            "parent",
            "dentry->d_name.name",
            "ns"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_find_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "631-662",
          "snippet": "static struct kernfs_node *kernfs_find_ns(struct kernfs_node *parent,\n\t\t\t\t\t  const unsigned char *name,\n\t\t\t\t\t  const void *ns)\n{\n\tstruct rb_node *node = parent->dir.children.rb_node;\n\tbool has_ns = kernfs_ns_enabled(parent);\n\tunsigned int hash;\n\n\tlockdep_assert_held(&kernfs_mutex);\n\n\tif (has_ns != (bool)ns) {\n\t\tWARN(1, KERN_WARNING \"kernfs: ns %s in '%s' for '%s'\\n\",\n\t\t     has_ns ? \"required\" : \"invalid\", parent->name, name);\n\t\treturn NULL;\n\t}\n\n\thash = kernfs_name_hash(name, ns);\n\twhile (node) {\n\t\tstruct kernfs_node *kn;\n\t\tint result;\n\n\t\tkn = rb_to_kn(node);\n\t\tresult = kernfs_name_compare(hash, name, ns, kn);\n\t\tif (result < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (result > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn kn;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic struct kernfs_node *kernfs_find_ns(struct kernfs_node *parent,\n\t\t\t\t\t  const unsigned char *name,\n\t\t\t\t\t  const void *ns)\n{\n\tstruct rb_node *node = parent->dir.children.rb_node;\n\tbool has_ns = kernfs_ns_enabled(parent);\n\tunsigned int hash;\n\n\tlockdep_assert_held(&kernfs_mutex);\n\n\tif (has_ns != (bool)ns) {\n\t\tWARN(1, KERN_WARNING \"kernfs: ns %s in '%s' for '%s'\\n\",\n\t\t     has_ns ? \"required\" : \"invalid\", parent->name, name);\n\t\treturn NULL;\n\t}\n\n\thash = kernfs_name_hash(name, ns);\n\twhile (node) {\n\t\tstruct kernfs_node *kn;\n\t\tint result;\n\n\t\tkn = rb_to_kn(node);\n\t\tresult = kernfs_name_compare(hash, name, ns, kn);\n\t\tif (result < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (result > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn kn;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_info",
          "args": [
            "dir->i_sb"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_ns_enabled",
          "args": [
            "parent"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic struct dentry *kernfs_iop_lookup(struct inode *dir,\n\t\t\t\t\tstruct dentry *dentry,\n\t\t\t\t\tunsigned int flags)\n{\n\tstruct dentry *ret;\n\tstruct kernfs_node *parent = dentry->d_parent->d_fsdata;\n\tstruct kernfs_node *kn;\n\tstruct inode *inode;\n\tconst void *ns = NULL;\n\n\tmutex_lock(&kernfs_mutex);\n\n\tif (kernfs_ns_enabled(parent))\n\t\tns = kernfs_info(dir->i_sb)->ns;\n\n\tkn = kernfs_find_ns(parent, dentry->d_name.name, ns);\n\n\t/* no such entry */\n\tif (!kn || !kernfs_active(kn)) {\n\t\tret = NULL;\n\t\tgoto out_unlock;\n\t}\n\tkernfs_get(kn);\n\tdentry->d_fsdata = kn;\n\n\t/* attach dentry and inode */\n\tinode = kernfs_get_inode(dir->i_sb, kn);\n\tif (!inode) {\n\t\tret = ERR_PTR(-ENOMEM);\n\t\tgoto out_unlock;\n\t}\n\n\t/* instantiate and hash dentry */\n\tret = d_splice_alias(inode, dentry);\n out_unlock:\n\tmutex_unlock(&kernfs_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "kernfs_create_dir_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "754-777",
    "snippet": "struct kernfs_node *kernfs_create_dir_ns(struct kernfs_node *parent,\n\t\t\t\t\t const char *name, umode_t mode,\n\t\t\t\t\t void *priv, const void *ns)\n{\n\tstruct kernfs_node *kn;\n\tint rc;\n\n\t/* allocate */\n\tkn = kernfs_new_node(parent, name, mode | S_IFDIR, KERNFS_DIR);\n\tif (!kn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkn->dir.root = parent->dir.root;\n\tkn->ns = ns;\n\tkn->priv = priv;\n\n\t/* link in */\n\trc = kernfs_add_one(kn);\n\tif (!rc)\n\t\treturn kn;\n\n\tkernfs_put(kn);\n\treturn ERR_PTR(rc);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "kn"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "393-436",
          "snippet": "void kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_add_one",
          "args": [
            "kn"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_add_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "569-620",
          "snippet": "int kernfs_add_one(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent = kn->parent;\n\tstruct kernfs_iattrs *ps_iattr;\n\tbool has_ns;\n\tint ret;\n\n\tmutex_lock(&kernfs_mutex);\n\n\tret = -EINVAL;\n\thas_ns = kernfs_ns_enabled(parent);\n\tif (WARN(has_ns != (bool)kn->ns, KERN_WARNING \"kernfs: ns %s in '%s' for '%s'\\n\",\n\t\t has_ns ? \"required\" : \"invalid\", parent->name, kn->name))\n\t\tgoto out_unlock;\n\n\tif (kernfs_type(parent) != KERNFS_DIR)\n\t\tgoto out_unlock;\n\n\tret = -ENOENT;\n\tif ((parent->flags & KERNFS_ACTIVATED) && !kernfs_active(parent))\n\t\tgoto out_unlock;\n\n\tkn->hash = kernfs_name_hash(kn->name, kn->ns);\n\n\tret = kernfs_link_sibling(kn);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* Update timestamps on the parent */\n\tps_iattr = parent->iattr;\n\tif (ps_iattr) {\n\t\tstruct iattr *ps_iattrs = &ps_iattr->ia_iattr;\n\t\tps_iattrs->ia_ctime = ps_iattrs->ia_mtime = CURRENT_TIME;\n\t}\n\n\tmutex_unlock(&kernfs_mutex);\n\n\t/*\n\t * Activate the new node unless CREATE_DEACTIVATED is requested.\n\t * If not activated here, the kernfs user is responsible for\n\t * activating the node with kernfs_activate().  A node which hasn't\n\t * been activated is not visible to userland and its removal won't\n\t * trigger deactivation.\n\t */\n\tif (!(kernfs_root(kn)->flags & KERNFS_ROOT_CREATE_DEACTIVATED))\n\t\tkernfs_activate(kn);\n\treturn 0;\n\nout_unlock:\n\tmutex_unlock(&kernfs_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nint kernfs_add_one(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent = kn->parent;\n\tstruct kernfs_iattrs *ps_iattr;\n\tbool has_ns;\n\tint ret;\n\n\tmutex_lock(&kernfs_mutex);\n\n\tret = -EINVAL;\n\thas_ns = kernfs_ns_enabled(parent);\n\tif (WARN(has_ns != (bool)kn->ns, KERN_WARNING \"kernfs: ns %s in '%s' for '%s'\\n\",\n\t\t has_ns ? \"required\" : \"invalid\", parent->name, kn->name))\n\t\tgoto out_unlock;\n\n\tif (kernfs_type(parent) != KERNFS_DIR)\n\t\tgoto out_unlock;\n\n\tret = -ENOENT;\n\tif ((parent->flags & KERNFS_ACTIVATED) && !kernfs_active(parent))\n\t\tgoto out_unlock;\n\n\tkn->hash = kernfs_name_hash(kn->name, kn->ns);\n\n\tret = kernfs_link_sibling(kn);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* Update timestamps on the parent */\n\tps_iattr = parent->iattr;\n\tif (ps_iattr) {\n\t\tstruct iattr *ps_iattrs = &ps_iattr->ia_iattr;\n\t\tps_iattrs->ia_ctime = ps_iattrs->ia_mtime = CURRENT_TIME;\n\t}\n\n\tmutex_unlock(&kernfs_mutex);\n\n\t/*\n\t * Activate the new node unless CREATE_DEACTIVATED is requested.\n\t * If not activated here, the kernfs user is responsible for\n\t * activating the node with kernfs_activate().  A node which hasn't\n\t * been activated is not visible to userland and its removal won't\n\t * trigger deactivation.\n\t */\n\tif (!(kernfs_root(kn)->flags & KERNFS_ROOT_CREATE_DEACTIVATED))\n\t\tkernfs_activate(kn);\n\treturn 0;\n\nout_unlock:\n\tmutex_unlock(&kernfs_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_new_node",
          "args": [
            "parent",
            "name",
            "mode | S_IFDIR",
            "KERNFS_DIR"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_new_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "543-555",
          "snippet": "struct kernfs_node *kernfs_new_node(struct kernfs_node *parent,\n\t\t\t\t    const char *name, umode_t mode,\n\t\t\t\t    unsigned flags)\n{\n\tstruct kernfs_node *kn;\n\n\tkn = __kernfs_new_node(kernfs_root(parent), name, mode, flags);\n\tif (kn) {\n\t\tkernfs_get(parent);\n\t\tkn->parent = parent;\n\t}\n\treturn kn;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstruct kernfs_node *kernfs_new_node(struct kernfs_node *parent,\n\t\t\t\t    const char *name, umode_t mode,\n\t\t\t\t    unsigned flags)\n{\n\tstruct kernfs_node *kn;\n\n\tkn = __kernfs_new_node(kernfs_root(parent), name, mode, flags);\n\tif (kn) {\n\t\tkernfs_get(parent);\n\t\tkn->parent = parent;\n\t}\n\treturn kn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstruct kernfs_node *kernfs_create_dir_ns(struct kernfs_node *parent,\n\t\t\t\t\t const char *name, umode_t mode,\n\t\t\t\t\t void *priv, const void *ns)\n{\n\tstruct kernfs_node *kn;\n\tint rc;\n\n\t/* allocate */\n\tkn = kernfs_new_node(parent, name, mode | S_IFDIR, KERNFS_DIR);\n\tif (!kn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkn->dir.root = parent->dir.root;\n\tkn->ns = ns;\n\tkn->priv = priv;\n\n\t/* link in */\n\trc = kernfs_add_one(kn);\n\tif (!rc)\n\t\treturn kn;\n\n\tkernfs_put(kn);\n\treturn ERR_PTR(rc);\n}"
  },
  {
    "function_name": "kernfs_destroy_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "739-742",
    "snippet": "void kernfs_destroy_root(struct kernfs_root *root)\n{\n\tkernfs_remove(root->kn);\t/* will also free @root */\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_remove",
          "args": [
            "root->kn"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_remove_self",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "1144-1193",
          "snippet": "bool kernfs_remove_self(struct kernfs_node *kn)\n{\n\tbool ret;\n\n\tmutex_lock(&kernfs_mutex);\n\tkernfs_break_active_protection(kn);\n\n\t/*\n\t * SUICIDAL is used to arbitrate among competing invocations.  Only\n\t * the first one will actually perform removal.  When the removal\n\t * is complete, SUICIDED is set and the active ref is restored\n\t * while holding kernfs_mutex.  The ones which lost arbitration\n\t * waits for SUICDED && drained which can happen only after the\n\t * enclosing kernfs operation which executed the winning instance\n\t * of kernfs_remove_self() finished.\n\t */\n\tif (!(kn->flags & KERNFS_SUICIDAL)) {\n\t\tkn->flags |= KERNFS_SUICIDAL;\n\t\t__kernfs_remove(kn);\n\t\tkn->flags |= KERNFS_SUICIDED;\n\t\tret = true;\n\t} else {\n\t\twait_queue_head_t *waitq = &kernfs_root(kn)->deactivate_waitq;\n\t\tDEFINE_WAIT(wait);\n\n\t\twhile (true) {\n\t\t\tprepare_to_wait(waitq, &wait, TASK_UNINTERRUPTIBLE);\n\n\t\t\tif ((kn->flags & KERNFS_SUICIDED) &&\n\t\t\t    atomic_read(&kn->active) == KN_DEACTIVATED_BIAS)\n\t\t\t\tbreak;\n\n\t\t\tmutex_unlock(&kernfs_mutex);\n\t\t\tschedule();\n\t\t\tmutex_lock(&kernfs_mutex);\n\t\t}\n\t\tfinish_wait(waitq, &wait);\n\t\tWARN_ON_ONCE(!RB_EMPTY_NODE(&kn->rb));\n\t\tret = false;\n\t}\n\n\t/*\n\t * This must be done while holding kernfs_mutex; otherwise, waiting\n\t * for SUICIDED && deactivated could finish prematurely.\n\t */\n\tkernfs_unbreak_active_protection(kn);\n\n\tmutex_unlock(&kernfs_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nbool kernfs_remove_self(struct kernfs_node *kn)\n{\n\tbool ret;\n\n\tmutex_lock(&kernfs_mutex);\n\tkernfs_break_active_protection(kn);\n\n\t/*\n\t * SUICIDAL is used to arbitrate among competing invocations.  Only\n\t * the first one will actually perform removal.  When the removal\n\t * is complete, SUICIDED is set and the active ref is restored\n\t * while holding kernfs_mutex.  The ones which lost arbitration\n\t * waits for SUICDED && drained which can happen only after the\n\t * enclosing kernfs operation which executed the winning instance\n\t * of kernfs_remove_self() finished.\n\t */\n\tif (!(kn->flags & KERNFS_SUICIDAL)) {\n\t\tkn->flags |= KERNFS_SUICIDAL;\n\t\t__kernfs_remove(kn);\n\t\tkn->flags |= KERNFS_SUICIDED;\n\t\tret = true;\n\t} else {\n\t\twait_queue_head_t *waitq = &kernfs_root(kn)->deactivate_waitq;\n\t\tDEFINE_WAIT(wait);\n\n\t\twhile (true) {\n\t\t\tprepare_to_wait(waitq, &wait, TASK_UNINTERRUPTIBLE);\n\n\t\t\tif ((kn->flags & KERNFS_SUICIDED) &&\n\t\t\t    atomic_read(&kn->active) == KN_DEACTIVATED_BIAS)\n\t\t\t\tbreak;\n\n\t\t\tmutex_unlock(&kernfs_mutex);\n\t\t\tschedule();\n\t\t\tmutex_lock(&kernfs_mutex);\n\t\t}\n\t\tfinish_wait(waitq, &wait);\n\t\tWARN_ON_ONCE(!RB_EMPTY_NODE(&kn->rb));\n\t\tret = false;\n\t}\n\n\t/*\n\t * This must be done while holding kernfs_mutex; otherwise, waiting\n\t * for SUICIDED && deactivated could finish prematurely.\n\t */\n\tkernfs_unbreak_active_protection(kn);\n\n\tmutex_unlock(&kernfs_mutex);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_destroy_root(struct kernfs_root *root)\n{\n\tkernfs_remove(root->kn);\t/* will also free @root */\n}"
  },
  {
    "function_name": "kernfs_create_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "697-730",
    "snippet": "struct kernfs_root *kernfs_create_root(struct kernfs_syscall_ops *scops,\n\t\t\t\t       unsigned int flags, void *priv)\n{\n\tstruct kernfs_root *root;\n\tstruct kernfs_node *kn;\n\n\troot = kzalloc(sizeof(*root), GFP_KERNEL);\n\tif (!root)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tida_init(&root->ino_ida);\n\tINIT_LIST_HEAD(&root->supers);\n\n\tkn = __kernfs_new_node(root, \"\", S_IFDIR | S_IRUGO | S_IXUGO,\n\t\t\t       KERNFS_DIR);\n\tif (!kn) {\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tkn->priv = priv;\n\tkn->dir.root = root;\n\n\troot->syscall_ops = scops;\n\troot->flags = flags;\n\troot->kn = kn;\n\tinit_waitqueue_head(&root->deactivate_waitq);\n\n\tif (!(root->flags & KERNFS_ROOT_CREATE_DEACTIVATED))\n\t\tkernfs_activate(kn);\n\n\treturn root;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_activate",
          "args": [
            "kn"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_activate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "964-983",
          "snippet": "void kernfs_activate(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *pos;\n\n\tmutex_lock(&kernfs_mutex);\n\n\tpos = NULL;\n\twhile ((pos = kernfs_next_descendant_post(pos, kn))) {\n\t\tif (!pos || (pos->flags & KERNFS_ACTIVATED))\n\t\t\tcontinue;\n\n\t\tWARN_ON_ONCE(pos->parent && RB_EMPTY_NODE(&pos->rb));\n\t\tWARN_ON_ONCE(atomic_read(&pos->active) != KN_DEACTIVATED_BIAS);\n\n\t\tatomic_sub(KN_DEACTIVATED_BIAS, &pos->active);\n\t\tpos->flags |= KERNFS_ACTIVATED;\n\t}\n\n\tmutex_unlock(&kernfs_mutex);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_activate(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *pos;\n\n\tmutex_lock(&kernfs_mutex);\n\n\tpos = NULL;\n\twhile ((pos = kernfs_next_descendant_post(pos, kn))) {\n\t\tif (!pos || (pos->flags & KERNFS_ACTIVATED))\n\t\t\tcontinue;\n\n\t\tWARN_ON_ONCE(pos->parent && RB_EMPTY_NODE(&pos->rb));\n\t\tWARN_ON_ONCE(atomic_read(&pos->active) != KN_DEACTIVATED_BIAS);\n\n\t\tatomic_sub(KN_DEACTIVATED_BIAS, &pos->active);\n\t\tpos->flags |= KERNFS_ACTIVATED;\n\t}\n\n\tmutex_unlock(&kernfs_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&root->deactivate_waitq"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "root"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ida_destroy",
          "args": [
            "&root->ino_ida"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kernfs_new_node",
          "args": [
            "root",
            "\"\"",
            "S_IFDIR | S_IRUGO | S_IXUGO",
            "KERNFS_DIR"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "__kernfs_new_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "506-541",
          "snippet": "static struct kernfs_node *__kernfs_new_node(struct kernfs_root *root,\n\t\t\t\t\t     const char *name, umode_t mode,\n\t\t\t\t\t     unsigned flags)\n{\n\tstruct kernfs_node *kn;\n\tint ret;\n\n\tname = kstrdup_const(name, GFP_KERNEL);\n\tif (!name)\n\t\treturn NULL;\n\n\tkn = kmem_cache_zalloc(kernfs_node_cache, GFP_KERNEL);\n\tif (!kn)\n\t\tgoto err_out1;\n\n\tret = ida_simple_get(&root->ino_ida, 1, 0, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto err_out2;\n\tkn->ino = ret;\n\n\tatomic_set(&kn->count, 1);\n\tatomic_set(&kn->active, KN_DEACTIVATED_BIAS);\n\tRB_CLEAR_NODE(&kn->rb);\n\n\tkn->name = name;\n\tkn->mode = mode;\n\tkn->flags = flags;\n\n\treturn kn;\n\n err_out2:\n\tkmem_cache_free(kernfs_node_cache, kn);\n err_out1:\n\tkfree_const(name);\n\treturn NULL;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic struct kernfs_node *__kernfs_new_node(struct kernfs_root *root,\n\t\t\t\t\t     const char *name, umode_t mode,\n\t\t\t\t\t     unsigned flags)\n{\n\tstruct kernfs_node *kn;\n\tint ret;\n\n\tname = kstrdup_const(name, GFP_KERNEL);\n\tif (!name)\n\t\treturn NULL;\n\n\tkn = kmem_cache_zalloc(kernfs_node_cache, GFP_KERNEL);\n\tif (!kn)\n\t\tgoto err_out1;\n\n\tret = ida_simple_get(&root->ino_ida, 1, 0, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto err_out2;\n\tkn->ino = ret;\n\n\tatomic_set(&kn->count, 1);\n\tatomic_set(&kn->active, KN_DEACTIVATED_BIAS);\n\tRB_CLEAR_NODE(&kn->rb);\n\n\tkn->name = name;\n\tkn->mode = mode;\n\tkn->flags = flags;\n\n\treturn kn;\n\n err_out2:\n\tkmem_cache_free(kernfs_node_cache, kn);\n err_out1:\n\tkfree_const(name);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&root->supers"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ida_init",
          "args": [
            "&root->ino_ida"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*root)",
            "GFP_KERNEL"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstruct kernfs_root *kernfs_create_root(struct kernfs_syscall_ops *scops,\n\t\t\t\t       unsigned int flags, void *priv)\n{\n\tstruct kernfs_root *root;\n\tstruct kernfs_node *kn;\n\n\troot = kzalloc(sizeof(*root), GFP_KERNEL);\n\tif (!root)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tida_init(&root->ino_ida);\n\tINIT_LIST_HEAD(&root->supers);\n\n\tkn = __kernfs_new_node(root, \"\", S_IFDIR | S_IRUGO | S_IXUGO,\n\t\t\t       KERNFS_DIR);\n\tif (!kn) {\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tkn->priv = priv;\n\tkn->dir.root = root;\n\n\troot->syscall_ops = scops;\n\troot->flags = flags;\n\troot->kn = kn;\n\tinit_waitqueue_head(&root->deactivate_waitq);\n\n\tif (!(root->flags & KERNFS_ROOT_CREATE_DEACTIVATED))\n\t\tkernfs_activate(kn);\n\n\treturn root;\n}"
  },
  {
    "function_name": "kernfs_find_and_get_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "674-685",
    "snippet": "struct kernfs_node *kernfs_find_and_get_ns(struct kernfs_node *parent,\n\t\t\t\t\t   const char *name, const void *ns)\n{\n\tstruct kernfs_node *kn;\n\n\tmutex_lock(&kernfs_mutex);\n\tkn = kernfs_find_ns(parent, name, ns);\n\tkernfs_get(kn);\n\tmutex_unlock(&kernfs_mutex);\n\n\treturn kn;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_get",
          "args": [
            "kn"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "378-384",
          "snippet": "void kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_find_ns",
          "args": [
            "parent",
            "name",
            "ns"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_find_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "631-662",
          "snippet": "static struct kernfs_node *kernfs_find_ns(struct kernfs_node *parent,\n\t\t\t\t\t  const unsigned char *name,\n\t\t\t\t\t  const void *ns)\n{\n\tstruct rb_node *node = parent->dir.children.rb_node;\n\tbool has_ns = kernfs_ns_enabled(parent);\n\tunsigned int hash;\n\n\tlockdep_assert_held(&kernfs_mutex);\n\n\tif (has_ns != (bool)ns) {\n\t\tWARN(1, KERN_WARNING \"kernfs: ns %s in '%s' for '%s'\\n\",\n\t\t     has_ns ? \"required\" : \"invalid\", parent->name, name);\n\t\treturn NULL;\n\t}\n\n\thash = kernfs_name_hash(name, ns);\n\twhile (node) {\n\t\tstruct kernfs_node *kn;\n\t\tint result;\n\n\t\tkn = rb_to_kn(node);\n\t\tresult = kernfs_name_compare(hash, name, ns, kn);\n\t\tif (result < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (result > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn kn;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic struct kernfs_node *kernfs_find_ns(struct kernfs_node *parent,\n\t\t\t\t\t  const unsigned char *name,\n\t\t\t\t\t  const void *ns)\n{\n\tstruct rb_node *node = parent->dir.children.rb_node;\n\tbool has_ns = kernfs_ns_enabled(parent);\n\tunsigned int hash;\n\n\tlockdep_assert_held(&kernfs_mutex);\n\n\tif (has_ns != (bool)ns) {\n\t\tWARN(1, KERN_WARNING \"kernfs: ns %s in '%s' for '%s'\\n\",\n\t\t     has_ns ? \"required\" : \"invalid\", parent->name, name);\n\t\treturn NULL;\n\t}\n\n\thash = kernfs_name_hash(name, ns);\n\twhile (node) {\n\t\tstruct kernfs_node *kn;\n\t\tint result;\n\n\t\tkn = rb_to_kn(node);\n\t\tresult = kernfs_name_compare(hash, name, ns, kn);\n\t\tif (result < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (result > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn kn;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstruct kernfs_node *kernfs_find_and_get_ns(struct kernfs_node *parent,\n\t\t\t\t\t   const char *name, const void *ns)\n{\n\tstruct kernfs_node *kn;\n\n\tmutex_lock(&kernfs_mutex);\n\tkn = kernfs_find_ns(parent, name, ns);\n\tkernfs_get(kn);\n\tmutex_unlock(&kernfs_mutex);\n\n\treturn kn;\n}"
  },
  {
    "function_name": "kernfs_find_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "631-662",
    "snippet": "static struct kernfs_node *kernfs_find_ns(struct kernfs_node *parent,\n\t\t\t\t\t  const unsigned char *name,\n\t\t\t\t\t  const void *ns)\n{\n\tstruct rb_node *node = parent->dir.children.rb_node;\n\tbool has_ns = kernfs_ns_enabled(parent);\n\tunsigned int hash;\n\n\tlockdep_assert_held(&kernfs_mutex);\n\n\tif (has_ns != (bool)ns) {\n\t\tWARN(1, KERN_WARNING \"kernfs: ns %s in '%s' for '%s'\\n\",\n\t\t     has_ns ? \"required\" : \"invalid\", parent->name, name);\n\t\treturn NULL;\n\t}\n\n\thash = kernfs_name_hash(name, ns);\n\twhile (node) {\n\t\tstruct kernfs_node *kn;\n\t\tint result;\n\n\t\tkn = rb_to_kn(node);\n\t\tresult = kernfs_name_compare(hash, name, ns, kn);\n\t\tif (result < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (result > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn kn;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_name_compare",
          "args": [
            "hash",
            "name",
            "ns",
            "kn"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_name_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "201-213",
          "snippet": "static int kernfs_name_compare(unsigned int hash, const char *name,\n\t\t\t       const void *ns, const struct kernfs_node *kn)\n{\n\tif (hash < kn->hash)\n\t\treturn -1;\n\tif (hash > kn->hash)\n\t\treturn 1;\n\tif (ns < kn->ns)\n\t\treturn -1;\n\tif (ns > kn->ns)\n\t\treturn 1;\n\treturn strcmp(name, kn->name);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic int kernfs_name_compare(unsigned int hash, const char *name,\n\t\t\t       const void *ns, const struct kernfs_node *kn)\n{\n\tif (hash < kn->hash)\n\t\treturn -1;\n\tif (hash > kn->hash)\n\t\treturn 1;\n\tif (ns < kn->ns)\n\t\treturn -1;\n\tif (ns > kn->ns)\n\t\treturn 1;\n\treturn strcmp(name, kn->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_to_kn",
          "args": [
            "node"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_name_hash",
          "args": [
            "name",
            "ns"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "185-199",
          "snippet": "static unsigned int kernfs_name_hash(const char *name, const void *ns)\n{\n\tunsigned long hash = init_name_hash();\n\tunsigned int len = strlen(name);\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\thash = (end_name_hash(hash) ^ hash_ptr((void *)ns, 31));\n\thash &= 0x7fffffffU;\n\t/* Reserve hash numbers 0, 1 and INT_MAX for magic directory entries */\n\tif (hash < 2)\n\t\thash += 2;\n\tif (hash >= INT_MAX)\n\t\thash = INT_MAX - 1;\n\treturn hash;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic unsigned int kernfs_name_hash(const char *name, const void *ns)\n{\n\tunsigned long hash = init_name_hash();\n\tunsigned int len = strlen(name);\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\thash = (end_name_hash(hash) ^ hash_ptr((void *)ns, 31));\n\thash &= 0x7fffffffU;\n\t/* Reserve hash numbers 0, 1 and INT_MAX for magic directory entries */\n\tif (hash < 2)\n\t\thash += 2;\n\tif (hash >= INT_MAX)\n\t\thash = INT_MAX - 1;\n\treturn hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "KERN_WARNING \"kernfs: ns %s in '%s' for '%s'\\n\"",
            "has_ns ? \"required\" : \"invalid\"",
            "parent->name",
            "name"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_ns_enabled",
          "args": [
            "parent"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic struct kernfs_node *kernfs_find_ns(struct kernfs_node *parent,\n\t\t\t\t\t  const unsigned char *name,\n\t\t\t\t\t  const void *ns)\n{\n\tstruct rb_node *node = parent->dir.children.rb_node;\n\tbool has_ns = kernfs_ns_enabled(parent);\n\tunsigned int hash;\n\n\tlockdep_assert_held(&kernfs_mutex);\n\n\tif (has_ns != (bool)ns) {\n\t\tWARN(1, KERN_WARNING \"kernfs: ns %s in '%s' for '%s'\\n\",\n\t\t     has_ns ? \"required\" : \"invalid\", parent->name, name);\n\t\treturn NULL;\n\t}\n\n\thash = kernfs_name_hash(name, ns);\n\twhile (node) {\n\t\tstruct kernfs_node *kn;\n\t\tint result;\n\n\t\tkn = rb_to_kn(node);\n\t\tresult = kernfs_name_compare(hash, name, ns, kn);\n\t\tif (result < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (result > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn kn;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "kernfs_add_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "569-620",
    "snippet": "int kernfs_add_one(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent = kn->parent;\n\tstruct kernfs_iattrs *ps_iattr;\n\tbool has_ns;\n\tint ret;\n\n\tmutex_lock(&kernfs_mutex);\n\n\tret = -EINVAL;\n\thas_ns = kernfs_ns_enabled(parent);\n\tif (WARN(has_ns != (bool)kn->ns, KERN_WARNING \"kernfs: ns %s in '%s' for '%s'\\n\",\n\t\t has_ns ? \"required\" : \"invalid\", parent->name, kn->name))\n\t\tgoto out_unlock;\n\n\tif (kernfs_type(parent) != KERNFS_DIR)\n\t\tgoto out_unlock;\n\n\tret = -ENOENT;\n\tif ((parent->flags & KERNFS_ACTIVATED) && !kernfs_active(parent))\n\t\tgoto out_unlock;\n\n\tkn->hash = kernfs_name_hash(kn->name, kn->ns);\n\n\tret = kernfs_link_sibling(kn);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* Update timestamps on the parent */\n\tps_iattr = parent->iattr;\n\tif (ps_iattr) {\n\t\tstruct iattr *ps_iattrs = &ps_iattr->ia_iattr;\n\t\tps_iattrs->ia_ctime = ps_iattrs->ia_mtime = CURRENT_TIME;\n\t}\n\n\tmutex_unlock(&kernfs_mutex);\n\n\t/*\n\t * Activate the new node unless CREATE_DEACTIVATED is requested.\n\t * If not activated here, the kernfs user is responsible for\n\t * activating the node with kernfs_activate().  A node which hasn't\n\t * been activated is not visible to userland and its removal won't\n\t * trigger deactivation.\n\t */\n\tif (!(kernfs_root(kn)->flags & KERNFS_ROOT_CREATE_DEACTIVATED))\n\t\tkernfs_activate(kn);\n\treturn 0;\n\nout_unlock:\n\tmutex_unlock(&kernfs_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_activate",
          "args": [
            "kn"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_activate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "964-983",
          "snippet": "void kernfs_activate(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *pos;\n\n\tmutex_lock(&kernfs_mutex);\n\n\tpos = NULL;\n\twhile ((pos = kernfs_next_descendant_post(pos, kn))) {\n\t\tif (!pos || (pos->flags & KERNFS_ACTIVATED))\n\t\t\tcontinue;\n\n\t\tWARN_ON_ONCE(pos->parent && RB_EMPTY_NODE(&pos->rb));\n\t\tWARN_ON_ONCE(atomic_read(&pos->active) != KN_DEACTIVATED_BIAS);\n\n\t\tatomic_sub(KN_DEACTIVATED_BIAS, &pos->active);\n\t\tpos->flags |= KERNFS_ACTIVATED;\n\t}\n\n\tmutex_unlock(&kernfs_mutex);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_activate(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *pos;\n\n\tmutex_lock(&kernfs_mutex);\n\n\tpos = NULL;\n\twhile ((pos = kernfs_next_descendant_post(pos, kn))) {\n\t\tif (!pos || (pos->flags & KERNFS_ACTIVATED))\n\t\t\tcontinue;\n\n\t\tWARN_ON_ONCE(pos->parent && RB_EMPTY_NODE(&pos->rb));\n\t\tWARN_ON_ONCE(atomic_read(&pos->active) != KN_DEACTIVATED_BIAS);\n\n\t\tatomic_sub(KN_DEACTIVATED_BIAS, &pos->active);\n\t\tpos->flags |= KERNFS_ACTIVATED;\n\t}\n\n\tmutex_unlock(&kernfs_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_root",
          "args": [
            "kn"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/kernfs-internal.h",
          "lines": "40-46",
          "snippet": "static inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)\n{\n\t/* if parent exists, it's always a dir; otherwise, @sd is a dir */\n\tif (kn->parent)\n\t\tkn = kn->parent;\n\treturn kn->dir.root;\n}",
          "includes": [
            "#include <linux/kernfs.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernfs.h>\n#include <linux/xattr.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/lockdep.h>\n\nstatic inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)\n{\n\t/* if parent exists, it's always a dir; otherwise, @sd is a dir */\n\tif (kn->parent)\n\t\tkn = kn->parent;\n\treturn kn->dir.root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_link_sibling",
          "args": [
            "kn"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_link_sibling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "234-263",
          "snippet": "static int kernfs_link_sibling(struct kernfs_node *kn)\n{\n\tstruct rb_node **node = &kn->parent->dir.children.rb_node;\n\tstruct rb_node *parent = NULL;\n\n\twhile (*node) {\n\t\tstruct kernfs_node *pos;\n\t\tint result;\n\n\t\tpos = rb_to_kn(*node);\n\t\tparent = *node;\n\t\tresult = kernfs_sd_compare(kn, pos);\n\t\tif (result < 0)\n\t\t\tnode = &pos->rb.rb_left;\n\t\telse if (result > 0)\n\t\t\tnode = &pos->rb.rb_right;\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\t/* add new node and rebalance the tree */\n\trb_link_node(&kn->rb, parent, node);\n\trb_insert_color(&kn->rb, &kn->parent->dir.children);\n\n\t/* successfully added, account subdir number */\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tkn->parent->dir.subdirs++;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic int kernfs_link_sibling(struct kernfs_node *kn)\n{\n\tstruct rb_node **node = &kn->parent->dir.children.rb_node;\n\tstruct rb_node *parent = NULL;\n\n\twhile (*node) {\n\t\tstruct kernfs_node *pos;\n\t\tint result;\n\n\t\tpos = rb_to_kn(*node);\n\t\tparent = *node;\n\t\tresult = kernfs_sd_compare(kn, pos);\n\t\tif (result < 0)\n\t\t\tnode = &pos->rb.rb_left;\n\t\telse if (result > 0)\n\t\t\tnode = &pos->rb.rb_right;\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\t/* add new node and rebalance the tree */\n\trb_link_node(&kn->rb, parent, node);\n\trb_insert_color(&kn->rb, &kn->parent->dir.children);\n\n\t/* successfully added, account subdir number */\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tkn->parent->dir.subdirs++;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_name_hash",
          "args": [
            "kn->name",
            "kn->ns"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "185-199",
          "snippet": "static unsigned int kernfs_name_hash(const char *name, const void *ns)\n{\n\tunsigned long hash = init_name_hash();\n\tunsigned int len = strlen(name);\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\thash = (end_name_hash(hash) ^ hash_ptr((void *)ns, 31));\n\thash &= 0x7fffffffU;\n\t/* Reserve hash numbers 0, 1 and INT_MAX for magic directory entries */\n\tif (hash < 2)\n\t\thash += 2;\n\tif (hash >= INT_MAX)\n\t\thash = INT_MAX - 1;\n\treturn hash;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic unsigned int kernfs_name_hash(const char *name, const void *ns)\n{\n\tunsigned long hash = init_name_hash();\n\tunsigned int len = strlen(name);\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\thash = (end_name_hash(hash) ^ hash_ptr((void *)ns, 31));\n\thash &= 0x7fffffffU;\n\t/* Reserve hash numbers 0, 1 and INT_MAX for magic directory entries */\n\tif (hash < 2)\n\t\thash += 2;\n\tif (hash >= INT_MAX)\n\t\thash = INT_MAX - 1;\n\treturn hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_active",
          "args": [
            "parent"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "27-31",
          "snippet": "static bool kernfs_active(struct kernfs_node *kn)\n{\n\tlockdep_assert_held(&kernfs_mutex);\n\treturn atomic_read(&kn->active) >= 0;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic bool kernfs_active(struct kernfs_node *kn)\n{\n\tlockdep_assert_held(&kernfs_mutex);\n\treturn atomic_read(&kn->active) >= 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_type",
          "args": [
            "parent"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "has_ns != (bool)kn->ns",
            "KERN_WARNING \"kernfs: ns %s in '%s' for '%s'\\n\"",
            "has_ns ? \"required\" : \"invalid\"",
            "parent->name",
            "kn->name"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_ns_enabled",
          "args": [
            "parent"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nint kernfs_add_one(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent = kn->parent;\n\tstruct kernfs_iattrs *ps_iattr;\n\tbool has_ns;\n\tint ret;\n\n\tmutex_lock(&kernfs_mutex);\n\n\tret = -EINVAL;\n\thas_ns = kernfs_ns_enabled(parent);\n\tif (WARN(has_ns != (bool)kn->ns, KERN_WARNING \"kernfs: ns %s in '%s' for '%s'\\n\",\n\t\t has_ns ? \"required\" : \"invalid\", parent->name, kn->name))\n\t\tgoto out_unlock;\n\n\tif (kernfs_type(parent) != KERNFS_DIR)\n\t\tgoto out_unlock;\n\n\tret = -ENOENT;\n\tif ((parent->flags & KERNFS_ACTIVATED) && !kernfs_active(parent))\n\t\tgoto out_unlock;\n\n\tkn->hash = kernfs_name_hash(kn->name, kn->ns);\n\n\tret = kernfs_link_sibling(kn);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* Update timestamps on the parent */\n\tps_iattr = parent->iattr;\n\tif (ps_iattr) {\n\t\tstruct iattr *ps_iattrs = &ps_iattr->ia_iattr;\n\t\tps_iattrs->ia_ctime = ps_iattrs->ia_mtime = CURRENT_TIME;\n\t}\n\n\tmutex_unlock(&kernfs_mutex);\n\n\t/*\n\t * Activate the new node unless CREATE_DEACTIVATED is requested.\n\t * If not activated here, the kernfs user is responsible for\n\t * activating the node with kernfs_activate().  A node which hasn't\n\t * been activated is not visible to userland and its removal won't\n\t * trigger deactivation.\n\t */\n\tif (!(kernfs_root(kn)->flags & KERNFS_ROOT_CREATE_DEACTIVATED))\n\t\tkernfs_activate(kn);\n\treturn 0;\n\nout_unlock:\n\tmutex_unlock(&kernfs_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "kernfs_new_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "543-555",
    "snippet": "struct kernfs_node *kernfs_new_node(struct kernfs_node *parent,\n\t\t\t\t    const char *name, umode_t mode,\n\t\t\t\t    unsigned flags)\n{\n\tstruct kernfs_node *kn;\n\n\tkn = __kernfs_new_node(kernfs_root(parent), name, mode, flags);\n\tif (kn) {\n\t\tkernfs_get(parent);\n\t\tkn->parent = parent;\n\t}\n\treturn kn;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_get",
          "args": [
            "parent"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "378-384",
          "snippet": "void kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kernfs_new_node",
          "args": [
            "kernfs_root(parent)",
            "name",
            "mode",
            "flags"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "__kernfs_new_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "506-541",
          "snippet": "static struct kernfs_node *__kernfs_new_node(struct kernfs_root *root,\n\t\t\t\t\t     const char *name, umode_t mode,\n\t\t\t\t\t     unsigned flags)\n{\n\tstruct kernfs_node *kn;\n\tint ret;\n\n\tname = kstrdup_const(name, GFP_KERNEL);\n\tif (!name)\n\t\treturn NULL;\n\n\tkn = kmem_cache_zalloc(kernfs_node_cache, GFP_KERNEL);\n\tif (!kn)\n\t\tgoto err_out1;\n\n\tret = ida_simple_get(&root->ino_ida, 1, 0, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto err_out2;\n\tkn->ino = ret;\n\n\tatomic_set(&kn->count, 1);\n\tatomic_set(&kn->active, KN_DEACTIVATED_BIAS);\n\tRB_CLEAR_NODE(&kn->rb);\n\n\tkn->name = name;\n\tkn->mode = mode;\n\tkn->flags = flags;\n\n\treturn kn;\n\n err_out2:\n\tkmem_cache_free(kernfs_node_cache, kn);\n err_out1:\n\tkfree_const(name);\n\treturn NULL;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic struct kernfs_node *__kernfs_new_node(struct kernfs_root *root,\n\t\t\t\t\t     const char *name, umode_t mode,\n\t\t\t\t\t     unsigned flags)\n{\n\tstruct kernfs_node *kn;\n\tint ret;\n\n\tname = kstrdup_const(name, GFP_KERNEL);\n\tif (!name)\n\t\treturn NULL;\n\n\tkn = kmem_cache_zalloc(kernfs_node_cache, GFP_KERNEL);\n\tif (!kn)\n\t\tgoto err_out1;\n\n\tret = ida_simple_get(&root->ino_ida, 1, 0, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto err_out2;\n\tkn->ino = ret;\n\n\tatomic_set(&kn->count, 1);\n\tatomic_set(&kn->active, KN_DEACTIVATED_BIAS);\n\tRB_CLEAR_NODE(&kn->rb);\n\n\tkn->name = name;\n\tkn->mode = mode;\n\tkn->flags = flags;\n\n\treturn kn;\n\n err_out2:\n\tkmem_cache_free(kernfs_node_cache, kn);\n err_out1:\n\tkfree_const(name);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_root",
          "args": [
            "parent"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/kernfs-internal.h",
          "lines": "40-46",
          "snippet": "static inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)\n{\n\t/* if parent exists, it's always a dir; otherwise, @sd is a dir */\n\tif (kn->parent)\n\t\tkn = kn->parent;\n\treturn kn->dir.root;\n}",
          "includes": [
            "#include <linux/kernfs.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernfs.h>\n#include <linux/xattr.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/lockdep.h>\n\nstatic inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)\n{\n\t/* if parent exists, it's always a dir; otherwise, @sd is a dir */\n\tif (kn->parent)\n\t\tkn = kn->parent;\n\treturn kn->dir.root;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstruct kernfs_node *kernfs_new_node(struct kernfs_node *parent,\n\t\t\t\t    const char *name, umode_t mode,\n\t\t\t\t    unsigned flags)\n{\n\tstruct kernfs_node *kn;\n\n\tkn = __kernfs_new_node(kernfs_root(parent), name, mode, flags);\n\tif (kn) {\n\t\tkernfs_get(parent);\n\t\tkn->parent = parent;\n\t}\n\treturn kn;\n}"
  },
  {
    "function_name": "__kernfs_new_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "506-541",
    "snippet": "static struct kernfs_node *__kernfs_new_node(struct kernfs_root *root,\n\t\t\t\t\t     const char *name, umode_t mode,\n\t\t\t\t\t     unsigned flags)\n{\n\tstruct kernfs_node *kn;\n\tint ret;\n\n\tname = kstrdup_const(name, GFP_KERNEL);\n\tif (!name)\n\t\treturn NULL;\n\n\tkn = kmem_cache_zalloc(kernfs_node_cache, GFP_KERNEL);\n\tif (!kn)\n\t\tgoto err_out1;\n\n\tret = ida_simple_get(&root->ino_ida, 1, 0, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto err_out2;\n\tkn->ino = ret;\n\n\tatomic_set(&kn->count, 1);\n\tatomic_set(&kn->active, KN_DEACTIVATED_BIAS);\n\tRB_CLEAR_NODE(&kn->rb);\n\n\tkn->name = name;\n\tkn->mode = mode;\n\tkn->flags = flags;\n\n\treturn kn;\n\n err_out2:\n\tkmem_cache_free(kernfs_node_cache, kn);\n err_out1:\n\tkfree_const(name);\n\treturn NULL;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_const",
          "args": [
            "name"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "kernfs_node_cache",
            "kn"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&kn->rb"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&kn->active",
            "KN_DEACTIVATED_BIAS"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&kn->count",
            "1"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ida_simple_get",
          "args": [
            "&root->ino_ida",
            "1",
            "0",
            "GFP_KERNEL"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "kernfs_node_cache",
            "GFP_KERNEL"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup_const",
          "args": [
            "name",
            "GFP_KERNEL"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic struct kernfs_node *__kernfs_new_node(struct kernfs_root *root,\n\t\t\t\t\t     const char *name, umode_t mode,\n\t\t\t\t\t     unsigned flags)\n{\n\tstruct kernfs_node *kn;\n\tint ret;\n\n\tname = kstrdup_const(name, GFP_KERNEL);\n\tif (!name)\n\t\treturn NULL;\n\n\tkn = kmem_cache_zalloc(kernfs_node_cache, GFP_KERNEL);\n\tif (!kn)\n\t\tgoto err_out1;\n\n\tret = ida_simple_get(&root->ino_ida, 1, 0, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto err_out2;\n\tkn->ino = ret;\n\n\tatomic_set(&kn->count, 1);\n\tatomic_set(&kn->active, KN_DEACTIVATED_BIAS);\n\tRB_CLEAR_NODE(&kn->rb);\n\n\tkn->name = name;\n\tkn->mode = mode;\n\tkn->flags = flags;\n\n\treturn kn;\n\n err_out2:\n\tkmem_cache_free(kernfs_node_cache, kn);\n err_out1:\n\tkfree_const(name);\n\treturn NULL;\n}"
  },
  {
    "function_name": "kernfs_node_from_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "499-504",
    "snippet": "struct kernfs_node *kernfs_node_from_dentry(struct dentry *dentry)\n{\n\tif (dentry->d_sb->s_op == &kernfs_sops)\n\t\treturn dentry->d_fsdata;\n\treturn NULL;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstruct kernfs_node *kernfs_node_from_dentry(struct dentry *dentry)\n{\n\tif (dentry->d_sb->s_op == &kernfs_sops)\n\t\treturn dentry->d_fsdata;\n\treturn NULL;\n}"
  },
  {
    "function_name": "kernfs_dop_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "478-481",
    "snippet": "static void kernfs_dop_release(struct dentry *dentry)\n{\n\tkernfs_put(dentry->d_fsdata);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "dentry->d_fsdata"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "393-436",
          "snippet": "void kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic void kernfs_dop_release(struct dentry *dentry)\n{\n\tkernfs_put(dentry->d_fsdata);\n}"
  },
  {
    "function_name": "kernfs_dop_revalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "439-476",
    "snippet": "static int kernfs_dop_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct kernfs_node *kn;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\t/* Always perform fresh lookup for negatives */\n\tif (!dentry->d_inode)\n\t\tgoto out_bad_unlocked;\n\n\tkn = dentry->d_fsdata;\n\tmutex_lock(&kernfs_mutex);\n\n\t/* The kernfs node has been deactivated */\n\tif (!kernfs_active(kn))\n\t\tgoto out_bad;\n\n\t/* The kernfs node has been moved? */\n\tif (dentry->d_parent->d_fsdata != kn->parent)\n\t\tgoto out_bad;\n\n\t/* The kernfs node has been renamed */\n\tif (strcmp(dentry->d_name.name, kn->name) != 0)\n\t\tgoto out_bad;\n\n\t/* The kernfs node has been moved to a different namespace */\n\tif (kn->parent && kernfs_ns_enabled(kn->parent) &&\n\t    kernfs_info(dentry->d_sb)->ns != kn->ns)\n\t\tgoto out_bad;\n\n\tmutex_unlock(&kernfs_mutex);\n\treturn 1;\nout_bad:\n\tmutex_unlock(&kernfs_mutex);\nout_bad_unlocked:\n\treturn 0;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_info",
          "args": [
            "dentry->d_sb"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_ns_enabled",
          "args": [
            "kn->parent"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dentry->d_name.name",
            "kn->name"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_active",
          "args": [
            "kn"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "27-31",
          "snippet": "static bool kernfs_active(struct kernfs_node *kn)\n{\n\tlockdep_assert_held(&kernfs_mutex);\n\treturn atomic_read(&kn->active) >= 0;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic bool kernfs_active(struct kernfs_node *kn)\n{\n\tlockdep_assert_held(&kernfs_mutex);\n\treturn atomic_read(&kn->active) >= 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic int kernfs_dop_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct kernfs_node *kn;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\t/* Always perform fresh lookup for negatives */\n\tif (!dentry->d_inode)\n\t\tgoto out_bad_unlocked;\n\n\tkn = dentry->d_fsdata;\n\tmutex_lock(&kernfs_mutex);\n\n\t/* The kernfs node has been deactivated */\n\tif (!kernfs_active(kn))\n\t\tgoto out_bad;\n\n\t/* The kernfs node has been moved? */\n\tif (dentry->d_parent->d_fsdata != kn->parent)\n\t\tgoto out_bad;\n\n\t/* The kernfs node has been renamed */\n\tif (strcmp(dentry->d_name.name, kn->name) != 0)\n\t\tgoto out_bad;\n\n\t/* The kernfs node has been moved to a different namespace */\n\tif (kn->parent && kernfs_ns_enabled(kn->parent) &&\n\t    kernfs_info(dentry->d_sb)->ns != kn->ns)\n\t\tgoto out_bad;\n\n\tmutex_unlock(&kernfs_mutex);\n\treturn 1;\nout_bad:\n\tmutex_unlock(&kernfs_mutex);\nout_bad_unlocked:\n\treturn 0;\n}"
  },
  {
    "function_name": "kernfs_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "393-436",
    "snippet": "void kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "root"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ida_destroy",
          "args": [
            "&root->ino_ida"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&kn->count"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "kernfs_node_cache",
            "kn"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ida_simple_remove",
          "args": [
            "&root->ino_ida",
            "kn->ino"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "kn->iattr"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_xattrs_free",
          "args": [
            "&kn->iattr->xattrs"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_release_secctx",
          "args": [
            "kn->iattr->ia_secdata",
            "kn->iattr->ia_secdata_len"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree_const",
          "args": [
            "kn->name"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "kn->symlink.target_kn"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "393-436",
          "snippet": "void kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_type",
          "args": [
            "kn"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "atomic_read(&kn->active) != KN_DEACTIVATED_BIAS",
            "\"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\"",
            "parent ? parent->name : \"\"",
            "kn->name",
            "atomic_read(&kn->active)"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kn->active"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kn->active"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_root",
          "args": [
            "kn"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/kernfs-internal.h",
          "lines": "40-46",
          "snippet": "static inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)\n{\n\t/* if parent exists, it's always a dir; otherwise, @sd is a dir */\n\tif (kn->parent)\n\t\tkn = kn->parent;\n\treturn kn->dir.root;\n}",
          "includes": [
            "#include <linux/kernfs.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernfs.h>\n#include <linux/xattr.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/lockdep.h>\n\nstatic inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)\n{\n\t/* if parent exists, it's always a dir; otherwise, @sd is a dir */\n\tif (kn->parent)\n\t\tkn = kn->parent;\n\treturn kn->dir.root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&kn->count"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}"
  },
  {
    "function_name": "kernfs_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "378-384",
    "snippet": "void kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&kn->count"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!atomic_read(&kn->count)"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kn->count"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}"
  },
  {
    "function_name": "kernfs_drain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "344-372",
    "snippet": "static void kernfs_drain(struct kernfs_node *kn)\n\t__releases(&kernfs_mutex) __acquires(&kernfs_mutex)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\n\tlockdep_assert_held(&kernfs_mutex);\n\tWARN_ON_ONCE(kernfs_active(kn));\n\n\tmutex_unlock(&kernfs_mutex);\n\n\tif (kernfs_lockdep(kn)) {\n\t\trwsem_acquire(&kn->dep_map, 0, 0, _RET_IP_);\n\t\tif (atomic_read(&kn->active) != KN_DEACTIVATED_BIAS)\n\t\t\tlock_contended(&kn->dep_map, _RET_IP_);\n\t}\n\n\t/* but everyone should wait for draining */\n\twait_event(root->deactivate_waitq,\n\t\t   atomic_read(&kn->active) == KN_DEACTIVATED_BIAS);\n\n\tif (kernfs_lockdep(kn)) {\n\t\tlock_acquired(&kn->dep_map, _RET_IP_);\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\t}\n\n\tkernfs_unmap_bin_file(kn);\n\n\tmutex_lock(&kernfs_mutex);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_unmap_bin_file",
          "args": [
            "kn"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_unmap_bin_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
          "lines": "742-766",
          "snippet": "void kernfs_unmap_bin_file(struct kernfs_node *kn)\n{\n\tstruct kernfs_open_node *on;\n\tstruct kernfs_open_file *of;\n\n\tif (!(kn->flags & KERNFS_HAS_MMAP))\n\t\treturn;\n\n\tspin_lock_irq(&kernfs_open_node_lock);\n\ton = kn->attr.open;\n\tif (on)\n\t\tatomic_inc(&on->refcnt);\n\tspin_unlock_irq(&kernfs_open_node_lock);\n\tif (!on)\n\t\treturn;\n\n\tmutex_lock(&kernfs_open_file_mutex);\n\tlist_for_each_entry(of, &on->files, list) {\n\t\tstruct inode *inode = file_inode(of->file);\n\t\tunmap_mapping_range(inode->i_mapping, 0, 0, 1);\n\t}\n\tmutex_unlock(&kernfs_open_file_mutex);\n\n\tkernfs_put_open_node(kn, NULL);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(kernfs_open_node_lock);",
            "static DEFINE_MUTEX(kernfs_open_file_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(kernfs_open_node_lock);\nstatic DEFINE_MUTEX(kernfs_open_file_mutex);\n\nvoid kernfs_unmap_bin_file(struct kernfs_node *kn)\n{\n\tstruct kernfs_open_node *on;\n\tstruct kernfs_open_file *of;\n\n\tif (!(kn->flags & KERNFS_HAS_MMAP))\n\t\treturn;\n\n\tspin_lock_irq(&kernfs_open_node_lock);\n\ton = kn->attr.open;\n\tif (on)\n\t\tatomic_inc(&on->refcnt);\n\tspin_unlock_irq(&kernfs_open_node_lock);\n\tif (!on)\n\t\treturn;\n\n\tmutex_lock(&kernfs_open_file_mutex);\n\tlist_for_each_entry(of, &on->files, list) {\n\t\tstruct inode *inode = file_inode(of->file);\n\t\tunmap_mapping_range(inode->i_mapping, 0, 0, 1);\n\t}\n\tmutex_unlock(&kernfs_open_file_mutex);\n\n\tkernfs_put_open_node(kn, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rwsem_release",
          "args": [
            "&kn->dep_map",
            "1",
            "_RET_IP_"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_acquired",
          "args": [
            "&kn->dep_map",
            "_RET_IP_"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_lockdep",
          "args": [
            "kn"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_lockdep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "33-40",
          "snippet": "static bool kernfs_lockdep(struct kernfs_node *kn)\n{\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\treturn kn->flags & KERNFS_LOCKDEP;\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic bool kernfs_lockdep(struct kernfs_node *kn)\n{\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\treturn kn->flags & KERNFS_LOCKDEP;\n#else\n\treturn false;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "root->deactivate_waitq",
            "atomic_read(&kn->active) == KN_DEACTIVATED_BIAS"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kn->active"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_contended",
          "args": [
            "&kn->dep_map",
            "_RET_IP_"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kn->active"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwsem_acquire",
          "args": [
            "&kn->dep_map",
            "0",
            "0",
            "_RET_IP_"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "kernfs_active(kn)"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_active",
          "args": [
            "kn"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "27-31",
          "snippet": "static bool kernfs_active(struct kernfs_node *kn)\n{\n\tlockdep_assert_held(&kernfs_mutex);\n\treturn atomic_read(&kn->active) >= 0;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic bool kernfs_active(struct kernfs_node *kn)\n{\n\tlockdep_assert_held(&kernfs_mutex);\n\treturn atomic_read(&kn->active) >= 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_root",
          "args": [
            "kn"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/kernfs-internal.h",
          "lines": "40-46",
          "snippet": "static inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)\n{\n\t/* if parent exists, it's always a dir; otherwise, @sd is a dir */\n\tif (kn->parent)\n\t\tkn = kn->parent;\n\treturn kn->dir.root;\n}",
          "includes": [
            "#include <linux/kernfs.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernfs.h>\n#include <linux/xattr.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/lockdep.h>\n\nstatic inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)\n{\n\t/* if parent exists, it's always a dir; otherwise, @sd is a dir */\n\tif (kn->parent)\n\t\tkn = kn->parent;\n\treturn kn->dir.root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic void kernfs_drain(struct kernfs_node *kn)\n\t__releases(&kernfs_mutex) __acquires(&kernfs_mutex)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\n\tlockdep_assert_held(&kernfs_mutex);\n\tWARN_ON_ONCE(kernfs_active(kn));\n\n\tmutex_unlock(&kernfs_mutex);\n\n\tif (kernfs_lockdep(kn)) {\n\t\trwsem_acquire(&kn->dep_map, 0, 0, _RET_IP_);\n\t\tif (atomic_read(&kn->active) != KN_DEACTIVATED_BIAS)\n\t\t\tlock_contended(&kn->dep_map, _RET_IP_);\n\t}\n\n\t/* but everyone should wait for draining */\n\twait_event(root->deactivate_waitq,\n\t\t   atomic_read(&kn->active) == KN_DEACTIVATED_BIAS);\n\n\tif (kernfs_lockdep(kn)) {\n\t\tlock_acquired(&kn->dep_map, _RET_IP_);\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\t}\n\n\tkernfs_unmap_bin_file(kn);\n\n\tmutex_lock(&kernfs_mutex);\n}"
  },
  {
    "function_name": "kernfs_put_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "319-334",
    "snippet": "void kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&root->deactivate_waitq"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "v != KN_DEACTIVATED_BIAS"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_return",
          "args": [
            "&kn->active"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwsem_release",
          "args": [
            "&kn->dep_map",
            "1",
            "_RET_IP_"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_lockdep",
          "args": [
            "kn"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_lockdep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "33-40",
          "snippet": "static bool kernfs_lockdep(struct kernfs_node *kn)\n{\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\treturn kn->flags & KERNFS_LOCKDEP;\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic bool kernfs_lockdep(struct kernfs_node *kn)\n{\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\treturn kn->flags & KERNFS_LOCKDEP;\n#else\n\treturn false;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!kn"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_root",
          "args": [
            "kn"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/kernfs-internal.h",
          "lines": "40-46",
          "snippet": "static inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)\n{\n\t/* if parent exists, it's always a dir; otherwise, @sd is a dir */\n\tif (kn->parent)\n\t\tkn = kn->parent;\n\treturn kn->dir.root;\n}",
          "includes": [
            "#include <linux/kernfs.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernfs.h>\n#include <linux/xattr.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/lockdep.h>\n\nstatic inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)\n{\n\t/* if parent exists, it's always a dir; otherwise, @sd is a dir */\n\tif (kn->parent)\n\t\tkn = kn->parent;\n\treturn kn->dir.root;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}"
  },
  {
    "function_name": "kernfs_get_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "299-310",
    "snippet": "struct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rwsem_acquire_read",
          "args": [
            "&kn->dep_map",
            "0",
            "1",
            "_RET_IP_"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_lockdep",
          "args": [
            "kn"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_lockdep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "33-40",
          "snippet": "static bool kernfs_lockdep(struct kernfs_node *kn)\n{\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\treturn kn->flags & KERNFS_LOCKDEP;\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic bool kernfs_lockdep(struct kernfs_node *kn)\n{\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\treturn kn->flags & KERNFS_LOCKDEP;\n#else\n\treturn false;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc_unless_negative",
          "args": [
            "&kn->active"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!kn"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstruct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}"
  },
  {
    "function_name": "kernfs_unlink_sibling",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "276-287",
    "snippet": "static bool kernfs_unlink_sibling(struct kernfs_node *kn)\n{\n\tif (RB_EMPTY_NODE(&kn->rb))\n\t\treturn false;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tkn->parent->dir.subdirs--;\n\n\trb_erase(&kn->rb, &kn->parent->dir.children);\n\tRB_CLEAR_NODE(&kn->rb);\n\treturn true;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&kn->rb"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&kn->rb",
            "&kn->parent->dir.children"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_type",
          "args": [
            "kn"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&kn->rb"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic bool kernfs_unlink_sibling(struct kernfs_node *kn)\n{\n\tif (RB_EMPTY_NODE(&kn->rb))\n\t\treturn false;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tkn->parent->dir.subdirs--;\n\n\trb_erase(&kn->rb, &kn->parent->dir.children);\n\tRB_CLEAR_NODE(&kn->rb);\n\treturn true;\n}"
  },
  {
    "function_name": "kernfs_link_sibling",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "234-263",
    "snippet": "static int kernfs_link_sibling(struct kernfs_node *kn)\n{\n\tstruct rb_node **node = &kn->parent->dir.children.rb_node;\n\tstruct rb_node *parent = NULL;\n\n\twhile (*node) {\n\t\tstruct kernfs_node *pos;\n\t\tint result;\n\n\t\tpos = rb_to_kn(*node);\n\t\tparent = *node;\n\t\tresult = kernfs_sd_compare(kn, pos);\n\t\tif (result < 0)\n\t\t\tnode = &pos->rb.rb_left;\n\t\telse if (result > 0)\n\t\t\tnode = &pos->rb.rb_right;\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\t/* add new node and rebalance the tree */\n\trb_link_node(&kn->rb, parent, node);\n\trb_insert_color(&kn->rb, &kn->parent->dir.children);\n\n\t/* successfully added, account subdir number */\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tkn->parent->dir.subdirs++;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_type",
          "args": [
            "kn"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&kn->rb",
            "&kn->parent->dir.children"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&kn->rb",
            "parent",
            "node"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_sd_compare",
          "args": [
            "kn",
            "pos"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_sd_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "215-219",
          "snippet": "static int kernfs_sd_compare(const struct kernfs_node *left,\n\t\t\t     const struct kernfs_node *right)\n{\n\treturn kernfs_name_compare(left->hash, left->name, left->ns, right);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic int kernfs_sd_compare(const struct kernfs_node *left,\n\t\t\t     const struct kernfs_node *right)\n{\n\treturn kernfs_name_compare(left->hash, left->name, left->ns, right);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_to_kn",
          "args": [
            "*node"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic int kernfs_link_sibling(struct kernfs_node *kn)\n{\n\tstruct rb_node **node = &kn->parent->dir.children.rb_node;\n\tstruct rb_node *parent = NULL;\n\n\twhile (*node) {\n\t\tstruct kernfs_node *pos;\n\t\tint result;\n\n\t\tpos = rb_to_kn(*node);\n\t\tparent = *node;\n\t\tresult = kernfs_sd_compare(kn, pos);\n\t\tif (result < 0)\n\t\t\tnode = &pos->rb.rb_left;\n\t\telse if (result > 0)\n\t\t\tnode = &pos->rb.rb_right;\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\t/* add new node and rebalance the tree */\n\trb_link_node(&kn->rb, parent, node);\n\trb_insert_color(&kn->rb, &kn->parent->dir.children);\n\n\t/* successfully added, account subdir number */\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tkn->parent->dir.subdirs++;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kernfs_sd_compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "215-219",
    "snippet": "static int kernfs_sd_compare(const struct kernfs_node *left,\n\t\t\t     const struct kernfs_node *right)\n{\n\treturn kernfs_name_compare(left->hash, left->name, left->ns, right);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_name_compare",
          "args": [
            "left->hash",
            "left->name",
            "left->ns",
            "right"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_name_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "201-213",
          "snippet": "static int kernfs_name_compare(unsigned int hash, const char *name,\n\t\t\t       const void *ns, const struct kernfs_node *kn)\n{\n\tif (hash < kn->hash)\n\t\treturn -1;\n\tif (hash > kn->hash)\n\t\treturn 1;\n\tif (ns < kn->ns)\n\t\treturn -1;\n\tif (ns > kn->ns)\n\t\treturn 1;\n\treturn strcmp(name, kn->name);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic int kernfs_name_compare(unsigned int hash, const char *name,\n\t\t\t       const void *ns, const struct kernfs_node *kn)\n{\n\tif (hash < kn->hash)\n\t\treturn -1;\n\tif (hash > kn->hash)\n\t\treturn 1;\n\tif (ns < kn->ns)\n\t\treturn -1;\n\tif (ns > kn->ns)\n\t\treturn 1;\n\treturn strcmp(name, kn->name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic int kernfs_sd_compare(const struct kernfs_node *left,\n\t\t\t     const struct kernfs_node *right)\n{\n\treturn kernfs_name_compare(left->hash, left->name, left->ns, right);\n}"
  },
  {
    "function_name": "kernfs_name_compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "201-213",
    "snippet": "static int kernfs_name_compare(unsigned int hash, const char *name,\n\t\t\t       const void *ns, const struct kernfs_node *kn)\n{\n\tif (hash < kn->hash)\n\t\treturn -1;\n\tif (hash > kn->hash)\n\t\treturn 1;\n\tif (ns < kn->ns)\n\t\treturn -1;\n\tif (ns > kn->ns)\n\t\treturn 1;\n\treturn strcmp(name, kn->name);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "kn->name"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic int kernfs_name_compare(unsigned int hash, const char *name,\n\t\t\t       const void *ns, const struct kernfs_node *kn)\n{\n\tif (hash < kn->hash)\n\t\treturn -1;\n\tif (hash > kn->hash)\n\t\treturn 1;\n\tif (ns < kn->ns)\n\t\treturn -1;\n\tif (ns > kn->ns)\n\t\treturn 1;\n\treturn strcmp(name, kn->name);\n}"
  },
  {
    "function_name": "kernfs_name_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "185-199",
    "snippet": "static unsigned int kernfs_name_hash(const char *name, const void *ns)\n{\n\tunsigned long hash = init_name_hash();\n\tunsigned int len = strlen(name);\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\thash = (end_name_hash(hash) ^ hash_ptr((void *)ns, 31));\n\thash &= 0x7fffffffU;\n\t/* Reserve hash numbers 0, 1 and INT_MAX for magic directory entries */\n\tif (hash < 2)\n\t\thash += 2;\n\tif (hash >= INT_MAX)\n\t\thash = INT_MAX - 1;\n\treturn hash;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_ptr",
          "args": [
            "(void *)ns",
            "31"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_name_hash",
          "args": [
            "hash"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "partial_name_hash",
          "args": [
            "*name++",
            "hash"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_name_hash",
          "args": [],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic unsigned int kernfs_name_hash(const char *name, const void *ns)\n{\n\tunsigned long hash = init_name_hash();\n\tunsigned int len = strlen(name);\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\thash = (end_name_hash(hash) ^ hash_ptr((void *)ns, 31));\n\thash &= 0x7fffffffU;\n\t/* Reserve hash numbers 0, 1 and INT_MAX for magic directory entries */\n\tif (hash < 2)\n\t\thash += 2;\n\tif (hash >= INT_MAX)\n\t\thash = INT_MAX - 1;\n\treturn hash;\n}"
  },
  {
    "function_name": "kernfs_get_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "165-176",
    "snippet": "struct kernfs_node *kernfs_get_parent(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&kernfs_rename_lock, flags);\n\tparent = kn->parent;\n\tkernfs_get(parent);\n\tspin_unlock_irqrestore(&kernfs_rename_lock, flags);\n\n\treturn parent;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(kernfs_rename_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&kernfs_rename_lock",
            "flags"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_get",
          "args": [
            "parent"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "378-384",
          "snippet": "void kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&kernfs_rename_lock",
            "flags"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(kernfs_rename_lock);\n\nstruct kernfs_node *kernfs_get_parent(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&kernfs_rename_lock, flags);\n\tparent = kn->parent;\n\tkernfs_get(parent);\n\tspin_unlock_irqrestore(&kernfs_rename_lock, flags);\n\n\treturn parent;\n}"
  },
  {
    "function_name": "pr_cont_kernfs_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "141-156",
    "snippet": "void pr_cont_kernfs_path(struct kernfs_node *kn)\n{\n\tunsigned long flags;\n\tchar *p;\n\n\tspin_lock_irqsave(&kernfs_rename_lock, flags);\n\n\tp = kernfs_path_locked(kn, kernfs_pr_cont_buf,\n\t\t\t       sizeof(kernfs_pr_cont_buf));\n\tif (p)\n\t\tpr_cont(\"%s\", p);\n\telse\n\t\tpr_cont(\"<name too long>\");\n\n\tspin_unlock_irqrestore(&kernfs_rename_lock, flags);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(kernfs_rename_lock);",
      "static char kernfs_pr_cont_buf[PATH_MAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&kernfs_rename_lock",
            "flags"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"<name too long>\""
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_kernfs_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "141-156",
          "snippet": "void pr_cont_kernfs_path(struct kernfs_node *kn)\n{\n\tunsigned long flags;\n\tchar *p;\n\n\tspin_lock_irqsave(&kernfs_rename_lock, flags);\n\n\tp = kernfs_path_locked(kn, kernfs_pr_cont_buf,\n\t\t\t       sizeof(kernfs_pr_cont_buf));\n\tif (p)\n\t\tpr_cont(\"%s\", p);\n\telse\n\t\tpr_cont(\"<name too long>\");\n\n\tspin_unlock_irqrestore(&kernfs_rename_lock, flags);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%s\"",
            "p"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_path_locked",
          "args": [
            "kn",
            "kernfs_pr_cont_buf",
            "sizeof(kernfs_pr_cont_buf)"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_path_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "47-69",
          "snippet": "static char * __must_check kernfs_path_locked(struct kernfs_node *kn, char *buf,\n\t\t\t\t\t      size_t buflen)\n{\n\tchar *p = buf + buflen;\n\tint len;\n\n\t*--p = '\\0';\n\n\tdo {\n\t\tlen = strlen(kn->name);\n\t\tif (p - buf < len + 1) {\n\t\t\tbuf[0] = '\\0';\n\t\t\tp = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tp -= len;\n\t\tmemcpy(p, kn->name, len);\n\t\t*--p = '/';\n\t\tkn = kn->parent;\n\t} while (kn && kn->parent);\n\n\treturn p;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic char * __must_check kernfs_path_locked(struct kernfs_node *kn, char *buf,\n\t\t\t\t\t      size_t buflen)\n{\n\tchar *p = buf + buflen;\n\tint len;\n\n\t*--p = '\\0';\n\n\tdo {\n\t\tlen = strlen(kn->name);\n\t\tif (p - buf < len + 1) {\n\t\t\tbuf[0] = '\\0';\n\t\t\tp = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tp -= len;\n\t\tmemcpy(p, kn->name, len);\n\t\t*--p = '/';\n\t\tkn = kn->parent;\n\t} while (kn && kn->parent);\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&kernfs_rename_lock",
            "flags"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(kernfs_rename_lock);\nstatic char kernfs_pr_cont_buf[PATH_MAX];\n\nvoid pr_cont_kernfs_path(struct kernfs_node *kn)\n{\n\tunsigned long flags;\n\tchar *p;\n\n\tspin_lock_irqsave(&kernfs_rename_lock, flags);\n\n\tp = kernfs_path_locked(kn, kernfs_pr_cont_buf,\n\t\t\t       sizeof(kernfs_pr_cont_buf));\n\tif (p)\n\t\tpr_cont(\"%s\", p);\n\telse\n\t\tpr_cont(\"<name too long>\");\n\n\tspin_unlock_irqrestore(&kernfs_rename_lock, flags);\n}"
  },
  {
    "function_name": "pr_cont_kernfs_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "123-133",
    "snippet": "void pr_cont_kernfs_name(struct kernfs_node *kn)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&kernfs_rename_lock, flags);\n\n\tkernfs_name_locked(kn, kernfs_pr_cont_buf, sizeof(kernfs_pr_cont_buf));\n\tpr_cont(\"%s\", kernfs_pr_cont_buf);\n\n\tspin_unlock_irqrestore(&kernfs_rename_lock, flags);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(kernfs_rename_lock);",
      "static char kernfs_pr_cont_buf[PATH_MAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&kernfs_rename_lock",
            "flags"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%s\"",
            "kernfs_pr_cont_buf"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_name_locked",
          "args": [
            "kn",
            "kernfs_pr_cont_buf",
            "sizeof(kernfs_pr_cont_buf)"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_name_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "42-45",
          "snippet": "static int kernfs_name_locked(struct kernfs_node *kn, char *buf, size_t buflen)\n{\n\treturn strlcpy(buf, kn->parent ? kn->name : \"/\", buflen);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic int kernfs_name_locked(struct kernfs_node *kn, char *buf, size_t buflen)\n{\n\treturn strlcpy(buf, kn->parent ? kn->name : \"/\", buflen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&kernfs_rename_lock",
            "flags"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(kernfs_rename_lock);\nstatic char kernfs_pr_cont_buf[PATH_MAX];\n\nvoid pr_cont_kernfs_name(struct kernfs_node *kn)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&kernfs_rename_lock, flags);\n\n\tkernfs_name_locked(kn, kernfs_pr_cont_buf, sizeof(kernfs_pr_cont_buf));\n\tpr_cont(\"%s\", kernfs_pr_cont_buf);\n\n\tspin_unlock_irqrestore(&kernfs_rename_lock, flags);\n}"
  },
  {
    "function_name": "kernfs_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "105-114",
    "snippet": "char *kernfs_path(struct kernfs_node *kn, char *buf, size_t buflen)\n{\n\tunsigned long flags;\n\tchar *p;\n\n\tspin_lock_irqsave(&kernfs_rename_lock, flags);\n\tp = kernfs_path_locked(kn, buf, buflen);\n\tspin_unlock_irqrestore(&kernfs_rename_lock, flags);\n\treturn p;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(kernfs_rename_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&kernfs_rename_lock",
            "flags"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_path_locked",
          "args": [
            "kn",
            "buf",
            "buflen"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_path_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "47-69",
          "snippet": "static char * __must_check kernfs_path_locked(struct kernfs_node *kn, char *buf,\n\t\t\t\t\t      size_t buflen)\n{\n\tchar *p = buf + buflen;\n\tint len;\n\n\t*--p = '\\0';\n\n\tdo {\n\t\tlen = strlen(kn->name);\n\t\tif (p - buf < len + 1) {\n\t\t\tbuf[0] = '\\0';\n\t\t\tp = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tp -= len;\n\t\tmemcpy(p, kn->name, len);\n\t\t*--p = '/';\n\t\tkn = kn->parent;\n\t} while (kn && kn->parent);\n\n\treturn p;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic char * __must_check kernfs_path_locked(struct kernfs_node *kn, char *buf,\n\t\t\t\t\t      size_t buflen)\n{\n\tchar *p = buf + buflen;\n\tint len;\n\n\t*--p = '\\0';\n\n\tdo {\n\t\tlen = strlen(kn->name);\n\t\tif (p - buf < len + 1) {\n\t\t\tbuf[0] = '\\0';\n\t\t\tp = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tp -= len;\n\t\tmemcpy(p, kn->name, len);\n\t\t*--p = '/';\n\t\tkn = kn->parent;\n\t} while (kn && kn->parent);\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&kernfs_rename_lock",
            "flags"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(kernfs_rename_lock);\n\nchar *kernfs_path(struct kernfs_node *kn, char *buf, size_t buflen)\n{\n\tunsigned long flags;\n\tchar *p;\n\n\tspin_lock_irqsave(&kernfs_rename_lock, flags);\n\tp = kernfs_path_locked(kn, buf, buflen);\n\tspin_unlock_irqrestore(&kernfs_rename_lock, flags);\n\treturn p;\n}"
  },
  {
    "function_name": "kernfs_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "83-92",
    "snippet": "int kernfs_name(struct kernfs_node *kn, char *buf, size_t buflen)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&kernfs_rename_lock, flags);\n\tret = kernfs_name_locked(kn, buf, buflen);\n\tspin_unlock_irqrestore(&kernfs_rename_lock, flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(kernfs_rename_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&kernfs_rename_lock",
            "flags"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_name_locked",
          "args": [
            "kn",
            "buf",
            "buflen"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_name_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "42-45",
          "snippet": "static int kernfs_name_locked(struct kernfs_node *kn, char *buf, size_t buflen)\n{\n\treturn strlcpy(buf, kn->parent ? kn->name : \"/\", buflen);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic int kernfs_name_locked(struct kernfs_node *kn, char *buf, size_t buflen)\n{\n\treturn strlcpy(buf, kn->parent ? kn->name : \"/\", buflen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&kernfs_rename_lock",
            "flags"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(kernfs_rename_lock);\n\nint kernfs_name(struct kernfs_node *kn, char *buf, size_t buflen)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&kernfs_rename_lock, flags);\n\tret = kernfs_name_locked(kn, buf, buflen);\n\tspin_unlock_irqrestore(&kernfs_rename_lock, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "kernfs_path_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "47-69",
    "snippet": "static char * __must_check kernfs_path_locked(struct kernfs_node *kn, char *buf,\n\t\t\t\t\t      size_t buflen)\n{\n\tchar *p = buf + buflen;\n\tint len;\n\n\t*--p = '\\0';\n\n\tdo {\n\t\tlen = strlen(kn->name);\n\t\tif (p - buf < len + 1) {\n\t\t\tbuf[0] = '\\0';\n\t\t\tp = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tp -= len;\n\t\tmemcpy(p, kn->name, len);\n\t\t*--p = '/';\n\t\tkn = kn->parent;\n\t} while (kn && kn->parent);\n\n\treturn p;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "kn->name",
            "len"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "kn->name"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic char * __must_check kernfs_path_locked(struct kernfs_node *kn, char *buf,\n\t\t\t\t\t      size_t buflen)\n{\n\tchar *p = buf + buflen;\n\tint len;\n\n\t*--p = '\\0';\n\n\tdo {\n\t\tlen = strlen(kn->name);\n\t\tif (p - buf < len + 1) {\n\t\t\tbuf[0] = '\\0';\n\t\t\tp = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tp -= len;\n\t\tmemcpy(p, kn->name, len);\n\t\t*--p = '/';\n\t\tkn = kn->parent;\n\t} while (kn && kn->parent);\n\n\treturn p;\n}"
  },
  {
    "function_name": "kernfs_name_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "42-45",
    "snippet": "static int kernfs_name_locked(struct kernfs_node *kn, char *buf, size_t buflen)\n{\n\treturn strlcpy(buf, kn->parent ? kn->name : \"/\", buflen);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "buf",
            "kn->parent ? kn->name : \"/\"",
            "buflen"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic int kernfs_name_locked(struct kernfs_node *kn, char *buf, size_t buflen)\n{\n\treturn strlcpy(buf, kn->parent ? kn->name : \"/\", buflen);\n}"
  },
  {
    "function_name": "kernfs_lockdep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "33-40",
    "snippet": "static bool kernfs_lockdep(struct kernfs_node *kn)\n{\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\treturn kn->flags & KERNFS_LOCKDEP;\n#else\n\treturn false;\n#endif\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic bool kernfs_lockdep(struct kernfs_node *kn)\n{\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\treturn kn->flags & KERNFS_LOCKDEP;\n#else\n\treturn false;\n#endif\n}"
  },
  {
    "function_name": "kernfs_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
    "lines": "27-31",
    "snippet": "static bool kernfs_active(struct kernfs_node *kn)\n{\n\tlockdep_assert_held(&kernfs_mutex);\n\treturn atomic_read(&kn->active) >= 0;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/hash.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kn->active"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic bool kernfs_active(struct kernfs_node *kn)\n{\n\tlockdep_assert_held(&kernfs_mutex);\n\treturn atomic_read(&kn->active) >= 0;\n}"
  }
]