[
  {
    "function_name": "exit_reiserfs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "2542-2547",
    "snippet": "static void __exit exit_reiserfs_fs(void)\n{\n\treiserfs_proc_info_global_done();\n\tunregister_filesystem(&reiserfs_fs_type);\n\tdestroy_inodecache();\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct file_system_type reiserfs_fs_type;",
      "struct file_system_type reiserfs_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"reiserfs\",\n\t.mount = get_super_block,\n\t.kill_sb = reiserfs_kill_sb,\n\t.fs_flags = FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 2546
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "636-644",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(reiserfs_inode_cachep);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *reiserfs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *reiserfs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(reiserfs_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&reiserfs_fs_type"
          ],
          "line": 2545
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_proc_info_global_done",
          "args": [],
          "line": 2544
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_proc_info_global_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "3148-3151",
          "snippet": "static inline int reiserfs_proc_info_global_done(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int reiserfs_proc_info_global_done(void)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstruct file_system_type reiserfs_fs_type;\nstruct file_system_type reiserfs_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"reiserfs\",\n\t.mount = get_super_block,\n\t.kill_sb = reiserfs_kill_sb,\n\t.fs_flags = FS_REQUIRES_DEV,\n};\n\nstatic void __exit exit_reiserfs_fs(void)\n{\n\treiserfs_proc_info_global_done();\n\tunregister_filesystem(&reiserfs_fs_type);\n\tdestroy_inodecache();\n}"
  },
  {
    "function_name": "init_reiserfs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "2520-2540",
    "snippet": "static int __init init_reiserfs_fs(void)\n{\n\tint ret;\n\n\tret = init_inodecache();\n\tif (ret)\n\t\treturn ret;\n\n\treiserfs_proc_info_global_init();\n\n\tret = register_filesystem(&reiserfs_fs_type);\n\tif (ret)\n\t\tgoto out;\n\n\treturn 0;\nout:\n\treiserfs_proc_info_global_done();\n\tdestroy_inodecache();\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct file_system_type reiserfs_fs_type;",
      "struct file_system_type reiserfs_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"reiserfs\",\n\t.mount = get_super_block,\n\t.kill_sb = reiserfs_kill_sb,\n\t.fs_flags = FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 2537
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "636-644",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(reiserfs_inode_cachep);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *reiserfs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *reiserfs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(reiserfs_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_proc_info_global_done",
          "args": [],
          "line": 2536
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_proc_info_global_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "3148-3151",
          "snippet": "static inline int reiserfs_proc_info_global_done(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int reiserfs_proc_info_global_done(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&reiserfs_fs_type"
          ],
          "line": 2530
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_proc_info_global_init",
          "args": [],
          "line": 2528
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_proc_info_global_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "3143-3146",
          "snippet": "static inline int reiserfs_proc_info_global_init(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int reiserfs_proc_info_global_init(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_inodecache",
          "args": [],
          "line": 2524
        },
        "resolved": true,
        "details": {
          "function_name": "init_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "623-634",
          "snippet": "static int __init init_inodecache(void)\n{\n\treiserfs_inode_cachep = kmem_cache_create(\"reiser_inode_cache\",\n\t\t\t\t\t\t  sizeof(struct\n\t\t\t\t\t\t\t reiserfs_inode_info),\n\t\t\t\t\t\t  0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t\t  init_once);\n\tif (reiserfs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *reiserfs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *reiserfs_inode_cachep;\n\nstatic int __init init_inodecache(void)\n{\n\treiserfs_inode_cachep = kmem_cache_create(\"reiser_inode_cache\",\n\t\t\t\t\t\t  sizeof(struct\n\t\t\t\t\t\t\t reiserfs_inode_info),\n\t\t\t\t\t\t  0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t\t  init_once);\n\tif (reiserfs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstruct file_system_type reiserfs_fs_type;\nstruct file_system_type reiserfs_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"reiserfs\",\n\t.mount = get_super_block,\n\t.kill_sb = reiserfs_kill_sb,\n\t.fs_flags = FS_REQUIRES_DEV,\n};\n\nstatic int __init init_reiserfs_fs(void)\n{\n\tint ret;\n\n\tret = init_inodecache();\n\tif (ret)\n\t\treturn ret;\n\n\treiserfs_proc_info_global_init();\n\n\tret = register_filesystem(&reiserfs_fs_type);\n\tif (ret)\n\t\tgoto out;\n\n\treturn 0;\nout:\n\treiserfs_proc_info_global_done();\n\tdestroy_inodecache();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "get_super_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "2513-2518",
    "snippet": "static struct dentry *get_super_block(struct file_system_type *fs_type,\n\t\t\t   int flags, const char *dev_name,\n\t\t\t   void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, reiserfs_fill_super);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int reiserfs_remount(struct super_block *s, int *flags, char *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "reiserfs_fill_super"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int reiserfs_remount(struct super_block *s, int *flags, char *data);\n\nstatic struct dentry *get_super_block(struct file_system_type *fs_type,\n\t\t\t   int flags, const char *dev_name,\n\t\t\t   void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, reiserfs_fill_super);\n}"
  },
  {
    "function_name": "reiserfs_quota_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "2451-2509",
    "snippet": "static ssize_t reiserfs_quota_write(struct super_block *sb, int type,\n\t\t\t\t    const char *data, size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tunsigned long blk = off >> sb->s_blocksize_bits;\n\tint err = 0, offset = off & (sb->s_blocksize - 1), tocopy;\n\tint journal_quota = REISERFS_SB(sb)->s_qf_names[type] != NULL;\n\tsize_t towrite = len;\n\tstruct buffer_head tmp_bh, *bh;\n\n\tif (!current->journal_info) {\n\t\tprintk(KERN_WARNING \"reiserfs: Quota write (off=%llu, len=%llu) cancelled because transaction is not started.\\n\",\n\t\t\t(unsigned long long)off, (unsigned long long)len);\n\t\treturn -EIO;\n\t}\n\twhile (towrite > 0) {\n\t\ttocopy = sb->s_blocksize - offset < towrite ?\n\t\t    sb->s_blocksize - offset : towrite;\n\t\ttmp_bh.b_state = 0;\n\t\treiserfs_write_lock(sb);\n\t\terr = reiserfs_get_block(inode, blk, &tmp_bh, GET_BLOCK_CREATE);\n\t\treiserfs_write_unlock(sb);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (offset || tocopy != sb->s_blocksize)\n\t\t\tbh = sb_bread(sb, tmp_bh.b_blocknr);\n\t\telse\n\t\t\tbh = sb_getblk(sb, tmp_bh.b_blocknr);\n\t\tif (!bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tmemcpy(bh->b_data + offset, data, tocopy);\n\t\tflush_dcache_page(bh->b_page);\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\treiserfs_write_lock(sb);\n\t\treiserfs_prepare_for_journal(sb, bh, 1);\n\t\tjournal_mark_dirty(current->journal_info, bh);\n\t\tif (!journal_quota)\n\t\t\treiserfs_add_ordered_list(inode, bh);\n\t\treiserfs_write_unlock(sb);\n\t\tbrelse(bh);\n\t\toffset = 0;\n\t\ttowrite -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\nout:\n\tif (len == towrite)\n\t\treturn err;\n\tif (inode->i_size < off + len - towrite)\n\t\ti_size_write(inode, off + len - towrite);\n\tinode->i_version++;\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(inode);\n\treturn len - towrite;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int reiserfs_remount(struct super_block *s, int *flags, char *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 2507
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "off + len - towrite"
          ],
          "line": 2504
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 2494
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "sb"
          ],
          "line": 2493
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_add_ordered_list",
          "args": [
            "inode",
            "bh"
          ],
          "line": 2492
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_add_ordered_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "788-791",
          "snippet": "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh)\n{\n\treturn __add_jh(SB_JOURNAL(inode->i_sb), bh, 0);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh)\n{\n\treturn __add_jh(SB_JOURNAL(inode->i_sb), bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_mark_dirty",
          "args": [
            "current->journal_info",
            "bh"
          ],
          "line": 2490
        },
        "resolved": true,
        "details": {
          "function_name": "journal_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3274-3379",
          "snippet": "int journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_prepare_for_journal",
          "args": [
            "sb",
            "bh",
            "1"
          ],
          "line": 2489
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_prepare_for_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3951-3968",
          "snippet": "int reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "sb"
          ],
          "line": 2488
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 2487
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 2486
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "bh->b_page"
          ],
          "line": 2485
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bh->b_data + offset",
            "data",
            "tocopy"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "tmp_bh.b_blocknr"
          ],
          "line": 2478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "tmp_bh.b_blocknr"
          ],
          "line": 2476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_get_block",
          "args": [
            "inode",
            "blk",
            "&tmp_bh",
            "GET_BLOCK_CREATE"
          ],
          "line": 2471
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "656-1159",
          "snippet": "int reiserfs_get_block(struct inode *inode, sector_t block,\n\t\t       struct buffer_head *bh_result, int create)\n{\n\tint repeat, retval = 0;\n\t/* b_blocknr_t is (unsigned) 32 bit int*/\n\tb_blocknr_t allocated_block_nr = 0;\n\tINITIALIZE_PATH(path);\n\tint pos_in_item;\n\tstruct cpu_key key;\n\tstruct buffer_head *bh, *unbh = NULL;\n\tstruct item_head *ih, tmp_ih;\n\t__le32 *item;\n\tint done;\n\tint fs_gen;\n\tstruct reiserfs_transaction_handle *th = NULL;\n\t/*\n\t * space reserved in transaction batch:\n\t * . 3 balancings in direct->indirect conversion\n\t * . 1 block involved into reiserfs_update_sd()\n\t * XXX in practically impossible worst case direct2indirect()\n\t * can incur (much) more than 3 balancings.\n\t * quota update for user, group\n\t */\n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 3 + 1 +\n\t    2 * REISERFS_QUOTA_TRANS_BLOCKS(inode->i_sb);\n\tint version;\n\tint dangle = 1;\n\tloff_t new_offset =\n\t    (((loff_t) block) << inode->i_sb->s_blocksize_bits) + 1;\n\n\treiserfs_write_lock(inode->i_sb);\n\tversion = get_inode_item_key_version(inode);\n\n\tif (!file_capable(inode, block)) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\treturn -EFBIG;\n\t}\n\n\t/*\n\t * if !create, we aren't changing the FS, so we don't need to\n\t * log anything, so we don't need to start a transaction\n\t */\n\tif (!(create & GET_BLOCK_CREATE)) {\n\t\tint ret;\n\t\t/* find number of block-th logical block of the file */\n\t\tret = _get_block_create_0(inode, block, bh_result,\n\t\t\t\t\t  create | GET_BLOCK_READ_DIRECT);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * if we're already in a transaction, make sure to close\n\t * any new transactions we start in this func\n\t */\n\tif ((create & GET_BLOCK_NO_DANGLE) ||\n\t    reiserfs_transaction_running(inode->i_sb))\n\t\tdangle = 0;\n\n\t/*\n\t * If file is of such a size, that it might have a tail and\n\t * tails are enabled  we should mark it as possibly needing\n\t * tail packing on close\n\t */\n\tif ((have_large_tails(inode->i_sb)\n\t     && inode->i_size < i_block_size(inode) * 4)\n\t    || (have_small_tails(inode->i_sb)\n\t\t&& inode->i_size < i_block_size(inode)))\n\t\tREISERFS_I(inode)->i_flags |= i_pack_on_close_mask;\n\n\t/* set the key of the first byte in the 'block'-th block of file */\n\tmake_cpu_key(&key, inode, new_offset, TYPE_ANY, 3 /*key length */ );\n\tif ((new_offset + inode->i_sb->s_blocksize - 1) > inode->i_size) {\nstart_trans:\n\t\tth = reiserfs_persistent_transaction(inode->i_sb, jbegin_count);\n\t\tif (!th) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto failure;\n\t\t}\n\t\treiserfs_update_inode_transaction(inode);\n\t}\nresearch:\n\n\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\tif (retval == IO_ERROR) {\n\t\tretval = -EIO;\n\t\tgoto failure;\n\t}\n\n\tbh = get_last_bh(&path);\n\tih = tp_item_head(&path);\n\titem = tp_item_body(&path);\n\tpos_in_item = path.pos_in_item;\n\n\tfs_gen = get_generation(inode->i_sb);\n\tcopy_item_head(&tmp_ih, ih);\n\n\tif (allocation_needed\n\t    (retval, allocated_block_nr, ih, item, pos_in_item)) {\n\t\t/* we have to allocate block for the unformatted node */\n\t\tif (!th) {\n\t\t\tpathrelse(&path);\n\t\t\tgoto start_trans;\n\t\t}\n\n\t\trepeat =\n\t\t    _allocate_block(th, block, inode, &allocated_block_nr,\n\t\t\t\t    &path, create);\n\n\t\t/*\n\t\t * restart the transaction to give the journal a chance to free\n\t\t * some blocks.  releases the path, so we have to go back to\n\t\t * research if we succeed on the second try\n\t\t */\n\t\tif (repeat == NO_DISK_SPACE || repeat == QUOTA_EXCEEDED) {\n\t\t\tSB_JOURNAL(inode->i_sb)->j_next_async_flush = 1;\n\t\t\tretval = restart_transaction(th, inode, &path);\n\t\t\tif (retval)\n\t\t\t\tgoto failure;\n\t\t\trepeat =\n\t\t\t    _allocate_block(th, block, inode,\n\t\t\t\t\t    &allocated_block_nr, NULL, create);\n\n\t\t\tif (repeat != NO_DISK_SPACE && repeat != QUOTA_EXCEEDED) {\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tif (repeat == QUOTA_EXCEEDED)\n\t\t\t\tretval = -EDQUOT;\n\t\t\telse\n\t\t\t\tretval = -ENOSPC;\n\t\t\tgoto failure;\n\t\t}\n\n\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\tgoto research;\n\t\t}\n\t}\n\n\tif (indirect_item_found(retval, ih)) {\n\t\tb_blocknr_t unfm_ptr;\n\t\t/*\n\t\t * 'block'-th block is in the file already (there is\n\t\t * corresponding cell in some indirect item). But it may be\n\t\t * zero unformatted node pointer (hole)\n\t\t */\n\t\tunfm_ptr = get_block_num(item, pos_in_item);\n\t\tif (unfm_ptr == 0) {\n\t\t\t/* use allocated block to plug the hole */\n\t\t\treiserfs_prepare_for_journal(inode->i_sb, bh, 1);\n\t\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\t\treiserfs_restore_prepared_buffer(inode->i_sb,\n\t\t\t\t\t\t\t\t bh);\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tset_buffer_new(bh_result);\n\t\t\tif (buffer_dirty(bh_result)\n\t\t\t    && reiserfs_data_ordered(inode->i_sb))\n\t\t\t\treiserfs_add_ordered_list(inode, bh_result);\n\t\t\tput_block_num(item, pos_in_item, allocated_block_nr);\n\t\t\tunfm_ptr = allocated_block_nr;\n\t\t\tjournal_mark_dirty(th, bh);\n\t\t\treiserfs_update_sd(th, inode);\n\t\t}\n\t\tset_block_dev_mapped(bh_result, unfm_ptr, inode);\n\t\tpathrelse(&path);\n\t\tretval = 0;\n\t\tif (!dangle && th)\n\t\t\tretval = reiserfs_end_persistent_transaction(th);\n\n\t\treiserfs_write_unlock(inode->i_sb);\n\n\t\t/*\n\t\t * the item was found, so new blocks were not added to the file\n\t\t * there is no need to make sure the inode is updated with this\n\t\t * transaction\n\t\t */\n\t\treturn retval;\n\t}\n\n\tif (!th) {\n\t\tpathrelse(&path);\n\t\tgoto start_trans;\n\t}\n\n\t/*\n\t * desired position is not found or is in the direct item. We have\n\t * to append file with holes up to 'block'-th block converting\n\t * direct items to indirect one if necessary\n\t */\n\tdone = 0;\n\tdo {\n\t\tif (is_statdata_le_ih(ih)) {\n\t\t\t__le32 unp = 0;\n\t\t\tstruct cpu_key tmp_key;\n\n\t\t\t/* indirect item has to be inserted */\n\t\t\tmake_le_item_head(&tmp_ih, &key, version, 1,\n\t\t\t\t\t  TYPE_INDIRECT, UNFM_P_SIZE,\n\t\t\t\t\t  0 /* free_space */ );\n\n\t\t\t/*\n\t\t\t * we are going to add 'block'-th block to the file.\n\t\t\t * Use allocated block for that\n\t\t\t */\n\t\t\tif (cpu_key_k_offset(&key) == 1) {\n\t\t\t\tunp = cpu_to_le32(allocated_block_nr);\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tset_buffer_new(bh_result);\n\t\t\t\tdone = 1;\n\t\t\t}\n\t\t\ttmp_key = key;\t/* ;) */\n\t\t\tset_cpu_key_k_offset(&tmp_key, 1);\n\t\t\tPATH_LAST_POSITION(&path)++;\n\n\t\t\tretval =\n\t\t\t    reiserfs_insert_item(th, &path, &tmp_key, &tmp_ih,\n\t\t\t\t\t\t inode, (char *)&unp);\n\t\t\tif (retval) {\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\t/*\n\t\t\t\t * retval == -ENOSPC, -EDQUOT or -EIO\n\t\t\t\t * or -EEXIST\n\t\t\t\t */\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t} else if (is_direct_le_ih(ih)) {\n\t\t\t/* direct item has to be converted */\n\t\t\tloff_t tail_offset;\n\n\t\t\ttail_offset =\n\t\t\t    ((le_ih_k_offset(ih) -\n\t\t\t      1) & ~(inode->i_sb->s_blocksize - 1)) + 1;\n\n\t\t\t/*\n\t\t\t * direct item we just found fits into block we have\n\t\t\t * to map. Convert it into unformatted node: use\n\t\t\t * bh_result for the conversion\n\t\t\t */\n\t\t\tif (tail_offset == cpu_key_k_offset(&key)) {\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tunbh = bh_result;\n\t\t\t\tdone = 1;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * we have to pad file tail stored in direct\n\t\t\t\t * item(s) up to block size and convert it\n\t\t\t\t * to unformatted node. FIXME: this should\n\t\t\t\t * also get into page cache\n\t\t\t\t */\n\n\t\t\t\tpathrelse(&path);\n\t\t\t\t/*\n\t\t\t\t * ugly, but we can only end the transaction if\n\t\t\t\t * we aren't nested\n\t\t\t\t */\n\t\t\t\tBUG_ON(!th->t_refcount);\n\t\t\t\tif (th->t_refcount == 1) {\n\t\t\t\t\tretval =\n\t\t\t\t\t    reiserfs_end_persistent_transaction\n\t\t\t\t\t    (th);\n\t\t\t\t\tth = NULL;\n\t\t\t\t\tif (retval)\n\t\t\t\t\t\tgoto failure;\n\t\t\t\t}\n\n\t\t\t\tretval =\n\t\t\t\t    convert_tail_for_hole(inode, bh_result,\n\t\t\t\t\t\t\t  tail_offset);\n\t\t\t\tif (retval) {\n\t\t\t\t\tif (retval != -ENOSPC)\n\t\t\t\t\t\treiserfs_error(inode->i_sb,\n\t\t\t\t\t\t\t\"clm-6004\",\n\t\t\t\t\t\t\t\"convert tail failed \"\n\t\t\t\t\t\t\t\"inode %lu, error %d\",\n\t\t\t\t\t\t\tinode->i_ino,\n\t\t\t\t\t\t\tretval);\n\t\t\t\t\tif (allocated_block_nr) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * the bitmap, the super,\n\t\t\t\t\t\t * and the stat data == 3\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (!th)\n\t\t\t\t\t\t\tth = reiserfs_persistent_transaction(inode->i_sb, 3);\n\t\t\t\t\t\tif (th)\n\t\t\t\t\t\t\treiserfs_free_block(th,\n\t\t\t\t\t\t\t\t\t    inode,\n\t\t\t\t\t\t\t\t\t    allocated_block_nr,\n\t\t\t\t\t\t\t\t\t    1);\n\t\t\t\t\t}\n\t\t\t\t\tgoto failure;\n\t\t\t\t}\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tretval =\n\t\t\t    direct2indirect(th, inode, &path, unbh,\n\t\t\t\t\t    tail_offset);\n\t\t\tif (retval) {\n\t\t\t\treiserfs_unmap_buffer(unbh);\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\t/*\n\t\t\t * it is important the set_buffer_uptodate is done\n\t\t\t * after the direct2indirect.  The buffer might\n\t\t\t * contain valid data newer than the data on disk\n\t\t\t * (read by readpage, changed, and then sent here by\n\t\t\t * writepage).  direct2indirect needs to know if unbh\n\t\t\t * was already up to date, so it can decide if the\n\t\t\t * data in unbh needs to be replaced with data from\n\t\t\t * the disk\n\t\t\t */\n\t\t\tset_buffer_uptodate(unbh);\n\n\t\t\t/*\n\t\t\t * unbh->b_page == NULL in case of DIRECT_IO request,\n\t\t\t * this means buffer will disappear shortly, so it\n\t\t\t * should not be added to\n\t\t\t */\n\t\t\tif (unbh->b_page) {\n\t\t\t\t/*\n\t\t\t\t * we've converted the tail, so we must\n\t\t\t\t * flush unbh before the transaction commits\n\t\t\t\t */\n\t\t\t\treiserfs_add_tail_list(inode, unbh);\n\n\t\t\t\t/*\n\t\t\t\t * mark it dirty now to prevent commit_write\n\t\t\t\t * from adding this buffer to the inode's\n\t\t\t\t * dirty buffer list\n\t\t\t\t */\n\t\t\t\t/*\n\t\t\t\t * AKPM: changed __mark_buffer_dirty to\n\t\t\t\t * mark_buffer_dirty().  It's still atomic,\n\t\t\t\t * but it sets the page dirty too, which makes\n\t\t\t\t * it eligible for writeback at any time by the\n\t\t\t\t * VM (which was also the case with\n\t\t\t\t * __mark_buffer_dirty())\n\t\t\t\t */\n\t\t\t\tmark_buffer_dirty(unbh);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * append indirect item with holes if needed, when\n\t\t\t * appending pointer to 'block'-th block use block,\n\t\t\t * which is already allocated\n\t\t\t */\n\t\t\tstruct cpu_key tmp_key;\n\t\t\t/*\n\t\t\t * We use this in case we need to allocate\n\t\t\t * only one block which is a fastpath\n\t\t\t */\n\t\t\tunp_t unf_single = 0;\n\t\t\tunp_t *un;\n\t\t\t__u64 max_to_insert =\n\t\t\t    MAX_ITEM_LEN(inode->i_sb->s_blocksize) /\n\t\t\t    UNFM_P_SIZE;\n\t\t\t__u64 blocks_needed;\n\n\t\t\tRFALSE(pos_in_item != ih_item_len(ih) / UNFM_P_SIZE,\n\t\t\t       \"vs-804: invalid position for append\");\n\t\t\t/*\n\t\t\t * indirect item has to be appended,\n\t\t\t * set up key of that position\n\t\t\t * (key type is unimportant)\n\t\t\t */\n\t\t\tmake_cpu_key(&tmp_key, inode,\n\t\t\t\t     le_key_k_offset(version,\n\t\t\t\t\t\t     &ih->ih_key) +\n\t\t\t\t     op_bytes_number(ih,\n\t\t\t\t\t\t     inode->i_sb->s_blocksize),\n\t\t\t\t     TYPE_INDIRECT, 3);\n\n\t\t\tRFALSE(cpu_key_k_offset(&tmp_key) > cpu_key_k_offset(&key),\n\t\t\t       \"green-805: invalid offset\");\n\t\t\tblocks_needed =\n\t\t\t    1 +\n\t\t\t    ((cpu_key_k_offset(&key) -\n\t\t\t      cpu_key_k_offset(&tmp_key)) >> inode->i_sb->\n\t\t\t     s_blocksize_bits);\n\n\t\t\tif (blocks_needed == 1) {\n\t\t\t\tun = &unf_single;\n\t\t\t} else {\n\t\t\t\tun = kzalloc(min(blocks_needed, max_to_insert) * UNFM_P_SIZE, GFP_NOFS);\n\t\t\t\tif (!un) {\n\t\t\t\t\tun = &unf_single;\n\t\t\t\t\tblocks_needed = 1;\n\t\t\t\t\tmax_to_insert = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (blocks_needed <= max_to_insert) {\n\t\t\t\t/*\n\t\t\t\t * we are going to add target block to\n\t\t\t\t * the file. Use allocated block for that\n\t\t\t\t */\n\t\t\t\tun[blocks_needed - 1] =\n\t\t\t\t    cpu_to_le32(allocated_block_nr);\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tset_buffer_new(bh_result);\n\t\t\t\tdone = 1;\n\t\t\t} else {\n\t\t\t\t/* paste hole to the indirect item */\n\t\t\t\t/*\n\t\t\t\t * If kmalloc failed, max_to_insert becomes\n\t\t\t\t * zero and it means we only have space for\n\t\t\t\t * one block\n\t\t\t\t */\n\t\t\t\tblocks_needed =\n\t\t\t\t    max_to_insert ? max_to_insert : 1;\n\t\t\t}\n\t\t\tretval =\n\t\t\t    reiserfs_paste_into_item(th, &path, &tmp_key, inode,\n\t\t\t\t\t\t     (char *)un,\n\t\t\t\t\t\t     UNFM_P_SIZE *\n\t\t\t\t\t\t     blocks_needed);\n\n\t\t\tif (blocks_needed != 1)\n\t\t\t\tkfree(un);\n\n\t\t\tif (retval) {\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\tif (!done) {\n\t\t\t\t/*\n\t\t\t\t * We need to mark new file size in case\n\t\t\t\t * this function will be interrupted/aborted\n\t\t\t\t * later on. And we may do this only for\n\t\t\t\t * holes.\n\t\t\t\t */\n\t\t\t\tinode->i_size +=\n\t\t\t\t    inode->i_sb->s_blocksize * blocks_needed;\n\t\t\t}\n\t\t}\n\n\t\tif (done == 1)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * this loop could log more blocks than we had originally\n\t\t * asked for.  So, we have to allow the transaction to end\n\t\t * if it is too big or too full.  Update the inode so things\n\t\t * are consistent if we crash before the function returns\n\t\t * release the path so that anybody waiting on the path before\n\t\t * ending their transaction will be able to continue.\n\t\t */\n\t\tif (journal_transaction_should_end(th, th->t_blocks_allocated)) {\n\t\t\tretval = restart_transaction(th, inode, &path);\n\t\t\tif (retval)\n\t\t\t\tgoto failure;\n\t\t}\n\t\t/*\n\t\t * inserting indirect pointers for a hole can take a\n\t\t * long time.  reschedule if needed and also release the write\n\t\t * lock for others.\n\t\t */\n\t\treiserfs_cond_resched(inode->i_sb);\n\n\t\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\t\tif (retval == IO_ERROR) {\n\t\t\tretval = -EIO;\n\t\t\tgoto failure;\n\t\t}\n\t\tif (retval == POSITION_FOUND) {\n\t\t\treiserfs_warning(inode->i_sb, \"vs-825\",\n\t\t\t\t\t \"%K should not be found\", &key);\n\t\t\tretval = -EEXIST;\n\t\t\tif (allocated_block_nr)\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\tpathrelse(&path);\n\t\t\tgoto failure;\n\t\t}\n\t\tbh = get_last_bh(&path);\n\t\tih = tp_item_head(&path);\n\t\titem = tp_item_body(&path);\n\t\tpos_in_item = path.pos_in_item;\n\t} while (1);\n\n\tretval = 0;\n\nfailure:\n\tif (th && (!dangle || (retval && !th->t_trans_id))) {\n\t\tint err;\n\t\tif (th->t_trans_id)\n\t\t\treiserfs_update_sd(th, inode);\n\t\terr = reiserfs_end_persistent_transaction(th);\n\t\tif (err)\n\t\t\tretval = err;\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\treiserfs_check_path(&path);\n\treturn retval;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint reiserfs_get_block(struct inode *inode, sector_t block,\n\t\t       struct buffer_head *bh_result, int create)\n{\n\tint repeat, retval = 0;\n\t/* b_blocknr_t is (unsigned) 32 bit int*/\n\tb_blocknr_t allocated_block_nr = 0;\n\tINITIALIZE_PATH(path);\n\tint pos_in_item;\n\tstruct cpu_key key;\n\tstruct buffer_head *bh, *unbh = NULL;\n\tstruct item_head *ih, tmp_ih;\n\t__le32 *item;\n\tint done;\n\tint fs_gen;\n\tstruct reiserfs_transaction_handle *th = NULL;\n\t/*\n\t * space reserved in transaction batch:\n\t * . 3 balancings in direct->indirect conversion\n\t * . 1 block involved into reiserfs_update_sd()\n\t * XXX in practically impossible worst case direct2indirect()\n\t * can incur (much) more than 3 balancings.\n\t * quota update for user, group\n\t */\n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 3 + 1 +\n\t    2 * REISERFS_QUOTA_TRANS_BLOCKS(inode->i_sb);\n\tint version;\n\tint dangle = 1;\n\tloff_t new_offset =\n\t    (((loff_t) block) << inode->i_sb->s_blocksize_bits) + 1;\n\n\treiserfs_write_lock(inode->i_sb);\n\tversion = get_inode_item_key_version(inode);\n\n\tif (!file_capable(inode, block)) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\treturn -EFBIG;\n\t}\n\n\t/*\n\t * if !create, we aren't changing the FS, so we don't need to\n\t * log anything, so we don't need to start a transaction\n\t */\n\tif (!(create & GET_BLOCK_CREATE)) {\n\t\tint ret;\n\t\t/* find number of block-th logical block of the file */\n\t\tret = _get_block_create_0(inode, block, bh_result,\n\t\t\t\t\t  create | GET_BLOCK_READ_DIRECT);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * if we're already in a transaction, make sure to close\n\t * any new transactions we start in this func\n\t */\n\tif ((create & GET_BLOCK_NO_DANGLE) ||\n\t    reiserfs_transaction_running(inode->i_sb))\n\t\tdangle = 0;\n\n\t/*\n\t * If file is of such a size, that it might have a tail and\n\t * tails are enabled  we should mark it as possibly needing\n\t * tail packing on close\n\t */\n\tif ((have_large_tails(inode->i_sb)\n\t     && inode->i_size < i_block_size(inode) * 4)\n\t    || (have_small_tails(inode->i_sb)\n\t\t&& inode->i_size < i_block_size(inode)))\n\t\tREISERFS_I(inode)->i_flags |= i_pack_on_close_mask;\n\n\t/* set the key of the first byte in the 'block'-th block of file */\n\tmake_cpu_key(&key, inode, new_offset, TYPE_ANY, 3 /*key length */ );\n\tif ((new_offset + inode->i_sb->s_blocksize - 1) > inode->i_size) {\nstart_trans:\n\t\tth = reiserfs_persistent_transaction(inode->i_sb, jbegin_count);\n\t\tif (!th) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto failure;\n\t\t}\n\t\treiserfs_update_inode_transaction(inode);\n\t}\nresearch:\n\n\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\tif (retval == IO_ERROR) {\n\t\tretval = -EIO;\n\t\tgoto failure;\n\t}\n\n\tbh = get_last_bh(&path);\n\tih = tp_item_head(&path);\n\titem = tp_item_body(&path);\n\tpos_in_item = path.pos_in_item;\n\n\tfs_gen = get_generation(inode->i_sb);\n\tcopy_item_head(&tmp_ih, ih);\n\n\tif (allocation_needed\n\t    (retval, allocated_block_nr, ih, item, pos_in_item)) {\n\t\t/* we have to allocate block for the unformatted node */\n\t\tif (!th) {\n\t\t\tpathrelse(&path);\n\t\t\tgoto start_trans;\n\t\t}\n\n\t\trepeat =\n\t\t    _allocate_block(th, block, inode, &allocated_block_nr,\n\t\t\t\t    &path, create);\n\n\t\t/*\n\t\t * restart the transaction to give the journal a chance to free\n\t\t * some blocks.  releases the path, so we have to go back to\n\t\t * research if we succeed on the second try\n\t\t */\n\t\tif (repeat == NO_DISK_SPACE || repeat == QUOTA_EXCEEDED) {\n\t\t\tSB_JOURNAL(inode->i_sb)->j_next_async_flush = 1;\n\t\t\tretval = restart_transaction(th, inode, &path);\n\t\t\tif (retval)\n\t\t\t\tgoto failure;\n\t\t\trepeat =\n\t\t\t    _allocate_block(th, block, inode,\n\t\t\t\t\t    &allocated_block_nr, NULL, create);\n\n\t\t\tif (repeat != NO_DISK_SPACE && repeat != QUOTA_EXCEEDED) {\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tif (repeat == QUOTA_EXCEEDED)\n\t\t\t\tretval = -EDQUOT;\n\t\t\telse\n\t\t\t\tretval = -ENOSPC;\n\t\t\tgoto failure;\n\t\t}\n\n\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\tgoto research;\n\t\t}\n\t}\n\n\tif (indirect_item_found(retval, ih)) {\n\t\tb_blocknr_t unfm_ptr;\n\t\t/*\n\t\t * 'block'-th block is in the file already (there is\n\t\t * corresponding cell in some indirect item). But it may be\n\t\t * zero unformatted node pointer (hole)\n\t\t */\n\t\tunfm_ptr = get_block_num(item, pos_in_item);\n\t\tif (unfm_ptr == 0) {\n\t\t\t/* use allocated block to plug the hole */\n\t\t\treiserfs_prepare_for_journal(inode->i_sb, bh, 1);\n\t\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\t\treiserfs_restore_prepared_buffer(inode->i_sb,\n\t\t\t\t\t\t\t\t bh);\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tset_buffer_new(bh_result);\n\t\t\tif (buffer_dirty(bh_result)\n\t\t\t    && reiserfs_data_ordered(inode->i_sb))\n\t\t\t\treiserfs_add_ordered_list(inode, bh_result);\n\t\t\tput_block_num(item, pos_in_item, allocated_block_nr);\n\t\t\tunfm_ptr = allocated_block_nr;\n\t\t\tjournal_mark_dirty(th, bh);\n\t\t\treiserfs_update_sd(th, inode);\n\t\t}\n\t\tset_block_dev_mapped(bh_result, unfm_ptr, inode);\n\t\tpathrelse(&path);\n\t\tretval = 0;\n\t\tif (!dangle && th)\n\t\t\tretval = reiserfs_end_persistent_transaction(th);\n\n\t\treiserfs_write_unlock(inode->i_sb);\n\n\t\t/*\n\t\t * the item was found, so new blocks were not added to the file\n\t\t * there is no need to make sure the inode is updated with this\n\t\t * transaction\n\t\t */\n\t\treturn retval;\n\t}\n\n\tif (!th) {\n\t\tpathrelse(&path);\n\t\tgoto start_trans;\n\t}\n\n\t/*\n\t * desired position is not found or is in the direct item. We have\n\t * to append file with holes up to 'block'-th block converting\n\t * direct items to indirect one if necessary\n\t */\n\tdone = 0;\n\tdo {\n\t\tif (is_statdata_le_ih(ih)) {\n\t\t\t__le32 unp = 0;\n\t\t\tstruct cpu_key tmp_key;\n\n\t\t\t/* indirect item has to be inserted */\n\t\t\tmake_le_item_head(&tmp_ih, &key, version, 1,\n\t\t\t\t\t  TYPE_INDIRECT, UNFM_P_SIZE,\n\t\t\t\t\t  0 /* free_space */ );\n\n\t\t\t/*\n\t\t\t * we are going to add 'block'-th block to the file.\n\t\t\t * Use allocated block for that\n\t\t\t */\n\t\t\tif (cpu_key_k_offset(&key) == 1) {\n\t\t\t\tunp = cpu_to_le32(allocated_block_nr);\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tset_buffer_new(bh_result);\n\t\t\t\tdone = 1;\n\t\t\t}\n\t\t\ttmp_key = key;\t/* ;) */\n\t\t\tset_cpu_key_k_offset(&tmp_key, 1);\n\t\t\tPATH_LAST_POSITION(&path)++;\n\n\t\t\tretval =\n\t\t\t    reiserfs_insert_item(th, &path, &tmp_key, &tmp_ih,\n\t\t\t\t\t\t inode, (char *)&unp);\n\t\t\tif (retval) {\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\t/*\n\t\t\t\t * retval == -ENOSPC, -EDQUOT or -EIO\n\t\t\t\t * or -EEXIST\n\t\t\t\t */\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t} else if (is_direct_le_ih(ih)) {\n\t\t\t/* direct item has to be converted */\n\t\t\tloff_t tail_offset;\n\n\t\t\ttail_offset =\n\t\t\t    ((le_ih_k_offset(ih) -\n\t\t\t      1) & ~(inode->i_sb->s_blocksize - 1)) + 1;\n\n\t\t\t/*\n\t\t\t * direct item we just found fits into block we have\n\t\t\t * to map. Convert it into unformatted node: use\n\t\t\t * bh_result for the conversion\n\t\t\t */\n\t\t\tif (tail_offset == cpu_key_k_offset(&key)) {\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tunbh = bh_result;\n\t\t\t\tdone = 1;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * we have to pad file tail stored in direct\n\t\t\t\t * item(s) up to block size and convert it\n\t\t\t\t * to unformatted node. FIXME: this should\n\t\t\t\t * also get into page cache\n\t\t\t\t */\n\n\t\t\t\tpathrelse(&path);\n\t\t\t\t/*\n\t\t\t\t * ugly, but we can only end the transaction if\n\t\t\t\t * we aren't nested\n\t\t\t\t */\n\t\t\t\tBUG_ON(!th->t_refcount);\n\t\t\t\tif (th->t_refcount == 1) {\n\t\t\t\t\tretval =\n\t\t\t\t\t    reiserfs_end_persistent_transaction\n\t\t\t\t\t    (th);\n\t\t\t\t\tth = NULL;\n\t\t\t\t\tif (retval)\n\t\t\t\t\t\tgoto failure;\n\t\t\t\t}\n\n\t\t\t\tretval =\n\t\t\t\t    convert_tail_for_hole(inode, bh_result,\n\t\t\t\t\t\t\t  tail_offset);\n\t\t\t\tif (retval) {\n\t\t\t\t\tif (retval != -ENOSPC)\n\t\t\t\t\t\treiserfs_error(inode->i_sb,\n\t\t\t\t\t\t\t\"clm-6004\",\n\t\t\t\t\t\t\t\"convert tail failed \"\n\t\t\t\t\t\t\t\"inode %lu, error %d\",\n\t\t\t\t\t\t\tinode->i_ino,\n\t\t\t\t\t\t\tretval);\n\t\t\t\t\tif (allocated_block_nr) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * the bitmap, the super,\n\t\t\t\t\t\t * and the stat data == 3\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (!th)\n\t\t\t\t\t\t\tth = reiserfs_persistent_transaction(inode->i_sb, 3);\n\t\t\t\t\t\tif (th)\n\t\t\t\t\t\t\treiserfs_free_block(th,\n\t\t\t\t\t\t\t\t\t    inode,\n\t\t\t\t\t\t\t\t\t    allocated_block_nr,\n\t\t\t\t\t\t\t\t\t    1);\n\t\t\t\t\t}\n\t\t\t\t\tgoto failure;\n\t\t\t\t}\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tretval =\n\t\t\t    direct2indirect(th, inode, &path, unbh,\n\t\t\t\t\t    tail_offset);\n\t\t\tif (retval) {\n\t\t\t\treiserfs_unmap_buffer(unbh);\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\t/*\n\t\t\t * it is important the set_buffer_uptodate is done\n\t\t\t * after the direct2indirect.  The buffer might\n\t\t\t * contain valid data newer than the data on disk\n\t\t\t * (read by readpage, changed, and then sent here by\n\t\t\t * writepage).  direct2indirect needs to know if unbh\n\t\t\t * was already up to date, so it can decide if the\n\t\t\t * data in unbh needs to be replaced with data from\n\t\t\t * the disk\n\t\t\t */\n\t\t\tset_buffer_uptodate(unbh);\n\n\t\t\t/*\n\t\t\t * unbh->b_page == NULL in case of DIRECT_IO request,\n\t\t\t * this means buffer will disappear shortly, so it\n\t\t\t * should not be added to\n\t\t\t */\n\t\t\tif (unbh->b_page) {\n\t\t\t\t/*\n\t\t\t\t * we've converted the tail, so we must\n\t\t\t\t * flush unbh before the transaction commits\n\t\t\t\t */\n\t\t\t\treiserfs_add_tail_list(inode, unbh);\n\n\t\t\t\t/*\n\t\t\t\t * mark it dirty now to prevent commit_write\n\t\t\t\t * from adding this buffer to the inode's\n\t\t\t\t * dirty buffer list\n\t\t\t\t */\n\t\t\t\t/*\n\t\t\t\t * AKPM: changed __mark_buffer_dirty to\n\t\t\t\t * mark_buffer_dirty().  It's still atomic,\n\t\t\t\t * but it sets the page dirty too, which makes\n\t\t\t\t * it eligible for writeback at any time by the\n\t\t\t\t * VM (which was also the case with\n\t\t\t\t * __mark_buffer_dirty())\n\t\t\t\t */\n\t\t\t\tmark_buffer_dirty(unbh);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * append indirect item with holes if needed, when\n\t\t\t * appending pointer to 'block'-th block use block,\n\t\t\t * which is already allocated\n\t\t\t */\n\t\t\tstruct cpu_key tmp_key;\n\t\t\t/*\n\t\t\t * We use this in case we need to allocate\n\t\t\t * only one block which is a fastpath\n\t\t\t */\n\t\t\tunp_t unf_single = 0;\n\t\t\tunp_t *un;\n\t\t\t__u64 max_to_insert =\n\t\t\t    MAX_ITEM_LEN(inode->i_sb->s_blocksize) /\n\t\t\t    UNFM_P_SIZE;\n\t\t\t__u64 blocks_needed;\n\n\t\t\tRFALSE(pos_in_item != ih_item_len(ih) / UNFM_P_SIZE,\n\t\t\t       \"vs-804: invalid position for append\");\n\t\t\t/*\n\t\t\t * indirect item has to be appended,\n\t\t\t * set up key of that position\n\t\t\t * (key type is unimportant)\n\t\t\t */\n\t\t\tmake_cpu_key(&tmp_key, inode,\n\t\t\t\t     le_key_k_offset(version,\n\t\t\t\t\t\t     &ih->ih_key) +\n\t\t\t\t     op_bytes_number(ih,\n\t\t\t\t\t\t     inode->i_sb->s_blocksize),\n\t\t\t\t     TYPE_INDIRECT, 3);\n\n\t\t\tRFALSE(cpu_key_k_offset(&tmp_key) > cpu_key_k_offset(&key),\n\t\t\t       \"green-805: invalid offset\");\n\t\t\tblocks_needed =\n\t\t\t    1 +\n\t\t\t    ((cpu_key_k_offset(&key) -\n\t\t\t      cpu_key_k_offset(&tmp_key)) >> inode->i_sb->\n\t\t\t     s_blocksize_bits);\n\n\t\t\tif (blocks_needed == 1) {\n\t\t\t\tun = &unf_single;\n\t\t\t} else {\n\t\t\t\tun = kzalloc(min(blocks_needed, max_to_insert) * UNFM_P_SIZE, GFP_NOFS);\n\t\t\t\tif (!un) {\n\t\t\t\t\tun = &unf_single;\n\t\t\t\t\tblocks_needed = 1;\n\t\t\t\t\tmax_to_insert = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (blocks_needed <= max_to_insert) {\n\t\t\t\t/*\n\t\t\t\t * we are going to add target block to\n\t\t\t\t * the file. Use allocated block for that\n\t\t\t\t */\n\t\t\t\tun[blocks_needed - 1] =\n\t\t\t\t    cpu_to_le32(allocated_block_nr);\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tset_buffer_new(bh_result);\n\t\t\t\tdone = 1;\n\t\t\t} else {\n\t\t\t\t/* paste hole to the indirect item */\n\t\t\t\t/*\n\t\t\t\t * If kmalloc failed, max_to_insert becomes\n\t\t\t\t * zero and it means we only have space for\n\t\t\t\t * one block\n\t\t\t\t */\n\t\t\t\tblocks_needed =\n\t\t\t\t    max_to_insert ? max_to_insert : 1;\n\t\t\t}\n\t\t\tretval =\n\t\t\t    reiserfs_paste_into_item(th, &path, &tmp_key, inode,\n\t\t\t\t\t\t     (char *)un,\n\t\t\t\t\t\t     UNFM_P_SIZE *\n\t\t\t\t\t\t     blocks_needed);\n\n\t\t\tif (blocks_needed != 1)\n\t\t\t\tkfree(un);\n\n\t\t\tif (retval) {\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\tif (!done) {\n\t\t\t\t/*\n\t\t\t\t * We need to mark new file size in case\n\t\t\t\t * this function will be interrupted/aborted\n\t\t\t\t * later on. And we may do this only for\n\t\t\t\t * holes.\n\t\t\t\t */\n\t\t\t\tinode->i_size +=\n\t\t\t\t    inode->i_sb->s_blocksize * blocks_needed;\n\t\t\t}\n\t\t}\n\n\t\tif (done == 1)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * this loop could log more blocks than we had originally\n\t\t * asked for.  So, we have to allow the transaction to end\n\t\t * if it is too big or too full.  Update the inode so things\n\t\t * are consistent if we crash before the function returns\n\t\t * release the path so that anybody waiting on the path before\n\t\t * ending their transaction will be able to continue.\n\t\t */\n\t\tif (journal_transaction_should_end(th, th->t_blocks_allocated)) {\n\t\t\tretval = restart_transaction(th, inode, &path);\n\t\t\tif (retval)\n\t\t\t\tgoto failure;\n\t\t}\n\t\t/*\n\t\t * inserting indirect pointers for a hole can take a\n\t\t * long time.  reschedule if needed and also release the write\n\t\t * lock for others.\n\t\t */\n\t\treiserfs_cond_resched(inode->i_sb);\n\n\t\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\t\tif (retval == IO_ERROR) {\n\t\t\tretval = -EIO;\n\t\t\tgoto failure;\n\t\t}\n\t\tif (retval == POSITION_FOUND) {\n\t\t\treiserfs_warning(inode->i_sb, \"vs-825\",\n\t\t\t\t\t \"%K should not be found\", &key);\n\t\t\tretval = -EEXIST;\n\t\t\tif (allocated_block_nr)\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\tpathrelse(&path);\n\t\t\tgoto failure;\n\t\t}\n\t\tbh = get_last_bh(&path);\n\t\tih = tp_item_head(&path);\n\t\titem = tp_item_body(&path);\n\t\tpos_in_item = path.pos_in_item;\n\t} while (1);\n\n\tretval = 0;\n\nfailure:\n\tif (th && (!dangle || (retval && !th->t_trans_id))) {\n\t\tint err;\n\t\tif (th->t_trans_id)\n\t\t\treiserfs_update_sd(th, inode);\n\t\terr = reiserfs_end_persistent_transaction(th);\n\t\tif (err)\n\t\t\tretval = err;\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\treiserfs_check_path(&path);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"reiserfs: Quota write (off=%llu, len=%llu) cancelled because transaction is not started.\\n\"",
            "(unsigned long long)off",
            "(unsigned long long)len"
          ],
          "line": 2462
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "sb"
          ],
          "line": 2457
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 2454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int reiserfs_remount(struct super_block *s, int *flags, char *data);\n\nstatic ssize_t reiserfs_quota_write(struct super_block *sb, int type,\n\t\t\t\t    const char *data, size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tunsigned long blk = off >> sb->s_blocksize_bits;\n\tint err = 0, offset = off & (sb->s_blocksize - 1), tocopy;\n\tint journal_quota = REISERFS_SB(sb)->s_qf_names[type] != NULL;\n\tsize_t towrite = len;\n\tstruct buffer_head tmp_bh, *bh;\n\n\tif (!current->journal_info) {\n\t\tprintk(KERN_WARNING \"reiserfs: Quota write (off=%llu, len=%llu) cancelled because transaction is not started.\\n\",\n\t\t\t(unsigned long long)off, (unsigned long long)len);\n\t\treturn -EIO;\n\t}\n\twhile (towrite > 0) {\n\t\ttocopy = sb->s_blocksize - offset < towrite ?\n\t\t    sb->s_blocksize - offset : towrite;\n\t\ttmp_bh.b_state = 0;\n\t\treiserfs_write_lock(sb);\n\t\terr = reiserfs_get_block(inode, blk, &tmp_bh, GET_BLOCK_CREATE);\n\t\treiserfs_write_unlock(sb);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (offset || tocopy != sb->s_blocksize)\n\t\t\tbh = sb_bread(sb, tmp_bh.b_blocknr);\n\t\telse\n\t\t\tbh = sb_getblk(sb, tmp_bh.b_blocknr);\n\t\tif (!bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tmemcpy(bh->b_data + offset, data, tocopy);\n\t\tflush_dcache_page(bh->b_page);\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\treiserfs_write_lock(sb);\n\t\treiserfs_prepare_for_journal(sb, bh, 1);\n\t\tjournal_mark_dirty(current->journal_info, bh);\n\t\tif (!journal_quota)\n\t\t\treiserfs_add_ordered_list(inode, bh);\n\t\treiserfs_write_unlock(sb);\n\t\tbrelse(bh);\n\t\toffset = 0;\n\t\ttowrite -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\nout:\n\tif (len == towrite)\n\t\treturn err;\n\tif (inode->i_size < off + len - towrite)\n\t\ti_size_write(inode, off + len - towrite);\n\tinode->i_version++;\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(inode);\n\treturn len - towrite;\n}"
  },
  {
    "function_name": "reiserfs_quota_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "2401-2445",
    "snippet": "static ssize_t reiserfs_quota_read(struct super_block *sb, int type, char *data,\n\t\t\t\t   size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tunsigned long blk = off >> sb->s_blocksize_bits;\n\tint err = 0, offset = off & (sb->s_blocksize - 1), tocopy;\n\tsize_t toread;\n\tstruct buffer_head tmp_bh, *bh;\n\tloff_t i_size = i_size_read(inode);\n\n\tif (off > i_size)\n\t\treturn 0;\n\tif (off + len > i_size)\n\t\tlen = i_size - off;\n\ttoread = len;\n\twhile (toread > 0) {\n\t\ttocopy =\n\t\t    sb->s_blocksize - offset <\n\t\t    toread ? sb->s_blocksize - offset : toread;\n\t\ttmp_bh.b_state = 0;\n\t\t/*\n\t\t * Quota files are without tails so we can safely\n\t\t * use this function\n\t\t */\n\t\treiserfs_write_lock(sb);\n\t\terr = reiserfs_get_block(inode, blk, &tmp_bh, 0);\n\t\treiserfs_write_unlock(sb);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!buffer_mapped(&tmp_bh))\t/* A hole? */\n\t\t\tmemset(data, 0, tocopy);\n\t\telse {\n\t\t\tbh = sb_bread(sb, tmp_bh.b_blocknr);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t\tmemcpy(data, bh->b_data + offset, tocopy);\n\t\t\tbrelse(bh);\n\t\t}\n\t\toffset = 0;\n\t\ttoread -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\n\treturn len;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int reiserfs_remount(struct super_block *s, int *flags, char *data);",
      "static const arg_desc_t tails[] = {\n\t{\"on\", 1 << REISERFS_LARGETAIL, 1 << REISERFS_SMALLTAIL},\n\t{\"off\", 0, (1 << REISERFS_LARGETAIL) | (1 << REISERFS_SMALLTAIL)},\n\t{\"small\", 1 << REISERFS_SMALLTAIL, 1 << REISERFS_LARGETAIL},\n\t{NULL, 0, 0}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 2437
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "bh->b_data + offset",
            "tocopy"
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "tmp_bh.b_blocknr"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data",
            "0",
            "tocopy"
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "&tmp_bh"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "sb"
          ],
          "line": 2427
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_get_block",
          "args": [
            "inode",
            "blk",
            "&tmp_bh",
            "0"
          ],
          "line": 2426
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "656-1159",
          "snippet": "int reiserfs_get_block(struct inode *inode, sector_t block,\n\t\t       struct buffer_head *bh_result, int create)\n{\n\tint repeat, retval = 0;\n\t/* b_blocknr_t is (unsigned) 32 bit int*/\n\tb_blocknr_t allocated_block_nr = 0;\n\tINITIALIZE_PATH(path);\n\tint pos_in_item;\n\tstruct cpu_key key;\n\tstruct buffer_head *bh, *unbh = NULL;\n\tstruct item_head *ih, tmp_ih;\n\t__le32 *item;\n\tint done;\n\tint fs_gen;\n\tstruct reiserfs_transaction_handle *th = NULL;\n\t/*\n\t * space reserved in transaction batch:\n\t * . 3 balancings in direct->indirect conversion\n\t * . 1 block involved into reiserfs_update_sd()\n\t * XXX in practically impossible worst case direct2indirect()\n\t * can incur (much) more than 3 balancings.\n\t * quota update for user, group\n\t */\n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 3 + 1 +\n\t    2 * REISERFS_QUOTA_TRANS_BLOCKS(inode->i_sb);\n\tint version;\n\tint dangle = 1;\n\tloff_t new_offset =\n\t    (((loff_t) block) << inode->i_sb->s_blocksize_bits) + 1;\n\n\treiserfs_write_lock(inode->i_sb);\n\tversion = get_inode_item_key_version(inode);\n\n\tif (!file_capable(inode, block)) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\treturn -EFBIG;\n\t}\n\n\t/*\n\t * if !create, we aren't changing the FS, so we don't need to\n\t * log anything, so we don't need to start a transaction\n\t */\n\tif (!(create & GET_BLOCK_CREATE)) {\n\t\tint ret;\n\t\t/* find number of block-th logical block of the file */\n\t\tret = _get_block_create_0(inode, block, bh_result,\n\t\t\t\t\t  create | GET_BLOCK_READ_DIRECT);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * if we're already in a transaction, make sure to close\n\t * any new transactions we start in this func\n\t */\n\tif ((create & GET_BLOCK_NO_DANGLE) ||\n\t    reiserfs_transaction_running(inode->i_sb))\n\t\tdangle = 0;\n\n\t/*\n\t * If file is of such a size, that it might have a tail and\n\t * tails are enabled  we should mark it as possibly needing\n\t * tail packing on close\n\t */\n\tif ((have_large_tails(inode->i_sb)\n\t     && inode->i_size < i_block_size(inode) * 4)\n\t    || (have_small_tails(inode->i_sb)\n\t\t&& inode->i_size < i_block_size(inode)))\n\t\tREISERFS_I(inode)->i_flags |= i_pack_on_close_mask;\n\n\t/* set the key of the first byte in the 'block'-th block of file */\n\tmake_cpu_key(&key, inode, new_offset, TYPE_ANY, 3 /*key length */ );\n\tif ((new_offset + inode->i_sb->s_blocksize - 1) > inode->i_size) {\nstart_trans:\n\t\tth = reiserfs_persistent_transaction(inode->i_sb, jbegin_count);\n\t\tif (!th) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto failure;\n\t\t}\n\t\treiserfs_update_inode_transaction(inode);\n\t}\nresearch:\n\n\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\tif (retval == IO_ERROR) {\n\t\tretval = -EIO;\n\t\tgoto failure;\n\t}\n\n\tbh = get_last_bh(&path);\n\tih = tp_item_head(&path);\n\titem = tp_item_body(&path);\n\tpos_in_item = path.pos_in_item;\n\n\tfs_gen = get_generation(inode->i_sb);\n\tcopy_item_head(&tmp_ih, ih);\n\n\tif (allocation_needed\n\t    (retval, allocated_block_nr, ih, item, pos_in_item)) {\n\t\t/* we have to allocate block for the unformatted node */\n\t\tif (!th) {\n\t\t\tpathrelse(&path);\n\t\t\tgoto start_trans;\n\t\t}\n\n\t\trepeat =\n\t\t    _allocate_block(th, block, inode, &allocated_block_nr,\n\t\t\t\t    &path, create);\n\n\t\t/*\n\t\t * restart the transaction to give the journal a chance to free\n\t\t * some blocks.  releases the path, so we have to go back to\n\t\t * research if we succeed on the second try\n\t\t */\n\t\tif (repeat == NO_DISK_SPACE || repeat == QUOTA_EXCEEDED) {\n\t\t\tSB_JOURNAL(inode->i_sb)->j_next_async_flush = 1;\n\t\t\tretval = restart_transaction(th, inode, &path);\n\t\t\tif (retval)\n\t\t\t\tgoto failure;\n\t\t\trepeat =\n\t\t\t    _allocate_block(th, block, inode,\n\t\t\t\t\t    &allocated_block_nr, NULL, create);\n\n\t\t\tif (repeat != NO_DISK_SPACE && repeat != QUOTA_EXCEEDED) {\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tif (repeat == QUOTA_EXCEEDED)\n\t\t\t\tretval = -EDQUOT;\n\t\t\telse\n\t\t\t\tretval = -ENOSPC;\n\t\t\tgoto failure;\n\t\t}\n\n\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\tgoto research;\n\t\t}\n\t}\n\n\tif (indirect_item_found(retval, ih)) {\n\t\tb_blocknr_t unfm_ptr;\n\t\t/*\n\t\t * 'block'-th block is in the file already (there is\n\t\t * corresponding cell in some indirect item). But it may be\n\t\t * zero unformatted node pointer (hole)\n\t\t */\n\t\tunfm_ptr = get_block_num(item, pos_in_item);\n\t\tif (unfm_ptr == 0) {\n\t\t\t/* use allocated block to plug the hole */\n\t\t\treiserfs_prepare_for_journal(inode->i_sb, bh, 1);\n\t\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\t\treiserfs_restore_prepared_buffer(inode->i_sb,\n\t\t\t\t\t\t\t\t bh);\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tset_buffer_new(bh_result);\n\t\t\tif (buffer_dirty(bh_result)\n\t\t\t    && reiserfs_data_ordered(inode->i_sb))\n\t\t\t\treiserfs_add_ordered_list(inode, bh_result);\n\t\t\tput_block_num(item, pos_in_item, allocated_block_nr);\n\t\t\tunfm_ptr = allocated_block_nr;\n\t\t\tjournal_mark_dirty(th, bh);\n\t\t\treiserfs_update_sd(th, inode);\n\t\t}\n\t\tset_block_dev_mapped(bh_result, unfm_ptr, inode);\n\t\tpathrelse(&path);\n\t\tretval = 0;\n\t\tif (!dangle && th)\n\t\t\tretval = reiserfs_end_persistent_transaction(th);\n\n\t\treiserfs_write_unlock(inode->i_sb);\n\n\t\t/*\n\t\t * the item was found, so new blocks were not added to the file\n\t\t * there is no need to make sure the inode is updated with this\n\t\t * transaction\n\t\t */\n\t\treturn retval;\n\t}\n\n\tif (!th) {\n\t\tpathrelse(&path);\n\t\tgoto start_trans;\n\t}\n\n\t/*\n\t * desired position is not found or is in the direct item. We have\n\t * to append file with holes up to 'block'-th block converting\n\t * direct items to indirect one if necessary\n\t */\n\tdone = 0;\n\tdo {\n\t\tif (is_statdata_le_ih(ih)) {\n\t\t\t__le32 unp = 0;\n\t\t\tstruct cpu_key tmp_key;\n\n\t\t\t/* indirect item has to be inserted */\n\t\t\tmake_le_item_head(&tmp_ih, &key, version, 1,\n\t\t\t\t\t  TYPE_INDIRECT, UNFM_P_SIZE,\n\t\t\t\t\t  0 /* free_space */ );\n\n\t\t\t/*\n\t\t\t * we are going to add 'block'-th block to the file.\n\t\t\t * Use allocated block for that\n\t\t\t */\n\t\t\tif (cpu_key_k_offset(&key) == 1) {\n\t\t\t\tunp = cpu_to_le32(allocated_block_nr);\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tset_buffer_new(bh_result);\n\t\t\t\tdone = 1;\n\t\t\t}\n\t\t\ttmp_key = key;\t/* ;) */\n\t\t\tset_cpu_key_k_offset(&tmp_key, 1);\n\t\t\tPATH_LAST_POSITION(&path)++;\n\n\t\t\tretval =\n\t\t\t    reiserfs_insert_item(th, &path, &tmp_key, &tmp_ih,\n\t\t\t\t\t\t inode, (char *)&unp);\n\t\t\tif (retval) {\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\t/*\n\t\t\t\t * retval == -ENOSPC, -EDQUOT or -EIO\n\t\t\t\t * or -EEXIST\n\t\t\t\t */\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t} else if (is_direct_le_ih(ih)) {\n\t\t\t/* direct item has to be converted */\n\t\t\tloff_t tail_offset;\n\n\t\t\ttail_offset =\n\t\t\t    ((le_ih_k_offset(ih) -\n\t\t\t      1) & ~(inode->i_sb->s_blocksize - 1)) + 1;\n\n\t\t\t/*\n\t\t\t * direct item we just found fits into block we have\n\t\t\t * to map. Convert it into unformatted node: use\n\t\t\t * bh_result for the conversion\n\t\t\t */\n\t\t\tif (tail_offset == cpu_key_k_offset(&key)) {\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tunbh = bh_result;\n\t\t\t\tdone = 1;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * we have to pad file tail stored in direct\n\t\t\t\t * item(s) up to block size and convert it\n\t\t\t\t * to unformatted node. FIXME: this should\n\t\t\t\t * also get into page cache\n\t\t\t\t */\n\n\t\t\t\tpathrelse(&path);\n\t\t\t\t/*\n\t\t\t\t * ugly, but we can only end the transaction if\n\t\t\t\t * we aren't nested\n\t\t\t\t */\n\t\t\t\tBUG_ON(!th->t_refcount);\n\t\t\t\tif (th->t_refcount == 1) {\n\t\t\t\t\tretval =\n\t\t\t\t\t    reiserfs_end_persistent_transaction\n\t\t\t\t\t    (th);\n\t\t\t\t\tth = NULL;\n\t\t\t\t\tif (retval)\n\t\t\t\t\t\tgoto failure;\n\t\t\t\t}\n\n\t\t\t\tretval =\n\t\t\t\t    convert_tail_for_hole(inode, bh_result,\n\t\t\t\t\t\t\t  tail_offset);\n\t\t\t\tif (retval) {\n\t\t\t\t\tif (retval != -ENOSPC)\n\t\t\t\t\t\treiserfs_error(inode->i_sb,\n\t\t\t\t\t\t\t\"clm-6004\",\n\t\t\t\t\t\t\t\"convert tail failed \"\n\t\t\t\t\t\t\t\"inode %lu, error %d\",\n\t\t\t\t\t\t\tinode->i_ino,\n\t\t\t\t\t\t\tretval);\n\t\t\t\t\tif (allocated_block_nr) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * the bitmap, the super,\n\t\t\t\t\t\t * and the stat data == 3\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (!th)\n\t\t\t\t\t\t\tth = reiserfs_persistent_transaction(inode->i_sb, 3);\n\t\t\t\t\t\tif (th)\n\t\t\t\t\t\t\treiserfs_free_block(th,\n\t\t\t\t\t\t\t\t\t    inode,\n\t\t\t\t\t\t\t\t\t    allocated_block_nr,\n\t\t\t\t\t\t\t\t\t    1);\n\t\t\t\t\t}\n\t\t\t\t\tgoto failure;\n\t\t\t\t}\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tretval =\n\t\t\t    direct2indirect(th, inode, &path, unbh,\n\t\t\t\t\t    tail_offset);\n\t\t\tif (retval) {\n\t\t\t\treiserfs_unmap_buffer(unbh);\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\t/*\n\t\t\t * it is important the set_buffer_uptodate is done\n\t\t\t * after the direct2indirect.  The buffer might\n\t\t\t * contain valid data newer than the data on disk\n\t\t\t * (read by readpage, changed, and then sent here by\n\t\t\t * writepage).  direct2indirect needs to know if unbh\n\t\t\t * was already up to date, so it can decide if the\n\t\t\t * data in unbh needs to be replaced with data from\n\t\t\t * the disk\n\t\t\t */\n\t\t\tset_buffer_uptodate(unbh);\n\n\t\t\t/*\n\t\t\t * unbh->b_page == NULL in case of DIRECT_IO request,\n\t\t\t * this means buffer will disappear shortly, so it\n\t\t\t * should not be added to\n\t\t\t */\n\t\t\tif (unbh->b_page) {\n\t\t\t\t/*\n\t\t\t\t * we've converted the tail, so we must\n\t\t\t\t * flush unbh before the transaction commits\n\t\t\t\t */\n\t\t\t\treiserfs_add_tail_list(inode, unbh);\n\n\t\t\t\t/*\n\t\t\t\t * mark it dirty now to prevent commit_write\n\t\t\t\t * from adding this buffer to the inode's\n\t\t\t\t * dirty buffer list\n\t\t\t\t */\n\t\t\t\t/*\n\t\t\t\t * AKPM: changed __mark_buffer_dirty to\n\t\t\t\t * mark_buffer_dirty().  It's still atomic,\n\t\t\t\t * but it sets the page dirty too, which makes\n\t\t\t\t * it eligible for writeback at any time by the\n\t\t\t\t * VM (which was also the case with\n\t\t\t\t * __mark_buffer_dirty())\n\t\t\t\t */\n\t\t\t\tmark_buffer_dirty(unbh);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * append indirect item with holes if needed, when\n\t\t\t * appending pointer to 'block'-th block use block,\n\t\t\t * which is already allocated\n\t\t\t */\n\t\t\tstruct cpu_key tmp_key;\n\t\t\t/*\n\t\t\t * We use this in case we need to allocate\n\t\t\t * only one block which is a fastpath\n\t\t\t */\n\t\t\tunp_t unf_single = 0;\n\t\t\tunp_t *un;\n\t\t\t__u64 max_to_insert =\n\t\t\t    MAX_ITEM_LEN(inode->i_sb->s_blocksize) /\n\t\t\t    UNFM_P_SIZE;\n\t\t\t__u64 blocks_needed;\n\n\t\t\tRFALSE(pos_in_item != ih_item_len(ih) / UNFM_P_SIZE,\n\t\t\t       \"vs-804: invalid position for append\");\n\t\t\t/*\n\t\t\t * indirect item has to be appended,\n\t\t\t * set up key of that position\n\t\t\t * (key type is unimportant)\n\t\t\t */\n\t\t\tmake_cpu_key(&tmp_key, inode,\n\t\t\t\t     le_key_k_offset(version,\n\t\t\t\t\t\t     &ih->ih_key) +\n\t\t\t\t     op_bytes_number(ih,\n\t\t\t\t\t\t     inode->i_sb->s_blocksize),\n\t\t\t\t     TYPE_INDIRECT, 3);\n\n\t\t\tRFALSE(cpu_key_k_offset(&tmp_key) > cpu_key_k_offset(&key),\n\t\t\t       \"green-805: invalid offset\");\n\t\t\tblocks_needed =\n\t\t\t    1 +\n\t\t\t    ((cpu_key_k_offset(&key) -\n\t\t\t      cpu_key_k_offset(&tmp_key)) >> inode->i_sb->\n\t\t\t     s_blocksize_bits);\n\n\t\t\tif (blocks_needed == 1) {\n\t\t\t\tun = &unf_single;\n\t\t\t} else {\n\t\t\t\tun = kzalloc(min(blocks_needed, max_to_insert) * UNFM_P_SIZE, GFP_NOFS);\n\t\t\t\tif (!un) {\n\t\t\t\t\tun = &unf_single;\n\t\t\t\t\tblocks_needed = 1;\n\t\t\t\t\tmax_to_insert = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (blocks_needed <= max_to_insert) {\n\t\t\t\t/*\n\t\t\t\t * we are going to add target block to\n\t\t\t\t * the file. Use allocated block for that\n\t\t\t\t */\n\t\t\t\tun[blocks_needed - 1] =\n\t\t\t\t    cpu_to_le32(allocated_block_nr);\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tset_buffer_new(bh_result);\n\t\t\t\tdone = 1;\n\t\t\t} else {\n\t\t\t\t/* paste hole to the indirect item */\n\t\t\t\t/*\n\t\t\t\t * If kmalloc failed, max_to_insert becomes\n\t\t\t\t * zero and it means we only have space for\n\t\t\t\t * one block\n\t\t\t\t */\n\t\t\t\tblocks_needed =\n\t\t\t\t    max_to_insert ? max_to_insert : 1;\n\t\t\t}\n\t\t\tretval =\n\t\t\t    reiserfs_paste_into_item(th, &path, &tmp_key, inode,\n\t\t\t\t\t\t     (char *)un,\n\t\t\t\t\t\t     UNFM_P_SIZE *\n\t\t\t\t\t\t     blocks_needed);\n\n\t\t\tif (blocks_needed != 1)\n\t\t\t\tkfree(un);\n\n\t\t\tif (retval) {\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\tif (!done) {\n\t\t\t\t/*\n\t\t\t\t * We need to mark new file size in case\n\t\t\t\t * this function will be interrupted/aborted\n\t\t\t\t * later on. And we may do this only for\n\t\t\t\t * holes.\n\t\t\t\t */\n\t\t\t\tinode->i_size +=\n\t\t\t\t    inode->i_sb->s_blocksize * blocks_needed;\n\t\t\t}\n\t\t}\n\n\t\tif (done == 1)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * this loop could log more blocks than we had originally\n\t\t * asked for.  So, we have to allow the transaction to end\n\t\t * if it is too big or too full.  Update the inode so things\n\t\t * are consistent if we crash before the function returns\n\t\t * release the path so that anybody waiting on the path before\n\t\t * ending their transaction will be able to continue.\n\t\t */\n\t\tif (journal_transaction_should_end(th, th->t_blocks_allocated)) {\n\t\t\tretval = restart_transaction(th, inode, &path);\n\t\t\tif (retval)\n\t\t\t\tgoto failure;\n\t\t}\n\t\t/*\n\t\t * inserting indirect pointers for a hole can take a\n\t\t * long time.  reschedule if needed and also release the write\n\t\t * lock for others.\n\t\t */\n\t\treiserfs_cond_resched(inode->i_sb);\n\n\t\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\t\tif (retval == IO_ERROR) {\n\t\t\tretval = -EIO;\n\t\t\tgoto failure;\n\t\t}\n\t\tif (retval == POSITION_FOUND) {\n\t\t\treiserfs_warning(inode->i_sb, \"vs-825\",\n\t\t\t\t\t \"%K should not be found\", &key);\n\t\t\tretval = -EEXIST;\n\t\t\tif (allocated_block_nr)\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\tpathrelse(&path);\n\t\t\tgoto failure;\n\t\t}\n\t\tbh = get_last_bh(&path);\n\t\tih = tp_item_head(&path);\n\t\titem = tp_item_body(&path);\n\t\tpos_in_item = path.pos_in_item;\n\t} while (1);\n\n\tretval = 0;\n\nfailure:\n\tif (th && (!dangle || (retval && !th->t_trans_id))) {\n\t\tint err;\n\t\tif (th->t_trans_id)\n\t\t\treiserfs_update_sd(th, inode);\n\t\terr = reiserfs_end_persistent_transaction(th);\n\t\tif (err)\n\t\t\tretval = err;\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\treiserfs_check_path(&path);\n\treturn retval;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint reiserfs_get_block(struct inode *inode, sector_t block,\n\t\t       struct buffer_head *bh_result, int create)\n{\n\tint repeat, retval = 0;\n\t/* b_blocknr_t is (unsigned) 32 bit int*/\n\tb_blocknr_t allocated_block_nr = 0;\n\tINITIALIZE_PATH(path);\n\tint pos_in_item;\n\tstruct cpu_key key;\n\tstruct buffer_head *bh, *unbh = NULL;\n\tstruct item_head *ih, tmp_ih;\n\t__le32 *item;\n\tint done;\n\tint fs_gen;\n\tstruct reiserfs_transaction_handle *th = NULL;\n\t/*\n\t * space reserved in transaction batch:\n\t * . 3 balancings in direct->indirect conversion\n\t * . 1 block involved into reiserfs_update_sd()\n\t * XXX in practically impossible worst case direct2indirect()\n\t * can incur (much) more than 3 balancings.\n\t * quota update for user, group\n\t */\n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 3 + 1 +\n\t    2 * REISERFS_QUOTA_TRANS_BLOCKS(inode->i_sb);\n\tint version;\n\tint dangle = 1;\n\tloff_t new_offset =\n\t    (((loff_t) block) << inode->i_sb->s_blocksize_bits) + 1;\n\n\treiserfs_write_lock(inode->i_sb);\n\tversion = get_inode_item_key_version(inode);\n\n\tif (!file_capable(inode, block)) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\treturn -EFBIG;\n\t}\n\n\t/*\n\t * if !create, we aren't changing the FS, so we don't need to\n\t * log anything, so we don't need to start a transaction\n\t */\n\tif (!(create & GET_BLOCK_CREATE)) {\n\t\tint ret;\n\t\t/* find number of block-th logical block of the file */\n\t\tret = _get_block_create_0(inode, block, bh_result,\n\t\t\t\t\t  create | GET_BLOCK_READ_DIRECT);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * if we're already in a transaction, make sure to close\n\t * any new transactions we start in this func\n\t */\n\tif ((create & GET_BLOCK_NO_DANGLE) ||\n\t    reiserfs_transaction_running(inode->i_sb))\n\t\tdangle = 0;\n\n\t/*\n\t * If file is of such a size, that it might have a tail and\n\t * tails are enabled  we should mark it as possibly needing\n\t * tail packing on close\n\t */\n\tif ((have_large_tails(inode->i_sb)\n\t     && inode->i_size < i_block_size(inode) * 4)\n\t    || (have_small_tails(inode->i_sb)\n\t\t&& inode->i_size < i_block_size(inode)))\n\t\tREISERFS_I(inode)->i_flags |= i_pack_on_close_mask;\n\n\t/* set the key of the first byte in the 'block'-th block of file */\n\tmake_cpu_key(&key, inode, new_offset, TYPE_ANY, 3 /*key length */ );\n\tif ((new_offset + inode->i_sb->s_blocksize - 1) > inode->i_size) {\nstart_trans:\n\t\tth = reiserfs_persistent_transaction(inode->i_sb, jbegin_count);\n\t\tif (!th) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto failure;\n\t\t}\n\t\treiserfs_update_inode_transaction(inode);\n\t}\nresearch:\n\n\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\tif (retval == IO_ERROR) {\n\t\tretval = -EIO;\n\t\tgoto failure;\n\t}\n\n\tbh = get_last_bh(&path);\n\tih = tp_item_head(&path);\n\titem = tp_item_body(&path);\n\tpos_in_item = path.pos_in_item;\n\n\tfs_gen = get_generation(inode->i_sb);\n\tcopy_item_head(&tmp_ih, ih);\n\n\tif (allocation_needed\n\t    (retval, allocated_block_nr, ih, item, pos_in_item)) {\n\t\t/* we have to allocate block for the unformatted node */\n\t\tif (!th) {\n\t\t\tpathrelse(&path);\n\t\t\tgoto start_trans;\n\t\t}\n\n\t\trepeat =\n\t\t    _allocate_block(th, block, inode, &allocated_block_nr,\n\t\t\t\t    &path, create);\n\n\t\t/*\n\t\t * restart the transaction to give the journal a chance to free\n\t\t * some blocks.  releases the path, so we have to go back to\n\t\t * research if we succeed on the second try\n\t\t */\n\t\tif (repeat == NO_DISK_SPACE || repeat == QUOTA_EXCEEDED) {\n\t\t\tSB_JOURNAL(inode->i_sb)->j_next_async_flush = 1;\n\t\t\tretval = restart_transaction(th, inode, &path);\n\t\t\tif (retval)\n\t\t\t\tgoto failure;\n\t\t\trepeat =\n\t\t\t    _allocate_block(th, block, inode,\n\t\t\t\t\t    &allocated_block_nr, NULL, create);\n\n\t\t\tif (repeat != NO_DISK_SPACE && repeat != QUOTA_EXCEEDED) {\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tif (repeat == QUOTA_EXCEEDED)\n\t\t\t\tretval = -EDQUOT;\n\t\t\telse\n\t\t\t\tretval = -ENOSPC;\n\t\t\tgoto failure;\n\t\t}\n\n\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\tgoto research;\n\t\t}\n\t}\n\n\tif (indirect_item_found(retval, ih)) {\n\t\tb_blocknr_t unfm_ptr;\n\t\t/*\n\t\t * 'block'-th block is in the file already (there is\n\t\t * corresponding cell in some indirect item). But it may be\n\t\t * zero unformatted node pointer (hole)\n\t\t */\n\t\tunfm_ptr = get_block_num(item, pos_in_item);\n\t\tif (unfm_ptr == 0) {\n\t\t\t/* use allocated block to plug the hole */\n\t\t\treiserfs_prepare_for_journal(inode->i_sb, bh, 1);\n\t\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\t\treiserfs_restore_prepared_buffer(inode->i_sb,\n\t\t\t\t\t\t\t\t bh);\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tset_buffer_new(bh_result);\n\t\t\tif (buffer_dirty(bh_result)\n\t\t\t    && reiserfs_data_ordered(inode->i_sb))\n\t\t\t\treiserfs_add_ordered_list(inode, bh_result);\n\t\t\tput_block_num(item, pos_in_item, allocated_block_nr);\n\t\t\tunfm_ptr = allocated_block_nr;\n\t\t\tjournal_mark_dirty(th, bh);\n\t\t\treiserfs_update_sd(th, inode);\n\t\t}\n\t\tset_block_dev_mapped(bh_result, unfm_ptr, inode);\n\t\tpathrelse(&path);\n\t\tretval = 0;\n\t\tif (!dangle && th)\n\t\t\tretval = reiserfs_end_persistent_transaction(th);\n\n\t\treiserfs_write_unlock(inode->i_sb);\n\n\t\t/*\n\t\t * the item was found, so new blocks were not added to the file\n\t\t * there is no need to make sure the inode is updated with this\n\t\t * transaction\n\t\t */\n\t\treturn retval;\n\t}\n\n\tif (!th) {\n\t\tpathrelse(&path);\n\t\tgoto start_trans;\n\t}\n\n\t/*\n\t * desired position is not found or is in the direct item. We have\n\t * to append file with holes up to 'block'-th block converting\n\t * direct items to indirect one if necessary\n\t */\n\tdone = 0;\n\tdo {\n\t\tif (is_statdata_le_ih(ih)) {\n\t\t\t__le32 unp = 0;\n\t\t\tstruct cpu_key tmp_key;\n\n\t\t\t/* indirect item has to be inserted */\n\t\t\tmake_le_item_head(&tmp_ih, &key, version, 1,\n\t\t\t\t\t  TYPE_INDIRECT, UNFM_P_SIZE,\n\t\t\t\t\t  0 /* free_space */ );\n\n\t\t\t/*\n\t\t\t * we are going to add 'block'-th block to the file.\n\t\t\t * Use allocated block for that\n\t\t\t */\n\t\t\tif (cpu_key_k_offset(&key) == 1) {\n\t\t\t\tunp = cpu_to_le32(allocated_block_nr);\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tset_buffer_new(bh_result);\n\t\t\t\tdone = 1;\n\t\t\t}\n\t\t\ttmp_key = key;\t/* ;) */\n\t\t\tset_cpu_key_k_offset(&tmp_key, 1);\n\t\t\tPATH_LAST_POSITION(&path)++;\n\n\t\t\tretval =\n\t\t\t    reiserfs_insert_item(th, &path, &tmp_key, &tmp_ih,\n\t\t\t\t\t\t inode, (char *)&unp);\n\t\t\tif (retval) {\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\t/*\n\t\t\t\t * retval == -ENOSPC, -EDQUOT or -EIO\n\t\t\t\t * or -EEXIST\n\t\t\t\t */\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t} else if (is_direct_le_ih(ih)) {\n\t\t\t/* direct item has to be converted */\n\t\t\tloff_t tail_offset;\n\n\t\t\ttail_offset =\n\t\t\t    ((le_ih_k_offset(ih) -\n\t\t\t      1) & ~(inode->i_sb->s_blocksize - 1)) + 1;\n\n\t\t\t/*\n\t\t\t * direct item we just found fits into block we have\n\t\t\t * to map. Convert it into unformatted node: use\n\t\t\t * bh_result for the conversion\n\t\t\t */\n\t\t\tif (tail_offset == cpu_key_k_offset(&key)) {\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tunbh = bh_result;\n\t\t\t\tdone = 1;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * we have to pad file tail stored in direct\n\t\t\t\t * item(s) up to block size and convert it\n\t\t\t\t * to unformatted node. FIXME: this should\n\t\t\t\t * also get into page cache\n\t\t\t\t */\n\n\t\t\t\tpathrelse(&path);\n\t\t\t\t/*\n\t\t\t\t * ugly, but we can only end the transaction if\n\t\t\t\t * we aren't nested\n\t\t\t\t */\n\t\t\t\tBUG_ON(!th->t_refcount);\n\t\t\t\tif (th->t_refcount == 1) {\n\t\t\t\t\tretval =\n\t\t\t\t\t    reiserfs_end_persistent_transaction\n\t\t\t\t\t    (th);\n\t\t\t\t\tth = NULL;\n\t\t\t\t\tif (retval)\n\t\t\t\t\t\tgoto failure;\n\t\t\t\t}\n\n\t\t\t\tretval =\n\t\t\t\t    convert_tail_for_hole(inode, bh_result,\n\t\t\t\t\t\t\t  tail_offset);\n\t\t\t\tif (retval) {\n\t\t\t\t\tif (retval != -ENOSPC)\n\t\t\t\t\t\treiserfs_error(inode->i_sb,\n\t\t\t\t\t\t\t\"clm-6004\",\n\t\t\t\t\t\t\t\"convert tail failed \"\n\t\t\t\t\t\t\t\"inode %lu, error %d\",\n\t\t\t\t\t\t\tinode->i_ino,\n\t\t\t\t\t\t\tretval);\n\t\t\t\t\tif (allocated_block_nr) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * the bitmap, the super,\n\t\t\t\t\t\t * and the stat data == 3\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (!th)\n\t\t\t\t\t\t\tth = reiserfs_persistent_transaction(inode->i_sb, 3);\n\t\t\t\t\t\tif (th)\n\t\t\t\t\t\t\treiserfs_free_block(th,\n\t\t\t\t\t\t\t\t\t    inode,\n\t\t\t\t\t\t\t\t\t    allocated_block_nr,\n\t\t\t\t\t\t\t\t\t    1);\n\t\t\t\t\t}\n\t\t\t\t\tgoto failure;\n\t\t\t\t}\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tretval =\n\t\t\t    direct2indirect(th, inode, &path, unbh,\n\t\t\t\t\t    tail_offset);\n\t\t\tif (retval) {\n\t\t\t\treiserfs_unmap_buffer(unbh);\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\t/*\n\t\t\t * it is important the set_buffer_uptodate is done\n\t\t\t * after the direct2indirect.  The buffer might\n\t\t\t * contain valid data newer than the data on disk\n\t\t\t * (read by readpage, changed, and then sent here by\n\t\t\t * writepage).  direct2indirect needs to know if unbh\n\t\t\t * was already up to date, so it can decide if the\n\t\t\t * data in unbh needs to be replaced with data from\n\t\t\t * the disk\n\t\t\t */\n\t\t\tset_buffer_uptodate(unbh);\n\n\t\t\t/*\n\t\t\t * unbh->b_page == NULL in case of DIRECT_IO request,\n\t\t\t * this means buffer will disappear shortly, so it\n\t\t\t * should not be added to\n\t\t\t */\n\t\t\tif (unbh->b_page) {\n\t\t\t\t/*\n\t\t\t\t * we've converted the tail, so we must\n\t\t\t\t * flush unbh before the transaction commits\n\t\t\t\t */\n\t\t\t\treiserfs_add_tail_list(inode, unbh);\n\n\t\t\t\t/*\n\t\t\t\t * mark it dirty now to prevent commit_write\n\t\t\t\t * from adding this buffer to the inode's\n\t\t\t\t * dirty buffer list\n\t\t\t\t */\n\t\t\t\t/*\n\t\t\t\t * AKPM: changed __mark_buffer_dirty to\n\t\t\t\t * mark_buffer_dirty().  It's still atomic,\n\t\t\t\t * but it sets the page dirty too, which makes\n\t\t\t\t * it eligible for writeback at any time by the\n\t\t\t\t * VM (which was also the case with\n\t\t\t\t * __mark_buffer_dirty())\n\t\t\t\t */\n\t\t\t\tmark_buffer_dirty(unbh);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * append indirect item with holes if needed, when\n\t\t\t * appending pointer to 'block'-th block use block,\n\t\t\t * which is already allocated\n\t\t\t */\n\t\t\tstruct cpu_key tmp_key;\n\t\t\t/*\n\t\t\t * We use this in case we need to allocate\n\t\t\t * only one block which is a fastpath\n\t\t\t */\n\t\t\tunp_t unf_single = 0;\n\t\t\tunp_t *un;\n\t\t\t__u64 max_to_insert =\n\t\t\t    MAX_ITEM_LEN(inode->i_sb->s_blocksize) /\n\t\t\t    UNFM_P_SIZE;\n\t\t\t__u64 blocks_needed;\n\n\t\t\tRFALSE(pos_in_item != ih_item_len(ih) / UNFM_P_SIZE,\n\t\t\t       \"vs-804: invalid position for append\");\n\t\t\t/*\n\t\t\t * indirect item has to be appended,\n\t\t\t * set up key of that position\n\t\t\t * (key type is unimportant)\n\t\t\t */\n\t\t\tmake_cpu_key(&tmp_key, inode,\n\t\t\t\t     le_key_k_offset(version,\n\t\t\t\t\t\t     &ih->ih_key) +\n\t\t\t\t     op_bytes_number(ih,\n\t\t\t\t\t\t     inode->i_sb->s_blocksize),\n\t\t\t\t     TYPE_INDIRECT, 3);\n\n\t\t\tRFALSE(cpu_key_k_offset(&tmp_key) > cpu_key_k_offset(&key),\n\t\t\t       \"green-805: invalid offset\");\n\t\t\tblocks_needed =\n\t\t\t    1 +\n\t\t\t    ((cpu_key_k_offset(&key) -\n\t\t\t      cpu_key_k_offset(&tmp_key)) >> inode->i_sb->\n\t\t\t     s_blocksize_bits);\n\n\t\t\tif (blocks_needed == 1) {\n\t\t\t\tun = &unf_single;\n\t\t\t} else {\n\t\t\t\tun = kzalloc(min(blocks_needed, max_to_insert) * UNFM_P_SIZE, GFP_NOFS);\n\t\t\t\tif (!un) {\n\t\t\t\t\tun = &unf_single;\n\t\t\t\t\tblocks_needed = 1;\n\t\t\t\t\tmax_to_insert = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (blocks_needed <= max_to_insert) {\n\t\t\t\t/*\n\t\t\t\t * we are going to add target block to\n\t\t\t\t * the file. Use allocated block for that\n\t\t\t\t */\n\t\t\t\tun[blocks_needed - 1] =\n\t\t\t\t    cpu_to_le32(allocated_block_nr);\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tset_buffer_new(bh_result);\n\t\t\t\tdone = 1;\n\t\t\t} else {\n\t\t\t\t/* paste hole to the indirect item */\n\t\t\t\t/*\n\t\t\t\t * If kmalloc failed, max_to_insert becomes\n\t\t\t\t * zero and it means we only have space for\n\t\t\t\t * one block\n\t\t\t\t */\n\t\t\t\tblocks_needed =\n\t\t\t\t    max_to_insert ? max_to_insert : 1;\n\t\t\t}\n\t\t\tretval =\n\t\t\t    reiserfs_paste_into_item(th, &path, &tmp_key, inode,\n\t\t\t\t\t\t     (char *)un,\n\t\t\t\t\t\t     UNFM_P_SIZE *\n\t\t\t\t\t\t     blocks_needed);\n\n\t\t\tif (blocks_needed != 1)\n\t\t\t\tkfree(un);\n\n\t\t\tif (retval) {\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\tif (!done) {\n\t\t\t\t/*\n\t\t\t\t * We need to mark new file size in case\n\t\t\t\t * this function will be interrupted/aborted\n\t\t\t\t * later on. And we may do this only for\n\t\t\t\t * holes.\n\t\t\t\t */\n\t\t\t\tinode->i_size +=\n\t\t\t\t    inode->i_sb->s_blocksize * blocks_needed;\n\t\t\t}\n\t\t}\n\n\t\tif (done == 1)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * this loop could log more blocks than we had originally\n\t\t * asked for.  So, we have to allow the transaction to end\n\t\t * if it is too big or too full.  Update the inode so things\n\t\t * are consistent if we crash before the function returns\n\t\t * release the path so that anybody waiting on the path before\n\t\t * ending their transaction will be able to continue.\n\t\t */\n\t\tif (journal_transaction_should_end(th, th->t_blocks_allocated)) {\n\t\t\tretval = restart_transaction(th, inode, &path);\n\t\t\tif (retval)\n\t\t\t\tgoto failure;\n\t\t}\n\t\t/*\n\t\t * inserting indirect pointers for a hole can take a\n\t\t * long time.  reschedule if needed and also release the write\n\t\t * lock for others.\n\t\t */\n\t\treiserfs_cond_resched(inode->i_sb);\n\n\t\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\t\tif (retval == IO_ERROR) {\n\t\t\tretval = -EIO;\n\t\t\tgoto failure;\n\t\t}\n\t\tif (retval == POSITION_FOUND) {\n\t\t\treiserfs_warning(inode->i_sb, \"vs-825\",\n\t\t\t\t\t \"%K should not be found\", &key);\n\t\t\tretval = -EEXIST;\n\t\t\tif (allocated_block_nr)\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\tpathrelse(&path);\n\t\t\tgoto failure;\n\t\t}\n\t\tbh = get_last_bh(&path);\n\t\tih = tp_item_head(&path);\n\t\titem = tp_item_body(&path);\n\t\tpos_in_item = path.pos_in_item;\n\t} while (1);\n\n\tretval = 0;\n\nfailure:\n\tif (th && (!dangle || (retval && !th->t_trans_id))) {\n\t\tint err;\n\t\tif (th->t_trans_id)\n\t\t\treiserfs_update_sd(th, inode);\n\t\terr = reiserfs_end_persistent_transaction(th);\n\t\tif (err)\n\t\t\tretval = err;\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\treiserfs_check_path(&path);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "sb"
          ],
          "line": 2425
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int reiserfs_remount(struct super_block *s, int *flags, char *data);\nstatic const arg_desc_t tails[] = {\n\t{\"on\", 1 << REISERFS_LARGETAIL, 1 << REISERFS_SMALLTAIL},\n\t{\"off\", 0, (1 << REISERFS_LARGETAIL) | (1 << REISERFS_SMALLTAIL)},\n\t{\"small\", 1 << REISERFS_SMALLTAIL, 1 << REISERFS_LARGETAIL},\n\t{NULL, 0, 0}\n};\n\nstatic ssize_t reiserfs_quota_read(struct super_block *sb, int type, char *data,\n\t\t\t\t   size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tunsigned long blk = off >> sb->s_blocksize_bits;\n\tint err = 0, offset = off & (sb->s_blocksize - 1), tocopy;\n\tsize_t toread;\n\tstruct buffer_head tmp_bh, *bh;\n\tloff_t i_size = i_size_read(inode);\n\n\tif (off > i_size)\n\t\treturn 0;\n\tif (off + len > i_size)\n\t\tlen = i_size - off;\n\ttoread = len;\n\twhile (toread > 0) {\n\t\ttocopy =\n\t\t    sb->s_blocksize - offset <\n\t\t    toread ? sb->s_blocksize - offset : toread;\n\t\ttmp_bh.b_state = 0;\n\t\t/*\n\t\t * Quota files are without tails so we can safely\n\t\t * use this function\n\t\t */\n\t\treiserfs_write_lock(sb);\n\t\terr = reiserfs_get_block(inode, blk, &tmp_bh, 0);\n\t\treiserfs_write_unlock(sb);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!buffer_mapped(&tmp_bh))\t/* A hole? */\n\t\t\tmemset(data, 0, tocopy);\n\t\telse {\n\t\t\tbh = sb_bread(sb, tmp_bh.b_blocknr);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t\tmemcpy(data, bh->b_data + offset, tocopy);\n\t\t\tbrelse(bh);\n\t\t}\n\t\toffset = 0;\n\t\ttoread -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\n\treturn len;\n}"
  },
  {
    "function_name": "reiserfs_quota_on",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "2331-2393",
    "snippet": "static int reiserfs_quota_on(struct super_block *sb, int type, int format_id,\n\t\t\t     struct path *path)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct reiserfs_transaction_handle th;\n\tint opt = type == USRQUOTA ? REISERFS_USRQUOTA : REISERFS_GRPQUOTA;\n\n\treiserfs_write_lock(sb);\n\tif (!(REISERFS_SB(sb)->s_mount_opt & (1 << opt))) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Quotafile not on the same filesystem? */\n\tif (path->dentry->d_sb != sb) {\n\t\terr = -EXDEV;\n\t\tgoto out;\n\t}\n\tinode = path->dentry->d_inode;\n\t/*\n\t * We must not pack tails for quota files on reiserfs for quota\n\t * IO to work\n\t */\n\tif (!(REISERFS_I(inode)->i_flags & i_nopack_mask)) {\n\t\terr = reiserfs_unpack(inode, NULL);\n\t\tif (err) {\n\t\t\treiserfs_warning(sb, \"super-6520\",\n\t\t\t\t\"Unpacking tail of quota file failed\"\n\t\t\t\t\" (%d). Cannot turn on quotas.\", err);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmark_inode_dirty(inode);\n\t}\n\t/* Journaling quota? */\n\tif (REISERFS_SB(sb)->s_qf_names[type]) {\n\t\t/* Quotafile not of fs root? */\n\t\tif (path->dentry->d_parent != sb->s_root)\n\t\t\treiserfs_warning(sb, \"super-6521\",\n\t\t\t\t \"Quota file not on filesystem root. \"\n\t\t\t\t \"Journalled quota will not work.\");\n\t}\n\n\t/*\n\t * When we journal data on quota file, we have to flush journal to see\n\t * all updates to the file when we bypass pagecache...\n\t */\n\tif (reiserfs_file_data_log(inode)) {\n\t\t/* Just start temporary transaction and finish it */\n\t\terr = journal_begin(&th, sb, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = journal_end_sync(&th);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\treiserfs_write_unlock(sb);\n\treturn dquot_quota_on(sb, type, format_id, path);\nout:\n\treiserfs_write_unlock(sb);\n\treturn err;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int reiserfs_remount(struct super_block *s, int *flags, char *data);",
      "static const arg_desc_t tails[] = {\n\t{\"on\", 1 << REISERFS_LARGETAIL, 1 << REISERFS_SMALLTAIL},\n\t{\"off\", 0, (1 << REISERFS_LARGETAIL) | (1 << REISERFS_SMALLTAIL)},\n\t{\"small\", 1 << REISERFS_SMALLTAIL, 1 << REISERFS_LARGETAIL},\n\t{NULL, 0, 0}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "sb"
          ],
          "line": 2391
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_quota_on",
          "args": [
            "sb",
            "type",
            "format_id",
            "path"
          ],
          "line": 2389
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_quota_on_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "2360-2385",
          "snippet": "int dquot_quota_on_mount(struct super_block *sb, char *qf_name,\n\t\tint format_id, int type)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\tmutex_lock(&sb->s_root->d_inode->i_mutex);\n\tdentry = lookup_one_len(qf_name, sb->s_root, strlen(qf_name));\n\tmutex_unlock(&sb->s_root->d_inode->i_mutex);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tif (!dentry->d_inode) {\n\t\terror = -ENOENT;\n\t\tgoto out;\n\t}\n\n\terror = security_quota_on(dentry);\n\tif (!error)\n\t\terror = vfs_load_quota_inode(dentry->d_inode, type, format_id,\n\t\t\t\tDQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\nout:\n\tdput(dentry);\n\treturn error;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_quota_on_mount(struct super_block *sb, char *qf_name,\n\t\tint format_id, int type)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\tmutex_lock(&sb->s_root->d_inode->i_mutex);\n\tdentry = lookup_one_len(qf_name, sb->s_root, strlen(qf_name));\n\tmutex_unlock(&sb->s_root->d_inode->i_mutex);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tif (!dentry->d_inode) {\n\t\terror = -ENOENT;\n\t\tgoto out;\n\t}\n\n\terror = security_quota_on(dentry);\n\tif (!error)\n\t\terror = vfs_load_quota_inode(dentry->d_inode, type, format_id,\n\t\t\t\tDQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\nout:\n\tdput(dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end_sync",
          "args": [
            "&th"
          ],
          "line": 2384
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "sb",
            "1"
          ],
          "line": 2381
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_file_data_log",
          "args": [
            "inode"
          ],
          "line": 2379
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_file_data_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2888-2894",
          "snippet": "static inline int reiserfs_file_data_log(struct inode *inode)\n{\n\tif (reiserfs_data_log(inode->i_sb) ||\n\t    (REISERFS_I(inode)->i_flags & i_data_log))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline int reiserfs_file_data_log(struct inode *inode)\n{\n\tif (reiserfs_data_log(inode->i_sb) ||\n\t    (REISERFS_I(inode)->i_flags & i_data_log))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"super-6521\"",
            "\"Quota file not on filesystem root. \"\n\t\t\t\t \"Journalled quota will not work.\""
          ],
          "line": 2370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "sb"
          ],
          "line": 2367
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 2364
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"super-6520\"",
            "\"Unpacking tail of quota file failed\"\n\t\t\t\t\" (%d). Cannot turn on quotas.\"",
            "err"
          ],
          "line": 2358
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_unpack",
          "args": [
            "inode",
            "NULL"
          ],
          "line": 2356
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_unpack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ioctl.c",
          "lines": "171-230",
          "snippet": "int reiserfs_unpack(struct inode *inode, struct file *filp)\n{\n\tint retval = 0;\n\tint index;\n\tstruct page *page;\n\tstruct address_space *mapping;\n\tunsigned long write_from;\n\tunsigned long blocksize = inode->i_sb->s_blocksize;\n\n\tif (inode->i_size == 0) {\n\t\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\t\treturn 0;\n\t}\n\t/* ioctl already done */\n\tif (REISERFS_I(inode)->i_flags & i_nopack_mask) {\n\t\treturn 0;\n\t}\n\n\t/* we need to make sure nobody is changing the file size beneath us */\n\treiserfs_mutex_lock_safe(&inode->i_mutex, inode->i_sb);\n\n\treiserfs_write_lock(inode->i_sb);\n\n\twrite_from = inode->i_size & (blocksize - 1);\n\t/* if we are on a block boundary, we are already unpacked.  */\n\tif (write_from == 0) {\n\t\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * we unpack by finding the page with the tail, and calling\n\t * __reiserfs_write_begin on that page.  This will force a\n\t * reiserfs_get_block to unpack the tail for us.\n\t */\n\tindex = inode->i_size >> PAGE_CACHE_SHIFT;\n\tmapping = inode->i_mapping;\n\tpage = grab_cache_page(mapping, index);\n\tretval = -ENOMEM;\n\tif (!page) {\n\t\tgoto out;\n\t}\n\tretval = __reiserfs_write_begin(page, write_from, 0);\n\tif (retval)\n\t\tgoto out_unlock;\n\n\t/* conversion can change page contents, must flush */\n\tflush_dcache_page(page);\n\tretval = reiserfs_commit_write(NULL, page, write_from, write_from);\n\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\nout_unlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treiserfs_write_unlock(inode->i_sb);\n\treturn retval;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include \"reiserfs.h\"\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint reiserfs_unpack(struct inode *inode, struct file *filp)\n{\n\tint retval = 0;\n\tint index;\n\tstruct page *page;\n\tstruct address_space *mapping;\n\tunsigned long write_from;\n\tunsigned long blocksize = inode->i_sb->s_blocksize;\n\n\tif (inode->i_size == 0) {\n\t\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\t\treturn 0;\n\t}\n\t/* ioctl already done */\n\tif (REISERFS_I(inode)->i_flags & i_nopack_mask) {\n\t\treturn 0;\n\t}\n\n\t/* we need to make sure nobody is changing the file size beneath us */\n\treiserfs_mutex_lock_safe(&inode->i_mutex, inode->i_sb);\n\n\treiserfs_write_lock(inode->i_sb);\n\n\twrite_from = inode->i_size & (blocksize - 1);\n\t/* if we are on a block boundary, we are already unpacked.  */\n\tif (write_from == 0) {\n\t\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * we unpack by finding the page with the tail, and calling\n\t * __reiserfs_write_begin on that page.  This will force a\n\t * reiserfs_get_block to unpack the tail for us.\n\t */\n\tindex = inode->i_size >> PAGE_CACHE_SHIFT;\n\tmapping = inode->i_mapping;\n\tpage = grab_cache_page(mapping, index);\n\tretval = -ENOMEM;\n\tif (!page) {\n\t\tgoto out;\n\t}\n\tretval = __reiserfs_write_begin(page, write_from, 0);\n\tif (retval)\n\t\tgoto out_unlock;\n\n\t/* conversion can change page contents, must flush */\n\tflush_dcache_page(page);\n\tretval = reiserfs_commit_write(NULL, page, write_from, write_from);\n\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\nout_unlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treiserfs_write_unlock(inode->i_sb);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 2355
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "sb"
          ],
          "line": 2339
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int reiserfs_remount(struct super_block *s, int *flags, char *data);\nstatic const arg_desc_t tails[] = {\n\t{\"on\", 1 << REISERFS_LARGETAIL, 1 << REISERFS_SMALLTAIL},\n\t{\"off\", 0, (1 << REISERFS_LARGETAIL) | (1 << REISERFS_SMALLTAIL)},\n\t{\"small\", 1 << REISERFS_SMALLTAIL, 1 << REISERFS_LARGETAIL},\n\t{NULL, 0, 0}\n};\n\nstatic int reiserfs_quota_on(struct super_block *sb, int type, int format_id,\n\t\t\t     struct path *path)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct reiserfs_transaction_handle th;\n\tint opt = type == USRQUOTA ? REISERFS_USRQUOTA : REISERFS_GRPQUOTA;\n\n\treiserfs_write_lock(sb);\n\tif (!(REISERFS_SB(sb)->s_mount_opt & (1 << opt))) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Quotafile not on the same filesystem? */\n\tif (path->dentry->d_sb != sb) {\n\t\terr = -EXDEV;\n\t\tgoto out;\n\t}\n\tinode = path->dentry->d_inode;\n\t/*\n\t * We must not pack tails for quota files on reiserfs for quota\n\t * IO to work\n\t */\n\tif (!(REISERFS_I(inode)->i_flags & i_nopack_mask)) {\n\t\terr = reiserfs_unpack(inode, NULL);\n\t\tif (err) {\n\t\t\treiserfs_warning(sb, \"super-6520\",\n\t\t\t\t\"Unpacking tail of quota file failed\"\n\t\t\t\t\" (%d). Cannot turn on quotas.\", err);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmark_inode_dirty(inode);\n\t}\n\t/* Journaling quota? */\n\tif (REISERFS_SB(sb)->s_qf_names[type]) {\n\t\t/* Quotafile not of fs root? */\n\t\tif (path->dentry->d_parent != sb->s_root)\n\t\t\treiserfs_warning(sb, \"super-6521\",\n\t\t\t\t \"Quota file not on filesystem root. \"\n\t\t\t\t \"Journalled quota will not work.\");\n\t}\n\n\t/*\n\t * When we journal data on quota file, we have to flush journal to see\n\t * all updates to the file when we bypass pagecache...\n\t */\n\tif (reiserfs_file_data_log(inode)) {\n\t\t/* Just start temporary transaction and finish it */\n\t\terr = journal_begin(&th, sb, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = journal_end_sync(&th);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\treiserfs_write_unlock(sb);\n\treturn dquot_quota_on(sb, type, format_id, path);\nout:\n\treiserfs_write_unlock(sb);\n\treturn err;\n}"
  },
  {
    "function_name": "reiserfs_quota_on_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "2322-2326",
    "snippet": "static int reiserfs_quota_on_mount(struct super_block *sb, int type)\n{\n\treturn dquot_quota_on_mount(sb, REISERFS_SB(sb)->s_qf_names[type],\n\t\t\t\t\tREISERFS_SB(sb)->s_jquota_fmt, type);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dquot_quota_on_mount",
          "args": [
            "sb",
            "REISERFS_SB(sb)->s_qf_names[type]",
            "REISERFS_SB(sb)->s_jquota_fmt",
            "type"
          ],
          "line": 2324
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_quota_on_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "2360-2385",
          "snippet": "int dquot_quota_on_mount(struct super_block *sb, char *qf_name,\n\t\tint format_id, int type)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\tmutex_lock(&sb->s_root->d_inode->i_mutex);\n\tdentry = lookup_one_len(qf_name, sb->s_root, strlen(qf_name));\n\tmutex_unlock(&sb->s_root->d_inode->i_mutex);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tif (!dentry->d_inode) {\n\t\terror = -ENOENT;\n\t\tgoto out;\n\t}\n\n\terror = security_quota_on(dentry);\n\tif (!error)\n\t\terror = vfs_load_quota_inode(dentry->d_inode, type, format_id,\n\t\t\t\tDQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\nout:\n\tdput(dentry);\n\treturn error;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_quota_on_mount(struct super_block *sb, char *qf_name,\n\t\tint format_id, int type)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\tmutex_lock(&sb->s_root->d_inode->i_mutex);\n\tdentry = lookup_one_len(qf_name, sb->s_root, strlen(qf_name));\n\tmutex_unlock(&sb->s_root->d_inode->i_mutex);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tif (!dentry->d_inode) {\n\t\terror = -ENOENT;\n\t\tgoto out;\n\t}\n\n\terror = security_quota_on(dentry);\n\tif (!error)\n\t\terror = vfs_load_quota_inode(dentry->d_inode, type, format_id,\n\t\t\t\tDQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\nout:\n\tdput(dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "sb"
          ],
          "line": 2325
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int reiserfs_quota_on_mount(struct super_block *sb, int type)\n{\n\treturn dquot_quota_on_mount(sb, REISERFS_SB(sb)->s_qf_names[type],\n\t\t\t\t\tREISERFS_SB(sb)->s_jquota_fmt, type);\n}"
  },
  {
    "function_name": "reiserfs_write_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "2297-2317",
    "snippet": "static int reiserfs_write_info(struct super_block *sb, int type)\n{\n\tstruct reiserfs_transaction_handle th;\n\tint ret, err;\n\tint depth;\n\n\t/* Data block + inode block */\n\treiserfs_write_lock(sb);\n\tret = journal_begin(&th, sb, 2);\n\tif (ret)\n\t\tgoto out;\n\tdepth = reiserfs_write_unlock_nested(sb);\n\tret = dquot_commit_info(sb, type);\n\treiserfs_write_lock_nested(sb, depth);\n\terr = journal_end(&th);\n\tif (!ret && err)\n\t\tret = err;\nout:\n\treiserfs_write_unlock(sb);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "sb"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "&th"
          ],
          "line": 2311
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "sb",
            "depth"
          ],
          "line": 2310
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_commit_info",
          "args": [
            "sb",
            "type"
          ],
          "line": 2309
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_commit_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1956-1965",
          "snippet": "int dquot_commit_info(struct super_block *sb, int type)\n{\n\tint ret;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\n\tmutex_lock(&dqopt->dqio_mutex);\n\tret = dqopt->ops[type]->write_file_info(sb, type);\n\tmutex_unlock(&dqopt->dqio_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_commit_info(struct super_block *sb, int type)\n{\n\tint ret;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\n\tmutex_lock(&dqopt->dqio_mutex);\n\tret = dqopt->ops[type]->write_file_info(sb, type);\n\tmutex_unlock(&dqopt->dqio_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "sb",
            "2"
          ],
          "line": 2305
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "sb"
          ],
          "line": 2304
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int reiserfs_write_info(struct super_block *sb, int type)\n{\n\tstruct reiserfs_transaction_handle th;\n\tint ret, err;\n\tint depth;\n\n\t/* Data block + inode block */\n\treiserfs_write_lock(sb);\n\tret = journal_begin(&th, sb, 2);\n\tif (ret)\n\t\tgoto out;\n\tdepth = reiserfs_write_unlock_nested(sb);\n\tret = dquot_commit_info(sb, type);\n\treiserfs_write_lock_nested(sb, depth);\n\terr = journal_end(&th);\n\tif (!ret && err)\n\t\tret = err;\nout:\n\treiserfs_write_unlock(sb);\n\treturn ret;\n}"
  },
  {
    "function_name": "reiserfs_mark_dquot_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "2286-2295",
    "snippet": "static int reiserfs_mark_dquot_dirty(struct dquot *dquot)\n{\n\t/* Are we journaling quotas? */\n\tif (REISERFS_SB(dquot->dq_sb)->s_qf_names[USRQUOTA] ||\n\t    REISERFS_SB(dquot->dq_sb)->s_qf_names[GRPQUOTA]) {\n\t\tdquot_mark_dquot_dirty(dquot);\n\t\treturn reiserfs_write_dquot(dquot);\n\t} else\n\t\treturn dquot_mark_dquot_dirty(dquot);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dquot_mark_dquot_dirty",
          "args": [
            "dquot"
          ],
          "line": 2294
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_mark_dquot_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "341-357",
          "snippet": "int dquot_mark_dquot_dirty(struct dquot *dquot)\n{\n\tint ret = 1;\n\n\t/* If quota is dirty already, we don't have to acquire dq_list_lock */\n\tif (test_bit(DQ_MOD_B, &dquot->dq_flags))\n\t\treturn 1;\n\n\tspin_lock(&dq_list_lock);\n\tif (!test_and_set_bit(DQ_MOD_B, &dquot->dq_flags)) {\n\t\tlist_add(&dquot->dq_dirty, &sb_dqopt(dquot->dq_sb)->\n\t\t\t\tinfo[dquot->dq_id.type].dqi_dirty_list);\n\t\tret = 0;\n\t}\n\tspin_unlock(&dq_list_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_mark_dquot_dirty(struct dquot *dquot)\n{\n\tint ret = 1;\n\n\t/* If quota is dirty already, we don't have to acquire dq_list_lock */\n\tif (test_bit(DQ_MOD_B, &dquot->dq_flags))\n\t\treturn 1;\n\n\tspin_lock(&dq_list_lock);\n\tif (!test_and_set_bit(DQ_MOD_B, &dquot->dq_flags)) {\n\t\tlist_add(&dquot->dq_dirty, &sb_dqopt(dquot->dq_sb)->\n\t\t\t\tinfo[dquot->dq_id.type].dqi_dirty_list);\n\t\tret = 0;\n\t}\n\tspin_unlock(&dq_list_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_dquot",
          "args": [
            "dquot"
          ],
          "line": 2292
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "2215-2236",
          "snippet": "static int reiserfs_write_dquot(struct dquot *dquot)\n{\n\tstruct reiserfs_transaction_handle th;\n\tint ret, err;\n\tint depth;\n\n\treiserfs_write_lock(dquot->dq_sb);\n\tret =\n\t    journal_begin(&th, dquot->dq_sb,\n\t\t\t  REISERFS_QUOTA_TRANS_BLOCKS(dquot->dq_sb));\n\tif (ret)\n\t\tgoto out;\n\tdepth = reiserfs_write_unlock_nested(dquot->dq_sb);\n\tret = dquot_commit(dquot);\n\treiserfs_write_lock_nested(dquot->dq_sb, depth);\n\terr = journal_end(&th);\n\tif (!ret && err)\n\t\tret = err;\nout:\n\treiserfs_write_unlock(dquot->dq_sb);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int reiserfs_write_dquot(struct dquot *dquot)\n{\n\tstruct reiserfs_transaction_handle th;\n\tint ret, err;\n\tint depth;\n\n\treiserfs_write_lock(dquot->dq_sb);\n\tret =\n\t    journal_begin(&th, dquot->dq_sb,\n\t\t\t  REISERFS_QUOTA_TRANS_BLOCKS(dquot->dq_sb));\n\tif (ret)\n\t\tgoto out;\n\tdepth = reiserfs_write_unlock_nested(dquot->dq_sb);\n\tret = dquot_commit(dquot);\n\treiserfs_write_lock_nested(dquot->dq_sb, depth);\n\terr = journal_end(&th);\n\tif (!ret && err)\n\t\tret = err;\nout:\n\treiserfs_write_unlock(dquot->dq_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "dquot->dq_sb"
          ],
          "line": 2290
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int reiserfs_mark_dquot_dirty(struct dquot *dquot)\n{\n\t/* Are we journaling quotas? */\n\tif (REISERFS_SB(dquot->dq_sb)->s_qf_names[USRQUOTA] ||\n\t    REISERFS_SB(dquot->dq_sb)->s_qf_names[GRPQUOTA]) {\n\t\tdquot_mark_dquot_dirty(dquot);\n\t\treturn reiserfs_write_dquot(dquot);\n\t} else\n\t\treturn dquot_mark_dquot_dirty(dquot);\n}"
  },
  {
    "function_name": "reiserfs_release_dquot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "2261-2284",
    "snippet": "static int reiserfs_release_dquot(struct dquot *dquot)\n{\n\tstruct reiserfs_transaction_handle th;\n\tint ret, err;\n\n\treiserfs_write_lock(dquot->dq_sb);\n\tret =\n\t    journal_begin(&th, dquot->dq_sb,\n\t\t\t  REISERFS_QUOTA_DEL_BLOCKS(dquot->dq_sb));\n\treiserfs_write_unlock(dquot->dq_sb);\n\tif (ret) {\n\t\t/* Release dquot anyway to avoid endless cycle in dqput() */\n\t\tdquot_release(dquot);\n\t\tgoto out;\n\t}\n\tret = dquot_release(dquot);\n\treiserfs_write_lock(dquot->dq_sb);\n\terr = journal_end(&th);\n\tif (!ret && err)\n\t\tret = err;\n\treiserfs_write_unlock(dquot->dq_sb);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "dquot->dq_sb"
          ],
          "line": 2281
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "&th"
          ],
          "line": 2278
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "dquot->dq_sb"
          ],
          "line": 2277
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_release",
          "args": [
            "dquot"
          ],
          "line": 2276
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "468-493",
          "snippet": "int dquot_release(struct dquot *dquot)\n{\n\tint ret = 0, ret2 = 0;\n\tstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\n\n\tmutex_lock(&dquot->dq_lock);\n\t/* Check whether we are not racing with some other dqget() */\n\tif (atomic_read(&dquot->dq_count) > 1)\n\t\tgoto out_dqlock;\n\tmutex_lock(&dqopt->dqio_mutex);\n\tif (dqopt->ops[dquot->dq_id.type]->release_dqblk) {\n\t\tret = dqopt->ops[dquot->dq_id.type]->release_dqblk(dquot);\n\t\t/* Write the info */\n\t\tif (info_dirty(&dqopt->info[dquot->dq_id.type])) {\n\t\t\tret2 = dqopt->ops[dquot->dq_id.type]->write_file_info(\n\t\t\t\t\t\tdquot->dq_sb, dquot->dq_id.type);\n\t\t}\n\t\tif (ret >= 0)\n\t\t\tret = ret2;\n\t}\n\tclear_bit(DQ_ACTIVE_B, &dquot->dq_flags);\n\tmutex_unlock(&dqopt->dqio_mutex);\nout_dqlock:\n\tmutex_unlock(&dquot->dq_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_release(struct dquot *dquot)\n{\n\tint ret = 0, ret2 = 0;\n\tstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\n\n\tmutex_lock(&dquot->dq_lock);\n\t/* Check whether we are not racing with some other dqget() */\n\tif (atomic_read(&dquot->dq_count) > 1)\n\t\tgoto out_dqlock;\n\tmutex_lock(&dqopt->dqio_mutex);\n\tif (dqopt->ops[dquot->dq_id.type]->release_dqblk) {\n\t\tret = dqopt->ops[dquot->dq_id.type]->release_dqblk(dquot);\n\t\t/* Write the info */\n\t\tif (info_dirty(&dqopt->info[dquot->dq_id.type])) {\n\t\t\tret2 = dqopt->ops[dquot->dq_id.type]->write_file_info(\n\t\t\t\t\t\tdquot->dq_sb, dquot->dq_id.type);\n\t\t}\n\t\tif (ret >= 0)\n\t\t\tret = ret2;\n\t}\n\tclear_bit(DQ_ACTIVE_B, &dquot->dq_flags);\n\tmutex_unlock(&dqopt->dqio_mutex);\nout_dqlock:\n\tmutex_unlock(&dquot->dq_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "dquot->dq_sb",
            "REISERFS_QUOTA_DEL_BLOCKS(dquot->dq_sb)"
          ],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_QUOTA_DEL_BLOCKS",
          "args": [
            "dquot->dq_sb"
          ],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int reiserfs_release_dquot(struct dquot *dquot)\n{\n\tstruct reiserfs_transaction_handle th;\n\tint ret, err;\n\n\treiserfs_write_lock(dquot->dq_sb);\n\tret =\n\t    journal_begin(&th, dquot->dq_sb,\n\t\t\t  REISERFS_QUOTA_DEL_BLOCKS(dquot->dq_sb));\n\treiserfs_write_unlock(dquot->dq_sb);\n\tif (ret) {\n\t\t/* Release dquot anyway to avoid endless cycle in dqput() */\n\t\tdquot_release(dquot);\n\t\tgoto out;\n\t}\n\tret = dquot_release(dquot);\n\treiserfs_write_lock(dquot->dq_sb);\n\terr = journal_end(&th);\n\tif (!ret && err)\n\t\tret = err;\n\treiserfs_write_unlock(dquot->dq_sb);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "reiserfs_acquire_dquot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "2238-2259",
    "snippet": "static int reiserfs_acquire_dquot(struct dquot *dquot)\n{\n\tstruct reiserfs_transaction_handle th;\n\tint ret, err;\n\tint depth;\n\n\treiserfs_write_lock(dquot->dq_sb);\n\tret =\n\t    journal_begin(&th, dquot->dq_sb,\n\t\t\t  REISERFS_QUOTA_INIT_BLOCKS(dquot->dq_sb));\n\tif (ret)\n\t\tgoto out;\n\tdepth = reiserfs_write_unlock_nested(dquot->dq_sb);\n\tret = dquot_acquire(dquot);\n\treiserfs_write_lock_nested(dquot->dq_sb, depth);\n\terr = journal_end(&th);\n\tif (!ret && err)\n\t\tret = err;\nout:\n\treiserfs_write_unlock(dquot->dq_sb);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "dquot->dq_sb"
          ],
          "line": 2257
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "&th"
          ],
          "line": 2253
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "dquot->dq_sb",
            "depth"
          ],
          "line": 2252
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_acquire",
          "args": [
            "dquot"
          ],
          "line": 2251
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_acquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "403-435",
          "snippet": "int dquot_acquire(struct dquot *dquot)\n{\n\tint ret = 0, ret2 = 0;\n\tstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\n\n\tmutex_lock(&dquot->dq_lock);\n\tmutex_lock(&dqopt->dqio_mutex);\n\tif (!test_bit(DQ_READ_B, &dquot->dq_flags))\n\t\tret = dqopt->ops[dquot->dq_id.type]->read_dqblk(dquot);\n\tif (ret < 0)\n\t\tgoto out_iolock;\n\tset_bit(DQ_READ_B, &dquot->dq_flags);\n\t/* Instantiate dquot if needed */\n\tif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags) && !dquot->dq_off) {\n\t\tret = dqopt->ops[dquot->dq_id.type]->commit_dqblk(dquot);\n\t\t/* Write the info if needed */\n\t\tif (info_dirty(&dqopt->info[dquot->dq_id.type])) {\n\t\t\tret2 = dqopt->ops[dquot->dq_id.type]->write_file_info(\n\t\t\t\t\tdquot->dq_sb, dquot->dq_id.type);\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto out_iolock;\n\t\tif (ret2 < 0) {\n\t\t\tret = ret2;\n\t\t\tgoto out_iolock;\n\t\t}\n\t}\n\tset_bit(DQ_ACTIVE_B, &dquot->dq_flags);\nout_iolock:\n\tmutex_unlock(&dqopt->dqio_mutex);\n\tmutex_unlock(&dquot->dq_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_acquire(struct dquot *dquot)\n{\n\tint ret = 0, ret2 = 0;\n\tstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\n\n\tmutex_lock(&dquot->dq_lock);\n\tmutex_lock(&dqopt->dqio_mutex);\n\tif (!test_bit(DQ_READ_B, &dquot->dq_flags))\n\t\tret = dqopt->ops[dquot->dq_id.type]->read_dqblk(dquot);\n\tif (ret < 0)\n\t\tgoto out_iolock;\n\tset_bit(DQ_READ_B, &dquot->dq_flags);\n\t/* Instantiate dquot if needed */\n\tif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags) && !dquot->dq_off) {\n\t\tret = dqopt->ops[dquot->dq_id.type]->commit_dqblk(dquot);\n\t\t/* Write the info if needed */\n\t\tif (info_dirty(&dqopt->info[dquot->dq_id.type])) {\n\t\t\tret2 = dqopt->ops[dquot->dq_id.type]->write_file_info(\n\t\t\t\t\tdquot->dq_sb, dquot->dq_id.type);\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto out_iolock;\n\t\tif (ret2 < 0) {\n\t\t\tret = ret2;\n\t\t\tgoto out_iolock;\n\t\t}\n\t}\n\tset_bit(DQ_ACTIVE_B, &dquot->dq_flags);\nout_iolock:\n\tmutex_unlock(&dqopt->dqio_mutex);\n\tmutex_unlock(&dquot->dq_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "dquot->dq_sb",
            "REISERFS_QUOTA_INIT_BLOCKS(dquot->dq_sb)"
          ],
          "line": 2246
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_QUOTA_INIT_BLOCKS",
          "args": [
            "dquot->dq_sb"
          ],
          "line": 2247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "dquot->dq_sb"
          ],
          "line": 2244
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int reiserfs_acquire_dquot(struct dquot *dquot)\n{\n\tstruct reiserfs_transaction_handle th;\n\tint ret, err;\n\tint depth;\n\n\treiserfs_write_lock(dquot->dq_sb);\n\tret =\n\t    journal_begin(&th, dquot->dq_sb,\n\t\t\t  REISERFS_QUOTA_INIT_BLOCKS(dquot->dq_sb));\n\tif (ret)\n\t\tgoto out;\n\tdepth = reiserfs_write_unlock_nested(dquot->dq_sb);\n\tret = dquot_acquire(dquot);\n\treiserfs_write_lock_nested(dquot->dq_sb, depth);\n\terr = journal_end(&th);\n\tif (!ret && err)\n\t\tret = err;\nout:\n\treiserfs_write_unlock(dquot->dq_sb);\n\treturn ret;\n}"
  },
  {
    "function_name": "reiserfs_write_dquot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "2215-2236",
    "snippet": "static int reiserfs_write_dquot(struct dquot *dquot)\n{\n\tstruct reiserfs_transaction_handle th;\n\tint ret, err;\n\tint depth;\n\n\treiserfs_write_lock(dquot->dq_sb);\n\tret =\n\t    journal_begin(&th, dquot->dq_sb,\n\t\t\t  REISERFS_QUOTA_TRANS_BLOCKS(dquot->dq_sb));\n\tif (ret)\n\t\tgoto out;\n\tdepth = reiserfs_write_unlock_nested(dquot->dq_sb);\n\tret = dquot_commit(dquot);\n\treiserfs_write_lock_nested(dquot->dq_sb, depth);\n\terr = journal_end(&th);\n\tif (!ret && err)\n\t\tret = err;\nout:\n\treiserfs_write_unlock(dquot->dq_sb);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "dquot->dq_sb"
          ],
          "line": 2234
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "&th"
          ],
          "line": 2230
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "dquot->dq_sb",
            "depth"
          ],
          "line": 2229
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_commit",
          "args": [
            "dquot"
          ],
          "line": 2228
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "441-462",
          "snippet": "int dquot_commit(struct dquot *dquot)\n{\n\tint ret = 0;\n\tstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\n\n\tmutex_lock(&dqopt->dqio_mutex);\n\tspin_lock(&dq_list_lock);\n\tif (!clear_dquot_dirty(dquot)) {\n\t\tspin_unlock(&dq_list_lock);\n\t\tgoto out_sem;\n\t}\n\tspin_unlock(&dq_list_lock);\n\t/* Inactive dquot can be only if there was error during read/init\n\t * => we have better not writing it */\n\tif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags))\n\t\tret = dqopt->ops[dquot->dq_id.type]->commit_dqblk(dquot);\n\telse\n\t\tret = -EIO;\nout_sem:\n\tmutex_unlock(&dqopt->dqio_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_commit(struct dquot *dquot)\n{\n\tint ret = 0;\n\tstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\n\n\tmutex_lock(&dqopt->dqio_mutex);\n\tspin_lock(&dq_list_lock);\n\tif (!clear_dquot_dirty(dquot)) {\n\t\tspin_unlock(&dq_list_lock);\n\t\tgoto out_sem;\n\t}\n\tspin_unlock(&dq_list_lock);\n\t/* Inactive dquot can be only if there was error during read/init\n\t * => we have better not writing it */\n\tif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags))\n\t\tret = dqopt->ops[dquot->dq_id.type]->commit_dqblk(dquot);\n\telse\n\t\tret = -EIO;\nout_sem:\n\tmutex_unlock(&dqopt->dqio_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "dquot->dq_sb",
            "REISERFS_QUOTA_TRANS_BLOCKS(dquot->dq_sb)"
          ],
          "line": 2223
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_QUOTA_TRANS_BLOCKS",
          "args": [
            "dquot->dq_sb"
          ],
          "line": 2224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "dquot->dq_sb"
          ],
          "line": 2221
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int reiserfs_write_dquot(struct dquot *dquot)\n{\n\tstruct reiserfs_transaction_handle th;\n\tint ret, err;\n\tint depth;\n\n\treiserfs_write_lock(dquot->dq_sb);\n\tret =\n\t    journal_begin(&th, dquot->dq_sb,\n\t\t\t  REISERFS_QUOTA_TRANS_BLOCKS(dquot->dq_sb));\n\tif (ret)\n\t\tgoto out;\n\tdepth = reiserfs_write_unlock_nested(dquot->dq_sb);\n\tret = dquot_commit(dquot);\n\treiserfs_write_lock_nested(dquot->dq_sb, depth);\n\terr = journal_end(&th);\n\tif (!ret && err)\n\t\tret = err;\nout:\n\treiserfs_write_unlock(dquot->dq_sb);\n\treturn ret;\n}"
  },
  {
    "function_name": "reiserfs_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "2196-2212",
    "snippet": "static int reiserfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(dentry->d_sb);\n\n\tbuf->f_namelen = (REISERFS_MAX_NAME(s->s_blocksize));\n\tbuf->f_bfree = sb_free_blocks(rs);\n\tbuf->f_bavail = buf->f_bfree;\n\tbuf->f_blocks = sb_block_count(rs) - sb_bmap_nr(rs) - 1;\n\tbuf->f_bsize = dentry->d_sb->s_blocksize;\n\t/* changed to accommodate gcc folks. */\n\tbuf->f_type = REISERFS_SUPER_MAGIC;\n\tbuf->f_fsid.val[0] = (u32)crc32_le(0, rs->s_uuid, sizeof(rs->s_uuid)/2);\n\tbuf->f_fsid.val[1] = (u32)crc32_le(0, rs->s_uuid + sizeof(rs->s_uuid)/2,\n\t\t\t\tsizeof(rs->s_uuid)/2);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int reiserfs_statfs(struct dentry *dentry, struct kstatfs *buf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "crc32_le",
          "args": [
            "0",
            "rs->s_uuid + sizeof(rs->s_uuid)/2",
            "sizeof(rs->s_uuid)/2"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc32_le",
          "args": [
            "0",
            "rs->s_uuid",
            "sizeof(rs->s_uuid)/2"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bmap_nr",
          "args": [
            "rs"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_block_count",
          "args": [
            "rs"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_free_blocks",
          "args": [
            "rs"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_MAX_NAME",
          "args": [
            "s->s_blocksize"
          ],
          "line": 2200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_DISK_SUPER_BLOCK",
          "args": [
            "dentry->d_sb"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int reiserfs_statfs(struct dentry *dentry, struct kstatfs *buf);\n\nstatic int reiserfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(dentry->d_sb);\n\n\tbuf->f_namelen = (REISERFS_MAX_NAME(s->s_blocksize));\n\tbuf->f_bfree = sb_free_blocks(rs);\n\tbuf->f_bavail = buf->f_bfree;\n\tbuf->f_blocks = sb_block_count(rs) - sb_bmap_nr(rs) - 1;\n\tbuf->f_bsize = dentry->d_sb->s_blocksize;\n\t/* changed to accommodate gcc folks. */\n\tbuf->f_type = REISERFS_SUPER_MAGIC;\n\tbuf->f_fsid.val[0] = (u32)crc32_le(0, rs->s_uuid, sizeof(rs->s_uuid)/2);\n\tbuf->f_fsid.val[1] = (u32)crc32_le(0, rs->s_uuid + sizeof(rs->s_uuid)/2,\n\t\t\t\tsizeof(rs->s_uuid)/2);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "reiserfs_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "1845-2194",
    "snippet": "static int reiserfs_fill_super(struct super_block *s, void *data, int silent)\n{\n\tstruct inode *root_inode;\n\tstruct reiserfs_transaction_handle th;\n\tint old_format = 0;\n\tunsigned long blocks;\n\tunsigned int commit_max_age = 0;\n\tint jinit_done = 0;\n\tstruct reiserfs_iget_args args;\n\tstruct reiserfs_super_block *rs;\n\tchar *jdev_name;\n\tstruct reiserfs_sb_info *sbi;\n\tint errval = -EINVAL;\n\tchar *qf_names[REISERFS_MAXQUOTAS] = {};\n\tunsigned int qfmt = 0;\n\n\tsave_mount_options(s, data);\n\n\tsbi = kzalloc(sizeof(struct reiserfs_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\ts->s_fs_info = sbi;\n\t/* Set default values for options: non-aggressive tails, RO on errors */\n\tsbi->s_mount_opt |= (1 << REISERFS_SMALLTAIL);\n\tsbi->s_mount_opt |= (1 << REISERFS_ERROR_RO);\n\tsbi->s_mount_opt |= (1 << REISERFS_BARRIER_FLUSH);\n\t/* no preallocation minimum, be smart in reiserfs_file_write instead */\n\tsbi->s_alloc_options.preallocmin = 0;\n\t/* Preallocate by 16 blocks (17-1) at once */\n\tsbi->s_alloc_options.preallocsize = 17;\n\t/* setup default block allocator options */\n\treiserfs_init_alloc_options(s);\n\n\tspin_lock_init(&sbi->old_work_lock);\n\tINIT_DELAYED_WORK(&sbi->old_work, flush_old_commits);\n\tmutex_init(&sbi->lock);\n\tsbi->lock_depth = -1;\n\n\tsbi->commit_wq = alloc_workqueue(\"reiserfs/%s\", WQ_MEM_RECLAIM, 0,\n\t\t\t\t\t s->s_id);\n\tif (!sbi->commit_wq) {\n\t\tSWARN(silent, s, \"\", \"Cannot allocate commit workqueue\");\n\t\terrval = -ENOMEM;\n\t\tgoto error_unlocked;\n\t}\n\n\tjdev_name = NULL;\n\tif (reiserfs_parse_options\n\t    (s, (char *)data, &sbi->s_mount_opt, &blocks, &jdev_name,\n\t     &commit_max_age, qf_names, &qfmt) == 0) {\n\t\tgoto error_unlocked;\n\t}\n\tif (jdev_name && jdev_name[0]) {\n\t\tsbi->s_jdev = kstrdup(jdev_name, GFP_KERNEL);\n\t\tif (!sbi->s_jdev) {\n\t\t\tSWARN(silent, s, \"\", \"Cannot allocate memory for \"\n\t\t\t\t\"journal device name\");\n\t\t\tgoto error;\n\t\t}\n\t}\n#ifdef CONFIG_QUOTA\n\thandle_quota_files(s, qf_names, &qfmt);\n#endif\n\n\tif (blocks) {\n\t\tSWARN(silent, s, \"jmacd-7\", \"resize option for remount only\");\n\t\tgoto error_unlocked;\n\t}\n\n\t/*\n\t * try old format (undistributed bitmap, super block in 8-th 1k\n\t * block of a device)\n\t */\n\tif (!read_super_block(s, REISERFS_OLD_DISK_OFFSET_IN_BYTES))\n\t\told_format = 1;\n\n\t/*\n\t * try new format (64-th 1k block), which can contain reiserfs\n\t * super block\n\t */\n\telse if (read_super_block(s, REISERFS_DISK_OFFSET_IN_BYTES)) {\n\t\tSWARN(silent, s, \"sh-2021\", \"can not find reiserfs on %s\",\n\t\t      s->s_id);\n\t\tgoto error_unlocked;\n\t}\n\n\trs = SB_DISK_SUPER_BLOCK(s);\n\t/*\n\t * Let's do basic sanity check to verify that underlying device is not\n\t * smaller than the filesystem. If the check fails then abort and\n\t * scream, because bad stuff will happen otherwise.\n\t */\n\tif (s->s_bdev && s->s_bdev->bd_inode\n\t    && i_size_read(s->s_bdev->bd_inode) <\n\t    sb_block_count(rs) * sb_blocksize(rs)) {\n\t\tSWARN(silent, s, \"\", \"Filesystem cannot be \"\n\t\t      \"mounted because it is bigger than the device\");\n\t\tSWARN(silent, s, \"\", \"You may need to run fsck \"\n\t\t      \"or increase size of your LVM partition\");\n\t\tSWARN(silent, s, \"\", \"Or may be you forgot to \"\n\t\t      \"reboot after fdisk when it told you to\");\n\t\tgoto error_unlocked;\n\t}\n\n\tsbi->s_mount_state = SB_REISERFS_STATE(s);\n\tsbi->s_mount_state = REISERFS_VALID_FS;\n\n\tif ((errval = reiserfs_init_bitmap_cache(s))) {\n\t\tSWARN(silent, s, \"jmacd-8\", \"unable to read bitmap\");\n\t\tgoto error_unlocked;\n\t}\n\n\terrval = -EINVAL;\n#ifdef CONFIG_REISERFS_CHECK\n\tSWARN(silent, s, \"\", \"CONFIG_REISERFS_CHECK is set ON\");\n\tSWARN(silent, s, \"\", \"- it is slow mode for debugging.\");\n#endif\n\n\t/* make data=ordered the default */\n\tif (!reiserfs_data_log(s) && !reiserfs_data_ordered(s) &&\n\t    !reiserfs_data_writeback(s)) {\n\t\tsbi->s_mount_opt |= (1 << REISERFS_DATA_ORDERED);\n\t}\n\n\tif (reiserfs_data_log(s)) {\n\t\treiserfs_info(s, \"using journaled data mode\\n\");\n\t} else if (reiserfs_data_ordered(s)) {\n\t\treiserfs_info(s, \"using ordered data mode\\n\");\n\t} else {\n\t\treiserfs_info(s, \"using writeback data mode\\n\");\n\t}\n\tif (reiserfs_barrier_flush(s)) {\n\t\tprintk(\"reiserfs: using flush barriers\\n\");\n\t}\n\n\tif (journal_init(s, jdev_name, old_format, commit_max_age)) {\n\t\tSWARN(silent, s, \"sh-2022\",\n\t\t      \"unable to initialize journal space\");\n\t\tgoto error_unlocked;\n\t} else {\n\t\t/*\n\t\t * once this is set, journal_release must be called\n\t\t * if we error out of the mount\n\t\t */\n\t\tjinit_done = 1;\n\t}\n\n\tif (reread_meta_blocks(s)) {\n\t\tSWARN(silent, s, \"jmacd-9\",\n\t\t      \"unable to reread meta blocks after journal init\");\n\t\tgoto error_unlocked;\n\t}\n\n\tif (replay_only(s))\n\t\tgoto error_unlocked;\n\n\tif (bdev_read_only(s->s_bdev) && !(s->s_flags & MS_RDONLY)) {\n\t\tSWARN(silent, s, \"clm-7000\",\n\t\t      \"Detected readonly device, marking FS readonly\");\n\t\ts->s_flags |= MS_RDONLY;\n\t}\n\targs.objectid = REISERFS_ROOT_OBJECTID;\n\targs.dirid = REISERFS_ROOT_PARENT_OBJECTID;\n\troot_inode =\n\t    iget5_locked(s, REISERFS_ROOT_OBJECTID, reiserfs_find_actor,\n\t\t\t reiserfs_init_locked_inode, (void *)&args);\n\tif (!root_inode) {\n\t\tSWARN(silent, s, \"jmacd-10\", \"get root inode failed\");\n\t\tgoto error_unlocked;\n\t}\n\n\t/*\n\t * This path assumed to be called with the BKL in the old times.\n\t * Now we have inherited the big reiserfs lock from it and many\n\t * reiserfs helpers called in the mount path and elsewhere require\n\t * this lock to be held even if it's not always necessary. Let's be\n\t * conservative and hold it early. The window can be reduced after\n\t * careful review of the code.\n\t */\n\treiserfs_write_lock(s);\n\n\tif (root_inode->i_state & I_NEW) {\n\t\treiserfs_read_locked_inode(root_inode, &args);\n\t\tunlock_new_inode(root_inode);\n\t}\n\n\ts->s_root = d_make_root(root_inode);\n\tif (!s->s_root)\n\t\tgoto error;\n\t/* define and initialize hash function */\n\tsbi->s_hash_function = hash_function(s);\n\tif (sbi->s_hash_function == NULL) {\n\t\tdput(s->s_root);\n\t\ts->s_root = NULL;\n\t\tgoto error;\n\t}\n\n\tif (is_reiserfs_3_5(rs)\n\t    || (is_reiserfs_jr(rs) && SB_VERSION(s) == REISERFS_VERSION_1))\n\t\tset_bit(REISERFS_3_5, &sbi->s_properties);\n\telse if (old_format)\n\t\tset_bit(REISERFS_OLD_FORMAT, &sbi->s_properties);\n\telse\n\t\tset_bit(REISERFS_3_6, &sbi->s_properties);\n\n\tif (!(s->s_flags & MS_RDONLY)) {\n\n\t\terrval = journal_begin(&th, s, 1);\n\t\tif (errval) {\n\t\t\tdput(s->s_root);\n\t\t\ts->s_root = NULL;\n\t\t\tgoto error;\n\t\t}\n\t\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);\n\n\t\tset_sb_umount_state(rs, REISERFS_ERROR_FS);\n\t\tset_sb_fs_state(rs, 0);\n\n\t\t/*\n\t\t * Clear out s_bmap_nr if it would wrap. We can handle this\n\t\t * case, but older revisions can't. This will cause the\n\t\t * file system to fail mount on those older implementations,\n\t\t * avoiding corruption. -jeffm\n\t\t */\n\t\tif (bmap_would_wrap(reiserfs_bmap_count(s)) &&\n\t\t    sb_bmap_nr(rs) != 0) {\n\t\t\treiserfs_warning(s, \"super-2030\", \"This file system \"\n\t\t\t\t\t\"claims to use %u bitmap blocks in \"\n\t\t\t\t\t\"its super block, but requires %u. \"\n\t\t\t\t\t\"Clearing to zero.\", sb_bmap_nr(rs),\n\t\t\t\t\treiserfs_bmap_count(s));\n\n\t\t\tset_sb_bmap_nr(rs, 0);\n\t\t}\n\n\t\tif (old_format_only(s)) {\n\t\t\t/*\n\t\t\t * filesystem of format 3.5 either with standard\n\t\t\t * or non-standard journal\n\t\t\t */\n\t\t\tif (convert_reiserfs(s)) {\n\t\t\t\t/* and -o conv is given */\n\t\t\t\tif (!silent)\n\t\t\t\t\treiserfs_info(s,\n\t\t\t\t\t\t      \"converting 3.5 filesystem to the 3.6 format\");\n\n\t\t\t\tif (is_reiserfs_3_5(rs))\n\t\t\t\t\t/*\n\t\t\t\t\t * put magic string of 3.6 format.\n\t\t\t\t\t * 2.2 will not be able to\n\t\t\t\t\t * mount this filesystem anymore\n\t\t\t\t\t */\n\t\t\t\t\tmemcpy(rs->s_v1.s_magic,\n\t\t\t\t\t       reiserfs_3_6_magic_string,\n\t\t\t\t\t       sizeof\n\t\t\t\t\t       (reiserfs_3_6_magic_string));\n\n\t\t\t\tset_sb_version(rs, REISERFS_VERSION_2);\n\t\t\t\treiserfs_convert_objectid_map_v1(s);\n\t\t\t\tset_bit(REISERFS_3_6, &sbi->s_properties);\n\t\t\t\tclear_bit(REISERFS_3_5, &sbi->s_properties);\n\t\t\t} else if (!silent) {\n\t\t\t\treiserfs_info(s, \"using 3.5.x disk format\\n\");\n\t\t\t}\n\t\t} else\n\t\t\tset_sb_mnt_count(rs, sb_mnt_count(rs) + 1);\n\n\n\t\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(s));\n\t\terrval = journal_end(&th);\n\t\tif (errval) {\n\t\t\tdput(s->s_root);\n\t\t\ts->s_root = NULL;\n\t\t\tgoto error;\n\t\t}\n\n\t\treiserfs_write_unlock(s);\n\t\tif ((errval = reiserfs_lookup_privroot(s)) ||\n\t\t    (errval = reiserfs_xattr_init(s, s->s_flags))) {\n\t\t\tdput(s->s_root);\n\t\t\ts->s_root = NULL;\n\t\t\tgoto error_unlocked;\n\t\t}\n\t\treiserfs_write_lock(s);\n\n\t\t/*\n\t\t * look for files which were to be removed in previous session\n\t\t */\n\t\tfinish_unfinished(s);\n\t} else {\n\t\tif (old_format_only(s) && !silent) {\n\t\t\treiserfs_info(s, \"using 3.5.x disk format\\n\");\n\t\t}\n\n\t\treiserfs_write_unlock(s);\n\t\tif ((errval = reiserfs_lookup_privroot(s)) ||\n\t\t    (errval = reiserfs_xattr_init(s, s->s_flags))) {\n\t\t\tdput(s->s_root);\n\t\t\ts->s_root = NULL;\n\t\t\tgoto error_unlocked;\n\t\t}\n\t\treiserfs_write_lock(s);\n\t}\n\t/*\n\t * mark hash in super block: it could be unset. overwrite should be ok\n\t */\n\tset_sb_hash_function_code(rs, function2code(sbi->s_hash_function));\n\n\thandle_attrs(s);\n\n\treiserfs_proc_info_init(s);\n\n\tinit_waitqueue_head(&(sbi->s_wait));\n\tspin_lock_init(&sbi->bitmap_lock);\n\n\treiserfs_write_unlock(s);\n\n\treturn (0);\n\nerror:\n\treiserfs_write_unlock(s);\n\nerror_unlocked:\n\t/* kill the commit thread, free journal ram */\n\tif (jinit_done) {\n\t\treiserfs_write_lock(s);\n\t\tjournal_release_error(NULL, s);\n\t\treiserfs_write_unlock(s);\n\t}\n\n\tif (sbi->commit_wq)\n\t\tdestroy_workqueue(sbi->commit_wq);\n\n\tcancel_delayed_work_sync(&REISERFS_SB(s)->old_work);\n\n\treiserfs_free_bitmap_cache(s);\n\tif (SB_BUFFER_WITH_SB(s))\n\t\tbrelse(SB_BUFFER_WITH_SB(s));\n#ifdef CONFIG_QUOTA\n\t{\n\t\tint j;\n\t\tfor (j = 0; j < REISERFS_MAXQUOTAS; j++)\n\t\t\tkfree(qf_names[j]);\n\t}\n#endif\n\tkfree(sbi);\n\n\ts->s_fs_info = NULL;\n\treturn errval;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char reiserfs_3_6_magic_string[] = REISER2FS_SUPER_MAGIC_STRING;",
      "static int reiserfs_remount(struct super_block *s, int *flags, char *data);",
      "static const arg_desc_t tails[] = {\n\t{\"on\", 1 << REISERFS_LARGETAIL, 1 << REISERFS_SMALLTAIL},\n\t{\"off\", 0, (1 << REISERFS_LARGETAIL) | (1 << REISERFS_SMALLTAIL)},\n\t{\"small\", 1 << REISERFS_SMALLTAIL, 1 << REISERFS_LARGETAIL},\n\t{NULL, 0, 0}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "qf_names[j]"
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "SB_BUFFER_WITH_SB(s)"
          ],
          "line": 2182
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_free_bitmap_cache",
          "args": [
            "s"
          ],
          "line": 2180
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_free_bitmap_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "1462-1468",
          "snippet": "void reiserfs_free_bitmap_cache(struct super_block *sb)\n{\n\tif (SB_AP_BITMAP(sb)) {\n\t\tvfree(SB_AP_BITMAP(sb));\n\t\tSB_AP_BITMAP(sb) = NULL;\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nvoid reiserfs_free_bitmap_cache(struct super_block *sb)\n{\n\tif (SB_AP_BITMAP(sb)) {\n\t\tvfree(SB_AP_BITMAP(sb));\n\t\tSB_AP_BITMAP(sb) = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&REISERFS_SB(s)->old_work"
          ],
          "line": 2178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "s"
          ],
          "line": 2178
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "sbi->commit_wq"
          ],
          "line": 2176
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "s"
          ],
          "line": 2172
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_release_error",
          "args": [
            "NULL",
            "s"
          ],
          "line": 2171
        },
        "resolved": true,
        "details": {
          "function_name": "journal_release_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "1983-1987",
          "snippet": "int journal_release_error(struct reiserfs_transaction_handle *th,\n\t\t\t  struct super_block *sb)\n{\n\treturn do_journal_release(th, sb, 1);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_release_error(struct reiserfs_transaction_handle *th,\n\t\t\t  struct super_block *sb)\n{\n\treturn do_journal_release(th, sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "s"
          ],
          "line": 2170
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sbi->bitmap_lock"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&(sbi->s_wait)"
          ],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_proc_info_init",
          "args": [
            "s"
          ],
          "line": 2155
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_proc_info_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "3133-3136",
          "snippet": "static inline int reiserfs_proc_info_init(struct super_block *sb)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline int reiserfs_proc_info_init(struct super_block *sb)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_attrs",
          "args": [
            "s"
          ],
          "line": 2153
        },
        "resolved": true,
        "details": {
          "function_name": "handle_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "1347-1365",
          "snippet": "static void handle_attrs(struct super_block *s)\n{\n\tstruct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(s);\n\n\tif (reiserfs_attrs(s)) {\n\t\tif (old_format_only(s)) {\n\t\t\treiserfs_warning(s, \"super-6517\", \"cannot support \"\n\t\t\t\t\t \"attributes on 3.5.x disk format\");\n\t\t\tREISERFS_SB(s)->s_mount_opt &= ~(1 << REISERFS_ATTRS);\n\t\t\treturn;\n\t\t}\n\t\tif (!(le32_to_cpu(rs->s_flags) & reiserfs_attrs_cleared)) {\n\t\t\treiserfs_warning(s, \"super-6518\", \"cannot support \"\n\t\t\t\t\t \"attributes until flag is set in \"\n\t\t\t\t\t \"super-block\");\n\t\t\tREISERFS_SB(s)->s_mount_opt &= ~(1 << REISERFS_ATTRS);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void handle_attrs(struct super_block *s)\n{\n\tstruct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(s);\n\n\tif (reiserfs_attrs(s)) {\n\t\tif (old_format_only(s)) {\n\t\t\treiserfs_warning(s, \"super-6517\", \"cannot support \"\n\t\t\t\t\t \"attributes on 3.5.x disk format\");\n\t\t\tREISERFS_SB(s)->s_mount_opt &= ~(1 << REISERFS_ATTRS);\n\t\t\treturn;\n\t\t}\n\t\tif (!(le32_to_cpu(rs->s_flags) & reiserfs_attrs_cleared)) {\n\t\t\treiserfs_warning(s, \"super-6518\", \"cannot support \"\n\t\t\t\t\t \"attributes until flag is set in \"\n\t\t\t\t\t \"super-block\");\n\t\t\tREISERFS_SB(s)->s_mount_opt &= ~(1 << REISERFS_ATTRS);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_sb_hash_function_code",
          "args": [
            "rs",
            "function2code(sbi->s_hash_function)"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "function2code",
          "args": [
            "sbi->s_hash_function"
          ],
          "line": 2151
        },
        "resolved": true,
        "details": {
          "function_name": "function2code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "1827-1839",
          "snippet": "static int function2code(hashf_t func)\n{\n\tif (func == keyed_hash)\n\t\treturn TEA_HASH;\n\tif (func == yura_hash)\n\t\treturn YURA_HASH;\n\tif (func == r5_hash)\n\t\treturn R5_HASH;\n\n\tBUG();\t\t\t/* should never happen */\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int function2code(hashf_t func)\n{\n\tif (func == keyed_hash)\n\t\treturn TEA_HASH;\n\tif (func == yura_hash)\n\t\treturn YURA_HASH;\n\tif (func == r5_hash)\n\t\treturn R5_HASH;\n\n\tBUG();\t\t\t/* should never happen */\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "s->s_root"
          ],
          "line": 2142
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_xattr_init",
          "args": [
            "s",
            "s->s_flags"
          ],
          "line": 2141
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_xattr_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "1020-1064",
          "snippet": "int reiserfs_xattr_init(struct super_block *s, int mount_flags)\n{\n\tint err = 0;\n\tstruct dentry *privroot = REISERFS_SB(s)->priv_root;\n\n\terr = xattr_mount_check(s);\n\tif (err)\n\t\tgoto error;\n\n\tif (!privroot->d_inode && !(mount_flags & MS_RDONLY)) {\n\t\tmutex_lock(&s->s_root->d_inode->i_mutex);\n\t\terr = create_privroot(REISERFS_SB(s)->priv_root);\n\t\tmutex_unlock(&s->s_root->d_inode->i_mutex);\n\t}\n\n\tif (privroot->d_inode) {\n\t\ts->s_xattr = reiserfs_xattr_handlers;\n\t\tmutex_lock(&privroot->d_inode->i_mutex);\n\t\tif (!REISERFS_SB(s)->xattr_root) {\n\t\t\tstruct dentry *dentry;\n\n\t\t\tdentry = lookup_one_len(XAROOT_NAME, privroot,\n\t\t\t\t\t\tstrlen(XAROOT_NAME));\n\t\t\tif (!IS_ERR(dentry))\n\t\t\t\tREISERFS_SB(s)->xattr_root = dentry;\n\t\t\telse\n\t\t\t\terr = PTR_ERR(dentry);\n\t\t}\n\t\tmutex_unlock(&privroot->d_inode->i_mutex);\n\t}\n\nerror:\n\tif (err) {\n\t\tclear_bit(REISERFS_XATTRS_USER, &REISERFS_SB(s)->s_mount_opt);\n\t\tclear_bit(REISERFS_POSIXACL, &REISERFS_SB(s)->s_mount_opt);\n\t}\n\n\t/* The super_block MS_POSIXACL must mirror the (no)acl mount option. */\n\tif (reiserfs_posixacl(s))\n\t\ts->s_flags |= MS_POSIXACL;\n\telse\n\t\ts->s_flags &= ~MS_POSIXACL;\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [
            "#define XAROOT_NAME   \"xattrs\""
          ],
          "globals_used": [
            "static const struct xattr_handler *reiserfs_xattr_handlers[] = {\n#ifdef CONFIG_REISERFS_FS_XATTR\n\t&reiserfs_xattr_user_handler,\n\t&reiserfs_xattr_trusted_handler,\n#endif\n#ifdef CONFIG_REISERFS_FS_SECURITY\n\t&reiserfs_xattr_security_handler,\n#endif\n#ifdef CONFIG_REISERFS_FS_POSIX_ACL\n\t&posix_acl_access_xattr_handler,\n\t&posix_acl_default_xattr_handler,\n#endif\n\tNULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\n#define XAROOT_NAME   \"xattrs\"\n\nstatic const struct xattr_handler *reiserfs_xattr_handlers[] = {\n#ifdef CONFIG_REISERFS_FS_XATTR\n\t&reiserfs_xattr_user_handler,\n\t&reiserfs_xattr_trusted_handler,\n#endif\n#ifdef CONFIG_REISERFS_FS_SECURITY\n\t&reiserfs_xattr_security_handler,\n#endif\n#ifdef CONFIG_REISERFS_FS_POSIX_ACL\n\t&posix_acl_access_xattr_handler,\n\t&posix_acl_default_xattr_handler,\n#endif\n\tNULL\n};\n\nint reiserfs_xattr_init(struct super_block *s, int mount_flags)\n{\n\tint err = 0;\n\tstruct dentry *privroot = REISERFS_SB(s)->priv_root;\n\n\terr = xattr_mount_check(s);\n\tif (err)\n\t\tgoto error;\n\n\tif (!privroot->d_inode && !(mount_flags & MS_RDONLY)) {\n\t\tmutex_lock(&s->s_root->d_inode->i_mutex);\n\t\terr = create_privroot(REISERFS_SB(s)->priv_root);\n\t\tmutex_unlock(&s->s_root->d_inode->i_mutex);\n\t}\n\n\tif (privroot->d_inode) {\n\t\ts->s_xattr = reiserfs_xattr_handlers;\n\t\tmutex_lock(&privroot->d_inode->i_mutex);\n\t\tif (!REISERFS_SB(s)->xattr_root) {\n\t\t\tstruct dentry *dentry;\n\n\t\t\tdentry = lookup_one_len(XAROOT_NAME, privroot,\n\t\t\t\t\t\tstrlen(XAROOT_NAME));\n\t\t\tif (!IS_ERR(dentry))\n\t\t\t\tREISERFS_SB(s)->xattr_root = dentry;\n\t\t\telse\n\t\t\t\terr = PTR_ERR(dentry);\n\t\t}\n\t\tmutex_unlock(&privroot->d_inode->i_mutex);\n\t}\n\nerror:\n\tif (err) {\n\t\tclear_bit(REISERFS_XATTRS_USER, &REISERFS_SB(s)->s_mount_opt);\n\t\tclear_bit(REISERFS_POSIXACL, &REISERFS_SB(s)->s_mount_opt);\n\t}\n\n\t/* The super_block MS_POSIXACL must mirror the (no)acl mount option. */\n\tif (reiserfs_posixacl(s))\n\t\ts->s_flags |= MS_POSIXACL;\n\telse\n\t\ts->s_flags &= ~MS_POSIXACL;\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_lookup_privroot",
          "args": [
            "s"
          ],
          "line": 2140
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_lookup_privroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "994-1013",
          "snippet": "int reiserfs_lookup_privroot(struct super_block *s)\n{\n\tstruct dentry *dentry;\n\tint err = 0;\n\n\t/* If we don't have the privroot located yet - go find it */\n\tmutex_lock(&s->s_root->d_inode->i_mutex);\n\tdentry = lookup_one_len(PRIVROOT_NAME, s->s_root,\n\t\t\t\tstrlen(PRIVROOT_NAME));\n\tif (!IS_ERR(dentry)) {\n\t\tREISERFS_SB(s)->priv_root = dentry;\n\t\td_set_d_op(dentry, &xattr_lookup_poison_ops);\n\t\tif (dentry->d_inode)\n\t\t\tdentry->d_inode->i_flags |= S_PRIVATE;\n\t} else\n\t\terr = PTR_ERR(dentry);\n\tmutex_unlock(&s->s_root->d_inode->i_mutex);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [
            "#define PRIVROOT_NAME \".reiserfs_priv\""
          ],
          "globals_used": [
            "static const struct dentry_operations xattr_lookup_poison_ops = {\n\t.d_revalidate = xattr_hide_revalidate,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\n#define PRIVROOT_NAME \".reiserfs_priv\"\n\nstatic const struct dentry_operations xattr_lookup_poison_ops = {\n\t.d_revalidate = xattr_hide_revalidate,\n};\n\nint reiserfs_lookup_privroot(struct super_block *s)\n{\n\tstruct dentry *dentry;\n\tint err = 0;\n\n\t/* If we don't have the privroot located yet - go find it */\n\tmutex_lock(&s->s_root->d_inode->i_mutex);\n\tdentry = lookup_one_len(PRIVROOT_NAME, s->s_root,\n\t\t\t\tstrlen(PRIVROOT_NAME));\n\tif (!IS_ERR(dentry)) {\n\t\tREISERFS_SB(s)->priv_root = dentry;\n\t\td_set_d_op(dentry, &xattr_lookup_poison_ops);\n\t\tif (dentry->d_inode)\n\t\t\tdentry->d_inode->i_flags |= S_PRIVATE;\n\t} else\n\t\terr = PTR_ERR(dentry);\n\tmutex_unlock(&s->s_root->d_inode->i_mutex);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_info",
          "args": [
            "s",
            "\"using 3.5.x disk format\\n\""
          ],
          "line": 2136
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "280-288",
          "snippet": "void reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "old_format_only",
          "args": [
            "s"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_unfinished",
          "args": [
            "s"
          ],
          "line": 2133
        },
        "resolved": true,
        "details": {
          "function_name": "finish_unfinished",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "193-387",
          "snippet": "static int finish_unfinished(struct super_block *s)\n{\n\tINITIALIZE_PATH(path);\n\tstruct cpu_key max_cpu_key, obj_key;\n\tstruct reiserfs_key save_link_key, last_inode_key;\n\tint retval = 0;\n\tstruct item_head *ih;\n\tstruct buffer_head *bh;\n\tint item_pos;\n\tchar *item;\n\tint done;\n\tstruct inode *inode;\n\tint truncate;\n#ifdef CONFIG_QUOTA\n\tint i;\n\tint ms_active_set;\n\tint quota_enabled[REISERFS_MAXQUOTAS];\n#endif\n\n\t/* compose key to look for \"save\" links */\n\tmax_cpu_key.version = KEY_FORMAT_3_5;\n\tmax_cpu_key.on_disk_key.k_dir_id = ~0U;\n\tmax_cpu_key.on_disk_key.k_objectid = ~0U;\n\tset_cpu_key_k_offset(&max_cpu_key, ~0U);\n\tmax_cpu_key.key_length = 3;\n\n\tmemset(&last_inode_key, 0, sizeof(last_inode_key));\n\n#ifdef CONFIG_QUOTA\n\t/* Needed for iput() to work correctly and not trash data */\n\tif (s->s_flags & MS_ACTIVE) {\n\t\tms_active_set = 0;\n\t} else {\n\t\tms_active_set = 1;\n\t\ts->s_flags |= MS_ACTIVE;\n\t}\n\t/* Turn on quotas so that they are updated correctly */\n\tfor (i = 0; i < REISERFS_MAXQUOTAS; i++) {\n\t\tquota_enabled[i] = 1;\n\t\tif (REISERFS_SB(s)->s_qf_names[i]) {\n\t\t\tint ret;\n\n\t\t\tif (sb_has_quota_active(s, i)) {\n\t\t\t\tquota_enabled[i] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tret = reiserfs_quota_on_mount(s, i);\n\t\t\tif (ret < 0)\n\t\t\t\treiserfs_warning(s, \"reiserfs-2500\",\n\t\t\t\t\t\t \"cannot turn on journaled \"\n\t\t\t\t\t\t \"quota: error %d\", ret);\n\t\t}\n\t}\n#endif\n\n\tdone = 0;\n\tREISERFS_SB(s)->s_is_unlinked_ok = 1;\n\twhile (!retval) {\n\t\tint depth;\n\t\tretval = search_item(s, &max_cpu_key, &path);\n\t\tif (retval != ITEM_NOT_FOUND) {\n\t\t\treiserfs_error(s, \"vs-2140\",\n\t\t\t\t       \"search_by_key returned %d\", retval);\n\t\t\tbreak;\n\t\t}\n\n\t\tbh = get_last_bh(&path);\n\t\titem_pos = get_item_pos(&path);\n\t\tif (item_pos != B_NR_ITEMS(bh)) {\n\t\t\treiserfs_warning(s, \"vs-2060\",\n\t\t\t\t\t \"wrong position found\");\n\t\t\tbreak;\n\t\t}\n\t\titem_pos--;\n\t\tih = item_head(bh, item_pos);\n\n\t\tif (le32_to_cpu(ih->ih_key.k_dir_id) != MAX_KEY_OBJECTID)\n\t\t\t/* there are no \"save\" links anymore */\n\t\t\tbreak;\n\n\t\tsave_link_key = ih->ih_key;\n\t\tif (is_indirect_le_ih(ih))\n\t\t\ttruncate = 1;\n\t\telse\n\t\t\ttruncate = 0;\n\n\t\t/* reiserfs_iget needs k_dirid and k_objectid only */\n\t\titem = ih_item_body(bh, ih);\n\t\tobj_key.on_disk_key.k_dir_id = le32_to_cpu(*(__le32 *) item);\n\t\tobj_key.on_disk_key.k_objectid =\n\t\t    le32_to_cpu(ih->ih_key.k_objectid);\n\t\tobj_key.on_disk_key.k_offset = 0;\n\t\tobj_key.on_disk_key.k_type = 0;\n\n\t\tpathrelse(&path);\n\n\t\tinode = reiserfs_iget(s, &obj_key);\n\t\tif (!inode) {\n\t\t\t/*\n\t\t\t * the unlink almost completed, it just did not\n\t\t\t * manage to remove \"save\" link and release objectid\n\t\t\t */\n\t\t\treiserfs_warning(s, \"vs-2180\", \"iget failed for %K\",\n\t\t\t\t\t &obj_key);\n\t\t\tretval = remove_save_link_only(s, &save_link_key, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!truncate && inode->i_nlink) {\n\t\t\t/* file is not unlinked */\n\t\t\treiserfs_warning(s, \"vs-2185\",\n\t\t\t\t\t \"file %K is not unlinked\",\n\t\t\t\t\t &obj_key);\n\t\t\tretval = remove_save_link_only(s, &save_link_key, 0);\n\t\t\tcontinue;\n\t\t}\n\t\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\tdquot_initialize(inode);\n\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\t\tif (truncate && S_ISDIR(inode->i_mode)) {\n\t\t\t/*\n\t\t\t * We got a truncate request for a dir which\n\t\t\t * is impossible.  The only imaginable way is to\n\t\t\t * execute unfinished truncate request then boot\n\t\t\t * into old kernel, remove the file and create dir\n\t\t\t * with the same key.\n\t\t\t */\n\t\t\treiserfs_warning(s, \"green-2101\",\n\t\t\t\t\t \"impossible truncate on a \"\n\t\t\t\t\t \"directory %k. Please report\",\n\t\t\t\t\t INODE_PKEY(inode));\n\t\t\tretval = remove_save_link_only(s, &save_link_key, 0);\n\t\t\ttruncate = 0;\n\t\t\tiput(inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (truncate) {\n\t\t\tREISERFS_I(inode)->i_flags |=\n\t\t\t    i_link_saved_truncate_mask;\n\t\t\t/*\n\t\t\t * not completed truncate found. New size was\n\t\t\t * committed together with \"save\" link\n\t\t\t */\n\t\t\treiserfs_info(s, \"Truncating %k to %lld ..\",\n\t\t\t\t      INODE_PKEY(inode), inode->i_size);\n\n\t\t\t/* don't update modification time */\n\t\t\treiserfs_truncate_file(inode, 0);\n\n\t\t\tretval = remove_save_link(inode, truncate);\n\t\t} else {\n\t\t\tREISERFS_I(inode)->i_flags |= i_link_saved_unlink_mask;\n\t\t\t/* not completed unlink (rmdir) found */\n\t\t\treiserfs_info(s, \"Removing %k..\", INODE_PKEY(inode));\n\t\t\tif (memcmp(&last_inode_key, INODE_PKEY(inode),\n\t\t\t\t\tsizeof(last_inode_key))){\n\t\t\t\tlast_inode_key = *INODE_PKEY(inode);\n\t\t\t\t/* removal gets completed in iput */\n\t\t\t\tretval = 0;\n\t\t\t} else {\n\t\t\t\treiserfs_warning(s, \"super-2189\", \"Dead loop \"\n\t\t\t\t\t\t \"in finish_unfinished \"\n\t\t\t\t\t\t \"detected, just remove \"\n\t\t\t\t\t\t \"save link\\n\");\n\t\t\t\tretval = remove_save_link_only(s,\n\t\t\t\t\t\t\t&save_link_key, 0);\n\t\t\t}\n\t\t}\n\n\t\tiput(inode);\n\t\tprintk(\"done\\n\");\n\t\tdone++;\n\t}\n\tREISERFS_SB(s)->s_is_unlinked_ok = 0;\n\n#ifdef CONFIG_QUOTA\n\t/* Turn quotas off */\n\treiserfs_write_unlock(s);\n\tfor (i = 0; i < REISERFS_MAXQUOTAS; i++) {\n\t\tif (sb_dqopt(s)->files[i] && quota_enabled[i])\n\t\t\tdquot_quota_off(s, i);\n\t}\n\treiserfs_write_lock(s);\n\tif (ms_active_set)\n\t\t/* Restore the flag back */\n\t\ts->s_flags &= ~MS_ACTIVE;\n#endif\n\tpathrelse(&path);\n\tif (done)\n\t\treiserfs_info(s, \"There were %d uncompleted unlinks/truncates. \"\n\t\t\t      \"Completed\\n\", done);\n\treturn retval;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int reiserfs_remount(struct super_block *s, int *flags, char *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int reiserfs_remount(struct super_block *s, int *flags, char *data);\n\nstatic int finish_unfinished(struct super_block *s)\n{\n\tINITIALIZE_PATH(path);\n\tstruct cpu_key max_cpu_key, obj_key;\n\tstruct reiserfs_key save_link_key, last_inode_key;\n\tint retval = 0;\n\tstruct item_head *ih;\n\tstruct buffer_head *bh;\n\tint item_pos;\n\tchar *item;\n\tint done;\n\tstruct inode *inode;\n\tint truncate;\n#ifdef CONFIG_QUOTA\n\tint i;\n\tint ms_active_set;\n\tint quota_enabled[REISERFS_MAXQUOTAS];\n#endif\n\n\t/* compose key to look for \"save\" links */\n\tmax_cpu_key.version = KEY_FORMAT_3_5;\n\tmax_cpu_key.on_disk_key.k_dir_id = ~0U;\n\tmax_cpu_key.on_disk_key.k_objectid = ~0U;\n\tset_cpu_key_k_offset(&max_cpu_key, ~0U);\n\tmax_cpu_key.key_length = 3;\n\n\tmemset(&last_inode_key, 0, sizeof(last_inode_key));\n\n#ifdef CONFIG_QUOTA\n\t/* Needed for iput() to work correctly and not trash data */\n\tif (s->s_flags & MS_ACTIVE) {\n\t\tms_active_set = 0;\n\t} else {\n\t\tms_active_set = 1;\n\t\ts->s_flags |= MS_ACTIVE;\n\t}\n\t/* Turn on quotas so that they are updated correctly */\n\tfor (i = 0; i < REISERFS_MAXQUOTAS; i++) {\n\t\tquota_enabled[i] = 1;\n\t\tif (REISERFS_SB(s)->s_qf_names[i]) {\n\t\t\tint ret;\n\n\t\t\tif (sb_has_quota_active(s, i)) {\n\t\t\t\tquota_enabled[i] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tret = reiserfs_quota_on_mount(s, i);\n\t\t\tif (ret < 0)\n\t\t\t\treiserfs_warning(s, \"reiserfs-2500\",\n\t\t\t\t\t\t \"cannot turn on journaled \"\n\t\t\t\t\t\t \"quota: error %d\", ret);\n\t\t}\n\t}\n#endif\n\n\tdone = 0;\n\tREISERFS_SB(s)->s_is_unlinked_ok = 1;\n\twhile (!retval) {\n\t\tint depth;\n\t\tretval = search_item(s, &max_cpu_key, &path);\n\t\tif (retval != ITEM_NOT_FOUND) {\n\t\t\treiserfs_error(s, \"vs-2140\",\n\t\t\t\t       \"search_by_key returned %d\", retval);\n\t\t\tbreak;\n\t\t}\n\n\t\tbh = get_last_bh(&path);\n\t\titem_pos = get_item_pos(&path);\n\t\tif (item_pos != B_NR_ITEMS(bh)) {\n\t\t\treiserfs_warning(s, \"vs-2060\",\n\t\t\t\t\t \"wrong position found\");\n\t\t\tbreak;\n\t\t}\n\t\titem_pos--;\n\t\tih = item_head(bh, item_pos);\n\n\t\tif (le32_to_cpu(ih->ih_key.k_dir_id) != MAX_KEY_OBJECTID)\n\t\t\t/* there are no \"save\" links anymore */\n\t\t\tbreak;\n\n\t\tsave_link_key = ih->ih_key;\n\t\tif (is_indirect_le_ih(ih))\n\t\t\ttruncate = 1;\n\t\telse\n\t\t\ttruncate = 0;\n\n\t\t/* reiserfs_iget needs k_dirid and k_objectid only */\n\t\titem = ih_item_body(bh, ih);\n\t\tobj_key.on_disk_key.k_dir_id = le32_to_cpu(*(__le32 *) item);\n\t\tobj_key.on_disk_key.k_objectid =\n\t\t    le32_to_cpu(ih->ih_key.k_objectid);\n\t\tobj_key.on_disk_key.k_offset = 0;\n\t\tobj_key.on_disk_key.k_type = 0;\n\n\t\tpathrelse(&path);\n\n\t\tinode = reiserfs_iget(s, &obj_key);\n\t\tif (!inode) {\n\t\t\t/*\n\t\t\t * the unlink almost completed, it just did not\n\t\t\t * manage to remove \"save\" link and release objectid\n\t\t\t */\n\t\t\treiserfs_warning(s, \"vs-2180\", \"iget failed for %K\",\n\t\t\t\t\t &obj_key);\n\t\t\tretval = remove_save_link_only(s, &save_link_key, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!truncate && inode->i_nlink) {\n\t\t\t/* file is not unlinked */\n\t\t\treiserfs_warning(s, \"vs-2185\",\n\t\t\t\t\t \"file %K is not unlinked\",\n\t\t\t\t\t &obj_key);\n\t\t\tretval = remove_save_link_only(s, &save_link_key, 0);\n\t\t\tcontinue;\n\t\t}\n\t\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\tdquot_initialize(inode);\n\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\t\tif (truncate && S_ISDIR(inode->i_mode)) {\n\t\t\t/*\n\t\t\t * We got a truncate request for a dir which\n\t\t\t * is impossible.  The only imaginable way is to\n\t\t\t * execute unfinished truncate request then boot\n\t\t\t * into old kernel, remove the file and create dir\n\t\t\t * with the same key.\n\t\t\t */\n\t\t\treiserfs_warning(s, \"green-2101\",\n\t\t\t\t\t \"impossible truncate on a \"\n\t\t\t\t\t \"directory %k. Please report\",\n\t\t\t\t\t INODE_PKEY(inode));\n\t\t\tretval = remove_save_link_only(s, &save_link_key, 0);\n\t\t\ttruncate = 0;\n\t\t\tiput(inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (truncate) {\n\t\t\tREISERFS_I(inode)->i_flags |=\n\t\t\t    i_link_saved_truncate_mask;\n\t\t\t/*\n\t\t\t * not completed truncate found. New size was\n\t\t\t * committed together with \"save\" link\n\t\t\t */\n\t\t\treiserfs_info(s, \"Truncating %k to %lld ..\",\n\t\t\t\t      INODE_PKEY(inode), inode->i_size);\n\n\t\t\t/* don't update modification time */\n\t\t\treiserfs_truncate_file(inode, 0);\n\n\t\t\tretval = remove_save_link(inode, truncate);\n\t\t} else {\n\t\t\tREISERFS_I(inode)->i_flags |= i_link_saved_unlink_mask;\n\t\t\t/* not completed unlink (rmdir) found */\n\t\t\treiserfs_info(s, \"Removing %k..\", INODE_PKEY(inode));\n\t\t\tif (memcmp(&last_inode_key, INODE_PKEY(inode),\n\t\t\t\t\tsizeof(last_inode_key))){\n\t\t\t\tlast_inode_key = *INODE_PKEY(inode);\n\t\t\t\t/* removal gets completed in iput */\n\t\t\t\tretval = 0;\n\t\t\t} else {\n\t\t\t\treiserfs_warning(s, \"super-2189\", \"Dead loop \"\n\t\t\t\t\t\t \"in finish_unfinished \"\n\t\t\t\t\t\t \"detected, just remove \"\n\t\t\t\t\t\t \"save link\\n\");\n\t\t\t\tretval = remove_save_link_only(s,\n\t\t\t\t\t\t\t&save_link_key, 0);\n\t\t\t}\n\t\t}\n\n\t\tiput(inode);\n\t\tprintk(\"done\\n\");\n\t\tdone++;\n\t}\n\tREISERFS_SB(s)->s_is_unlinked_ok = 0;\n\n#ifdef CONFIG_QUOTA\n\t/* Turn quotas off */\n\treiserfs_write_unlock(s);\n\tfor (i = 0; i < REISERFS_MAXQUOTAS; i++) {\n\t\tif (sb_dqopt(s)->files[i] && quota_enabled[i])\n\t\t\tdquot_quota_off(s, i);\n\t}\n\treiserfs_write_lock(s);\n\tif (ms_active_set)\n\t\t/* Restore the flag back */\n\t\ts->s_flags &= ~MS_ACTIVE;\n#endif\n\tpathrelse(&path);\n\tif (done)\n\t\treiserfs_info(s, \"There were %d uncompleted unlinks/truncates. \"\n\t\t\t      \"Completed\\n\", done);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "&th"
          ],
          "line": 2114
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_mark_dirty",
          "args": [
            "&th",
            "SB_BUFFER_WITH_SB(s)"
          ],
          "line": 2113
        },
        "resolved": true,
        "details": {
          "function_name": "journal_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3274-3379",
          "snippet": "int journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sb_mnt_count",
          "args": [
            "rs",
            "sb_mnt_count(rs) + 1"
          ],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_mnt_count",
          "args": [
            "rs"
          ],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "REISERFS_3_5",
            "&sbi->s_properties"
          ],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "REISERFS_3_6",
            "&sbi->s_properties"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_convert_objectid_map_v1",
          "args": [
            "s"
          ],
          "line": 2103
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_convert_objectid_map_v1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/objectid.c",
          "lines": "179-217",
          "snippet": "int reiserfs_convert_objectid_map_v1(struct super_block *s)\n{\n\tstruct reiserfs_super_block *disk_sb = SB_DISK_SUPER_BLOCK(s);\n\tint cur_size = sb_oid_cursize(disk_sb);\n\tint new_size = (s->s_blocksize - SB_SIZE) / sizeof(__u32) / 2 * 2;\n\tint old_max = sb_oid_maxsize(disk_sb);\n\tstruct reiserfs_super_block_v1 *disk_sb_v1;\n\t__le32 *objectid_map, *new_objectid_map;\n\tint i;\n\n\tdisk_sb_v1 =\n\t    (struct reiserfs_super_block_v1 *)(SB_BUFFER_WITH_SB(s)->b_data);\n\tobjectid_map = (__le32 *) (disk_sb_v1 + 1);\n\tnew_objectid_map = (__le32 *) (disk_sb + 1);\n\n\tif (cur_size > new_size) {\n\t\t/*\n\t\t * mark everyone used that was listed as free at\n\t\t * the end of the objectid map\n\t\t */\n\t\tobjectid_map[new_size - 1] = objectid_map[cur_size - 1];\n\t\tset_sb_oid_cursize(disk_sb, new_size);\n\t}\n\t/* move the smaller objectid map past the end of the new super */\n\tfor (i = new_size - 1; i >= 0; i--) {\n\t\tobjectid_map[i + (old_max - new_size)] = objectid_map[i];\n\t}\n\n\t/* set the max size so we don't overflow later */\n\tset_sb_oid_maxsize(disk_sb, new_size);\n\n\t/* Zero out label and generate random UUID */\n\tmemset(disk_sb->s_label, 0, sizeof(disk_sb->s_label));\n\tgenerate_random_uuid(disk_sb->s_uuid);\n\n\t/* finally, zero out the unused chunk of the new super */\n\tmemset(disk_sb->s_unused, 0, sizeof(disk_sb->s_unused));\n\treturn 0;\n}",
          "includes": [
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/random.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/random.h>\n#include <linux/string.h>\n\nint reiserfs_convert_objectid_map_v1(struct super_block *s)\n{\n\tstruct reiserfs_super_block *disk_sb = SB_DISK_SUPER_BLOCK(s);\n\tint cur_size = sb_oid_cursize(disk_sb);\n\tint new_size = (s->s_blocksize - SB_SIZE) / sizeof(__u32) / 2 * 2;\n\tint old_max = sb_oid_maxsize(disk_sb);\n\tstruct reiserfs_super_block_v1 *disk_sb_v1;\n\t__le32 *objectid_map, *new_objectid_map;\n\tint i;\n\n\tdisk_sb_v1 =\n\t    (struct reiserfs_super_block_v1 *)(SB_BUFFER_WITH_SB(s)->b_data);\n\tobjectid_map = (__le32 *) (disk_sb_v1 + 1);\n\tnew_objectid_map = (__le32 *) (disk_sb + 1);\n\n\tif (cur_size > new_size) {\n\t\t/*\n\t\t * mark everyone used that was listed as free at\n\t\t * the end of the objectid map\n\t\t */\n\t\tobjectid_map[new_size - 1] = objectid_map[cur_size - 1];\n\t\tset_sb_oid_cursize(disk_sb, new_size);\n\t}\n\t/* move the smaller objectid map past the end of the new super */\n\tfor (i = new_size - 1; i >= 0; i--) {\n\t\tobjectid_map[i + (old_max - new_size)] = objectid_map[i];\n\t}\n\n\t/* set the max size so we don't overflow later */\n\tset_sb_oid_maxsize(disk_sb, new_size);\n\n\t/* Zero out label and generate random UUID */\n\tmemset(disk_sb->s_label, 0, sizeof(disk_sb->s_label));\n\tgenerate_random_uuid(disk_sb->s_uuid);\n\n\t/* finally, zero out the unused chunk of the new super */\n\tmemset(disk_sb->s_unused, 0, sizeof(disk_sb->s_unused));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_sb_version",
          "args": [
            "rs",
            "REISERFS_VERSION_2"
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "rs->s_v1.s_magic",
            "reiserfs_3_6_magic_string",
            "sizeof\n\t\t\t\t\t       (reiserfs_3_6_magic_string)"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_reiserfs_3_5",
          "args": [
            "rs"
          ],
          "line": 2091
        },
        "resolved": true,
        "details": {
          "function_name": "is_reiserfs_3_5",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "39-43",
          "snippet": "int is_reiserfs_3_5(struct reiserfs_super_block *rs)\n{\n\treturn !strncmp(rs->s_v1.s_magic, reiserfs_3_5_magic_string,\n\t\t\tstrlen(reiserfs_3_5_magic_string));\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char reiserfs_3_5_magic_string[] = REISERFS_SUPER_MAGIC_STRING;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const char reiserfs_3_5_magic_string[] = REISERFS_SUPER_MAGIC_STRING;\n\nint is_reiserfs_3_5(struct reiserfs_super_block *rs)\n{\n\treturn !strncmp(rs->s_v1.s_magic, reiserfs_3_5_magic_string,\n\t\t\tstrlen(reiserfs_3_5_magic_string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "convert_reiserfs",
          "args": [
            "s"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_format_only",
          "args": [
            "s"
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sb_bmap_nr",
          "args": [
            "rs",
            "0"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"super-2030\"",
            "\"This file system \"\n\t\t\t\t\t\"claims to use %u bitmap blocks in \"\n\t\t\t\t\t\"its super block, but requires %u. \"\n\t\t\t\t\t\"Clearing to zero.\"",
            "sb_bmap_nr(rs)",
            "reiserfs_bmap_count(s)"
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_bmap_count",
          "args": [
            "s"
          ],
          "line": 2075
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_bmap_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1161-1164",
          "snippet": "static inline __u32 reiserfs_bmap_count(struct super_block *sb)\n{\n\treturn (SB_BLOCK_COUNT(sb) - 1) / (sb->s_blocksize * 8) + 1;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline __u32 reiserfs_bmap_count(struct super_block *sb)\n{\n\treturn (SB_BLOCK_COUNT(sb) - 1) / (sb->s_blocksize * 8) + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bmap_nr",
          "args": [
            "rs"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bmap_nr",
          "args": [
            "rs"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bmap_would_wrap",
          "args": [
            "reiserfs_bmap_count(s)"
          ],
          "line": 2069
        },
        "resolved": true,
        "details": {
          "function_name": "bmap_would_wrap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1166-1169",
          "snippet": "static inline int bmap_would_wrap(unsigned bmap_nr)\n{\n\treturn bmap_nr > ((1LL << 16) - 1);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int bmap_would_wrap(unsigned bmap_nr)\n{\n\treturn bmap_nr > ((1LL << 16) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_sb_fs_state",
          "args": [
            "rs",
            "0"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sb_umount_state",
          "args": [
            "rs",
            "REISERFS_ERROR_FS"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_prepare_for_journal",
          "args": [
            "s",
            "SB_BUFFER_WITH_SB(s)",
            "1"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_prepare_for_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3951-3968",
          "snippet": "int reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "s",
            "1"
          ],
          "line": 2052
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_VERSION",
          "args": [
            "s"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_reiserfs_jr",
          "args": [
            "rs"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "is_reiserfs_jr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "51-55",
          "snippet": "int is_reiserfs_jr(struct reiserfs_super_block *rs)\n{\n\treturn !strncmp(rs->s_v1.s_magic, reiserfs_jr_magic_string,\n\t\t\tstrlen(reiserfs_jr_magic_string));\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char reiserfs_jr_magic_string[] = REISER2FS_JR_SUPER_MAGIC_STRING;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const char reiserfs_jr_magic_string[] = REISER2FS_JR_SUPER_MAGIC_STRING;\n\nint is_reiserfs_jr(struct reiserfs_super_block *rs)\n{\n\treturn !strncmp(rs->s_v1.s_magic, reiserfs_jr_magic_string,\n\t\t\tstrlen(reiserfs_jr_magic_string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_function",
          "args": [
            "s"
          ],
          "line": 2035
        },
        "resolved": true,
        "details": {
          "function_name": "hash_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "1810-1824",
          "snippet": "static hashf_t hash_function(struct super_block *s)\n{\n\tswitch (what_hash(s)) {\n\tcase TEA_HASH:\n\t\treiserfs_info(s, \"Using tea hash to sort names\\n\");\n\t\treturn keyed_hash;\n\tcase YURA_HASH:\n\t\treiserfs_info(s, \"Using rupasov hash to sort names\\n\");\n\t\treturn yura_hash;\n\tcase R5_HASH:\n\t\treiserfs_info(s, \"Using r5 hash to sort names\\n\");\n\t\treturn r5_hash;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic hashf_t hash_function(struct super_block *s)\n{\n\tswitch (what_hash(s)) {\n\tcase TEA_HASH:\n\t\treiserfs_info(s, \"Using tea hash to sort names\\n\");\n\t\treturn keyed_hash;\n\tcase YURA_HASH:\n\t\treiserfs_info(s, \"Using rupasov hash to sort names\\n\");\n\t\treturn yura_hash;\n\tcase R5_HASH:\n\t\treiserfs_info(s, \"Using r5 hash to sort names\\n\");\n\t\treturn r5_hash;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "root_inode"
          ],
          "line": 2031
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "root_inode"
          ],
          "line": 2028
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_read_locked_inode",
          "args": [
            "root_inode",
            "&args"
          ],
          "line": 2027
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1542-1618",
          "snippet": "void reiserfs_read_locked_inode(struct inode *inode,\n\t\t\t\tstruct reiserfs_iget_args *args)\n{\n\tINITIALIZE_PATH(path_to_sd);\n\tstruct cpu_key key;\n\tunsigned long dirino;\n\tint retval;\n\n\tdirino = args->dirid;\n\n\t/*\n\t * set version 1, version 2 could be used too, because stat data\n\t * key is the same in both versions\n\t */\n\tkey.version = KEY_FORMAT_3_5;\n\tkey.on_disk_key.k_dir_id = dirino;\n\tkey.on_disk_key.k_objectid = inode->i_ino;\n\tkey.on_disk_key.k_offset = 0;\n\tkey.on_disk_key.k_type = 0;\n\n\t/* look for the object's stat data */\n\tretval = search_item(inode->i_sb, &key, &path_to_sd);\n\tif (retval == IO_ERROR) {\n\t\treiserfs_error(inode->i_sb, \"vs-13070\",\n\t\t\t       \"i/o failure occurred trying to find \"\n\t\t\t       \"stat data of %K\", &key);\n\t\treiserfs_make_bad_inode(inode);\n\t\treturn;\n\t}\n\n\t/* a stale NFS handle can trigger this without it being an error */\n\tif (retval != ITEM_FOUND) {\n\t\tpathrelse(&path_to_sd);\n\t\treiserfs_make_bad_inode(inode);\n\t\tclear_nlink(inode);\n\t\treturn;\n\t}\n\n\tinit_inode(inode, &path_to_sd);\n\n\t/*\n\t * It is possible that knfsd is trying to access inode of a file\n\t * that is being removed from the disk by some other thread. As we\n\t * update sd on unlink all that is required is to check for nlink\n\t * here. This bug was first found by Sizif when debugging\n\t * SquidNG/Butterfly, forgotten, and found again after Philippe\n\t * Gramoulle <philippe.gramoulle@mmania.com> reproduced it.\n\n\t * More logical fix would require changes in fs/inode.c:iput() to\n\t * remove inode from hash-table _after_ fs cleaned disk stuff up and\n\t * in iget() to return NULL if I_FREEING inode is found in\n\t * hash-table.\n\t */\n\n\t/*\n\t * Currently there is one place where it's ok to meet inode with\n\t * nlink==0: processing of open-unlinked and half-truncated files\n\t * during mount (fs/reiserfs/super.c:finish_unfinished()).\n\t */\n\tif ((inode->i_nlink == 0) &&\n\t    !REISERFS_SB(inode->i_sb)->s_is_unlinked_ok) {\n\t\treiserfs_warning(inode->i_sb, \"vs-13075\",\n\t\t\t\t \"dead inode read from disk %K. \"\n\t\t\t\t \"This is likely to be race with knfsd. Ignore\",\n\t\t\t\t &key);\n\t\treiserfs_make_bad_inode(inode);\n\t}\n\n\t/* init inode should be relsing */\n\treiserfs_check_path(&path_to_sd);\n\n\t/*\n\t * Stat data v1 doesn't support ACLs.\n\t */\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\tcache_no_acl(inode);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nvoid reiserfs_read_locked_inode(struct inode *inode,\n\t\t\t\tstruct reiserfs_iget_args *args)\n{\n\tINITIALIZE_PATH(path_to_sd);\n\tstruct cpu_key key;\n\tunsigned long dirino;\n\tint retval;\n\n\tdirino = args->dirid;\n\n\t/*\n\t * set version 1, version 2 could be used too, because stat data\n\t * key is the same in both versions\n\t */\n\tkey.version = KEY_FORMAT_3_5;\n\tkey.on_disk_key.k_dir_id = dirino;\n\tkey.on_disk_key.k_objectid = inode->i_ino;\n\tkey.on_disk_key.k_offset = 0;\n\tkey.on_disk_key.k_type = 0;\n\n\t/* look for the object's stat data */\n\tretval = search_item(inode->i_sb, &key, &path_to_sd);\n\tif (retval == IO_ERROR) {\n\t\treiserfs_error(inode->i_sb, \"vs-13070\",\n\t\t\t       \"i/o failure occurred trying to find \"\n\t\t\t       \"stat data of %K\", &key);\n\t\treiserfs_make_bad_inode(inode);\n\t\treturn;\n\t}\n\n\t/* a stale NFS handle can trigger this without it being an error */\n\tif (retval != ITEM_FOUND) {\n\t\tpathrelse(&path_to_sd);\n\t\treiserfs_make_bad_inode(inode);\n\t\tclear_nlink(inode);\n\t\treturn;\n\t}\n\n\tinit_inode(inode, &path_to_sd);\n\n\t/*\n\t * It is possible that knfsd is trying to access inode of a file\n\t * that is being removed from the disk by some other thread. As we\n\t * update sd on unlink all that is required is to check for nlink\n\t * here. This bug was first found by Sizif when debugging\n\t * SquidNG/Butterfly, forgotten, and found again after Philippe\n\t * Gramoulle <philippe.gramoulle@mmania.com> reproduced it.\n\n\t * More logical fix would require changes in fs/inode.c:iput() to\n\t * remove inode from hash-table _after_ fs cleaned disk stuff up and\n\t * in iget() to return NULL if I_FREEING inode is found in\n\t * hash-table.\n\t */\n\n\t/*\n\t * Currently there is one place where it's ok to meet inode with\n\t * nlink==0: processing of open-unlinked and half-truncated files\n\t * during mount (fs/reiserfs/super.c:finish_unfinished()).\n\t */\n\tif ((inode->i_nlink == 0) &&\n\t    !REISERFS_SB(inode->i_sb)->s_is_unlinked_ok) {\n\t\treiserfs_warning(inode->i_sb, \"vs-13075\",\n\t\t\t\t \"dead inode read from disk %K. \"\n\t\t\t\t \"This is likely to be race with knfsd. Ignore\",\n\t\t\t\t &key);\n\t\treiserfs_make_bad_inode(inode);\n\t}\n\n\t/* init inode should be relsing */\n\treiserfs_check_path(&path_to_sd);\n\n\t/*\n\t * Stat data v1 doesn't support ACLs.\n\t */\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\tcache_no_acl(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SWARN",
          "args": [
            "silent",
            "s",
            "\"jmacd-10\"",
            "\"get root inode failed\""
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget5_locked",
          "args": [
            "s",
            "REISERFS_ROOT_OBJECTID",
            "reiserfs_find_actor",
            "reiserfs_init_locked_inode",
            "(void *)&args"
          ],
          "line": 2009
        },
        "resolved": true,
        "details": {
          "function_name": "iget5_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "991-1047",
          "snippet": "struct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SWARN",
          "args": [
            "silent",
            "s",
            "\"clm-7000\"",
            "\"Detected readonly device, marking FS readonly\""
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_read_only",
          "args": [
            "s->s_bdev"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replay_only",
          "args": [
            "s"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWARN",
          "args": [
            "silent",
            "s",
            "\"jmacd-9\"",
            "\"unable to reread meta blocks after journal init\""
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reread_meta_blocks",
          "args": [
            "s"
          ],
          "line": 1992
        },
        "resolved": true,
        "details": {
          "function_name": "reread_meta_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "1658-1668",
          "snippet": "static int reread_meta_blocks(struct super_block *s)\n{\n\tll_rw_block(READ, 1, &SB_BUFFER_WITH_SB(s));\n\twait_on_buffer(SB_BUFFER_WITH_SB(s));\n\tif (!buffer_uptodate(SB_BUFFER_WITH_SB(s))) {\n\t\treiserfs_warning(s, \"reiserfs-2504\", \"error reading the super\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int reread_meta_blocks(struct super_block *s)\n{\n\tll_rw_block(READ, 1, &SB_BUFFER_WITH_SB(s));\n\twait_on_buffer(SB_BUFFER_WITH_SB(s));\n\tif (!buffer_uptodate(SB_BUFFER_WITH_SB(s))) {\n\t\treiserfs_warning(s, \"reiserfs-2504\", \"error reading the super\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SWARN",
          "args": [
            "silent",
            "s",
            "\"sh-2022\"",
            "\"unable to initialize journal space\""
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_init",
          "args": [
            "s",
            "jdev_name",
            "old_format",
            "commit_max_age"
          ],
          "line": 1980
        },
        "resolved": true,
        "details": {
          "function_name": "journal_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "2718-2904",
          "snippet": "int journal_init(struct super_block *sb, const char *j_dev_name,\n\t\t int old_format, unsigned int commit_max_age)\n{\n\tint num_cnodes = SB_ONDISK_JOURNAL_SIZE(sb) * 2;\n\tstruct buffer_head *bhjh;\n\tstruct reiserfs_super_block *rs;\n\tstruct reiserfs_journal_header *jh;\n\tstruct reiserfs_journal *journal;\n\tstruct reiserfs_journal_list *jl;\n\tchar b[BDEVNAME_SIZE];\n\tint ret;\n\n\tjournal = SB_JOURNAL(sb) = vzalloc(sizeof(struct reiserfs_journal));\n\tif (!journal) {\n\t\treiserfs_warning(sb, \"journal-1256\",\n\t\t\t\t \"unable to get memory for journal structure\");\n\t\treturn 1;\n\t}\n\tINIT_LIST_HEAD(&journal->j_bitmap_nodes);\n\tINIT_LIST_HEAD(&journal->j_prealloc_list);\n\tINIT_LIST_HEAD(&journal->j_working_list);\n\tINIT_LIST_HEAD(&journal->j_journal_list);\n\tjournal->j_persistent_trans = 0;\n\tif (reiserfs_allocate_list_bitmaps(sb, journal->j_list_bitmap,\n\t\t\t\t\t   reiserfs_bmap_count(sb)))\n\t\tgoto free_and_return;\n\n\tallocate_bitmap_nodes(sb);\n\n\t/* reserved for journal area support */\n\tSB_JOURNAL_1st_RESERVED_BLOCK(sb) = (old_format ?\n\t\t\t\t\t\t REISERFS_OLD_DISK_OFFSET_IN_BYTES\n\t\t\t\t\t\t / sb->s_blocksize +\n\t\t\t\t\t\t reiserfs_bmap_count(sb) +\n\t\t\t\t\t\t 1 :\n\t\t\t\t\t\t REISERFS_DISK_OFFSET_IN_BYTES /\n\t\t\t\t\t\t sb->s_blocksize + 2);\n\n\t/*\n\t * Sanity check to see is the standard journal fitting\n\t * within first bitmap (actual for small blocksizes)\n\t */\n\tif (!SB_ONDISK_JOURNAL_DEVICE(sb) &&\n\t    (SB_JOURNAL_1st_RESERVED_BLOCK(sb) +\n\t     SB_ONDISK_JOURNAL_SIZE(sb) > sb->s_blocksize * 8)) {\n\t\treiserfs_warning(sb, \"journal-1393\",\n\t\t\t\t \"journal does not fit for area addressed \"\n\t\t\t\t \"by first of bitmap blocks. It starts at \"\n\t\t\t\t \"%u and its size is %u. Block size %ld\",\n\t\t\t\t SB_JOURNAL_1st_RESERVED_BLOCK(sb),\n\t\t\t\t SB_ONDISK_JOURNAL_SIZE(sb),\n\t\t\t\t sb->s_blocksize);\n\t\tgoto free_and_return;\n\t}\n\n\tif (journal_init_dev(sb, journal, j_dev_name) != 0) {\n\t\treiserfs_warning(sb, \"sh-462\",\n\t\t\t\t \"unable to initialize journal device\");\n\t\tgoto free_and_return;\n\t}\n\n\trs = SB_DISK_SUPER_BLOCK(sb);\n\n\t/* read journal header */\n\tbhjh = journal_bread(sb,\n\t\t\t     SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t     SB_ONDISK_JOURNAL_SIZE(sb));\n\tif (!bhjh) {\n\t\treiserfs_warning(sb, \"sh-459\",\n\t\t\t\t \"unable to read journal header\");\n\t\tgoto free_and_return;\n\t}\n\tjh = (struct reiserfs_journal_header *)(bhjh->b_data);\n\n\t/* make sure that journal matches to the super block */\n\tif (is_reiserfs_jr(rs)\n\t    && (le32_to_cpu(jh->jh_journal.jp_journal_magic) !=\n\t\tsb_jp_journal_magic(rs))) {\n\t\treiserfs_warning(sb, \"sh-460\",\n\t\t\t\t \"journal header magic %x (device %s) does \"\n\t\t\t\t \"not match to magic found in super block %x\",\n\t\t\t\t jh->jh_journal.jp_journal_magic,\n\t\t\t\t bdevname(journal->j_dev_bd, b),\n\t\t\t\t sb_jp_journal_magic(rs));\n\t\tbrelse(bhjh);\n\t\tgoto free_and_return;\n\t}\n\n\tjournal->j_trans_max = le32_to_cpu(jh->jh_journal.jp_journal_trans_max);\n\tjournal->j_max_batch = le32_to_cpu(jh->jh_journal.jp_journal_max_batch);\n\tjournal->j_max_commit_age =\n\t    le32_to_cpu(jh->jh_journal.jp_journal_max_commit_age);\n\tjournal->j_max_trans_age = JOURNAL_MAX_TRANS_AGE;\n\n\tif (check_advise_trans_params(sb, journal) != 0)\n\t        goto free_and_return;\n\tjournal->j_default_max_commit_age = journal->j_max_commit_age;\n\n\tif (commit_max_age != 0) {\n\t\tjournal->j_max_commit_age = commit_max_age;\n\t\tjournal->j_max_trans_age = commit_max_age;\n\t}\n\n\treiserfs_info(sb, \"journal params: device %s, size %u, \"\n\t\t      \"journal first block %u, max trans len %u, max batch %u, \"\n\t\t      \"max commit age %u, max trans age %u\\n\",\n\t\t      bdevname(journal->j_dev_bd, b),\n\t\t      SB_ONDISK_JOURNAL_SIZE(sb),\n\t\t      SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t      journal->j_trans_max,\n\t\t      journal->j_max_batch,\n\t\t      journal->j_max_commit_age, journal->j_max_trans_age);\n\n\tbrelse(bhjh);\n\n\tjournal->j_list_bitmap_index = 0;\n\tjournal_list_init(sb);\n\n\tmemset(journal->j_list_hash_table, 0,\n\t       JOURNAL_HASH_SIZE * sizeof(struct reiserfs_journal_cnode *));\n\n\tINIT_LIST_HEAD(&journal->j_dirty_buffers);\n\tspin_lock_init(&journal->j_dirty_buffers_lock);\n\n\tjournal->j_start = 0;\n\tjournal->j_len = 0;\n\tjournal->j_len_alloc = 0;\n\tatomic_set(&journal->j_wcount, 0);\n\tatomic_set(&journal->j_async_throttle, 0);\n\tjournal->j_bcount = 0;\n\tjournal->j_trans_start_time = 0;\n\tjournal->j_last = NULL;\n\tjournal->j_first = NULL;\n\tinit_waitqueue_head(&journal->j_join_wait);\n\tmutex_init(&journal->j_mutex);\n\tmutex_init(&journal->j_flush_mutex);\n\n\tjournal->j_trans_id = 10;\n\tjournal->j_mount_id = 10;\n\tjournal->j_state = 0;\n\tatomic_set(&journal->j_jlock, 0);\n\tjournal->j_cnode_free_list = allocate_cnodes(num_cnodes);\n\tjournal->j_cnode_free_orig = journal->j_cnode_free_list;\n\tjournal->j_cnode_free = journal->j_cnode_free_list ? num_cnodes : 0;\n\tjournal->j_cnode_used = 0;\n\tjournal->j_must_wait = 0;\n\n\tif (journal->j_cnode_free == 0) {\n\t\treiserfs_warning(sb, \"journal-2004\", \"Journal cnode memory \"\n\t\t                 \"allocation failed (%ld bytes). Journal is \"\n\t\t                 \"too large for available memory. Usually \"\n\t\t                 \"this is due to a journal that is too large.\",\n\t\t                 sizeof (struct reiserfs_journal_cnode) * num_cnodes);\n        \tgoto free_and_return;\n\t}\n\n\tinit_journal_hash(sb);\n\tjl = journal->j_current_jl;\n\n\t/*\n\t * get_list_bitmap() may call flush_commit_list() which\n\t * requires the lock. Calling flush_commit_list() shouldn't happen\n\t * this early but I like to be paranoid.\n\t */\n\treiserfs_write_lock(sb);\n\tjl->j_list_bitmap = get_list_bitmap(sb, jl);\n\treiserfs_write_unlock(sb);\n\tif (!jl->j_list_bitmap) {\n\t\treiserfs_warning(sb, \"journal-2005\",\n\t\t\t\t \"get_list_bitmap failed for journal list 0\");\n\t\tgoto free_and_return;\n\t}\n\n\tret = journal_read(sb);\n\tif (ret < 0) {\n\t\treiserfs_warning(sb, \"reiserfs-2006\",\n\t\t\t\t \"Replay Failure, unable to mount\");\n\t\tgoto free_and_return;\n\t}\n\n\tINIT_DELAYED_WORK(&journal->j_work, flush_async_commits);\n\tjournal->j_work_sb = sb;\n\treturn 0;\nfree_and_return:\n\tfree_journal_ram(sb);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nint journal_init(struct super_block *sb, const char *j_dev_name,\n\t\t int old_format, unsigned int commit_max_age)\n{\n\tint num_cnodes = SB_ONDISK_JOURNAL_SIZE(sb) * 2;\n\tstruct buffer_head *bhjh;\n\tstruct reiserfs_super_block *rs;\n\tstruct reiserfs_journal_header *jh;\n\tstruct reiserfs_journal *journal;\n\tstruct reiserfs_journal_list *jl;\n\tchar b[BDEVNAME_SIZE];\n\tint ret;\n\n\tjournal = SB_JOURNAL(sb) = vzalloc(sizeof(struct reiserfs_journal));\n\tif (!journal) {\n\t\treiserfs_warning(sb, \"journal-1256\",\n\t\t\t\t \"unable to get memory for journal structure\");\n\t\treturn 1;\n\t}\n\tINIT_LIST_HEAD(&journal->j_bitmap_nodes);\n\tINIT_LIST_HEAD(&journal->j_prealloc_list);\n\tINIT_LIST_HEAD(&journal->j_working_list);\n\tINIT_LIST_HEAD(&journal->j_journal_list);\n\tjournal->j_persistent_trans = 0;\n\tif (reiserfs_allocate_list_bitmaps(sb, journal->j_list_bitmap,\n\t\t\t\t\t   reiserfs_bmap_count(sb)))\n\t\tgoto free_and_return;\n\n\tallocate_bitmap_nodes(sb);\n\n\t/* reserved for journal area support */\n\tSB_JOURNAL_1st_RESERVED_BLOCK(sb) = (old_format ?\n\t\t\t\t\t\t REISERFS_OLD_DISK_OFFSET_IN_BYTES\n\t\t\t\t\t\t / sb->s_blocksize +\n\t\t\t\t\t\t reiserfs_bmap_count(sb) +\n\t\t\t\t\t\t 1 :\n\t\t\t\t\t\t REISERFS_DISK_OFFSET_IN_BYTES /\n\t\t\t\t\t\t sb->s_blocksize + 2);\n\n\t/*\n\t * Sanity check to see is the standard journal fitting\n\t * within first bitmap (actual for small blocksizes)\n\t */\n\tif (!SB_ONDISK_JOURNAL_DEVICE(sb) &&\n\t    (SB_JOURNAL_1st_RESERVED_BLOCK(sb) +\n\t     SB_ONDISK_JOURNAL_SIZE(sb) > sb->s_blocksize * 8)) {\n\t\treiserfs_warning(sb, \"journal-1393\",\n\t\t\t\t \"journal does not fit for area addressed \"\n\t\t\t\t \"by first of bitmap blocks. It starts at \"\n\t\t\t\t \"%u and its size is %u. Block size %ld\",\n\t\t\t\t SB_JOURNAL_1st_RESERVED_BLOCK(sb),\n\t\t\t\t SB_ONDISK_JOURNAL_SIZE(sb),\n\t\t\t\t sb->s_blocksize);\n\t\tgoto free_and_return;\n\t}\n\n\tif (journal_init_dev(sb, journal, j_dev_name) != 0) {\n\t\treiserfs_warning(sb, \"sh-462\",\n\t\t\t\t \"unable to initialize journal device\");\n\t\tgoto free_and_return;\n\t}\n\n\trs = SB_DISK_SUPER_BLOCK(sb);\n\n\t/* read journal header */\n\tbhjh = journal_bread(sb,\n\t\t\t     SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t     SB_ONDISK_JOURNAL_SIZE(sb));\n\tif (!bhjh) {\n\t\treiserfs_warning(sb, \"sh-459\",\n\t\t\t\t \"unable to read journal header\");\n\t\tgoto free_and_return;\n\t}\n\tjh = (struct reiserfs_journal_header *)(bhjh->b_data);\n\n\t/* make sure that journal matches to the super block */\n\tif (is_reiserfs_jr(rs)\n\t    && (le32_to_cpu(jh->jh_journal.jp_journal_magic) !=\n\t\tsb_jp_journal_magic(rs))) {\n\t\treiserfs_warning(sb, \"sh-460\",\n\t\t\t\t \"journal header magic %x (device %s) does \"\n\t\t\t\t \"not match to magic found in super block %x\",\n\t\t\t\t jh->jh_journal.jp_journal_magic,\n\t\t\t\t bdevname(journal->j_dev_bd, b),\n\t\t\t\t sb_jp_journal_magic(rs));\n\t\tbrelse(bhjh);\n\t\tgoto free_and_return;\n\t}\n\n\tjournal->j_trans_max = le32_to_cpu(jh->jh_journal.jp_journal_trans_max);\n\tjournal->j_max_batch = le32_to_cpu(jh->jh_journal.jp_journal_max_batch);\n\tjournal->j_max_commit_age =\n\t    le32_to_cpu(jh->jh_journal.jp_journal_max_commit_age);\n\tjournal->j_max_trans_age = JOURNAL_MAX_TRANS_AGE;\n\n\tif (check_advise_trans_params(sb, journal) != 0)\n\t        goto free_and_return;\n\tjournal->j_default_max_commit_age = journal->j_max_commit_age;\n\n\tif (commit_max_age != 0) {\n\t\tjournal->j_max_commit_age = commit_max_age;\n\t\tjournal->j_max_trans_age = commit_max_age;\n\t}\n\n\treiserfs_info(sb, \"journal params: device %s, size %u, \"\n\t\t      \"journal first block %u, max trans len %u, max batch %u, \"\n\t\t      \"max commit age %u, max trans age %u\\n\",\n\t\t      bdevname(journal->j_dev_bd, b),\n\t\t      SB_ONDISK_JOURNAL_SIZE(sb),\n\t\t      SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t      journal->j_trans_max,\n\t\t      journal->j_max_batch,\n\t\t      journal->j_max_commit_age, journal->j_max_trans_age);\n\n\tbrelse(bhjh);\n\n\tjournal->j_list_bitmap_index = 0;\n\tjournal_list_init(sb);\n\n\tmemset(journal->j_list_hash_table, 0,\n\t       JOURNAL_HASH_SIZE * sizeof(struct reiserfs_journal_cnode *));\n\n\tINIT_LIST_HEAD(&journal->j_dirty_buffers);\n\tspin_lock_init(&journal->j_dirty_buffers_lock);\n\n\tjournal->j_start = 0;\n\tjournal->j_len = 0;\n\tjournal->j_len_alloc = 0;\n\tatomic_set(&journal->j_wcount, 0);\n\tatomic_set(&journal->j_async_throttle, 0);\n\tjournal->j_bcount = 0;\n\tjournal->j_trans_start_time = 0;\n\tjournal->j_last = NULL;\n\tjournal->j_first = NULL;\n\tinit_waitqueue_head(&journal->j_join_wait);\n\tmutex_init(&journal->j_mutex);\n\tmutex_init(&journal->j_flush_mutex);\n\n\tjournal->j_trans_id = 10;\n\tjournal->j_mount_id = 10;\n\tjournal->j_state = 0;\n\tatomic_set(&journal->j_jlock, 0);\n\tjournal->j_cnode_free_list = allocate_cnodes(num_cnodes);\n\tjournal->j_cnode_free_orig = journal->j_cnode_free_list;\n\tjournal->j_cnode_free = journal->j_cnode_free_list ? num_cnodes : 0;\n\tjournal->j_cnode_used = 0;\n\tjournal->j_must_wait = 0;\n\n\tif (journal->j_cnode_free == 0) {\n\t\treiserfs_warning(sb, \"journal-2004\", \"Journal cnode memory \"\n\t\t                 \"allocation failed (%ld bytes). Journal is \"\n\t\t                 \"too large for available memory. Usually \"\n\t\t                 \"this is due to a journal that is too large.\",\n\t\t                 sizeof (struct reiserfs_journal_cnode) * num_cnodes);\n        \tgoto free_and_return;\n\t}\n\n\tinit_journal_hash(sb);\n\tjl = journal->j_current_jl;\n\n\t/*\n\t * get_list_bitmap() may call flush_commit_list() which\n\t * requires the lock. Calling flush_commit_list() shouldn't happen\n\t * this early but I like to be paranoid.\n\t */\n\treiserfs_write_lock(sb);\n\tjl->j_list_bitmap = get_list_bitmap(sb, jl);\n\treiserfs_write_unlock(sb);\n\tif (!jl->j_list_bitmap) {\n\t\treiserfs_warning(sb, \"journal-2005\",\n\t\t\t\t \"get_list_bitmap failed for journal list 0\");\n\t\tgoto free_and_return;\n\t}\n\n\tret = journal_read(sb);\n\tif (ret < 0) {\n\t\treiserfs_warning(sb, \"reiserfs-2006\",\n\t\t\t\t \"Replay Failure, unable to mount\");\n\t\tgoto free_and_return;\n\t}\n\n\tINIT_DELAYED_WORK(&journal->j_work, flush_async_commits);\n\tjournal->j_work_sb = sb;\n\treturn 0;\nfree_and_return:\n\tfree_journal_ram(sb);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"reiserfs: using flush barriers\\n\""
          ],
          "line": 1977
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "291-295",
          "snippet": "static void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nstatic void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_barrier_flush",
          "args": [
            "s"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_data_ordered",
          "args": [
            "s"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_data_log",
          "args": [
            "s"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_data_writeback",
          "args": [
            "s"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_data_ordered",
          "args": [
            "s"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_data_log",
          "args": [
            "s"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWARN",
          "args": [
            "silent",
            "s",
            "\"\"",
            "\"- it is slow mode for debugging.\""
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWARN",
          "args": [
            "silent",
            "s",
            "\"\"",
            "\"CONFIG_REISERFS_CHECK is set ON\""
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWARN",
          "args": [
            "silent",
            "s",
            "\"jmacd-8\"",
            "\"unable to read bitmap\""
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_init_bitmap_cache",
          "args": [
            "s"
          ],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_init_bitmap_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "1446-1460",
          "snippet": "int reiserfs_init_bitmap_cache(struct super_block *sb)\n{\n\tstruct reiserfs_bitmap_info *bitmap;\n\tunsigned int bmap_nr = reiserfs_bmap_count(sb);\n\n\tbitmap = vmalloc(sizeof(*bitmap) * bmap_nr);\n\tif (bitmap == NULL)\n\t\treturn -ENOMEM;\n\n\tmemset(bitmap, 0xff, sizeof(*bitmap) * bmap_nr);\n\n\tSB_AP_BITMAP(sb) = bitmap;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nint reiserfs_init_bitmap_cache(struct super_block *sb)\n{\n\tstruct reiserfs_bitmap_info *bitmap;\n\tunsigned int bmap_nr = reiserfs_bmap_count(sb);\n\n\tbitmap = vmalloc(sizeof(*bitmap) * bmap_nr);\n\tif (bitmap == NULL)\n\t\treturn -ENOMEM;\n\n\tmemset(bitmap, 0xff, sizeof(*bitmap) * bmap_nr);\n\n\tSB_AP_BITMAP(sb) = bitmap;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_REISERFS_STATE",
          "args": [
            "s"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWARN",
          "args": [
            "silent",
            "s",
            "\"\"",
            "\"Or may be you forgot to \"\n\t\t      \"reboot after fdisk when it told you to\""
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWARN",
          "args": [
            "silent",
            "s",
            "\"\"",
            "\"You may need to run fsck \"\n\t\t      \"or increase size of your LVM partition\""
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWARN",
          "args": [
            "silent",
            "s",
            "\"\"",
            "\"Filesystem cannot be \"\n\t\t      \"mounted because it is bigger than the device\""
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_blocksize",
          "args": [
            "rs"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_block_count",
          "args": [
            "rs"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "s->s_bdev->bd_inode"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_DISK_SUPER_BLOCK",
          "args": [
            "s"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWARN",
          "args": [
            "silent",
            "s",
            "\"sh-2021\"",
            "\"can not find reiserfs on %s\"",
            "s->s_id"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_super_block",
          "args": [
            "s",
            "REISERFS_DISK_OFFSET_IN_BYTES"
          ],
          "line": 1925
        },
        "resolved": true,
        "details": {
          "function_name": "read_super_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "1555-1655",
          "snippet": "static int read_super_block(struct super_block *s, int offset)\n{\n\tstruct buffer_head *bh;\n\tstruct reiserfs_super_block *rs;\n\tint fs_blocksize;\n\n\tbh = sb_bread(s, offset / s->s_blocksize);\n\tif (!bh) {\n\t\treiserfs_warning(s, \"sh-2006\",\n\t\t\t\t \"bread failed (dev %s, block %lu, size %lu)\",\n\t\t\t\t s->s_id, offset / s->s_blocksize,\n\t\t\t\t s->s_blocksize);\n\t\treturn 1;\n\t}\n\n\trs = (struct reiserfs_super_block *)bh->b_data;\n\tif (!is_any_reiserfs_magic_string(rs)) {\n\t\tbrelse(bh);\n\t\treturn 1;\n\t}\n\t/*\n\t * ok, reiserfs signature (old or new) found in at the given offset\n\t */\n\tfs_blocksize = sb_blocksize(rs);\n\tbrelse(bh);\n\tsb_set_blocksize(s, fs_blocksize);\n\n\tbh = sb_bread(s, offset / s->s_blocksize);\n\tif (!bh) {\n\t\treiserfs_warning(s, \"sh-2007\",\n\t\t\t\t \"bread failed (dev %s, block %lu, size %lu)\",\n\t\t\t\t s->s_id, offset / s->s_blocksize,\n\t\t\t\t s->s_blocksize);\n\t\treturn 1;\n\t}\n\n\trs = (struct reiserfs_super_block *)bh->b_data;\n\tif (sb_blocksize(rs) != s->s_blocksize) {\n\t\treiserfs_warning(s, \"sh-2011\", \"can't find a reiserfs \"\n\t\t\t\t \"filesystem on (dev %s, block %llu, size %lu)\",\n\t\t\t\t s->s_id,\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t s->s_blocksize);\n\t\tbrelse(bh);\n\t\treturn 1;\n\t}\n\n\tif (rs->s_v1.s_root_block == cpu_to_le32(-1)) {\n\t\tbrelse(bh);\n\t\treiserfs_warning(s, \"super-6519\", \"Unfinished reiserfsck \"\n\t\t\t\t \"--rebuild-tree run detected. Please run\\n\"\n\t\t\t\t \"reiserfsck --rebuild-tree and wait for a \"\n\t\t\t\t \"completion. If that fails\\n\"\n\t\t\t\t \"get newer reiserfsprogs package\");\n\t\treturn 1;\n\t}\n\n\tSB_BUFFER_WITH_SB(s) = bh;\n\tSB_DISK_SUPER_BLOCK(s) = rs;\n\n\t/*\n\t * magic is of non-standard journal filesystem, look at s_version to\n\t * find which format is in use\n\t */\n\tif (is_reiserfs_jr(rs)) {\n\t\tif (sb_version(rs) == REISERFS_VERSION_2)\n\t\t\treiserfs_info(s, \"found reiserfs format \\\"3.6\\\"\"\n\t\t\t\t      \" with non-standard journal\\n\");\n\t\telse if (sb_version(rs) == REISERFS_VERSION_1)\n\t\t\treiserfs_info(s, \"found reiserfs format \\\"3.5\\\"\"\n\t\t\t\t      \" with non-standard journal\\n\");\n\t\telse {\n\t\t\treiserfs_warning(s, \"sh-2012\", \"found unknown \"\n\t\t\t\t\t \"format \\\"%u\\\" of reiserfs with \"\n\t\t\t\t\t \"non-standard magic\", sb_version(rs));\n\t\t\treturn 1;\n\t\t}\n\t} else\n\t\t/*\n\t\t * s_version of standard format may contain incorrect\n\t\t * information, so we just look at the magic string\n\t\t */\n\t\treiserfs_info(s,\n\t\t\t      \"found reiserfs format \\\"%s\\\" with standard journal\\n\",\n\t\t\t      is_reiserfs_3_5(rs) ? \"3.5\" : \"3.6\");\n\n\ts->s_op = &reiserfs_sops;\n\ts->s_export_op = &reiserfs_export_ops;\n#ifdef CONFIG_QUOTA\n\ts->s_qcop = &reiserfs_qctl_operations;\n\ts->dq_op = &reiserfs_quota_operations;\n\ts->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;\n#endif\n\n\t/*\n\t * new format is limited by the 32 bit wide i_blocks field, want to\n\t * be one full block below that.\n\t */\n\ts->s_maxbytes = (512LL << 32) - s->s_blocksize;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct super_operations reiserfs_sops = {\n\t.alloc_inode = reiserfs_alloc_inode,\n\t.destroy_inode = reiserfs_destroy_inode,\n\t.write_inode = reiserfs_write_inode,\n\t.dirty_inode = reiserfs_dirty_inode,\n\t.evict_inode = reiserfs_evict_inode,\n\t.put_super = reiserfs_put_super,\n\t.sync_fs = reiserfs_sync_fs,\n\t.freeze_fs = reiserfs_freeze,\n\t.unfreeze_fs = reiserfs_unfreeze,\n\t.statfs = reiserfs_statfs,\n\t.remount_fs = reiserfs_remount,\n\t.show_options = reiserfs_show_options,\n#ifdef CONFIG_QUOTA\n\t.quota_read = reiserfs_quota_read,\n\t.quota_write = reiserfs_quota_write,\n\t.get_dquots = reiserfs_get_dquots,\n#endif\n};",
            "static const struct export_operations reiserfs_export_ops = {\n\t.encode_fh = reiserfs_encode_fh,\n\t.fh_to_dentry = reiserfs_fh_to_dentry,\n\t.fh_to_parent = reiserfs_fh_to_parent,\n\t.get_parent = reiserfs_get_parent,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct super_operations reiserfs_sops = {\n\t.alloc_inode = reiserfs_alloc_inode,\n\t.destroy_inode = reiserfs_destroy_inode,\n\t.write_inode = reiserfs_write_inode,\n\t.dirty_inode = reiserfs_dirty_inode,\n\t.evict_inode = reiserfs_evict_inode,\n\t.put_super = reiserfs_put_super,\n\t.sync_fs = reiserfs_sync_fs,\n\t.freeze_fs = reiserfs_freeze,\n\t.unfreeze_fs = reiserfs_unfreeze,\n\t.statfs = reiserfs_statfs,\n\t.remount_fs = reiserfs_remount,\n\t.show_options = reiserfs_show_options,\n#ifdef CONFIG_QUOTA\n\t.quota_read = reiserfs_quota_read,\n\t.quota_write = reiserfs_quota_write,\n\t.get_dquots = reiserfs_get_dquots,\n#endif\n};\nstatic const struct export_operations reiserfs_export_ops = {\n\t.encode_fh = reiserfs_encode_fh,\n\t.fh_to_dentry = reiserfs_fh_to_dentry,\n\t.fh_to_parent = reiserfs_fh_to_parent,\n\t.get_parent = reiserfs_get_parent,\n};\n\nstatic int read_super_block(struct super_block *s, int offset)\n{\n\tstruct buffer_head *bh;\n\tstruct reiserfs_super_block *rs;\n\tint fs_blocksize;\n\n\tbh = sb_bread(s, offset / s->s_blocksize);\n\tif (!bh) {\n\t\treiserfs_warning(s, \"sh-2006\",\n\t\t\t\t \"bread failed (dev %s, block %lu, size %lu)\",\n\t\t\t\t s->s_id, offset / s->s_blocksize,\n\t\t\t\t s->s_blocksize);\n\t\treturn 1;\n\t}\n\n\trs = (struct reiserfs_super_block *)bh->b_data;\n\tif (!is_any_reiserfs_magic_string(rs)) {\n\t\tbrelse(bh);\n\t\treturn 1;\n\t}\n\t/*\n\t * ok, reiserfs signature (old or new) found in at the given offset\n\t */\n\tfs_blocksize = sb_blocksize(rs);\n\tbrelse(bh);\n\tsb_set_blocksize(s, fs_blocksize);\n\n\tbh = sb_bread(s, offset / s->s_blocksize);\n\tif (!bh) {\n\t\treiserfs_warning(s, \"sh-2007\",\n\t\t\t\t \"bread failed (dev %s, block %lu, size %lu)\",\n\t\t\t\t s->s_id, offset / s->s_blocksize,\n\t\t\t\t s->s_blocksize);\n\t\treturn 1;\n\t}\n\n\trs = (struct reiserfs_super_block *)bh->b_data;\n\tif (sb_blocksize(rs) != s->s_blocksize) {\n\t\treiserfs_warning(s, \"sh-2011\", \"can't find a reiserfs \"\n\t\t\t\t \"filesystem on (dev %s, block %llu, size %lu)\",\n\t\t\t\t s->s_id,\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t s->s_blocksize);\n\t\tbrelse(bh);\n\t\treturn 1;\n\t}\n\n\tif (rs->s_v1.s_root_block == cpu_to_le32(-1)) {\n\t\tbrelse(bh);\n\t\treiserfs_warning(s, \"super-6519\", \"Unfinished reiserfsck \"\n\t\t\t\t \"--rebuild-tree run detected. Please run\\n\"\n\t\t\t\t \"reiserfsck --rebuild-tree and wait for a \"\n\t\t\t\t \"completion. If that fails\\n\"\n\t\t\t\t \"get newer reiserfsprogs package\");\n\t\treturn 1;\n\t}\n\n\tSB_BUFFER_WITH_SB(s) = bh;\n\tSB_DISK_SUPER_BLOCK(s) = rs;\n\n\t/*\n\t * magic is of non-standard journal filesystem, look at s_version to\n\t * find which format is in use\n\t */\n\tif (is_reiserfs_jr(rs)) {\n\t\tif (sb_version(rs) == REISERFS_VERSION_2)\n\t\t\treiserfs_info(s, \"found reiserfs format \\\"3.6\\\"\"\n\t\t\t\t      \" with non-standard journal\\n\");\n\t\telse if (sb_version(rs) == REISERFS_VERSION_1)\n\t\t\treiserfs_info(s, \"found reiserfs format \\\"3.5\\\"\"\n\t\t\t\t      \" with non-standard journal\\n\");\n\t\telse {\n\t\t\treiserfs_warning(s, \"sh-2012\", \"found unknown \"\n\t\t\t\t\t \"format \\\"%u\\\" of reiserfs with \"\n\t\t\t\t\t \"non-standard magic\", sb_version(rs));\n\t\t\treturn 1;\n\t\t}\n\t} else\n\t\t/*\n\t\t * s_version of standard format may contain incorrect\n\t\t * information, so we just look at the magic string\n\t\t */\n\t\treiserfs_info(s,\n\t\t\t      \"found reiserfs format \\\"%s\\\" with standard journal\\n\",\n\t\t\t      is_reiserfs_3_5(rs) ? \"3.5\" : \"3.6\");\n\n\ts->s_op = &reiserfs_sops;\n\ts->s_export_op = &reiserfs_export_ops;\n#ifdef CONFIG_QUOTA\n\ts->s_qcop = &reiserfs_qctl_operations;\n\ts->dq_op = &reiserfs_quota_operations;\n\ts->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;\n#endif\n\n\t/*\n\t * new format is limited by the 32 bit wide i_blocks field, want to\n\t * be one full block below that.\n\t */\n\ts->s_maxbytes = (512LL << 32) - s->s_blocksize;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SWARN",
          "args": [
            "silent",
            "s",
            "\"jmacd-7\"",
            "\"resize option for remount only\""
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_quota_files",
          "args": [
            "s",
            "qf_names",
            "&qfmt"
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "handle_quota_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "1368-1380",
          "snippet": "static void handle_quota_files(struct super_block *s, char **qf_names,\n\t\t\t       unsigned int *qfmt)\n{\n\tint i;\n\n\tfor (i = 0; i < REISERFS_MAXQUOTAS; i++) {\n\t\tif (qf_names[i] != REISERFS_SB(s)->s_qf_names[i])\n\t\t\tkfree(REISERFS_SB(s)->s_qf_names[i]);\n\t\tREISERFS_SB(s)->s_qf_names[i] = qf_names[i];\n\t}\n\tif (*qfmt)\n\t\tREISERFS_SB(s)->s_jquota_fmt = *qfmt;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void handle_quota_files(struct super_block *s, char **qf_names,\n\t\t\t       unsigned int *qfmt)\n{\n\tint i;\n\n\tfor (i = 0; i < REISERFS_MAXQUOTAS; i++) {\n\t\tif (qf_names[i] != REISERFS_SB(s)->s_qf_names[i])\n\t\t\tkfree(REISERFS_SB(s)->s_qf_names[i]);\n\t\tREISERFS_SB(s)->s_qf_names[i] = qf_names[i];\n\t}\n\tif (*qfmt)\n\t\tREISERFS_SB(s)->s_jquota_fmt = *qfmt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SWARN",
          "args": [
            "silent",
            "s",
            "\"\"",
            "\"Cannot allocate memory for \"\n\t\t\t\t\"journal device name\""
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "jdev_name",
            "GFP_KERNEL"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_parse_options",
          "args": [
            "s",
            "(char *)data",
            "&sbi->s_mount_opt",
            "&blocks",
            "&jdev_name",
            "&commit_max_age",
            "qf_names",
            "&qfmt"
          ],
          "line": 1892
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "1063-1299",
          "snippet": "static int reiserfs_parse_options(struct super_block *s,\n\n\t\t\t\t  /* string given via mount's -o */\n\t\t\t\t  char *options,\n\n\t\t\t\t  /*\n\t\t\t\t   * after the parsing phase, contains the\n\t\t\t\t   * collection of bitflags defining what\n\t\t\t\t   * mount options were selected.\n\t\t\t\t   */\n\t\t\t\t  unsigned long *mount_options,\n\n\t\t\t\t  /* strtol-ed from NNN of resize=NNN */\n\t\t\t\t  unsigned long *blocks,\n\t\t\t\t  char **jdev_name,\n\t\t\t\t  unsigned int *commit_max_age,\n\t\t\t\t  char **qf_names,\n\t\t\t\t  unsigned int *qfmt)\n{\n\tint c;\n\tchar *arg = NULL;\n\tchar *pos;\n\topt_desc_t opts[] = {\n\t\t/*\n\t\t * Compatibility stuff, so that -o notail for old\n\t\t * setups still work\n\t\t */\n\t\t{\"tails\",.arg_required = 't',.values = tails},\n\t\t{\"notail\",.clrmask =\n\t\t (1 << REISERFS_LARGETAIL) | (1 << REISERFS_SMALLTAIL)},\n\t\t{\"conv\",.setmask = 1 << REISERFS_CONVERT},\n\t\t{\"attrs\",.setmask = 1 << REISERFS_ATTRS},\n\t\t{\"noattrs\",.clrmask = 1 << REISERFS_ATTRS},\n\t\t{\"expose_privroot\", .setmask = 1 << REISERFS_EXPOSE_PRIVROOT},\n#ifdef CONFIG_REISERFS_FS_XATTR\n\t\t{\"user_xattr\",.setmask = 1 << REISERFS_XATTRS_USER},\n\t\t{\"nouser_xattr\",.clrmask = 1 << REISERFS_XATTRS_USER},\n#else\n\t\t{\"user_xattr\",.setmask = 1 << REISERFS_UNSUPPORTED_OPT},\n\t\t{\"nouser_xattr\",.clrmask = 1 << REISERFS_UNSUPPORTED_OPT},\n#endif\n#ifdef CONFIG_REISERFS_FS_POSIX_ACL\n\t\t{\"acl\",.setmask = 1 << REISERFS_POSIXACL},\n\t\t{\"noacl\",.clrmask = 1 << REISERFS_POSIXACL},\n#else\n\t\t{\"acl\",.setmask = 1 << REISERFS_UNSUPPORTED_OPT},\n\t\t{\"noacl\",.clrmask = 1 << REISERFS_UNSUPPORTED_OPT},\n#endif\n\t\t{.option_name = \"nolog\"},\n\t\t{\"replayonly\",.setmask = 1 << REPLAYONLY},\n\t\t{\"block-allocator\",.arg_required = 'a',.values = balloc},\n\t\t{\"data\",.arg_required = 'd',.values = logging_mode},\n\t\t{\"barrier\",.arg_required = 'b',.values = barrier_mode},\n\t\t{\"resize\",.arg_required = 'r',.values = NULL},\n\t\t{\"jdev\",.arg_required = 'j',.values = NULL},\n\t\t{\"nolargeio\",.arg_required = 'w',.values = NULL},\n\t\t{\"commit\",.arg_required = 'c',.values = NULL},\n\t\t{\"usrquota\",.setmask = 1 << REISERFS_USRQUOTA},\n\t\t{\"grpquota\",.setmask = 1 << REISERFS_GRPQUOTA},\n\t\t{\"noquota\",.clrmask = 1 << REISERFS_USRQUOTA | 1 << REISERFS_GRPQUOTA},\n\t\t{\"errors\",.arg_required = 'e',.values = error_actions},\n\t\t{\"usrjquota\",.arg_required =\n\t\t 'u' | (1 << REISERFS_OPT_ALLOWEMPTY),.values = NULL},\n\t\t{\"grpjquota\",.arg_required =\n\t\t 'g' | (1 << REISERFS_OPT_ALLOWEMPTY),.values = NULL},\n\t\t{\"jqfmt\",.arg_required = 'f',.values = NULL},\n\t\t{.option_name = NULL}\n\t};\n\n\t*blocks = 0;\n\tif (!options || !*options)\n\t\t/*\n\t\t * use default configuration: create tails, journaling on, no\n\t\t * conversion to newest format\n\t\t */\n\t\treturn 1;\n\n\tfor (pos = options; pos;) {\n\t\tc = reiserfs_getopt(s, &pos, opts, &arg, mount_options);\n\t\tif (c == -1)\n\t\t\t/* wrong option is given */\n\t\t\treturn 0;\n\n\t\tif (c == 'r') {\n\t\t\tchar *p;\n\n\t\t\tp = NULL;\n\t\t\t/* \"resize=NNN\" or \"resize=auto\" */\n\n\t\t\tif (!strcmp(arg, \"auto\")) {\n\t\t\t\t/* From JFS code, to auto-get the size. */\n\t\t\t\t*blocks =\n\t\t\t\t    s->s_bdev->bd_inode->i_size >> s->\n\t\t\t\t    s_blocksize_bits;\n\t\t\t} else {\n\t\t\t\t*blocks = simple_strtoul(arg, &p, 0);\n\t\t\t\tif (*p != '\\0') {\n\t\t\t\t\t/* NNN does not look like a number */\n\t\t\t\t\treiserfs_warning(s, \"super-6507\",\n\t\t\t\t\t\t\t \"bad value %s for \"\n\t\t\t\t\t\t\t \"-oresize\\n\", arg);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (c == 'c') {\n\t\t\tchar *p = NULL;\n\t\t\tunsigned long val = simple_strtoul(arg, &p, 0);\n\t\t\t/* commit=NNN (time in seconds) */\n\t\t\tif (*p != '\\0' || val >= (unsigned int)-1) {\n\t\t\t\treiserfs_warning(s, \"super-6508\",\n\t\t\t\t\t\t \"bad value %s for -ocommit\\n\",\n\t\t\t\t\t\t arg);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t*commit_max_age = (unsigned int)val;\n\t\t}\n\n\t\tif (c == 'w') {\n\t\t\treiserfs_warning(s, \"super-6509\", \"nolargeio option \"\n\t\t\t\t\t \"is no longer supported\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (c == 'j') {\n\t\t\tif (arg && *arg && jdev_name) {\n\t\t\t\t/* Hm, already assigned? */\n\t\t\t\tif (*jdev_name) {\n\t\t\t\t\treiserfs_warning(s, \"super-6510\",\n\t\t\t\t\t\t\t \"journal device was \"\n\t\t\t\t\t\t\t \"already specified to \"\n\t\t\t\t\t\t\t \"be %s\", *jdev_name);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t*jdev_name = arg;\n\t\t\t}\n\t\t}\n#ifdef CONFIG_QUOTA\n\t\tif (c == 'u' || c == 'g') {\n\t\t\tint qtype = c == 'u' ? USRQUOTA : GRPQUOTA;\n\n\t\t\tif (sb_any_quota_loaded(s) &&\n\t\t\t    (!*arg != !REISERFS_SB(s)->s_qf_names[qtype])) {\n\t\t\t\treiserfs_warning(s, \"super-6511\",\n\t\t\t\t\t\t \"cannot change journaled \"\n\t\t\t\t\t\t \"quota options when quota \"\n\t\t\t\t\t\t \"turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (*arg) {\t/* Some filename specified? */\n\t\t\t\tif (REISERFS_SB(s)->s_qf_names[qtype]\n\t\t\t\t    && strcmp(REISERFS_SB(s)->s_qf_names[qtype],\n\t\t\t\t\t      arg)) {\n\t\t\t\t\treiserfs_warning(s, \"super-6512\",\n\t\t\t\t\t\t\t \"%s quota file \"\n\t\t\t\t\t\t\t \"already specified.\",\n\t\t\t\t\t\t\t QTYPE2NAME(qtype));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (strchr(arg, '/')) {\n\t\t\t\t\treiserfs_warning(s, \"super-6513\",\n\t\t\t\t\t\t\t \"quotafile must be \"\n\t\t\t\t\t\t\t \"on filesystem root.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tqf_names[qtype] = kstrdup(arg, GFP_KERNEL);\n\t\t\t\tif (!qf_names[qtype]) {\n\t\t\t\t\treiserfs_warning(s, \"reiserfs-2502\",\n\t\t\t\t\t\t\t \"not enough memory \"\n\t\t\t\t\t\t\t \"for storing \"\n\t\t\t\t\t\t\t \"quotafile name.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (qtype == USRQUOTA)\n\t\t\t\t\t*mount_options |= 1 << REISERFS_USRQUOTA;\n\t\t\t\telse\n\t\t\t\t\t*mount_options |= 1 << REISERFS_GRPQUOTA;\n\t\t\t} else {\n\t\t\t\tif (qf_names[qtype] !=\n\t\t\t\t    REISERFS_SB(s)->s_qf_names[qtype])\n\t\t\t\t\tkfree(qf_names[qtype]);\n\t\t\t\tqf_names[qtype] = NULL;\n\t\t\t\tif (qtype == USRQUOTA)\n\t\t\t\t\t*mount_options &= ~(1 << REISERFS_USRQUOTA);\n\t\t\t\telse\n\t\t\t\t\t*mount_options &= ~(1 << REISERFS_GRPQUOTA);\n\t\t\t}\n\t\t}\n\t\tif (c == 'f') {\n\t\t\tif (!strcmp(arg, \"vfsold\"))\n\t\t\t\t*qfmt = QFMT_VFS_OLD;\n\t\t\telse if (!strcmp(arg, \"vfsv0\"))\n\t\t\t\t*qfmt = QFMT_VFS_V0;\n\t\t\telse {\n\t\t\t\treiserfs_warning(s, \"super-6514\",\n\t\t\t\t\t\t \"unknown quota format \"\n\t\t\t\t\t\t \"specified.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (sb_any_quota_loaded(s) &&\n\t\t\t    *qfmt != REISERFS_SB(s)->s_jquota_fmt) {\n\t\t\t\treiserfs_warning(s, \"super-6515\",\n\t\t\t\t\t\t \"cannot change journaled \"\n\t\t\t\t\t\t \"quota options when quota \"\n\t\t\t\t\t\t \"turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n#else\n\t\tif (c == 'u' || c == 'g' || c == 'f') {\n\t\t\treiserfs_warning(s, \"reiserfs-2503\", \"journaled \"\n\t\t\t\t\t \"quota options not supported.\");\n\t\t\treturn 0;\n\t\t}\n#endif\n\t}\n\n#ifdef CONFIG_QUOTA\n\tif (!REISERFS_SB(s)->s_jquota_fmt && !*qfmt\n\t    && (qf_names[USRQUOTA] || qf_names[GRPQUOTA])) {\n\t\treiserfs_warning(s, \"super-6515\",\n\t\t\t\t \"journaled quota format not specified.\");\n\t\treturn 0;\n\t}\n\tif ((!(*mount_options & (1 << REISERFS_USRQUOTA)) &&\n\t       sb_has_quota_loaded(s, USRQUOTA)) ||\n\t    (!(*mount_options & (1 << REISERFS_GRPQUOTA)) &&\n\t       sb_has_quota_loaded(s, GRPQUOTA))) {\n\t\treiserfs_warning(s, \"super-6516\", \"quota options must \"\n\t\t\t\t \"be present when quota is turned on.\");\n\t\treturn 0;\n\t}\n#endif\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define REISERFS_OPT_ALLOWEMPTY 31"
          ],
          "globals_used": [
            "static int reiserfs_remount(struct super_block *s, int *flags, char *data);",
            "static const arg_desc_t logging_mode[] = {\n\t{\"ordered\", 1 << REISERFS_DATA_ORDERED,\n\t (1 << REISERFS_DATA_LOG | 1 << REISERFS_DATA_WRITEBACK)},\n\t{\"journal\", 1 << REISERFS_DATA_LOG,\n\t (1 << REISERFS_DATA_ORDERED | 1 << REISERFS_DATA_WRITEBACK)},\n\t{\"writeback\", 1 << REISERFS_DATA_WRITEBACK,\n\t (1 << REISERFS_DATA_ORDERED | 1 << REISERFS_DATA_LOG)},\n\t{.value = NULL}\n};",
            "static const arg_desc_t barrier_mode[] = {\n\t{\"none\", 1 << REISERFS_BARRIER_NONE, 1 << REISERFS_BARRIER_FLUSH},\n\t{\"flush\", 1 << REISERFS_BARRIER_FLUSH, 1 << REISERFS_BARRIER_NONE},\n\t{.value = NULL}\n};",
            "static const arg_desc_t balloc[] = {\n\t{\"noborder\", 1 << REISERFS_NO_BORDER, 0},\n\t{\"border\", 0, 1 << REISERFS_NO_BORDER},\n\t{\"no_unhashed_relocation\", 1 << REISERFS_NO_UNHASHED_RELOCATION, 0},\n\t{\"hashed_relocation\", 1 << REISERFS_HASHED_RELOCATION, 0},\n\t{\"test4\", 1 << REISERFS_TEST4, 0},\n\t{\"notest4\", 0, 1 << REISERFS_TEST4},\n\t{NULL, 0, 0}\n};",
            "static const arg_desc_t tails[] = {\n\t{\"on\", 1 << REISERFS_LARGETAIL, 1 << REISERFS_SMALLTAIL},\n\t{\"off\", 0, (1 << REISERFS_LARGETAIL) | (1 << REISERFS_SMALLTAIL)},\n\t{\"small\", 1 << REISERFS_SMALLTAIL, 1 << REISERFS_LARGETAIL},\n\t{NULL, 0, 0}\n};",
            "static const arg_desc_t error_actions[] = {\n\t{\"panic\", 1 << REISERFS_ERROR_PANIC,\n\t (1 << REISERFS_ERROR_RO | 1 << REISERFS_ERROR_CONTINUE)},\n\t{\"ro-remount\", 1 << REISERFS_ERROR_RO,\n\t (1 << REISERFS_ERROR_PANIC | 1 << REISERFS_ERROR_CONTINUE)},\n#ifdef REISERFS_JOURNAL_ERROR_ALLOWS_NO_LOG\n\t{\"continue\", 1 << REISERFS_ERROR_CONTINUE,\n\t (1 << REISERFS_ERROR_PANIC | 1 << REISERFS_ERROR_RO)},\n#endif\n\t{NULL, 0, 0},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define REISERFS_OPT_ALLOWEMPTY 31\n\nstatic int reiserfs_remount(struct super_block *s, int *flags, char *data);\nstatic const arg_desc_t logging_mode[] = {\n\t{\"ordered\", 1 << REISERFS_DATA_ORDERED,\n\t (1 << REISERFS_DATA_LOG | 1 << REISERFS_DATA_WRITEBACK)},\n\t{\"journal\", 1 << REISERFS_DATA_LOG,\n\t (1 << REISERFS_DATA_ORDERED | 1 << REISERFS_DATA_WRITEBACK)},\n\t{\"writeback\", 1 << REISERFS_DATA_WRITEBACK,\n\t (1 << REISERFS_DATA_ORDERED | 1 << REISERFS_DATA_LOG)},\n\t{.value = NULL}\n};\nstatic const arg_desc_t barrier_mode[] = {\n\t{\"none\", 1 << REISERFS_BARRIER_NONE, 1 << REISERFS_BARRIER_FLUSH},\n\t{\"flush\", 1 << REISERFS_BARRIER_FLUSH, 1 << REISERFS_BARRIER_NONE},\n\t{.value = NULL}\n};\nstatic const arg_desc_t balloc[] = {\n\t{\"noborder\", 1 << REISERFS_NO_BORDER, 0},\n\t{\"border\", 0, 1 << REISERFS_NO_BORDER},\n\t{\"no_unhashed_relocation\", 1 << REISERFS_NO_UNHASHED_RELOCATION, 0},\n\t{\"hashed_relocation\", 1 << REISERFS_HASHED_RELOCATION, 0},\n\t{\"test4\", 1 << REISERFS_TEST4, 0},\n\t{\"notest4\", 0, 1 << REISERFS_TEST4},\n\t{NULL, 0, 0}\n};\nstatic const arg_desc_t tails[] = {\n\t{\"on\", 1 << REISERFS_LARGETAIL, 1 << REISERFS_SMALLTAIL},\n\t{\"off\", 0, (1 << REISERFS_LARGETAIL) | (1 << REISERFS_SMALLTAIL)},\n\t{\"small\", 1 << REISERFS_SMALLTAIL, 1 << REISERFS_LARGETAIL},\n\t{NULL, 0, 0}\n};\nstatic const arg_desc_t error_actions[] = {\n\t{\"panic\", 1 << REISERFS_ERROR_PANIC,\n\t (1 << REISERFS_ERROR_RO | 1 << REISERFS_ERROR_CONTINUE)},\n\t{\"ro-remount\", 1 << REISERFS_ERROR_RO,\n\t (1 << REISERFS_ERROR_PANIC | 1 << REISERFS_ERROR_CONTINUE)},\n#ifdef REISERFS_JOURNAL_ERROR_ALLOWS_NO_LOG\n\t{\"continue\", 1 << REISERFS_ERROR_CONTINUE,\n\t (1 << REISERFS_ERROR_PANIC | 1 << REISERFS_ERROR_RO)},\n#endif\n\t{NULL, 0, 0},\n};\n\nstatic int reiserfs_parse_options(struct super_block *s,\n\n\t\t\t\t  /* string given via mount's -o */\n\t\t\t\t  char *options,\n\n\t\t\t\t  /*\n\t\t\t\t   * after the parsing phase, contains the\n\t\t\t\t   * collection of bitflags defining what\n\t\t\t\t   * mount options were selected.\n\t\t\t\t   */\n\t\t\t\t  unsigned long *mount_options,\n\n\t\t\t\t  /* strtol-ed from NNN of resize=NNN */\n\t\t\t\t  unsigned long *blocks,\n\t\t\t\t  char **jdev_name,\n\t\t\t\t  unsigned int *commit_max_age,\n\t\t\t\t  char **qf_names,\n\t\t\t\t  unsigned int *qfmt)\n{\n\tint c;\n\tchar *arg = NULL;\n\tchar *pos;\n\topt_desc_t opts[] = {\n\t\t/*\n\t\t * Compatibility stuff, so that -o notail for old\n\t\t * setups still work\n\t\t */\n\t\t{\"tails\",.arg_required = 't',.values = tails},\n\t\t{\"notail\",.clrmask =\n\t\t (1 << REISERFS_LARGETAIL) | (1 << REISERFS_SMALLTAIL)},\n\t\t{\"conv\",.setmask = 1 << REISERFS_CONVERT},\n\t\t{\"attrs\",.setmask = 1 << REISERFS_ATTRS},\n\t\t{\"noattrs\",.clrmask = 1 << REISERFS_ATTRS},\n\t\t{\"expose_privroot\", .setmask = 1 << REISERFS_EXPOSE_PRIVROOT},\n#ifdef CONFIG_REISERFS_FS_XATTR\n\t\t{\"user_xattr\",.setmask = 1 << REISERFS_XATTRS_USER},\n\t\t{\"nouser_xattr\",.clrmask = 1 << REISERFS_XATTRS_USER},\n#else\n\t\t{\"user_xattr\",.setmask = 1 << REISERFS_UNSUPPORTED_OPT},\n\t\t{\"nouser_xattr\",.clrmask = 1 << REISERFS_UNSUPPORTED_OPT},\n#endif\n#ifdef CONFIG_REISERFS_FS_POSIX_ACL\n\t\t{\"acl\",.setmask = 1 << REISERFS_POSIXACL},\n\t\t{\"noacl\",.clrmask = 1 << REISERFS_POSIXACL},\n#else\n\t\t{\"acl\",.setmask = 1 << REISERFS_UNSUPPORTED_OPT},\n\t\t{\"noacl\",.clrmask = 1 << REISERFS_UNSUPPORTED_OPT},\n#endif\n\t\t{.option_name = \"nolog\"},\n\t\t{\"replayonly\",.setmask = 1 << REPLAYONLY},\n\t\t{\"block-allocator\",.arg_required = 'a',.values = balloc},\n\t\t{\"data\",.arg_required = 'd',.values = logging_mode},\n\t\t{\"barrier\",.arg_required = 'b',.values = barrier_mode},\n\t\t{\"resize\",.arg_required = 'r',.values = NULL},\n\t\t{\"jdev\",.arg_required = 'j',.values = NULL},\n\t\t{\"nolargeio\",.arg_required = 'w',.values = NULL},\n\t\t{\"commit\",.arg_required = 'c',.values = NULL},\n\t\t{\"usrquota\",.setmask = 1 << REISERFS_USRQUOTA},\n\t\t{\"grpquota\",.setmask = 1 << REISERFS_GRPQUOTA},\n\t\t{\"noquota\",.clrmask = 1 << REISERFS_USRQUOTA | 1 << REISERFS_GRPQUOTA},\n\t\t{\"errors\",.arg_required = 'e',.values = error_actions},\n\t\t{\"usrjquota\",.arg_required =\n\t\t 'u' | (1 << REISERFS_OPT_ALLOWEMPTY),.values = NULL},\n\t\t{\"grpjquota\",.arg_required =\n\t\t 'g' | (1 << REISERFS_OPT_ALLOWEMPTY),.values = NULL},\n\t\t{\"jqfmt\",.arg_required = 'f',.values = NULL},\n\t\t{.option_name = NULL}\n\t};\n\n\t*blocks = 0;\n\tif (!options || !*options)\n\t\t/*\n\t\t * use default configuration: create tails, journaling on, no\n\t\t * conversion to newest format\n\t\t */\n\t\treturn 1;\n\n\tfor (pos = options; pos;) {\n\t\tc = reiserfs_getopt(s, &pos, opts, &arg, mount_options);\n\t\tif (c == -1)\n\t\t\t/* wrong option is given */\n\t\t\treturn 0;\n\n\t\tif (c == 'r') {\n\t\t\tchar *p;\n\n\t\t\tp = NULL;\n\t\t\t/* \"resize=NNN\" or \"resize=auto\" */\n\n\t\t\tif (!strcmp(arg, \"auto\")) {\n\t\t\t\t/* From JFS code, to auto-get the size. */\n\t\t\t\t*blocks =\n\t\t\t\t    s->s_bdev->bd_inode->i_size >> s->\n\t\t\t\t    s_blocksize_bits;\n\t\t\t} else {\n\t\t\t\t*blocks = simple_strtoul(arg, &p, 0);\n\t\t\t\tif (*p != '\\0') {\n\t\t\t\t\t/* NNN does not look like a number */\n\t\t\t\t\treiserfs_warning(s, \"super-6507\",\n\t\t\t\t\t\t\t \"bad value %s for \"\n\t\t\t\t\t\t\t \"-oresize\\n\", arg);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (c == 'c') {\n\t\t\tchar *p = NULL;\n\t\t\tunsigned long val = simple_strtoul(arg, &p, 0);\n\t\t\t/* commit=NNN (time in seconds) */\n\t\t\tif (*p != '\\0' || val >= (unsigned int)-1) {\n\t\t\t\treiserfs_warning(s, \"super-6508\",\n\t\t\t\t\t\t \"bad value %s for -ocommit\\n\",\n\t\t\t\t\t\t arg);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t*commit_max_age = (unsigned int)val;\n\t\t}\n\n\t\tif (c == 'w') {\n\t\t\treiserfs_warning(s, \"super-6509\", \"nolargeio option \"\n\t\t\t\t\t \"is no longer supported\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (c == 'j') {\n\t\t\tif (arg && *arg && jdev_name) {\n\t\t\t\t/* Hm, already assigned? */\n\t\t\t\tif (*jdev_name) {\n\t\t\t\t\treiserfs_warning(s, \"super-6510\",\n\t\t\t\t\t\t\t \"journal device was \"\n\t\t\t\t\t\t\t \"already specified to \"\n\t\t\t\t\t\t\t \"be %s\", *jdev_name);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t*jdev_name = arg;\n\t\t\t}\n\t\t}\n#ifdef CONFIG_QUOTA\n\t\tif (c == 'u' || c == 'g') {\n\t\t\tint qtype = c == 'u' ? USRQUOTA : GRPQUOTA;\n\n\t\t\tif (sb_any_quota_loaded(s) &&\n\t\t\t    (!*arg != !REISERFS_SB(s)->s_qf_names[qtype])) {\n\t\t\t\treiserfs_warning(s, \"super-6511\",\n\t\t\t\t\t\t \"cannot change journaled \"\n\t\t\t\t\t\t \"quota options when quota \"\n\t\t\t\t\t\t \"turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (*arg) {\t/* Some filename specified? */\n\t\t\t\tif (REISERFS_SB(s)->s_qf_names[qtype]\n\t\t\t\t    && strcmp(REISERFS_SB(s)->s_qf_names[qtype],\n\t\t\t\t\t      arg)) {\n\t\t\t\t\treiserfs_warning(s, \"super-6512\",\n\t\t\t\t\t\t\t \"%s quota file \"\n\t\t\t\t\t\t\t \"already specified.\",\n\t\t\t\t\t\t\t QTYPE2NAME(qtype));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (strchr(arg, '/')) {\n\t\t\t\t\treiserfs_warning(s, \"super-6513\",\n\t\t\t\t\t\t\t \"quotafile must be \"\n\t\t\t\t\t\t\t \"on filesystem root.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tqf_names[qtype] = kstrdup(arg, GFP_KERNEL);\n\t\t\t\tif (!qf_names[qtype]) {\n\t\t\t\t\treiserfs_warning(s, \"reiserfs-2502\",\n\t\t\t\t\t\t\t \"not enough memory \"\n\t\t\t\t\t\t\t \"for storing \"\n\t\t\t\t\t\t\t \"quotafile name.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (qtype == USRQUOTA)\n\t\t\t\t\t*mount_options |= 1 << REISERFS_USRQUOTA;\n\t\t\t\telse\n\t\t\t\t\t*mount_options |= 1 << REISERFS_GRPQUOTA;\n\t\t\t} else {\n\t\t\t\tif (qf_names[qtype] !=\n\t\t\t\t    REISERFS_SB(s)->s_qf_names[qtype])\n\t\t\t\t\tkfree(qf_names[qtype]);\n\t\t\t\tqf_names[qtype] = NULL;\n\t\t\t\tif (qtype == USRQUOTA)\n\t\t\t\t\t*mount_options &= ~(1 << REISERFS_USRQUOTA);\n\t\t\t\telse\n\t\t\t\t\t*mount_options &= ~(1 << REISERFS_GRPQUOTA);\n\t\t\t}\n\t\t}\n\t\tif (c == 'f') {\n\t\t\tif (!strcmp(arg, \"vfsold\"))\n\t\t\t\t*qfmt = QFMT_VFS_OLD;\n\t\t\telse if (!strcmp(arg, \"vfsv0\"))\n\t\t\t\t*qfmt = QFMT_VFS_V0;\n\t\t\telse {\n\t\t\t\treiserfs_warning(s, \"super-6514\",\n\t\t\t\t\t\t \"unknown quota format \"\n\t\t\t\t\t\t \"specified.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (sb_any_quota_loaded(s) &&\n\t\t\t    *qfmt != REISERFS_SB(s)->s_jquota_fmt) {\n\t\t\t\treiserfs_warning(s, \"super-6515\",\n\t\t\t\t\t\t \"cannot change journaled \"\n\t\t\t\t\t\t \"quota options when quota \"\n\t\t\t\t\t\t \"turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n#else\n\t\tif (c == 'u' || c == 'g' || c == 'f') {\n\t\t\treiserfs_warning(s, \"reiserfs-2503\", \"journaled \"\n\t\t\t\t\t \"quota options not supported.\");\n\t\t\treturn 0;\n\t\t}\n#endif\n\t}\n\n#ifdef CONFIG_QUOTA\n\tif (!REISERFS_SB(s)->s_jquota_fmt && !*qfmt\n\t    && (qf_names[USRQUOTA] || qf_names[GRPQUOTA])) {\n\t\treiserfs_warning(s, \"super-6515\",\n\t\t\t\t \"journaled quota format not specified.\");\n\t\treturn 0;\n\t}\n\tif ((!(*mount_options & (1 << REISERFS_USRQUOTA)) &&\n\t       sb_has_quota_loaded(s, USRQUOTA)) ||\n\t    (!(*mount_options & (1 << REISERFS_GRPQUOTA)) &&\n\t       sb_has_quota_loaded(s, GRPQUOTA))) {\n\t\treiserfs_warning(s, \"super-6516\", \"quota options must \"\n\t\t\t\t \"be present when quota is turned on.\");\n\t\treturn 0;\n\t}\n#endif\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SWARN",
          "args": [
            "silent",
            "s",
            "\"\"",
            "\"Cannot allocate commit workqueue\""
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"reiserfs/%s\"",
            "WQ_MEM_RECLAIM",
            "0",
            "s->s_id"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "134-161",
          "snippet": "struct btrfs_workqueue *btrfs_alloc_workqueue(const char *name,\n\t\t\t\t\t      int flags,\n\t\t\t\t\t      int max_active,\n\t\t\t\t\t      int thresh)\n{\n\tstruct btrfs_workqueue *ret = kzalloc(sizeof(*ret), GFP_NOFS);\n\n\tif (!ret)\n\t\treturn NULL;\n\n\tret->normal = __btrfs_alloc_workqueue(name, flags & ~WQ_HIGHPRI,\n\t\t\t\t\t      max_active, thresh);\n\tif (!ret->normal) {\n\t\tkfree(ret);\n\t\treturn NULL;\n\t}\n\n\tif (flags & WQ_HIGHPRI) {\n\t\tret->high = __btrfs_alloc_workqueue(name, flags, max_active,\n\t\t\t\t\t\t    thresh);\n\t\tif (!ret->high) {\n\t\t\t__btrfs_destroy_workqueue(ret->normal);\n\t\t\tkfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstruct btrfs_workqueue *btrfs_alloc_workqueue(const char *name,\n\t\t\t\t\t      int flags,\n\t\t\t\t\t      int max_active,\n\t\t\t\t\t      int thresh)\n{\n\tstruct btrfs_workqueue *ret = kzalloc(sizeof(*ret), GFP_NOFS);\n\n\tif (!ret)\n\t\treturn NULL;\n\n\tret->normal = __btrfs_alloc_workqueue(name, flags & ~WQ_HIGHPRI,\n\t\t\t\t\t      max_active, thresh);\n\tif (!ret->normal) {\n\t\tkfree(ret);\n\t\treturn NULL;\n\t}\n\n\tif (flags & WQ_HIGHPRI) {\n\t\tret->high = __btrfs_alloc_workqueue(name, flags, max_active,\n\t\t\t\t\t\t    thresh);\n\t\tif (!ret->high) {\n\t\t\t__btrfs_destroy_workqueue(ret->normal);\n\t\t\tkfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sbi->lock"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&sbi->old_work",
            "flush_old_commits"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sbi->old_work_lock"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_init_alloc_options",
          "args": [
            "s"
          ],
          "line": 1876
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_init_alloc_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "558-563",
          "snippet": "void reiserfs_init_alloc_options(struct super_block *s)\n{\n\tset_bit(_ALLOC_skip_busy, &SB_ALLOC_OPTS(s));\n\tset_bit(_ALLOC_dirid_groups, &SB_ALLOC_OPTS(s));\n\tset_bit(_ALLOC_packing_groups, &SB_ALLOC_OPTS(s));\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define  _ALLOC_packing_groups 12",
            "#define  _ALLOC_dirid_groups 10",
            "#define  _ALLOC_skip_busy 5"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\n#define  _ALLOC_packing_groups 12\n#define  _ALLOC_dirid_groups 10\n#define  _ALLOC_skip_busy 5\n\nvoid reiserfs_init_alloc_options(struct super_block *s)\n{\n\tset_bit(_ALLOC_skip_busy, &SB_ALLOC_OPTS(s));\n\tset_bit(_ALLOC_dirid_groups, &SB_ALLOC_OPTS(s));\n\tset_bit(_ALLOC_packing_groups, &SB_ALLOC_OPTS(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct reiserfs_sb_info)",
            "GFP_KERNEL"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_mount_options",
          "args": [
            "s",
            "data"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "save_mount_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1189-1193",
          "snippet": "void save_mount_options(struct super_block *sb, char *options)\n{\n\tBUG_ON(sb->s_options);\n\trcu_assign_pointer(sb->s_options, kstrdup(options, GFP_KERNEL));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid save_mount_options(struct super_block *sb, char *options)\n{\n\tBUG_ON(sb->s_options);\n\trcu_assign_pointer(sb->s_options, kstrdup(options, GFP_KERNEL));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const char reiserfs_3_6_magic_string[] = REISER2FS_SUPER_MAGIC_STRING;\nstatic int reiserfs_remount(struct super_block *s, int *flags, char *data);\nstatic const arg_desc_t tails[] = {\n\t{\"on\", 1 << REISERFS_LARGETAIL, 1 << REISERFS_SMALLTAIL},\n\t{\"off\", 0, (1 << REISERFS_LARGETAIL) | (1 << REISERFS_SMALLTAIL)},\n\t{\"small\", 1 << REISERFS_SMALLTAIL, 1 << REISERFS_LARGETAIL},\n\t{NULL, 0, 0}\n};\n\nstatic int reiserfs_fill_super(struct super_block *s, void *data, int silent)\n{\n\tstruct inode *root_inode;\n\tstruct reiserfs_transaction_handle th;\n\tint old_format = 0;\n\tunsigned long blocks;\n\tunsigned int commit_max_age = 0;\n\tint jinit_done = 0;\n\tstruct reiserfs_iget_args args;\n\tstruct reiserfs_super_block *rs;\n\tchar *jdev_name;\n\tstruct reiserfs_sb_info *sbi;\n\tint errval = -EINVAL;\n\tchar *qf_names[REISERFS_MAXQUOTAS] = {};\n\tunsigned int qfmt = 0;\n\n\tsave_mount_options(s, data);\n\n\tsbi = kzalloc(sizeof(struct reiserfs_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\ts->s_fs_info = sbi;\n\t/* Set default values for options: non-aggressive tails, RO on errors */\n\tsbi->s_mount_opt |= (1 << REISERFS_SMALLTAIL);\n\tsbi->s_mount_opt |= (1 << REISERFS_ERROR_RO);\n\tsbi->s_mount_opt |= (1 << REISERFS_BARRIER_FLUSH);\n\t/* no preallocation minimum, be smart in reiserfs_file_write instead */\n\tsbi->s_alloc_options.preallocmin = 0;\n\t/* Preallocate by 16 blocks (17-1) at once */\n\tsbi->s_alloc_options.preallocsize = 17;\n\t/* setup default block allocator options */\n\treiserfs_init_alloc_options(s);\n\n\tspin_lock_init(&sbi->old_work_lock);\n\tINIT_DELAYED_WORK(&sbi->old_work, flush_old_commits);\n\tmutex_init(&sbi->lock);\n\tsbi->lock_depth = -1;\n\n\tsbi->commit_wq = alloc_workqueue(\"reiserfs/%s\", WQ_MEM_RECLAIM, 0,\n\t\t\t\t\t s->s_id);\n\tif (!sbi->commit_wq) {\n\t\tSWARN(silent, s, \"\", \"Cannot allocate commit workqueue\");\n\t\terrval = -ENOMEM;\n\t\tgoto error_unlocked;\n\t}\n\n\tjdev_name = NULL;\n\tif (reiserfs_parse_options\n\t    (s, (char *)data, &sbi->s_mount_opt, &blocks, &jdev_name,\n\t     &commit_max_age, qf_names, &qfmt) == 0) {\n\t\tgoto error_unlocked;\n\t}\n\tif (jdev_name && jdev_name[0]) {\n\t\tsbi->s_jdev = kstrdup(jdev_name, GFP_KERNEL);\n\t\tif (!sbi->s_jdev) {\n\t\t\tSWARN(silent, s, \"\", \"Cannot allocate memory for \"\n\t\t\t\t\"journal device name\");\n\t\t\tgoto error;\n\t\t}\n\t}\n#ifdef CONFIG_QUOTA\n\thandle_quota_files(s, qf_names, &qfmt);\n#endif\n\n\tif (blocks) {\n\t\tSWARN(silent, s, \"jmacd-7\", \"resize option for remount only\");\n\t\tgoto error_unlocked;\n\t}\n\n\t/*\n\t * try old format (undistributed bitmap, super block in 8-th 1k\n\t * block of a device)\n\t */\n\tif (!read_super_block(s, REISERFS_OLD_DISK_OFFSET_IN_BYTES))\n\t\told_format = 1;\n\n\t/*\n\t * try new format (64-th 1k block), which can contain reiserfs\n\t * super block\n\t */\n\telse if (read_super_block(s, REISERFS_DISK_OFFSET_IN_BYTES)) {\n\t\tSWARN(silent, s, \"sh-2021\", \"can not find reiserfs on %s\",\n\t\t      s->s_id);\n\t\tgoto error_unlocked;\n\t}\n\n\trs = SB_DISK_SUPER_BLOCK(s);\n\t/*\n\t * Let's do basic sanity check to verify that underlying device is not\n\t * smaller than the filesystem. If the check fails then abort and\n\t * scream, because bad stuff will happen otherwise.\n\t */\n\tif (s->s_bdev && s->s_bdev->bd_inode\n\t    && i_size_read(s->s_bdev->bd_inode) <\n\t    sb_block_count(rs) * sb_blocksize(rs)) {\n\t\tSWARN(silent, s, \"\", \"Filesystem cannot be \"\n\t\t      \"mounted because it is bigger than the device\");\n\t\tSWARN(silent, s, \"\", \"You may need to run fsck \"\n\t\t      \"or increase size of your LVM partition\");\n\t\tSWARN(silent, s, \"\", \"Or may be you forgot to \"\n\t\t      \"reboot after fdisk when it told you to\");\n\t\tgoto error_unlocked;\n\t}\n\n\tsbi->s_mount_state = SB_REISERFS_STATE(s);\n\tsbi->s_mount_state = REISERFS_VALID_FS;\n\n\tif ((errval = reiserfs_init_bitmap_cache(s))) {\n\t\tSWARN(silent, s, \"jmacd-8\", \"unable to read bitmap\");\n\t\tgoto error_unlocked;\n\t}\n\n\terrval = -EINVAL;\n#ifdef CONFIG_REISERFS_CHECK\n\tSWARN(silent, s, \"\", \"CONFIG_REISERFS_CHECK is set ON\");\n\tSWARN(silent, s, \"\", \"- it is slow mode for debugging.\");\n#endif\n\n\t/* make data=ordered the default */\n\tif (!reiserfs_data_log(s) && !reiserfs_data_ordered(s) &&\n\t    !reiserfs_data_writeback(s)) {\n\t\tsbi->s_mount_opt |= (1 << REISERFS_DATA_ORDERED);\n\t}\n\n\tif (reiserfs_data_log(s)) {\n\t\treiserfs_info(s, \"using journaled data mode\\n\");\n\t} else if (reiserfs_data_ordered(s)) {\n\t\treiserfs_info(s, \"using ordered data mode\\n\");\n\t} else {\n\t\treiserfs_info(s, \"using writeback data mode\\n\");\n\t}\n\tif (reiserfs_barrier_flush(s)) {\n\t\tprintk(\"reiserfs: using flush barriers\\n\");\n\t}\n\n\tif (journal_init(s, jdev_name, old_format, commit_max_age)) {\n\t\tSWARN(silent, s, \"sh-2022\",\n\t\t      \"unable to initialize journal space\");\n\t\tgoto error_unlocked;\n\t} else {\n\t\t/*\n\t\t * once this is set, journal_release must be called\n\t\t * if we error out of the mount\n\t\t */\n\t\tjinit_done = 1;\n\t}\n\n\tif (reread_meta_blocks(s)) {\n\t\tSWARN(silent, s, \"jmacd-9\",\n\t\t      \"unable to reread meta blocks after journal init\");\n\t\tgoto error_unlocked;\n\t}\n\n\tif (replay_only(s))\n\t\tgoto error_unlocked;\n\n\tif (bdev_read_only(s->s_bdev) && !(s->s_flags & MS_RDONLY)) {\n\t\tSWARN(silent, s, \"clm-7000\",\n\t\t      \"Detected readonly device, marking FS readonly\");\n\t\ts->s_flags |= MS_RDONLY;\n\t}\n\targs.objectid = REISERFS_ROOT_OBJECTID;\n\targs.dirid = REISERFS_ROOT_PARENT_OBJECTID;\n\troot_inode =\n\t    iget5_locked(s, REISERFS_ROOT_OBJECTID, reiserfs_find_actor,\n\t\t\t reiserfs_init_locked_inode, (void *)&args);\n\tif (!root_inode) {\n\t\tSWARN(silent, s, \"jmacd-10\", \"get root inode failed\");\n\t\tgoto error_unlocked;\n\t}\n\n\t/*\n\t * This path assumed to be called with the BKL in the old times.\n\t * Now we have inherited the big reiserfs lock from it and many\n\t * reiserfs helpers called in the mount path and elsewhere require\n\t * this lock to be held even if it's not always necessary. Let's be\n\t * conservative and hold it early. The window can be reduced after\n\t * careful review of the code.\n\t */\n\treiserfs_write_lock(s);\n\n\tif (root_inode->i_state & I_NEW) {\n\t\treiserfs_read_locked_inode(root_inode, &args);\n\t\tunlock_new_inode(root_inode);\n\t}\n\n\ts->s_root = d_make_root(root_inode);\n\tif (!s->s_root)\n\t\tgoto error;\n\t/* define and initialize hash function */\n\tsbi->s_hash_function = hash_function(s);\n\tif (sbi->s_hash_function == NULL) {\n\t\tdput(s->s_root);\n\t\ts->s_root = NULL;\n\t\tgoto error;\n\t}\n\n\tif (is_reiserfs_3_5(rs)\n\t    || (is_reiserfs_jr(rs) && SB_VERSION(s) == REISERFS_VERSION_1))\n\t\tset_bit(REISERFS_3_5, &sbi->s_properties);\n\telse if (old_format)\n\t\tset_bit(REISERFS_OLD_FORMAT, &sbi->s_properties);\n\telse\n\t\tset_bit(REISERFS_3_6, &sbi->s_properties);\n\n\tif (!(s->s_flags & MS_RDONLY)) {\n\n\t\terrval = journal_begin(&th, s, 1);\n\t\tif (errval) {\n\t\t\tdput(s->s_root);\n\t\t\ts->s_root = NULL;\n\t\t\tgoto error;\n\t\t}\n\t\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);\n\n\t\tset_sb_umount_state(rs, REISERFS_ERROR_FS);\n\t\tset_sb_fs_state(rs, 0);\n\n\t\t/*\n\t\t * Clear out s_bmap_nr if it would wrap. We can handle this\n\t\t * case, but older revisions can't. This will cause the\n\t\t * file system to fail mount on those older implementations,\n\t\t * avoiding corruption. -jeffm\n\t\t */\n\t\tif (bmap_would_wrap(reiserfs_bmap_count(s)) &&\n\t\t    sb_bmap_nr(rs) != 0) {\n\t\t\treiserfs_warning(s, \"super-2030\", \"This file system \"\n\t\t\t\t\t\"claims to use %u bitmap blocks in \"\n\t\t\t\t\t\"its super block, but requires %u. \"\n\t\t\t\t\t\"Clearing to zero.\", sb_bmap_nr(rs),\n\t\t\t\t\treiserfs_bmap_count(s));\n\n\t\t\tset_sb_bmap_nr(rs, 0);\n\t\t}\n\n\t\tif (old_format_only(s)) {\n\t\t\t/*\n\t\t\t * filesystem of format 3.5 either with standard\n\t\t\t * or non-standard journal\n\t\t\t */\n\t\t\tif (convert_reiserfs(s)) {\n\t\t\t\t/* and -o conv is given */\n\t\t\t\tif (!silent)\n\t\t\t\t\treiserfs_info(s,\n\t\t\t\t\t\t      \"converting 3.5 filesystem to the 3.6 format\");\n\n\t\t\t\tif (is_reiserfs_3_5(rs))\n\t\t\t\t\t/*\n\t\t\t\t\t * put magic string of 3.6 format.\n\t\t\t\t\t * 2.2 will not be able to\n\t\t\t\t\t * mount this filesystem anymore\n\t\t\t\t\t */\n\t\t\t\t\tmemcpy(rs->s_v1.s_magic,\n\t\t\t\t\t       reiserfs_3_6_magic_string,\n\t\t\t\t\t       sizeof\n\t\t\t\t\t       (reiserfs_3_6_magic_string));\n\n\t\t\t\tset_sb_version(rs, REISERFS_VERSION_2);\n\t\t\t\treiserfs_convert_objectid_map_v1(s);\n\t\t\t\tset_bit(REISERFS_3_6, &sbi->s_properties);\n\t\t\t\tclear_bit(REISERFS_3_5, &sbi->s_properties);\n\t\t\t} else if (!silent) {\n\t\t\t\treiserfs_info(s, \"using 3.5.x disk format\\n\");\n\t\t\t}\n\t\t} else\n\t\t\tset_sb_mnt_count(rs, sb_mnt_count(rs) + 1);\n\n\n\t\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(s));\n\t\terrval = journal_end(&th);\n\t\tif (errval) {\n\t\t\tdput(s->s_root);\n\t\t\ts->s_root = NULL;\n\t\t\tgoto error;\n\t\t}\n\n\t\treiserfs_write_unlock(s);\n\t\tif ((errval = reiserfs_lookup_privroot(s)) ||\n\t\t    (errval = reiserfs_xattr_init(s, s->s_flags))) {\n\t\t\tdput(s->s_root);\n\t\t\ts->s_root = NULL;\n\t\t\tgoto error_unlocked;\n\t\t}\n\t\treiserfs_write_lock(s);\n\n\t\t/*\n\t\t * look for files which were to be removed in previous session\n\t\t */\n\t\tfinish_unfinished(s);\n\t} else {\n\t\tif (old_format_only(s) && !silent) {\n\t\t\treiserfs_info(s, \"using 3.5.x disk format\\n\");\n\t\t}\n\n\t\treiserfs_write_unlock(s);\n\t\tif ((errval = reiserfs_lookup_privroot(s)) ||\n\t\t    (errval = reiserfs_xattr_init(s, s->s_flags))) {\n\t\t\tdput(s->s_root);\n\t\t\ts->s_root = NULL;\n\t\t\tgoto error_unlocked;\n\t\t}\n\t\treiserfs_write_lock(s);\n\t}\n\t/*\n\t * mark hash in super block: it could be unset. overwrite should be ok\n\t */\n\tset_sb_hash_function_code(rs, function2code(sbi->s_hash_function));\n\n\thandle_attrs(s);\n\n\treiserfs_proc_info_init(s);\n\n\tinit_waitqueue_head(&(sbi->s_wait));\n\tspin_lock_init(&sbi->bitmap_lock);\n\n\treiserfs_write_unlock(s);\n\n\treturn (0);\n\nerror:\n\treiserfs_write_unlock(s);\n\nerror_unlocked:\n\t/* kill the commit thread, free journal ram */\n\tif (jinit_done) {\n\t\treiserfs_write_lock(s);\n\t\tjournal_release_error(NULL, s);\n\t\treiserfs_write_unlock(s);\n\t}\n\n\tif (sbi->commit_wq)\n\t\tdestroy_workqueue(sbi->commit_wq);\n\n\tcancel_delayed_work_sync(&REISERFS_SB(s)->old_work);\n\n\treiserfs_free_bitmap_cache(s);\n\tif (SB_BUFFER_WITH_SB(s))\n\t\tbrelse(SB_BUFFER_WITH_SB(s));\n#ifdef CONFIG_QUOTA\n\t{\n\t\tint j;\n\t\tfor (j = 0; j < REISERFS_MAXQUOTAS; j++)\n\t\t\tkfree(qf_names[j]);\n\t}\n#endif\n\tkfree(sbi);\n\n\ts->s_fs_info = NULL;\n\treturn errval;\n}"
  },
  {
    "function_name": "function2code",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "1827-1839",
    "snippet": "static int function2code(hashf_t func)\n{\n\tif (func == keyed_hash)\n\t\treturn TEA_HASH;\n\tif (func == yura_hash)\n\t\treturn YURA_HASH;\n\tif (func == r5_hash)\n\t\treturn R5_HASH;\n\n\tBUG();\t\t\t/* should never happen */\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int function2code(hashf_t func)\n{\n\tif (func == keyed_hash)\n\t\treturn TEA_HASH;\n\tif (func == yura_hash)\n\t\treturn YURA_HASH;\n\tif (func == r5_hash)\n\t\treturn R5_HASH;\n\n\tBUG();\t\t\t/* should never happen */\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hash_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "1810-1824",
    "snippet": "static hashf_t hash_function(struct super_block *s)\n{\n\tswitch (what_hash(s)) {\n\tcase TEA_HASH:\n\t\treiserfs_info(s, \"Using tea hash to sort names\\n\");\n\t\treturn keyed_hash;\n\tcase YURA_HASH:\n\t\treiserfs_info(s, \"Using rupasov hash to sort names\\n\");\n\t\treturn yura_hash;\n\tcase R5_HASH:\n\t\treiserfs_info(s, \"Using r5 hash to sort names\\n\");\n\t\treturn r5_hash;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_info",
          "args": [
            "s",
            "\"Using r5 hash to sort names\\n\""
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "280-288",
          "snippet": "void reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "what_hash",
          "args": [
            "s"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "what_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "1745-1807",
          "snippet": "static int what_hash(struct super_block *s)\n{\n\t__u32 code;\n\n\tcode = sb_hash_function_code(SB_DISK_SUPER_BLOCK(s));\n\n\t/*\n\t * reiserfs_hash_detect() == true if any of the hash mount options\n\t * were used.  We must check them to make sure the user isn't\n\t * using a bad hash value\n\t */\n\tif (code == UNSET_HASH || reiserfs_hash_detect(s))\n\t\tcode = find_hash_out(s);\n\n\tif (code != UNSET_HASH && reiserfs_hash_detect(s)) {\n\t\t/*\n\t\t * detection has found the hash, and we must check against the\n\t\t * mount options\n\t\t */\n\t\tif (reiserfs_rupasov_hash(s) && code != YURA_HASH) {\n\t\t\treiserfs_warning(s, \"reiserfs-2507\",\n\t\t\t\t\t \"Error, %s hash detected, \"\n\t\t\t\t\t \"unable to force rupasov hash\",\n\t\t\t\t\t reiserfs_hashname(code));\n\t\t\tcode = UNSET_HASH;\n\t\t} else if (reiserfs_tea_hash(s) && code != TEA_HASH) {\n\t\t\treiserfs_warning(s, \"reiserfs-2508\",\n\t\t\t\t\t \"Error, %s hash detected, \"\n\t\t\t\t\t \"unable to force tea hash\",\n\t\t\t\t\t reiserfs_hashname(code));\n\t\t\tcode = UNSET_HASH;\n\t\t} else if (reiserfs_r5_hash(s) && code != R5_HASH) {\n\t\t\treiserfs_warning(s, \"reiserfs-2509\",\n\t\t\t\t\t \"Error, %s hash detected, \"\n\t\t\t\t\t \"unable to force r5 hash\",\n\t\t\t\t\t reiserfs_hashname(code));\n\t\t\tcode = UNSET_HASH;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * find_hash_out was not called or\n\t\t * could not determine the hash\n\t\t */\n\t\tif (reiserfs_rupasov_hash(s)) {\n\t\t\tcode = YURA_HASH;\n\t\t} else if (reiserfs_tea_hash(s)) {\n\t\t\tcode = TEA_HASH;\n\t\t} else if (reiserfs_r5_hash(s)) {\n\t\t\tcode = R5_HASH;\n\t\t}\n\t}\n\n\t/*\n\t * if we are mounted RW, and we have a new valid hash code, update\n\t * the super\n\t */\n\tif (code != UNSET_HASH &&\n\t    !(s->s_flags & MS_RDONLY) &&\n\t    code != sb_hash_function_code(SB_DISK_SUPER_BLOCK(s))) {\n\t\tset_sb_hash_function_code(SB_DISK_SUPER_BLOCK(s), code);\n\t}\n\treturn code;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int what_hash(struct super_block *s)\n{\n\t__u32 code;\n\n\tcode = sb_hash_function_code(SB_DISK_SUPER_BLOCK(s));\n\n\t/*\n\t * reiserfs_hash_detect() == true if any of the hash mount options\n\t * were used.  We must check them to make sure the user isn't\n\t * using a bad hash value\n\t */\n\tif (code == UNSET_HASH || reiserfs_hash_detect(s))\n\t\tcode = find_hash_out(s);\n\n\tif (code != UNSET_HASH && reiserfs_hash_detect(s)) {\n\t\t/*\n\t\t * detection has found the hash, and we must check against the\n\t\t * mount options\n\t\t */\n\t\tif (reiserfs_rupasov_hash(s) && code != YURA_HASH) {\n\t\t\treiserfs_warning(s, \"reiserfs-2507\",\n\t\t\t\t\t \"Error, %s hash detected, \"\n\t\t\t\t\t \"unable to force rupasov hash\",\n\t\t\t\t\t reiserfs_hashname(code));\n\t\t\tcode = UNSET_HASH;\n\t\t} else if (reiserfs_tea_hash(s) && code != TEA_HASH) {\n\t\t\treiserfs_warning(s, \"reiserfs-2508\",\n\t\t\t\t\t \"Error, %s hash detected, \"\n\t\t\t\t\t \"unable to force tea hash\",\n\t\t\t\t\t reiserfs_hashname(code));\n\t\t\tcode = UNSET_HASH;\n\t\t} else if (reiserfs_r5_hash(s) && code != R5_HASH) {\n\t\t\treiserfs_warning(s, \"reiserfs-2509\",\n\t\t\t\t\t \"Error, %s hash detected, \"\n\t\t\t\t\t \"unable to force r5 hash\",\n\t\t\t\t\t reiserfs_hashname(code));\n\t\t\tcode = UNSET_HASH;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * find_hash_out was not called or\n\t\t * could not determine the hash\n\t\t */\n\t\tif (reiserfs_rupasov_hash(s)) {\n\t\t\tcode = YURA_HASH;\n\t\t} else if (reiserfs_tea_hash(s)) {\n\t\t\tcode = TEA_HASH;\n\t\t} else if (reiserfs_r5_hash(s)) {\n\t\t\tcode = R5_HASH;\n\t\t}\n\t}\n\n\t/*\n\t * if we are mounted RW, and we have a new valid hash code, update\n\t * the super\n\t */\n\tif (code != UNSET_HASH &&\n\t    !(s->s_flags & MS_RDONLY) &&\n\t    code != sb_hash_function_code(SB_DISK_SUPER_BLOCK(s))) {\n\t\tset_sb_hash_function_code(SB_DISK_SUPER_BLOCK(s), code);\n\t}\n\treturn code;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic hashf_t hash_function(struct super_block *s)\n{\n\tswitch (what_hash(s)) {\n\tcase TEA_HASH:\n\t\treiserfs_info(s, \"Using tea hash to sort names\\n\");\n\t\treturn keyed_hash;\n\tcase YURA_HASH:\n\t\treiserfs_info(s, \"Using rupasov hash to sort names\\n\");\n\t\treturn yura_hash;\n\tcase R5_HASH:\n\t\treiserfs_info(s, \"Using r5 hash to sort names\\n\");\n\t\treturn r5_hash;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "what_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "1745-1807",
    "snippet": "static int what_hash(struct super_block *s)\n{\n\t__u32 code;\n\n\tcode = sb_hash_function_code(SB_DISK_SUPER_BLOCK(s));\n\n\t/*\n\t * reiserfs_hash_detect() == true if any of the hash mount options\n\t * were used.  We must check them to make sure the user isn't\n\t * using a bad hash value\n\t */\n\tif (code == UNSET_HASH || reiserfs_hash_detect(s))\n\t\tcode = find_hash_out(s);\n\n\tif (code != UNSET_HASH && reiserfs_hash_detect(s)) {\n\t\t/*\n\t\t * detection has found the hash, and we must check against the\n\t\t * mount options\n\t\t */\n\t\tif (reiserfs_rupasov_hash(s) && code != YURA_HASH) {\n\t\t\treiserfs_warning(s, \"reiserfs-2507\",\n\t\t\t\t\t \"Error, %s hash detected, \"\n\t\t\t\t\t \"unable to force rupasov hash\",\n\t\t\t\t\t reiserfs_hashname(code));\n\t\t\tcode = UNSET_HASH;\n\t\t} else if (reiserfs_tea_hash(s) && code != TEA_HASH) {\n\t\t\treiserfs_warning(s, \"reiserfs-2508\",\n\t\t\t\t\t \"Error, %s hash detected, \"\n\t\t\t\t\t \"unable to force tea hash\",\n\t\t\t\t\t reiserfs_hashname(code));\n\t\t\tcode = UNSET_HASH;\n\t\t} else if (reiserfs_r5_hash(s) && code != R5_HASH) {\n\t\t\treiserfs_warning(s, \"reiserfs-2509\",\n\t\t\t\t\t \"Error, %s hash detected, \"\n\t\t\t\t\t \"unable to force r5 hash\",\n\t\t\t\t\t reiserfs_hashname(code));\n\t\t\tcode = UNSET_HASH;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * find_hash_out was not called or\n\t\t * could not determine the hash\n\t\t */\n\t\tif (reiserfs_rupasov_hash(s)) {\n\t\t\tcode = YURA_HASH;\n\t\t} else if (reiserfs_tea_hash(s)) {\n\t\t\tcode = TEA_HASH;\n\t\t} else if (reiserfs_r5_hash(s)) {\n\t\t\tcode = R5_HASH;\n\t\t}\n\t}\n\n\t/*\n\t * if we are mounted RW, and we have a new valid hash code, update\n\t * the super\n\t */\n\tif (code != UNSET_HASH &&\n\t    !(s->s_flags & MS_RDONLY) &&\n\t    code != sb_hash_function_code(SB_DISK_SUPER_BLOCK(s))) {\n\t\tset_sb_hash_function_code(SB_DISK_SUPER_BLOCK(s), code);\n\t}\n\treturn code;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_sb_hash_function_code",
          "args": [
            "SB_DISK_SUPER_BLOCK(s)",
            "code"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_DISK_SUPER_BLOCK",
          "args": [
            "s"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_hash_function_code",
          "args": [
            "SB_DISK_SUPER_BLOCK(s)"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_DISK_SUPER_BLOCK",
          "args": [
            "s"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_r5_hash",
          "args": [
            "s"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_tea_hash",
          "args": [
            "s"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_rupasov_hash",
          "args": [
            "s"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"reiserfs-2509\"",
            "\"Error, %s hash detected, \"\n\t\t\t\t\t \"unable to force r5 hash\"",
            "reiserfs_hashname(code)"
          ],
          "line": 1777
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_hashname",
          "args": [
            "code"
          ],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_hashname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "514-524",
          "snippet": "char *reiserfs_hashname(int code)\n{\n\tif (code == YURA_HASH)\n\t\treturn \"rupasov\";\n\tif (code == TEA_HASH)\n\t\treturn \"tea\";\n\tif (code == R5_HASH)\n\t\treturn \"r5\";\n\n\treturn \"unknown\";\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nchar *reiserfs_hashname(int code)\n{\n\tif (code == YURA_HASH)\n\t\treturn \"rupasov\";\n\tif (code == TEA_HASH)\n\t\treturn \"tea\";\n\tif (code == R5_HASH)\n\t\treturn \"r5\";\n\n\treturn \"unknown\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_r5_hash",
          "args": [
            "s"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_tea_hash",
          "args": [
            "s"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_rupasov_hash",
          "args": [
            "s"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_hash_detect",
          "args": [
            "s"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_hash_out",
          "args": [
            "s"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "find_hash_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "1679-1742",
          "snippet": "static __u32 find_hash_out(struct super_block *s)\n{\n\tint retval;\n\tstruct inode *inode;\n\tstruct cpu_key key;\n\tINITIALIZE_PATH(path);\n\tstruct reiserfs_dir_entry de;\n\tstruct reiserfs_de_head *deh;\n\t__u32 hash = DEFAULT_HASH;\n\t__u32 deh_hashval, teahash, r5hash, yurahash;\n\n\tinode = s->s_root->d_inode;\n\n\tmake_cpu_key(&key, inode, ~0, TYPE_DIRENTRY, 3);\n\tretval = search_by_entry_key(s, &key, &path, &de);\n\tif (retval == IO_ERROR) {\n\t\tpathrelse(&path);\n\t\treturn UNSET_HASH;\n\t}\n\tif (retval == NAME_NOT_FOUND)\n\t\tde.de_entry_num--;\n\n\tset_de_name_and_namelen(&de);\n\tdeh = de.de_deh + de.de_entry_num;\n\n\tif (deh_offset(deh) == DOT_DOT_OFFSET) {\n\t\t/* allow override in this case */\n\t\tif (reiserfs_rupasov_hash(s))\n\t\t\thash = YURA_HASH;\n\t\treiserfs_info(s, \"FS seems to be empty, autodetect is using the default hash\\n\");\n\t\tgoto out;\n\t}\n\n\tdeh_hashval = GET_HASH_VALUE(deh_offset(deh));\n\tr5hash = GET_HASH_VALUE(r5_hash(de.de_name, de.de_namelen));\n\tteahash = GET_HASH_VALUE(keyed_hash(de.de_name, de.de_namelen));\n\tyurahash = GET_HASH_VALUE(yura_hash(de.de_name, de.de_namelen));\n\n\tif ((teahash == r5hash && deh_hashval == r5hash) ||\n\t    (teahash == yurahash && deh_hashval == yurahash) ||\n\t    (r5hash == yurahash && deh_hashval == yurahash)) {\n\t\treiserfs_warning(s, \"reiserfs-2506\",\n\t\t\t\t \"Unable to automatically detect hash \"\n\t\t\t\t \"function. Please mount with -o \"\n\t\t\t\t \"hash={tea,rupasov,r5}\");\n\t\thash = UNSET_HASH;\n\t\tgoto out;\n\t}\n\n\tif (deh_hashval == yurahash)\n\t\thash = YURA_HASH;\n\telse if (deh_hashval == teahash)\n\t\thash = TEA_HASH;\n\telse if (deh_hashval == r5hash)\n\t\thash = R5_HASH;\n\telse {\n\t\treiserfs_warning(s, \"reiserfs-2506\",\n\t\t\t\t \"Unrecognised hash function\");\n\t\thash = UNSET_HASH;\n\t}\nout:\n\tpathrelse(&path);\n\treturn hash;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic __u32 find_hash_out(struct super_block *s)\n{\n\tint retval;\n\tstruct inode *inode;\n\tstruct cpu_key key;\n\tINITIALIZE_PATH(path);\n\tstruct reiserfs_dir_entry de;\n\tstruct reiserfs_de_head *deh;\n\t__u32 hash = DEFAULT_HASH;\n\t__u32 deh_hashval, teahash, r5hash, yurahash;\n\n\tinode = s->s_root->d_inode;\n\n\tmake_cpu_key(&key, inode, ~0, TYPE_DIRENTRY, 3);\n\tretval = search_by_entry_key(s, &key, &path, &de);\n\tif (retval == IO_ERROR) {\n\t\tpathrelse(&path);\n\t\treturn UNSET_HASH;\n\t}\n\tif (retval == NAME_NOT_FOUND)\n\t\tde.de_entry_num--;\n\n\tset_de_name_and_namelen(&de);\n\tdeh = de.de_deh + de.de_entry_num;\n\n\tif (deh_offset(deh) == DOT_DOT_OFFSET) {\n\t\t/* allow override in this case */\n\t\tif (reiserfs_rupasov_hash(s))\n\t\t\thash = YURA_HASH;\n\t\treiserfs_info(s, \"FS seems to be empty, autodetect is using the default hash\\n\");\n\t\tgoto out;\n\t}\n\n\tdeh_hashval = GET_HASH_VALUE(deh_offset(deh));\n\tr5hash = GET_HASH_VALUE(r5_hash(de.de_name, de.de_namelen));\n\tteahash = GET_HASH_VALUE(keyed_hash(de.de_name, de.de_namelen));\n\tyurahash = GET_HASH_VALUE(yura_hash(de.de_name, de.de_namelen));\n\n\tif ((teahash == r5hash && deh_hashval == r5hash) ||\n\t    (teahash == yurahash && deh_hashval == yurahash) ||\n\t    (r5hash == yurahash && deh_hashval == yurahash)) {\n\t\treiserfs_warning(s, \"reiserfs-2506\",\n\t\t\t\t \"Unable to automatically detect hash \"\n\t\t\t\t \"function. Please mount with -o \"\n\t\t\t\t \"hash={tea,rupasov,r5}\");\n\t\thash = UNSET_HASH;\n\t\tgoto out;\n\t}\n\n\tif (deh_hashval == yurahash)\n\t\thash = YURA_HASH;\n\telse if (deh_hashval == teahash)\n\t\thash = TEA_HASH;\n\telse if (deh_hashval == r5hash)\n\t\thash = R5_HASH;\n\telse {\n\t\treiserfs_warning(s, \"reiserfs-2506\",\n\t\t\t\t \"Unrecognised hash function\");\n\t\thash = UNSET_HASH;\n\t}\nout:\n\tpathrelse(&path);\n\treturn hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_hash_detect",
          "args": [
            "s"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_hash_function_code",
          "args": [
            "SB_DISK_SUPER_BLOCK(s)"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_DISK_SUPER_BLOCK",
          "args": [
            "s"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int what_hash(struct super_block *s)\n{\n\t__u32 code;\n\n\tcode = sb_hash_function_code(SB_DISK_SUPER_BLOCK(s));\n\n\t/*\n\t * reiserfs_hash_detect() == true if any of the hash mount options\n\t * were used.  We must check them to make sure the user isn't\n\t * using a bad hash value\n\t */\n\tif (code == UNSET_HASH || reiserfs_hash_detect(s))\n\t\tcode = find_hash_out(s);\n\n\tif (code != UNSET_HASH && reiserfs_hash_detect(s)) {\n\t\t/*\n\t\t * detection has found the hash, and we must check against the\n\t\t * mount options\n\t\t */\n\t\tif (reiserfs_rupasov_hash(s) && code != YURA_HASH) {\n\t\t\treiserfs_warning(s, \"reiserfs-2507\",\n\t\t\t\t\t \"Error, %s hash detected, \"\n\t\t\t\t\t \"unable to force rupasov hash\",\n\t\t\t\t\t reiserfs_hashname(code));\n\t\t\tcode = UNSET_HASH;\n\t\t} else if (reiserfs_tea_hash(s) && code != TEA_HASH) {\n\t\t\treiserfs_warning(s, \"reiserfs-2508\",\n\t\t\t\t\t \"Error, %s hash detected, \"\n\t\t\t\t\t \"unable to force tea hash\",\n\t\t\t\t\t reiserfs_hashname(code));\n\t\t\tcode = UNSET_HASH;\n\t\t} else if (reiserfs_r5_hash(s) && code != R5_HASH) {\n\t\t\treiserfs_warning(s, \"reiserfs-2509\",\n\t\t\t\t\t \"Error, %s hash detected, \"\n\t\t\t\t\t \"unable to force r5 hash\",\n\t\t\t\t\t reiserfs_hashname(code));\n\t\t\tcode = UNSET_HASH;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * find_hash_out was not called or\n\t\t * could not determine the hash\n\t\t */\n\t\tif (reiserfs_rupasov_hash(s)) {\n\t\t\tcode = YURA_HASH;\n\t\t} else if (reiserfs_tea_hash(s)) {\n\t\t\tcode = TEA_HASH;\n\t\t} else if (reiserfs_r5_hash(s)) {\n\t\t\tcode = R5_HASH;\n\t\t}\n\t}\n\n\t/*\n\t * if we are mounted RW, and we have a new valid hash code, update\n\t * the super\n\t */\n\tif (code != UNSET_HASH &&\n\t    !(s->s_flags & MS_RDONLY) &&\n\t    code != sb_hash_function_code(SB_DISK_SUPER_BLOCK(s))) {\n\t\tset_sb_hash_function_code(SB_DISK_SUPER_BLOCK(s), code);\n\t}\n\treturn code;\n}"
  },
  {
    "function_name": "find_hash_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "1679-1742",
    "snippet": "static __u32 find_hash_out(struct super_block *s)\n{\n\tint retval;\n\tstruct inode *inode;\n\tstruct cpu_key key;\n\tINITIALIZE_PATH(path);\n\tstruct reiserfs_dir_entry de;\n\tstruct reiserfs_de_head *deh;\n\t__u32 hash = DEFAULT_HASH;\n\t__u32 deh_hashval, teahash, r5hash, yurahash;\n\n\tinode = s->s_root->d_inode;\n\n\tmake_cpu_key(&key, inode, ~0, TYPE_DIRENTRY, 3);\n\tretval = search_by_entry_key(s, &key, &path, &de);\n\tif (retval == IO_ERROR) {\n\t\tpathrelse(&path);\n\t\treturn UNSET_HASH;\n\t}\n\tif (retval == NAME_NOT_FOUND)\n\t\tde.de_entry_num--;\n\n\tset_de_name_and_namelen(&de);\n\tdeh = de.de_deh + de.de_entry_num;\n\n\tif (deh_offset(deh) == DOT_DOT_OFFSET) {\n\t\t/* allow override in this case */\n\t\tif (reiserfs_rupasov_hash(s))\n\t\t\thash = YURA_HASH;\n\t\treiserfs_info(s, \"FS seems to be empty, autodetect is using the default hash\\n\");\n\t\tgoto out;\n\t}\n\n\tdeh_hashval = GET_HASH_VALUE(deh_offset(deh));\n\tr5hash = GET_HASH_VALUE(r5_hash(de.de_name, de.de_namelen));\n\tteahash = GET_HASH_VALUE(keyed_hash(de.de_name, de.de_namelen));\n\tyurahash = GET_HASH_VALUE(yura_hash(de.de_name, de.de_namelen));\n\n\tif ((teahash == r5hash && deh_hashval == r5hash) ||\n\t    (teahash == yurahash && deh_hashval == yurahash) ||\n\t    (r5hash == yurahash && deh_hashval == yurahash)) {\n\t\treiserfs_warning(s, \"reiserfs-2506\",\n\t\t\t\t \"Unable to automatically detect hash \"\n\t\t\t\t \"function. Please mount with -o \"\n\t\t\t\t \"hash={tea,rupasov,r5}\");\n\t\thash = UNSET_HASH;\n\t\tgoto out;\n\t}\n\n\tif (deh_hashval == yurahash)\n\t\thash = YURA_HASH;\n\telse if (deh_hashval == teahash)\n\t\thash = TEA_HASH;\n\telse if (deh_hashval == r5hash)\n\t\thash = R5_HASH;\n\telse {\n\t\treiserfs_warning(s, \"reiserfs-2506\",\n\t\t\t\t \"Unrecognised hash function\");\n\t\thash = UNSET_HASH;\n\t}\nout:\n\tpathrelse(&path);\n\treturn hash;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pathrelse",
          "args": [
            "&path"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "376-387",
          "snippet": "void pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"reiserfs-2506\"",
            "\"Unrecognised hash function\""
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"reiserfs-2506\"",
            "\"Unable to automatically detect hash \"\n\t\t\t\t \"function. Please mount with -o \"\n\t\t\t\t \"hash={tea,rupasov,r5}\""
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_HASH_VALUE",
          "args": [
            "yura_hash(de.de_name, de.de_namelen)"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "yura_hash",
          "args": [
            "de.de_name",
            "de.de_namelen"
          ],
          "line": 1715
        },
        "resolved": true,
        "details": {
          "function_name": "yura_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/hashes.c",
          "lines": "128-165",
          "snippet": "u32 yura_hash(const signed char *msg, int len)\n{\n\tint j, pow;\n\tu32 a, c;\n\tint i;\n\n\tfor (pow = 1, i = 1; i < len; i++)\n\t\tpow = pow * 10;\n\n\tif (len == 1)\n\t\ta = msg[0] - 48;\n\telse\n\t\ta = (msg[0] - 48) * pow;\n\n\tfor (i = 1; i < len; i++) {\n\t\tc = msg[i] - 48;\n\t\tfor (pow = 1, j = i; j < len - 1; j++)\n\t\t\tpow = pow * 10;\n\t\ta = a + c * pow;\n\t}\n\n\tfor (; i < 40; i++) {\n\t\tc = '0' - 48;\n\t\tfor (pow = 1, j = i; j < len - 1; j++)\n\t\t\tpow = pow * 10;\n\t\ta = a + c * pow;\n\t}\n\n\tfor (; i < 256; i++) {\n\t\tc = i;\n\t\tfor (pow = 1, j = i; j < len - 1; j++)\n\t\t\tpow = pow * 10;\n\t\ta = a + c * pow;\n\t}\n\n\ta = a << 7;\n\treturn a;\n}",
          "includes": [
            "#include <asm/types.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/types.h>\n#include \"reiserfs.h\"\n#include <linux/kernel.h>\n\nu32 yura_hash(const signed char *msg, int len)\n{\n\tint j, pow;\n\tu32 a, c;\n\tint i;\n\n\tfor (pow = 1, i = 1; i < len; i++)\n\t\tpow = pow * 10;\n\n\tif (len == 1)\n\t\ta = msg[0] - 48;\n\telse\n\t\ta = (msg[0] - 48) * pow;\n\n\tfor (i = 1; i < len; i++) {\n\t\tc = msg[i] - 48;\n\t\tfor (pow = 1, j = i; j < len - 1; j++)\n\t\t\tpow = pow * 10;\n\t\ta = a + c * pow;\n\t}\n\n\tfor (; i < 40; i++) {\n\t\tc = '0' - 48;\n\t\tfor (pow = 1, j = i; j < len - 1; j++)\n\t\t\tpow = pow * 10;\n\t\ta = a + c * pow;\n\t}\n\n\tfor (; i < 256; i++) {\n\t\tc = i;\n\t\tfor (pow = 1, j = i; j < len - 1; j++)\n\t\t\tpow = pow * 10;\n\t\ta = a + c * pow;\n\t}\n\n\ta = a << 7;\n\treturn a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_HASH_VALUE",
          "args": [
            "keyed_hash(de.de_name, de.de_namelen)"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyed_hash",
          "args": [
            "de.de_name",
            "de.de_namelen"
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "keyed_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/hashes.c",
          "lines": "44-122",
          "snippet": "u32 keyed_hash(const signed char *msg, int len)\n{\n\tu32 k[] = { 0x9464a485, 0x542e1a94, 0x3e846bff, 0xb75bcfc3 };\n\n\tu32 h0 = k[0], h1 = k[1];\n\tu32 a, b, c, d;\n\tu32 pad;\n\tint i;\n\n\t/*      assert(len >= 0 && len < 256); */\n\n\tpad = (u32) len | ((u32) len << 8);\n\tpad |= pad << 16;\n\n\twhile (len >= 16) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\t\td = (u32) msg[12] |\n\t\t    (u32) msg[13] << 8 |\n\t\t    (u32) msg[14] << 16 | (u32) msg[15] << 24;\n\n\t\tTEACORE(PARTROUNDS);\n\n\t\tlen -= 16;\n\t\tmsg += 16;\n\t}\n\n\tif (len >= 12) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\n\t\td = pad;\n\t\tfor (i = 12; i < len; i++) {\n\t\t\td <<= 8;\n\t\t\td |= msg[i];\n\t\t}\n\t} else if (len >= 8) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\n\t\tc = d = pad;\n\t\tfor (i = 8; i < len; i++) {\n\t\t\tc <<= 8;\n\t\t\tc |= msg[i];\n\t\t}\n\t} else if (len >= 4) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\n\t\tb = c = d = pad;\n\t\tfor (i = 4; i < len; i++) {\n\t\t\tb <<= 8;\n\t\t\tb |= msg[i];\n\t\t}\n\t} else {\n\t\ta = b = c = d = pad;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\ta <<= 8;\n\t\t\ta |= msg[i];\n\t\t}\n\t}\n\n\tTEACORE(FULLROUNDS);\n\n/*\treturn 0;*/\n\treturn h0 ^ h1;\n}",
          "includes": [
            "#include <asm/types.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PARTROUNDS 6\t\t/* 6 gets complete mixing */",
            "#define FULLROUNDS 10\t\t/* 32 is overkill, 16 is strong crypto */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/types.h>\n#include \"reiserfs.h\"\n#include <linux/kernel.h>\n\n#define PARTROUNDS 6\t\t/* 6 gets complete mixing */\n#define FULLROUNDS 10\t\t/* 32 is overkill, 16 is strong crypto */\n\nu32 keyed_hash(const signed char *msg, int len)\n{\n\tu32 k[] = { 0x9464a485, 0x542e1a94, 0x3e846bff, 0xb75bcfc3 };\n\n\tu32 h0 = k[0], h1 = k[1];\n\tu32 a, b, c, d;\n\tu32 pad;\n\tint i;\n\n\t/*      assert(len >= 0 && len < 256); */\n\n\tpad = (u32) len | ((u32) len << 8);\n\tpad |= pad << 16;\n\n\twhile (len >= 16) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\t\td = (u32) msg[12] |\n\t\t    (u32) msg[13] << 8 |\n\t\t    (u32) msg[14] << 16 | (u32) msg[15] << 24;\n\n\t\tTEACORE(PARTROUNDS);\n\n\t\tlen -= 16;\n\t\tmsg += 16;\n\t}\n\n\tif (len >= 12) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\n\t\td = pad;\n\t\tfor (i = 12; i < len; i++) {\n\t\t\td <<= 8;\n\t\t\td |= msg[i];\n\t\t}\n\t} else if (len >= 8) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\n\t\tc = d = pad;\n\t\tfor (i = 8; i < len; i++) {\n\t\t\tc <<= 8;\n\t\t\tc |= msg[i];\n\t\t}\n\t} else if (len >= 4) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\n\t\tb = c = d = pad;\n\t\tfor (i = 4; i < len; i++) {\n\t\t\tb <<= 8;\n\t\t\tb |= msg[i];\n\t\t}\n\t} else {\n\t\ta = b = c = d = pad;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\ta <<= 8;\n\t\t\ta |= msg[i];\n\t\t}\n\t}\n\n\tTEACORE(FULLROUNDS);\n\n/*\treturn 0;*/\n\treturn h0 ^ h1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_HASH_VALUE",
          "args": [
            "r5_hash(de.de_name, de.de_namelen)"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r5_hash",
          "args": [
            "de.de_name",
            "de.de_namelen"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "r5_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/hashes.c",
          "lines": "167-177",
          "snippet": "u32 r5_hash(const signed char *msg, int len)\n{\n\tu32 a = 0;\n\twhile (*msg) {\n\t\ta += *msg << 4;\n\t\ta += *msg >> 4;\n\t\ta *= 11;\n\t\tmsg++;\n\t}\n\treturn a;\n}",
          "includes": [
            "#include <asm/types.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/types.h>\n#include \"reiserfs.h\"\n#include <linux/kernel.h>\n\nu32 r5_hash(const signed char *msg, int len)\n{\n\tu32 a = 0;\n\twhile (*msg) {\n\t\ta += *msg << 4;\n\t\ta += *msg >> 4;\n\t\ta *= 11;\n\t\tmsg++;\n\t}\n\treturn a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_HASH_VALUE",
          "args": [
            "deh_offset(deh)"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_offset",
          "args": [
            "deh"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_info",
          "args": [
            "s",
            "\"FS seems to be empty, autodetect is using the default hash\\n\""
          ],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "280-288",
          "snippet": "void reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_rupasov_hash",
          "args": [
            "s"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_offset",
          "args": [
            "deh"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_de_name_and_namelen",
          "args": [
            "&de"
          ],
          "line": 1701
        },
        "resolved": true,
        "details": {
          "function_name": "set_de_name_and_namelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "72-83",
          "snippet": "inline void set_de_name_and_namelen(struct reiserfs_dir_entry *de)\n{\n\tstruct reiserfs_de_head *deh = de->de_deh + de->de_entry_num;\n\n\tBUG_ON(de->de_entry_num >= ih_entry_count(de->de_ih));\n\n\tde->de_entrylen = entry_length(de->de_bh, de->de_ih, de->de_entry_num);\n\tde->de_namelen = de->de_entrylen - (de_with_sd(deh) ? SD_SIZE : 0);\n\tde->de_name = ih_item_body(de->de_bh, de->de_ih) + deh_location(deh);\n\tif (de->de_name[de->de_namelen - 1] == 0)\n\t\tde->de_namelen = strlen(de->de_name);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\ninline void set_de_name_and_namelen(struct reiserfs_dir_entry *de)\n{\n\tstruct reiserfs_de_head *deh = de->de_deh + de->de_entry_num;\n\n\tBUG_ON(de->de_entry_num >= ih_entry_count(de->de_ih));\n\n\tde->de_entrylen = entry_length(de->de_bh, de->de_ih, de->de_entry_num);\n\tde->de_namelen = de->de_entrylen - (de_with_sd(deh) ? SD_SIZE : 0);\n\tde->de_name = ih_item_body(de->de_bh, de->de_ih) + deh_location(deh);\n\tif (de->de_name[de->de_namelen - 1] == 0)\n\t\tde->de_namelen = strlen(de->de_name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "search_by_entry_key",
          "args": [
            "s",
            "&key",
            "&path",
            "&de"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "search_by_entry_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "120-175",
          "snippet": "int search_by_entry_key(struct super_block *sb, const struct cpu_key *key,\n\t\t\tstruct treepath *path, struct reiserfs_dir_entry *de)\n{\n\tint retval;\n\n\tretval = search_item(sb, key, path);\n\tswitch (retval) {\n\tcase ITEM_NOT_FOUND:\n\t\tif (!PATH_LAST_POSITION(path)) {\n\t\t\treiserfs_error(sb, \"vs-7000\", \"search_by_key \"\n\t\t\t\t       \"returned item position == 0\");\n\t\t\tpathrelse(path);\n\t\t\treturn IO_ERROR;\n\t\t}\n\t\tPATH_LAST_POSITION(path)--;\n\n\tcase ITEM_FOUND:\n\t\tbreak;\n\n\tcase IO_ERROR:\n\t\treturn retval;\n\n\tdefault:\n\t\tpathrelse(path);\n\t\treiserfs_error(sb, \"vs-7002\", \"no path to here\");\n\t\treturn IO_ERROR;\n\t}\n\n\tset_de_item_location(de, path);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (!is_direntry_le_ih(de->de_ih) ||\n\t    COMP_SHORT_KEYS(&de->de_ih->ih_key, key)) {\n\t\tprint_block(de->de_bh, 0, -1, -1);\n\t\treiserfs_panic(sb, \"vs-7005\", \"found item %h is not directory \"\n\t\t\t       \"item or does not belong to the same directory \"\n\t\t\t       \"as key %K\", de->de_ih, key);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/*\n\t * binary search in directory item by third component of the\n\t * key. sets de->de_entry_num of de\n\t */\n\tretval = bin_search_in_dir_item(de, cpu_key_k_offset(key));\n\tpath->pos_in_item = de->de_entry_num;\n\tif (retval != NAME_NOT_FOUND) {\n\t\t/*\n\t\t * ugly, but rename needs de_bh, de_deh, de_name,\n\t\t * de_namelen, de_objectid set\n\t\t */\n\t\tset_de_name_and_namelen(de);\n\t\tset_de_object_key(de);\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nint search_by_entry_key(struct super_block *sb, const struct cpu_key *key,\n\t\t\tstruct treepath *path, struct reiserfs_dir_entry *de)\n{\n\tint retval;\n\n\tretval = search_item(sb, key, path);\n\tswitch (retval) {\n\tcase ITEM_NOT_FOUND:\n\t\tif (!PATH_LAST_POSITION(path)) {\n\t\t\treiserfs_error(sb, \"vs-7000\", \"search_by_key \"\n\t\t\t\t       \"returned item position == 0\");\n\t\t\tpathrelse(path);\n\t\t\treturn IO_ERROR;\n\t\t}\n\t\tPATH_LAST_POSITION(path)--;\n\n\tcase ITEM_FOUND:\n\t\tbreak;\n\n\tcase IO_ERROR:\n\t\treturn retval;\n\n\tdefault:\n\t\tpathrelse(path);\n\t\treiserfs_error(sb, \"vs-7002\", \"no path to here\");\n\t\treturn IO_ERROR;\n\t}\n\n\tset_de_item_location(de, path);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (!is_direntry_le_ih(de->de_ih) ||\n\t    COMP_SHORT_KEYS(&de->de_ih->ih_key, key)) {\n\t\tprint_block(de->de_bh, 0, -1, -1);\n\t\treiserfs_panic(sb, \"vs-7005\", \"found item %h is not directory \"\n\t\t\t       \"item or does not belong to the same directory \"\n\t\t\t       \"as key %K\", de->de_ih, key);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/*\n\t * binary search in directory item by third component of the\n\t * key. sets de->de_entry_num of de\n\t */\n\tretval = bin_search_in_dir_item(de, cpu_key_k_offset(key));\n\tpath->pos_in_item = de->de_entry_num;\n\tif (retval != NAME_NOT_FOUND) {\n\t\t/*\n\t\t * ugly, but rename needs de_bh, de_deh, de_name,\n\t\t * de_namelen, de_objectid set\n\t\t */\n\t\tset_de_name_and_namelen(de);\n\t\tset_de_object_key(de);\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_cpu_key",
          "args": [
            "&key",
            "inode",
            "~0",
            "TYPE_DIRENTRY",
            "3"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "make_cpu_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "126-133",
          "snippet": "void make_cpu_key(struct cpu_key *key, struct inode *inode, loff_t offset,\n\t\t  int type, int length)\n{\n\t_make_cpu_key(key, get_inode_item_key_version(inode),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_dir_id),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_objectid), offset, type,\n\t\t      length);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid make_cpu_key(struct cpu_key *key, struct inode *inode, loff_t offset,\n\t\t  int type, int length)\n{\n\t_make_cpu_key(key, get_inode_item_key_version(inode),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_dir_id),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_objectid), offset, type,\n\t\t      length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INITIALIZE_PATH",
          "args": [
            "path"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic __u32 find_hash_out(struct super_block *s)\n{\n\tint retval;\n\tstruct inode *inode;\n\tstruct cpu_key key;\n\tINITIALIZE_PATH(path);\n\tstruct reiserfs_dir_entry de;\n\tstruct reiserfs_de_head *deh;\n\t__u32 hash = DEFAULT_HASH;\n\t__u32 deh_hashval, teahash, r5hash, yurahash;\n\n\tinode = s->s_root->d_inode;\n\n\tmake_cpu_key(&key, inode, ~0, TYPE_DIRENTRY, 3);\n\tretval = search_by_entry_key(s, &key, &path, &de);\n\tif (retval == IO_ERROR) {\n\t\tpathrelse(&path);\n\t\treturn UNSET_HASH;\n\t}\n\tif (retval == NAME_NOT_FOUND)\n\t\tde.de_entry_num--;\n\n\tset_de_name_and_namelen(&de);\n\tdeh = de.de_deh + de.de_entry_num;\n\n\tif (deh_offset(deh) == DOT_DOT_OFFSET) {\n\t\t/* allow override in this case */\n\t\tif (reiserfs_rupasov_hash(s))\n\t\t\thash = YURA_HASH;\n\t\treiserfs_info(s, \"FS seems to be empty, autodetect is using the default hash\\n\");\n\t\tgoto out;\n\t}\n\n\tdeh_hashval = GET_HASH_VALUE(deh_offset(deh));\n\tr5hash = GET_HASH_VALUE(r5_hash(de.de_name, de.de_namelen));\n\tteahash = GET_HASH_VALUE(keyed_hash(de.de_name, de.de_namelen));\n\tyurahash = GET_HASH_VALUE(yura_hash(de.de_name, de.de_namelen));\n\n\tif ((teahash == r5hash && deh_hashval == r5hash) ||\n\t    (teahash == yurahash && deh_hashval == yurahash) ||\n\t    (r5hash == yurahash && deh_hashval == yurahash)) {\n\t\treiserfs_warning(s, \"reiserfs-2506\",\n\t\t\t\t \"Unable to automatically detect hash \"\n\t\t\t\t \"function. Please mount with -o \"\n\t\t\t\t \"hash={tea,rupasov,r5}\");\n\t\thash = UNSET_HASH;\n\t\tgoto out;\n\t}\n\n\tif (deh_hashval == yurahash)\n\t\thash = YURA_HASH;\n\telse if (deh_hashval == teahash)\n\t\thash = TEA_HASH;\n\telse if (deh_hashval == r5hash)\n\t\thash = R5_HASH;\n\telse {\n\t\treiserfs_warning(s, \"reiserfs-2506\",\n\t\t\t\t \"Unrecognised hash function\");\n\t\thash = UNSET_HASH;\n\t}\nout:\n\tpathrelse(&path);\n\treturn hash;\n}"
  },
  {
    "function_name": "reread_meta_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "1658-1668",
    "snippet": "static int reread_meta_blocks(struct super_block *s)\n{\n\tll_rw_block(READ, 1, &SB_BUFFER_WITH_SB(s));\n\twait_on_buffer(SB_BUFFER_WITH_SB(s));\n\tif (!buffer_uptodate(SB_BUFFER_WITH_SB(s))) {\n\t\treiserfs_warning(s, \"reiserfs-2504\", \"error reading the super\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"reiserfs-2504\"",
            "\"error reading the super\""
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "SB_BUFFER_WITH_SB(s)"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "SB_BUFFER_WITH_SB(s)"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "READ",
            "1",
            "&SB_BUFFER_WITH_SB(s)"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3086-3112",
          "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int reread_meta_blocks(struct super_block *s)\n{\n\tll_rw_block(READ, 1, &SB_BUFFER_WITH_SB(s));\n\twait_on_buffer(SB_BUFFER_WITH_SB(s));\n\tif (!buffer_uptodate(SB_BUFFER_WITH_SB(s))) {\n\t\treiserfs_warning(s, \"reiserfs-2504\", \"error reading the super\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "read_super_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "1555-1655",
    "snippet": "static int read_super_block(struct super_block *s, int offset)\n{\n\tstruct buffer_head *bh;\n\tstruct reiserfs_super_block *rs;\n\tint fs_blocksize;\n\n\tbh = sb_bread(s, offset / s->s_blocksize);\n\tif (!bh) {\n\t\treiserfs_warning(s, \"sh-2006\",\n\t\t\t\t \"bread failed (dev %s, block %lu, size %lu)\",\n\t\t\t\t s->s_id, offset / s->s_blocksize,\n\t\t\t\t s->s_blocksize);\n\t\treturn 1;\n\t}\n\n\trs = (struct reiserfs_super_block *)bh->b_data;\n\tif (!is_any_reiserfs_magic_string(rs)) {\n\t\tbrelse(bh);\n\t\treturn 1;\n\t}\n\t/*\n\t * ok, reiserfs signature (old or new) found in at the given offset\n\t */\n\tfs_blocksize = sb_blocksize(rs);\n\tbrelse(bh);\n\tsb_set_blocksize(s, fs_blocksize);\n\n\tbh = sb_bread(s, offset / s->s_blocksize);\n\tif (!bh) {\n\t\treiserfs_warning(s, \"sh-2007\",\n\t\t\t\t \"bread failed (dev %s, block %lu, size %lu)\",\n\t\t\t\t s->s_id, offset / s->s_blocksize,\n\t\t\t\t s->s_blocksize);\n\t\treturn 1;\n\t}\n\n\trs = (struct reiserfs_super_block *)bh->b_data;\n\tif (sb_blocksize(rs) != s->s_blocksize) {\n\t\treiserfs_warning(s, \"sh-2011\", \"can't find a reiserfs \"\n\t\t\t\t \"filesystem on (dev %s, block %llu, size %lu)\",\n\t\t\t\t s->s_id,\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t s->s_blocksize);\n\t\tbrelse(bh);\n\t\treturn 1;\n\t}\n\n\tif (rs->s_v1.s_root_block == cpu_to_le32(-1)) {\n\t\tbrelse(bh);\n\t\treiserfs_warning(s, \"super-6519\", \"Unfinished reiserfsck \"\n\t\t\t\t \"--rebuild-tree run detected. Please run\\n\"\n\t\t\t\t \"reiserfsck --rebuild-tree and wait for a \"\n\t\t\t\t \"completion. If that fails\\n\"\n\t\t\t\t \"get newer reiserfsprogs package\");\n\t\treturn 1;\n\t}\n\n\tSB_BUFFER_WITH_SB(s) = bh;\n\tSB_DISK_SUPER_BLOCK(s) = rs;\n\n\t/*\n\t * magic is of non-standard journal filesystem, look at s_version to\n\t * find which format is in use\n\t */\n\tif (is_reiserfs_jr(rs)) {\n\t\tif (sb_version(rs) == REISERFS_VERSION_2)\n\t\t\treiserfs_info(s, \"found reiserfs format \\\"3.6\\\"\"\n\t\t\t\t      \" with non-standard journal\\n\");\n\t\telse if (sb_version(rs) == REISERFS_VERSION_1)\n\t\t\treiserfs_info(s, \"found reiserfs format \\\"3.5\\\"\"\n\t\t\t\t      \" with non-standard journal\\n\");\n\t\telse {\n\t\t\treiserfs_warning(s, \"sh-2012\", \"found unknown \"\n\t\t\t\t\t \"format \\\"%u\\\" of reiserfs with \"\n\t\t\t\t\t \"non-standard magic\", sb_version(rs));\n\t\t\treturn 1;\n\t\t}\n\t} else\n\t\t/*\n\t\t * s_version of standard format may contain incorrect\n\t\t * information, so we just look at the magic string\n\t\t */\n\t\treiserfs_info(s,\n\t\t\t      \"found reiserfs format \\\"%s\\\" with standard journal\\n\",\n\t\t\t      is_reiserfs_3_5(rs) ? \"3.5\" : \"3.6\");\n\n\ts->s_op = &reiserfs_sops;\n\ts->s_export_op = &reiserfs_export_ops;\n#ifdef CONFIG_QUOTA\n\ts->s_qcop = &reiserfs_qctl_operations;\n\ts->dq_op = &reiserfs_quota_operations;\n\ts->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;\n#endif\n\n\t/*\n\t * new format is limited by the 32 bit wide i_blocks field, want to\n\t * be one full block below that.\n\t */\n\ts->s_maxbytes = (512LL << 32) - s->s_blocksize;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct super_operations reiserfs_sops = {\n\t.alloc_inode = reiserfs_alloc_inode,\n\t.destroy_inode = reiserfs_destroy_inode,\n\t.write_inode = reiserfs_write_inode,\n\t.dirty_inode = reiserfs_dirty_inode,\n\t.evict_inode = reiserfs_evict_inode,\n\t.put_super = reiserfs_put_super,\n\t.sync_fs = reiserfs_sync_fs,\n\t.freeze_fs = reiserfs_freeze,\n\t.unfreeze_fs = reiserfs_unfreeze,\n\t.statfs = reiserfs_statfs,\n\t.remount_fs = reiserfs_remount,\n\t.show_options = reiserfs_show_options,\n#ifdef CONFIG_QUOTA\n\t.quota_read = reiserfs_quota_read,\n\t.quota_write = reiserfs_quota_write,\n\t.get_dquots = reiserfs_get_dquots,\n#endif\n};",
      "static const struct export_operations reiserfs_export_ops = {\n\t.encode_fh = reiserfs_encode_fh,\n\t.fh_to_dentry = reiserfs_fh_to_dentry,\n\t.fh_to_parent = reiserfs_fh_to_parent,\n\t.get_parent = reiserfs_get_parent,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_info",
          "args": [
            "s",
            "\"found reiserfs format \\\"%s\\\" with standard journal\\n\"",
            "is_reiserfs_3_5(rs) ? \"3.5\" : \"3.6\""
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "280-288",
          "snippet": "void reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_reiserfs_3_5",
          "args": [
            "rs"
          ],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "is_reiserfs_3_5",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "39-43",
          "snippet": "int is_reiserfs_3_5(struct reiserfs_super_block *rs)\n{\n\treturn !strncmp(rs->s_v1.s_magic, reiserfs_3_5_magic_string,\n\t\t\tstrlen(reiserfs_3_5_magic_string));\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char reiserfs_3_5_magic_string[] = REISERFS_SUPER_MAGIC_STRING;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const char reiserfs_3_5_magic_string[] = REISERFS_SUPER_MAGIC_STRING;\n\nint is_reiserfs_3_5(struct reiserfs_super_block *rs)\n{\n\treturn !strncmp(rs->s_v1.s_magic, reiserfs_3_5_magic_string,\n\t\t\tstrlen(reiserfs_3_5_magic_string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"sh-2012\"",
            "\"found unknown \"\n\t\t\t\t\t \"format \\\"%u\\\" of reiserfs with \"\n\t\t\t\t\t \"non-standard magic\"",
            "sb_version(rs)"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_version",
          "args": [
            "rs"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasfinobt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "565-569",
          "snippet": "static inline int xfs_sb_version_hasfinobt(xfs_sb_t *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) &&\n\t\t(sbp->sb_features_ro_compat & XFS_SB_FEAT_RO_COMPAT_FINOBT);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_FEAT_RO_COMPAT_FINOBT   (1 << 0)\t\t/* free inode btree */",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_FEAT_RO_COMPAT_FINOBT   (1 << 0)\t\t/* free inode btree */\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hasfinobt(xfs_sb_t *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) &&\n\t\t(sbp->sb_features_ro_compat & XFS_SB_FEAT_RO_COMPAT_FINOBT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_reiserfs_jr",
          "args": [
            "rs"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "is_reiserfs_jr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "51-55",
          "snippet": "int is_reiserfs_jr(struct reiserfs_super_block *rs)\n{\n\treturn !strncmp(rs->s_v1.s_magic, reiserfs_jr_magic_string,\n\t\t\tstrlen(reiserfs_jr_magic_string));\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char reiserfs_jr_magic_string[] = REISER2FS_JR_SUPER_MAGIC_STRING;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const char reiserfs_jr_magic_string[] = REISER2FS_JR_SUPER_MAGIC_STRING;\n\nint is_reiserfs_jr(struct reiserfs_super_block *rs)\n{\n\treturn !strncmp(rs->s_v1.s_magic, reiserfs_jr_magic_string,\n\t\t\tstrlen(reiserfs_jr_magic_string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_DISK_SUPER_BLOCK",
          "args": [
            "s"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"super-6519\"",
            "\"Unfinished reiserfsck \"\n\t\t\t\t \"--rebuild-tree run detected. Please run\\n\"\n\t\t\t\t \"reiserfsck --rebuild-tree and wait for a \"\n\t\t\t\t \"completion. If that fails\\n\"\n\t\t\t\t \"get newer reiserfsprogs package\""
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_blocksize",
          "args": [
            "rs"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "s",
            "offset / s->s_blocksize"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "s",
            "fs_blocksize"
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_blocksize",
          "args": [
            "rs"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_any_reiserfs_magic_string",
          "args": [
            "rs"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "is_any_reiserfs_magic_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "57-61",
          "snippet": "static int is_any_reiserfs_magic_string(struct reiserfs_super_block *rs)\n{\n\treturn (is_reiserfs_3_5(rs) || is_reiserfs_3_6(rs) ||\n\t\tis_reiserfs_jr(rs));\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int is_any_reiserfs_magic_string(struct reiserfs_super_block *rs)\n{\n\treturn (is_reiserfs_3_5(rs) || is_reiserfs_3_6(rs) ||\n\t\tis_reiserfs_jr(rs));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "s",
            "offset / s->s_blocksize"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct super_operations reiserfs_sops = {\n\t.alloc_inode = reiserfs_alloc_inode,\n\t.destroy_inode = reiserfs_destroy_inode,\n\t.write_inode = reiserfs_write_inode,\n\t.dirty_inode = reiserfs_dirty_inode,\n\t.evict_inode = reiserfs_evict_inode,\n\t.put_super = reiserfs_put_super,\n\t.sync_fs = reiserfs_sync_fs,\n\t.freeze_fs = reiserfs_freeze,\n\t.unfreeze_fs = reiserfs_unfreeze,\n\t.statfs = reiserfs_statfs,\n\t.remount_fs = reiserfs_remount,\n\t.show_options = reiserfs_show_options,\n#ifdef CONFIG_QUOTA\n\t.quota_read = reiserfs_quota_read,\n\t.quota_write = reiserfs_quota_write,\n\t.get_dquots = reiserfs_get_dquots,\n#endif\n};\nstatic const struct export_operations reiserfs_export_ops = {\n\t.encode_fh = reiserfs_encode_fh,\n\t.fh_to_dentry = reiserfs_fh_to_dentry,\n\t.fh_to_parent = reiserfs_fh_to_parent,\n\t.get_parent = reiserfs_get_parent,\n};\n\nstatic int read_super_block(struct super_block *s, int offset)\n{\n\tstruct buffer_head *bh;\n\tstruct reiserfs_super_block *rs;\n\tint fs_blocksize;\n\n\tbh = sb_bread(s, offset / s->s_blocksize);\n\tif (!bh) {\n\t\treiserfs_warning(s, \"sh-2006\",\n\t\t\t\t \"bread failed (dev %s, block %lu, size %lu)\",\n\t\t\t\t s->s_id, offset / s->s_blocksize,\n\t\t\t\t s->s_blocksize);\n\t\treturn 1;\n\t}\n\n\trs = (struct reiserfs_super_block *)bh->b_data;\n\tif (!is_any_reiserfs_magic_string(rs)) {\n\t\tbrelse(bh);\n\t\treturn 1;\n\t}\n\t/*\n\t * ok, reiserfs signature (old or new) found in at the given offset\n\t */\n\tfs_blocksize = sb_blocksize(rs);\n\tbrelse(bh);\n\tsb_set_blocksize(s, fs_blocksize);\n\n\tbh = sb_bread(s, offset / s->s_blocksize);\n\tif (!bh) {\n\t\treiserfs_warning(s, \"sh-2007\",\n\t\t\t\t \"bread failed (dev %s, block %lu, size %lu)\",\n\t\t\t\t s->s_id, offset / s->s_blocksize,\n\t\t\t\t s->s_blocksize);\n\t\treturn 1;\n\t}\n\n\trs = (struct reiserfs_super_block *)bh->b_data;\n\tif (sb_blocksize(rs) != s->s_blocksize) {\n\t\treiserfs_warning(s, \"sh-2011\", \"can't find a reiserfs \"\n\t\t\t\t \"filesystem on (dev %s, block %llu, size %lu)\",\n\t\t\t\t s->s_id,\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t s->s_blocksize);\n\t\tbrelse(bh);\n\t\treturn 1;\n\t}\n\n\tif (rs->s_v1.s_root_block == cpu_to_le32(-1)) {\n\t\tbrelse(bh);\n\t\treiserfs_warning(s, \"super-6519\", \"Unfinished reiserfsck \"\n\t\t\t\t \"--rebuild-tree run detected. Please run\\n\"\n\t\t\t\t \"reiserfsck --rebuild-tree and wait for a \"\n\t\t\t\t \"completion. If that fails\\n\"\n\t\t\t\t \"get newer reiserfsprogs package\");\n\t\treturn 1;\n\t}\n\n\tSB_BUFFER_WITH_SB(s) = bh;\n\tSB_DISK_SUPER_BLOCK(s) = rs;\n\n\t/*\n\t * magic is of non-standard journal filesystem, look at s_version to\n\t * find which format is in use\n\t */\n\tif (is_reiserfs_jr(rs)) {\n\t\tif (sb_version(rs) == REISERFS_VERSION_2)\n\t\t\treiserfs_info(s, \"found reiserfs format \\\"3.6\\\"\"\n\t\t\t\t      \" with non-standard journal\\n\");\n\t\telse if (sb_version(rs) == REISERFS_VERSION_1)\n\t\t\treiserfs_info(s, \"found reiserfs format \\\"3.5\\\"\"\n\t\t\t\t      \" with non-standard journal\\n\");\n\t\telse {\n\t\t\treiserfs_warning(s, \"sh-2012\", \"found unknown \"\n\t\t\t\t\t \"format \\\"%u\\\" of reiserfs with \"\n\t\t\t\t\t \"non-standard magic\", sb_version(rs));\n\t\t\treturn 1;\n\t\t}\n\t} else\n\t\t/*\n\t\t * s_version of standard format may contain incorrect\n\t\t * information, so we just look at the magic string\n\t\t */\n\t\treiserfs_info(s,\n\t\t\t      \"found reiserfs format \\\"%s\\\" with standard journal\\n\",\n\t\t\t      is_reiserfs_3_5(rs) ? \"3.5\" : \"3.6\");\n\n\ts->s_op = &reiserfs_sops;\n\ts->s_export_op = &reiserfs_export_ops;\n#ifdef CONFIG_QUOTA\n\ts->s_qcop = &reiserfs_qctl_operations;\n\ts->dq_op = &reiserfs_quota_operations;\n\ts->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;\n#endif\n\n\t/*\n\t * new format is limited by the 32 bit wide i_blocks field, want to\n\t * be one full block below that.\n\t */\n\ts->s_maxbytes = (512LL << 32) - s->s_blocksize;\n\treturn 0;\n}"
  },
  {
    "function_name": "reiserfs_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "1383-1553",
    "snippet": "static int reiserfs_remount(struct super_block *s, int *mount_flags, char *arg)\n{\n\tstruct reiserfs_super_block *rs;\n\tstruct reiserfs_transaction_handle th;\n\tunsigned long blocks;\n\tunsigned long mount_options = REISERFS_SB(s)->s_mount_opt;\n\tunsigned long safe_mask = 0;\n\tunsigned int commit_max_age = (unsigned int)-1;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tchar *new_opts = kstrdup(arg, GFP_KERNEL);\n\tint err;\n\tchar *qf_names[REISERFS_MAXQUOTAS];\n\tunsigned int qfmt = 0;\n#ifdef CONFIG_QUOTA\n\tint i;\n#endif\n\n\tsync_filesystem(s);\n\treiserfs_write_lock(s);\n\n#ifdef CONFIG_QUOTA\n\tmemcpy(qf_names, REISERFS_SB(s)->s_qf_names, sizeof(qf_names));\n#endif\n\n\trs = SB_DISK_SUPER_BLOCK(s);\n\n\tif (!reiserfs_parse_options\n\t    (s, arg, &mount_options, &blocks, NULL, &commit_max_age,\n\t    qf_names, &qfmt)) {\n#ifdef CONFIG_QUOTA\n\t\tfor (i = 0; i < REISERFS_MAXQUOTAS; i++)\n\t\t\tif (qf_names[i] != REISERFS_SB(s)->s_qf_names[i])\n\t\t\t\tkfree(qf_names[i]);\n#endif\n\t\terr = -EINVAL;\n\t\tgoto out_err_unlock;\n\t}\n#ifdef CONFIG_QUOTA\n\thandle_quota_files(s, qf_names, &qfmt);\n#endif\n\n\thandle_attrs(s);\n\n\t/* Add options that are safe here */\n\tsafe_mask |= 1 << REISERFS_SMALLTAIL;\n\tsafe_mask |= 1 << REISERFS_LARGETAIL;\n\tsafe_mask |= 1 << REISERFS_NO_BORDER;\n\tsafe_mask |= 1 << REISERFS_NO_UNHASHED_RELOCATION;\n\tsafe_mask |= 1 << REISERFS_HASHED_RELOCATION;\n\tsafe_mask |= 1 << REISERFS_TEST4;\n\tsafe_mask |= 1 << REISERFS_ATTRS;\n\tsafe_mask |= 1 << REISERFS_XATTRS_USER;\n\tsafe_mask |= 1 << REISERFS_POSIXACL;\n\tsafe_mask |= 1 << REISERFS_BARRIER_FLUSH;\n\tsafe_mask |= 1 << REISERFS_BARRIER_NONE;\n\tsafe_mask |= 1 << REISERFS_ERROR_RO;\n\tsafe_mask |= 1 << REISERFS_ERROR_CONTINUE;\n\tsafe_mask |= 1 << REISERFS_ERROR_PANIC;\n\tsafe_mask |= 1 << REISERFS_USRQUOTA;\n\tsafe_mask |= 1 << REISERFS_GRPQUOTA;\n\n\t/*\n\t * Update the bitmask, taking care to keep\n\t * the bits we're not allowed to change here\n\t */\n\tREISERFS_SB(s)->s_mount_opt =\n\t    (REISERFS_SB(s)->\n\t     s_mount_opt & ~safe_mask) | (mount_options & safe_mask);\n\n\tif (commit_max_age != 0 && commit_max_age != (unsigned int)-1) {\n\t\tjournal->j_max_commit_age = commit_max_age;\n\t\tjournal->j_max_trans_age = commit_max_age;\n\t} else if (commit_max_age == 0) {\n\t\t/* 0 means restore defaults. */\n\t\tjournal->j_max_commit_age = journal->j_default_max_commit_age;\n\t\tjournal->j_max_trans_age = JOURNAL_MAX_TRANS_AGE;\n\t}\n\n\tif (blocks) {\n\t\terr = reiserfs_resize(s, blocks);\n\t\tif (err != 0)\n\t\t\tgoto out_err_unlock;\n\t}\n\n\tif (*mount_flags & MS_RDONLY) {\n\t\treiserfs_write_unlock(s);\n\t\treiserfs_xattr_init(s, *mount_flags);\n\t\t/* remount read-only */\n\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t/* it is read-only already */\n\t\t\tgoto out_ok_unlocked;\n\n\t\terr = dquot_suspend(s, -1);\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\n\t\t/* try to remount file system with read-only permissions */\n\t\tif (sb_umount_state(rs) == REISERFS_VALID_FS\n\t\t    || REISERFS_SB(s)->s_mount_state != REISERFS_VALID_FS) {\n\t\t\tgoto out_ok_unlocked;\n\t\t}\n\n\t\treiserfs_write_lock(s);\n\n\t\terr = journal_begin(&th, s, 10);\n\t\tif (err)\n\t\t\tgoto out_err_unlock;\n\n\t\t/* Mounting a rw partition read-only. */\n\t\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);\n\t\tset_sb_umount_state(rs, REISERFS_SB(s)->s_mount_state);\n\t\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(s));\n\t} else {\n\t\t/* remount read-write */\n\t\tif (!(s->s_flags & MS_RDONLY)) {\n\t\t\treiserfs_write_unlock(s);\n\t\t\treiserfs_xattr_init(s, *mount_flags);\n\t\t\tgoto out_ok_unlocked;\t/* We are read-write already */\n\t\t}\n\n\t\tif (reiserfs_is_journal_aborted(journal)) {\n\t\t\terr = journal->j_errno;\n\t\t\tgoto out_err_unlock;\n\t\t}\n\n\t\thandle_data_mode(s, mount_options);\n\t\thandle_barrier_mode(s, mount_options);\n\t\tREISERFS_SB(s)->s_mount_state = sb_umount_state(rs);\n\n\t\t/* now it is safe to call journal_begin */\n\t\ts->s_flags &= ~MS_RDONLY;\n\t\terr = journal_begin(&th, s, 10);\n\t\tif (err)\n\t\t\tgoto out_err_unlock;\n\n\t\t/* Mount a partition which is read-only, read-write */\n\t\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);\n\t\tREISERFS_SB(s)->s_mount_state = sb_umount_state(rs);\n\t\ts->s_flags &= ~MS_RDONLY;\n\t\tset_sb_umount_state(rs, REISERFS_ERROR_FS);\n\t\tif (!old_format_only(s))\n\t\t\tset_sb_mnt_count(rs, sb_mnt_count(rs) + 1);\n\t\t/* mark_buffer_dirty (SB_BUFFER_WITH_SB (s), 1); */\n\t\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(s));\n\t\tREISERFS_SB(s)->s_mount_state = REISERFS_VALID_FS;\n\t}\n\t/* this will force a full flush of all journal lists */\n\tSB_JOURNAL(s)->j_must_wait = 1;\n\terr = journal_end(&th);\n\tif (err)\n\t\tgoto out_err_unlock;\n\n\treiserfs_write_unlock(s);\n\tif (!(*mount_flags & MS_RDONLY)) {\n\t\tdquot_resume(s, -1);\n\t\treiserfs_write_lock(s);\n\t\tfinish_unfinished(s);\n\t\treiserfs_write_unlock(s);\n\t\treiserfs_xattr_init(s, *mount_flags);\n\t}\n\nout_ok_unlocked:\n\treplace_mount_options(s, new_opts);\n\treturn 0;\n\nout_err_unlock:\n\treiserfs_write_unlock(s);\nout_err:\n\tkfree(new_opts);\n\treturn err;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_opts"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "s"
          ],
          "line": 1549
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "replace_mount_options",
          "args": [
            "s",
            "new_opts"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "replace_mount_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1196-1204",
          "snippet": "void replace_mount_options(struct super_block *sb, char *options)\n{\n\tchar *old = sb->s_options;\n\trcu_assign_pointer(sb->s_options, options);\n\tif (old) {\n\t\tsynchronize_rcu();\n\t\tkfree(old);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid replace_mount_options(struct super_block *sb, char *options)\n{\n\tchar *old = sb->s_options;\n\trcu_assign_pointer(sb->s_options, options);\n\tif (old) {\n\t\tsynchronize_rcu();\n\t\tkfree(old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_xattr_init",
          "args": [
            "s",
            "*mount_flags"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_xattr_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "1020-1064",
          "snippet": "int reiserfs_xattr_init(struct super_block *s, int mount_flags)\n{\n\tint err = 0;\n\tstruct dentry *privroot = REISERFS_SB(s)->priv_root;\n\n\terr = xattr_mount_check(s);\n\tif (err)\n\t\tgoto error;\n\n\tif (!privroot->d_inode && !(mount_flags & MS_RDONLY)) {\n\t\tmutex_lock(&s->s_root->d_inode->i_mutex);\n\t\terr = create_privroot(REISERFS_SB(s)->priv_root);\n\t\tmutex_unlock(&s->s_root->d_inode->i_mutex);\n\t}\n\n\tif (privroot->d_inode) {\n\t\ts->s_xattr = reiserfs_xattr_handlers;\n\t\tmutex_lock(&privroot->d_inode->i_mutex);\n\t\tif (!REISERFS_SB(s)->xattr_root) {\n\t\t\tstruct dentry *dentry;\n\n\t\t\tdentry = lookup_one_len(XAROOT_NAME, privroot,\n\t\t\t\t\t\tstrlen(XAROOT_NAME));\n\t\t\tif (!IS_ERR(dentry))\n\t\t\t\tREISERFS_SB(s)->xattr_root = dentry;\n\t\t\telse\n\t\t\t\terr = PTR_ERR(dentry);\n\t\t}\n\t\tmutex_unlock(&privroot->d_inode->i_mutex);\n\t}\n\nerror:\n\tif (err) {\n\t\tclear_bit(REISERFS_XATTRS_USER, &REISERFS_SB(s)->s_mount_opt);\n\t\tclear_bit(REISERFS_POSIXACL, &REISERFS_SB(s)->s_mount_opt);\n\t}\n\n\t/* The super_block MS_POSIXACL must mirror the (no)acl mount option. */\n\tif (reiserfs_posixacl(s))\n\t\ts->s_flags |= MS_POSIXACL;\n\telse\n\t\ts->s_flags &= ~MS_POSIXACL;\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [
            "#define XAROOT_NAME   \"xattrs\""
          ],
          "globals_used": [
            "static const struct xattr_handler *reiserfs_xattr_handlers[] = {\n#ifdef CONFIG_REISERFS_FS_XATTR\n\t&reiserfs_xattr_user_handler,\n\t&reiserfs_xattr_trusted_handler,\n#endif\n#ifdef CONFIG_REISERFS_FS_SECURITY\n\t&reiserfs_xattr_security_handler,\n#endif\n#ifdef CONFIG_REISERFS_FS_POSIX_ACL\n\t&posix_acl_access_xattr_handler,\n\t&posix_acl_default_xattr_handler,\n#endif\n\tNULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\n#define XAROOT_NAME   \"xattrs\"\n\nstatic const struct xattr_handler *reiserfs_xattr_handlers[] = {\n#ifdef CONFIG_REISERFS_FS_XATTR\n\t&reiserfs_xattr_user_handler,\n\t&reiserfs_xattr_trusted_handler,\n#endif\n#ifdef CONFIG_REISERFS_FS_SECURITY\n\t&reiserfs_xattr_security_handler,\n#endif\n#ifdef CONFIG_REISERFS_FS_POSIX_ACL\n\t&posix_acl_access_xattr_handler,\n\t&posix_acl_default_xattr_handler,\n#endif\n\tNULL\n};\n\nint reiserfs_xattr_init(struct super_block *s, int mount_flags)\n{\n\tint err = 0;\n\tstruct dentry *privroot = REISERFS_SB(s)->priv_root;\n\n\terr = xattr_mount_check(s);\n\tif (err)\n\t\tgoto error;\n\n\tif (!privroot->d_inode && !(mount_flags & MS_RDONLY)) {\n\t\tmutex_lock(&s->s_root->d_inode->i_mutex);\n\t\terr = create_privroot(REISERFS_SB(s)->priv_root);\n\t\tmutex_unlock(&s->s_root->d_inode->i_mutex);\n\t}\n\n\tif (privroot->d_inode) {\n\t\ts->s_xattr = reiserfs_xattr_handlers;\n\t\tmutex_lock(&privroot->d_inode->i_mutex);\n\t\tif (!REISERFS_SB(s)->xattr_root) {\n\t\t\tstruct dentry *dentry;\n\n\t\t\tdentry = lookup_one_len(XAROOT_NAME, privroot,\n\t\t\t\t\t\tstrlen(XAROOT_NAME));\n\t\t\tif (!IS_ERR(dentry))\n\t\t\t\tREISERFS_SB(s)->xattr_root = dentry;\n\t\t\telse\n\t\t\t\terr = PTR_ERR(dentry);\n\t\t}\n\t\tmutex_unlock(&privroot->d_inode->i_mutex);\n\t}\n\nerror:\n\tif (err) {\n\t\tclear_bit(REISERFS_XATTRS_USER, &REISERFS_SB(s)->s_mount_opt);\n\t\tclear_bit(REISERFS_POSIXACL, &REISERFS_SB(s)->s_mount_opt);\n\t}\n\n\t/* The super_block MS_POSIXACL must mirror the (no)acl mount option. */\n\tif (reiserfs_posixacl(s))\n\t\ts->s_flags |= MS_POSIXACL;\n\telse\n\t\ts->s_flags &= ~MS_POSIXACL;\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_unfinished",
          "args": [
            "s"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "finish_unfinished",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "193-387",
          "snippet": "static int finish_unfinished(struct super_block *s)\n{\n\tINITIALIZE_PATH(path);\n\tstruct cpu_key max_cpu_key, obj_key;\n\tstruct reiserfs_key save_link_key, last_inode_key;\n\tint retval = 0;\n\tstruct item_head *ih;\n\tstruct buffer_head *bh;\n\tint item_pos;\n\tchar *item;\n\tint done;\n\tstruct inode *inode;\n\tint truncate;\n#ifdef CONFIG_QUOTA\n\tint i;\n\tint ms_active_set;\n\tint quota_enabled[REISERFS_MAXQUOTAS];\n#endif\n\n\t/* compose key to look for \"save\" links */\n\tmax_cpu_key.version = KEY_FORMAT_3_5;\n\tmax_cpu_key.on_disk_key.k_dir_id = ~0U;\n\tmax_cpu_key.on_disk_key.k_objectid = ~0U;\n\tset_cpu_key_k_offset(&max_cpu_key, ~0U);\n\tmax_cpu_key.key_length = 3;\n\n\tmemset(&last_inode_key, 0, sizeof(last_inode_key));\n\n#ifdef CONFIG_QUOTA\n\t/* Needed for iput() to work correctly and not trash data */\n\tif (s->s_flags & MS_ACTIVE) {\n\t\tms_active_set = 0;\n\t} else {\n\t\tms_active_set = 1;\n\t\ts->s_flags |= MS_ACTIVE;\n\t}\n\t/* Turn on quotas so that they are updated correctly */\n\tfor (i = 0; i < REISERFS_MAXQUOTAS; i++) {\n\t\tquota_enabled[i] = 1;\n\t\tif (REISERFS_SB(s)->s_qf_names[i]) {\n\t\t\tint ret;\n\n\t\t\tif (sb_has_quota_active(s, i)) {\n\t\t\t\tquota_enabled[i] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tret = reiserfs_quota_on_mount(s, i);\n\t\t\tif (ret < 0)\n\t\t\t\treiserfs_warning(s, \"reiserfs-2500\",\n\t\t\t\t\t\t \"cannot turn on journaled \"\n\t\t\t\t\t\t \"quota: error %d\", ret);\n\t\t}\n\t}\n#endif\n\n\tdone = 0;\n\tREISERFS_SB(s)->s_is_unlinked_ok = 1;\n\twhile (!retval) {\n\t\tint depth;\n\t\tretval = search_item(s, &max_cpu_key, &path);\n\t\tif (retval != ITEM_NOT_FOUND) {\n\t\t\treiserfs_error(s, \"vs-2140\",\n\t\t\t\t       \"search_by_key returned %d\", retval);\n\t\t\tbreak;\n\t\t}\n\n\t\tbh = get_last_bh(&path);\n\t\titem_pos = get_item_pos(&path);\n\t\tif (item_pos != B_NR_ITEMS(bh)) {\n\t\t\treiserfs_warning(s, \"vs-2060\",\n\t\t\t\t\t \"wrong position found\");\n\t\t\tbreak;\n\t\t}\n\t\titem_pos--;\n\t\tih = item_head(bh, item_pos);\n\n\t\tif (le32_to_cpu(ih->ih_key.k_dir_id) != MAX_KEY_OBJECTID)\n\t\t\t/* there are no \"save\" links anymore */\n\t\t\tbreak;\n\n\t\tsave_link_key = ih->ih_key;\n\t\tif (is_indirect_le_ih(ih))\n\t\t\ttruncate = 1;\n\t\telse\n\t\t\ttruncate = 0;\n\n\t\t/* reiserfs_iget needs k_dirid and k_objectid only */\n\t\titem = ih_item_body(bh, ih);\n\t\tobj_key.on_disk_key.k_dir_id = le32_to_cpu(*(__le32 *) item);\n\t\tobj_key.on_disk_key.k_objectid =\n\t\t    le32_to_cpu(ih->ih_key.k_objectid);\n\t\tobj_key.on_disk_key.k_offset = 0;\n\t\tobj_key.on_disk_key.k_type = 0;\n\n\t\tpathrelse(&path);\n\n\t\tinode = reiserfs_iget(s, &obj_key);\n\t\tif (!inode) {\n\t\t\t/*\n\t\t\t * the unlink almost completed, it just did not\n\t\t\t * manage to remove \"save\" link and release objectid\n\t\t\t */\n\t\t\treiserfs_warning(s, \"vs-2180\", \"iget failed for %K\",\n\t\t\t\t\t &obj_key);\n\t\t\tretval = remove_save_link_only(s, &save_link_key, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!truncate && inode->i_nlink) {\n\t\t\t/* file is not unlinked */\n\t\t\treiserfs_warning(s, \"vs-2185\",\n\t\t\t\t\t \"file %K is not unlinked\",\n\t\t\t\t\t &obj_key);\n\t\t\tretval = remove_save_link_only(s, &save_link_key, 0);\n\t\t\tcontinue;\n\t\t}\n\t\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\tdquot_initialize(inode);\n\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\t\tif (truncate && S_ISDIR(inode->i_mode)) {\n\t\t\t/*\n\t\t\t * We got a truncate request for a dir which\n\t\t\t * is impossible.  The only imaginable way is to\n\t\t\t * execute unfinished truncate request then boot\n\t\t\t * into old kernel, remove the file and create dir\n\t\t\t * with the same key.\n\t\t\t */\n\t\t\treiserfs_warning(s, \"green-2101\",\n\t\t\t\t\t \"impossible truncate on a \"\n\t\t\t\t\t \"directory %k. Please report\",\n\t\t\t\t\t INODE_PKEY(inode));\n\t\t\tretval = remove_save_link_only(s, &save_link_key, 0);\n\t\t\ttruncate = 0;\n\t\t\tiput(inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (truncate) {\n\t\t\tREISERFS_I(inode)->i_flags |=\n\t\t\t    i_link_saved_truncate_mask;\n\t\t\t/*\n\t\t\t * not completed truncate found. New size was\n\t\t\t * committed together with \"save\" link\n\t\t\t */\n\t\t\treiserfs_info(s, \"Truncating %k to %lld ..\",\n\t\t\t\t      INODE_PKEY(inode), inode->i_size);\n\n\t\t\t/* don't update modification time */\n\t\t\treiserfs_truncate_file(inode, 0);\n\n\t\t\tretval = remove_save_link(inode, truncate);\n\t\t} else {\n\t\t\tREISERFS_I(inode)->i_flags |= i_link_saved_unlink_mask;\n\t\t\t/* not completed unlink (rmdir) found */\n\t\t\treiserfs_info(s, \"Removing %k..\", INODE_PKEY(inode));\n\t\t\tif (memcmp(&last_inode_key, INODE_PKEY(inode),\n\t\t\t\t\tsizeof(last_inode_key))){\n\t\t\t\tlast_inode_key = *INODE_PKEY(inode);\n\t\t\t\t/* removal gets completed in iput */\n\t\t\t\tretval = 0;\n\t\t\t} else {\n\t\t\t\treiserfs_warning(s, \"super-2189\", \"Dead loop \"\n\t\t\t\t\t\t \"in finish_unfinished \"\n\t\t\t\t\t\t \"detected, just remove \"\n\t\t\t\t\t\t \"save link\\n\");\n\t\t\t\tretval = remove_save_link_only(s,\n\t\t\t\t\t\t\t&save_link_key, 0);\n\t\t\t}\n\t\t}\n\n\t\tiput(inode);\n\t\tprintk(\"done\\n\");\n\t\tdone++;\n\t}\n\tREISERFS_SB(s)->s_is_unlinked_ok = 0;\n\n#ifdef CONFIG_QUOTA\n\t/* Turn quotas off */\n\treiserfs_write_unlock(s);\n\tfor (i = 0; i < REISERFS_MAXQUOTAS; i++) {\n\t\tif (sb_dqopt(s)->files[i] && quota_enabled[i])\n\t\t\tdquot_quota_off(s, i);\n\t}\n\treiserfs_write_lock(s);\n\tif (ms_active_set)\n\t\t/* Restore the flag back */\n\t\ts->s_flags &= ~MS_ACTIVE;\n#endif\n\tpathrelse(&path);\n\tif (done)\n\t\treiserfs_info(s, \"There were %d uncompleted unlinks/truncates. \"\n\t\t\t      \"Completed\\n\", done);\n\treturn retval;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int reiserfs_remount(struct super_block *s, int *flags, char *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int reiserfs_remount(struct super_block *s, int *flags, char *data);\n\nstatic int finish_unfinished(struct super_block *s)\n{\n\tINITIALIZE_PATH(path);\n\tstruct cpu_key max_cpu_key, obj_key;\n\tstruct reiserfs_key save_link_key, last_inode_key;\n\tint retval = 0;\n\tstruct item_head *ih;\n\tstruct buffer_head *bh;\n\tint item_pos;\n\tchar *item;\n\tint done;\n\tstruct inode *inode;\n\tint truncate;\n#ifdef CONFIG_QUOTA\n\tint i;\n\tint ms_active_set;\n\tint quota_enabled[REISERFS_MAXQUOTAS];\n#endif\n\n\t/* compose key to look for \"save\" links */\n\tmax_cpu_key.version = KEY_FORMAT_3_5;\n\tmax_cpu_key.on_disk_key.k_dir_id = ~0U;\n\tmax_cpu_key.on_disk_key.k_objectid = ~0U;\n\tset_cpu_key_k_offset(&max_cpu_key, ~0U);\n\tmax_cpu_key.key_length = 3;\n\n\tmemset(&last_inode_key, 0, sizeof(last_inode_key));\n\n#ifdef CONFIG_QUOTA\n\t/* Needed for iput() to work correctly and not trash data */\n\tif (s->s_flags & MS_ACTIVE) {\n\t\tms_active_set = 0;\n\t} else {\n\t\tms_active_set = 1;\n\t\ts->s_flags |= MS_ACTIVE;\n\t}\n\t/* Turn on quotas so that they are updated correctly */\n\tfor (i = 0; i < REISERFS_MAXQUOTAS; i++) {\n\t\tquota_enabled[i] = 1;\n\t\tif (REISERFS_SB(s)->s_qf_names[i]) {\n\t\t\tint ret;\n\n\t\t\tif (sb_has_quota_active(s, i)) {\n\t\t\t\tquota_enabled[i] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tret = reiserfs_quota_on_mount(s, i);\n\t\t\tif (ret < 0)\n\t\t\t\treiserfs_warning(s, \"reiserfs-2500\",\n\t\t\t\t\t\t \"cannot turn on journaled \"\n\t\t\t\t\t\t \"quota: error %d\", ret);\n\t\t}\n\t}\n#endif\n\n\tdone = 0;\n\tREISERFS_SB(s)->s_is_unlinked_ok = 1;\n\twhile (!retval) {\n\t\tint depth;\n\t\tretval = search_item(s, &max_cpu_key, &path);\n\t\tif (retval != ITEM_NOT_FOUND) {\n\t\t\treiserfs_error(s, \"vs-2140\",\n\t\t\t\t       \"search_by_key returned %d\", retval);\n\t\t\tbreak;\n\t\t}\n\n\t\tbh = get_last_bh(&path);\n\t\titem_pos = get_item_pos(&path);\n\t\tif (item_pos != B_NR_ITEMS(bh)) {\n\t\t\treiserfs_warning(s, \"vs-2060\",\n\t\t\t\t\t \"wrong position found\");\n\t\t\tbreak;\n\t\t}\n\t\titem_pos--;\n\t\tih = item_head(bh, item_pos);\n\n\t\tif (le32_to_cpu(ih->ih_key.k_dir_id) != MAX_KEY_OBJECTID)\n\t\t\t/* there are no \"save\" links anymore */\n\t\t\tbreak;\n\n\t\tsave_link_key = ih->ih_key;\n\t\tif (is_indirect_le_ih(ih))\n\t\t\ttruncate = 1;\n\t\telse\n\t\t\ttruncate = 0;\n\n\t\t/* reiserfs_iget needs k_dirid and k_objectid only */\n\t\titem = ih_item_body(bh, ih);\n\t\tobj_key.on_disk_key.k_dir_id = le32_to_cpu(*(__le32 *) item);\n\t\tobj_key.on_disk_key.k_objectid =\n\t\t    le32_to_cpu(ih->ih_key.k_objectid);\n\t\tobj_key.on_disk_key.k_offset = 0;\n\t\tobj_key.on_disk_key.k_type = 0;\n\n\t\tpathrelse(&path);\n\n\t\tinode = reiserfs_iget(s, &obj_key);\n\t\tif (!inode) {\n\t\t\t/*\n\t\t\t * the unlink almost completed, it just did not\n\t\t\t * manage to remove \"save\" link and release objectid\n\t\t\t */\n\t\t\treiserfs_warning(s, \"vs-2180\", \"iget failed for %K\",\n\t\t\t\t\t &obj_key);\n\t\t\tretval = remove_save_link_only(s, &save_link_key, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!truncate && inode->i_nlink) {\n\t\t\t/* file is not unlinked */\n\t\t\treiserfs_warning(s, \"vs-2185\",\n\t\t\t\t\t \"file %K is not unlinked\",\n\t\t\t\t\t &obj_key);\n\t\t\tretval = remove_save_link_only(s, &save_link_key, 0);\n\t\t\tcontinue;\n\t\t}\n\t\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\tdquot_initialize(inode);\n\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\t\tif (truncate && S_ISDIR(inode->i_mode)) {\n\t\t\t/*\n\t\t\t * We got a truncate request for a dir which\n\t\t\t * is impossible.  The only imaginable way is to\n\t\t\t * execute unfinished truncate request then boot\n\t\t\t * into old kernel, remove the file and create dir\n\t\t\t * with the same key.\n\t\t\t */\n\t\t\treiserfs_warning(s, \"green-2101\",\n\t\t\t\t\t \"impossible truncate on a \"\n\t\t\t\t\t \"directory %k. Please report\",\n\t\t\t\t\t INODE_PKEY(inode));\n\t\t\tretval = remove_save_link_only(s, &save_link_key, 0);\n\t\t\ttruncate = 0;\n\t\t\tiput(inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (truncate) {\n\t\t\tREISERFS_I(inode)->i_flags |=\n\t\t\t    i_link_saved_truncate_mask;\n\t\t\t/*\n\t\t\t * not completed truncate found. New size was\n\t\t\t * committed together with \"save\" link\n\t\t\t */\n\t\t\treiserfs_info(s, \"Truncating %k to %lld ..\",\n\t\t\t\t      INODE_PKEY(inode), inode->i_size);\n\n\t\t\t/* don't update modification time */\n\t\t\treiserfs_truncate_file(inode, 0);\n\n\t\t\tretval = remove_save_link(inode, truncate);\n\t\t} else {\n\t\t\tREISERFS_I(inode)->i_flags |= i_link_saved_unlink_mask;\n\t\t\t/* not completed unlink (rmdir) found */\n\t\t\treiserfs_info(s, \"Removing %k..\", INODE_PKEY(inode));\n\t\t\tif (memcmp(&last_inode_key, INODE_PKEY(inode),\n\t\t\t\t\tsizeof(last_inode_key))){\n\t\t\t\tlast_inode_key = *INODE_PKEY(inode);\n\t\t\t\t/* removal gets completed in iput */\n\t\t\t\tretval = 0;\n\t\t\t} else {\n\t\t\t\treiserfs_warning(s, \"super-2189\", \"Dead loop \"\n\t\t\t\t\t\t \"in finish_unfinished \"\n\t\t\t\t\t\t \"detected, just remove \"\n\t\t\t\t\t\t \"save link\\n\");\n\t\t\t\tretval = remove_save_link_only(s,\n\t\t\t\t\t\t\t&save_link_key, 0);\n\t\t\t}\n\t\t}\n\n\t\tiput(inode);\n\t\tprintk(\"done\\n\");\n\t\tdone++;\n\t}\n\tREISERFS_SB(s)->s_is_unlinked_ok = 0;\n\n#ifdef CONFIG_QUOTA\n\t/* Turn quotas off */\n\treiserfs_write_unlock(s);\n\tfor (i = 0; i < REISERFS_MAXQUOTAS; i++) {\n\t\tif (sb_dqopt(s)->files[i] && quota_enabled[i])\n\t\t\tdquot_quota_off(s, i);\n\t}\n\treiserfs_write_lock(s);\n\tif (ms_active_set)\n\t\t/* Restore the flag back */\n\t\ts->s_flags &= ~MS_ACTIVE;\n#endif\n\tpathrelse(&path);\n\tif (done)\n\t\treiserfs_info(s, \"There were %d uncompleted unlinks/truncates. \"\n\t\t\t      \"Completed\\n\", done);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "s"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_resume",
          "args": [
            "s",
            "-1"
          ],
          "line": 1537
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_resume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "2256-2289",
          "snippet": "int dquot_resume(struct super_block *sb, int type)\n{\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct inode *inode;\n\tint ret = 0, cnt;\n\tunsigned int flags;\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&dqopt->dqonoff_mutex);\n\t\tif (!sb_has_quota_suspended(sb, cnt)) {\n\t\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\t\tcontinue;\n\t\t}\n\t\tinode = dqopt->files[cnt];\n\t\tdqopt->files[cnt] = NULL;\n\t\tspin_lock(&dq_state_lock);\n\t\tflags = dqopt->flags & dquot_state_flag(DQUOT_USAGE_ENABLED |\n\t\t\t\t\t\t\tDQUOT_LIMITS_ENABLED,\n\t\t\t\t\t\t\tcnt);\n\t\tdqopt->flags &= ~dquot_state_flag(DQUOT_STATE_FLAGS, cnt);\n\t\tspin_unlock(&dq_state_lock);\n\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\t\tflags = dquot_generic_flag(flags, cnt);\n\t\tret = vfs_load_quota_inode(inode, cnt,\n\t\t\t\tdqopt->info[cnt].dqi_fmt_id, flags);\n\t\tiput(inode);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_resume(struct super_block *sb, int type)\n{\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct inode *inode;\n\tint ret = 0, cnt;\n\tunsigned int flags;\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&dqopt->dqonoff_mutex);\n\t\tif (!sb_has_quota_suspended(sb, cnt)) {\n\t\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\t\tcontinue;\n\t\t}\n\t\tinode = dqopt->files[cnt];\n\t\tdqopt->files[cnt] = NULL;\n\t\tspin_lock(&dq_state_lock);\n\t\tflags = dqopt->flags & dquot_state_flag(DQUOT_USAGE_ENABLED |\n\t\t\t\t\t\t\tDQUOT_LIMITS_ENABLED,\n\t\t\t\t\t\t\tcnt);\n\t\tdqopt->flags &= ~dquot_state_flag(DQUOT_STATE_FLAGS, cnt);\n\t\tspin_unlock(&dq_state_lock);\n\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\t\tflags = dquot_generic_flag(flags, cnt);\n\t\tret = vfs_load_quota_inode(inode, cnt,\n\t\t\t\tdqopt->info[cnt].dqi_fmt_id, flags);\n\t\tiput(inode);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "&th"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "s"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "s"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_mark_dirty",
          "args": [
            "&th",
            "SB_BUFFER_WITH_SB(s)"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "journal_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3274-3379",
          "snippet": "int journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sb_mnt_count",
          "args": [
            "rs",
            "sb_mnt_count(rs) + 1"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_mnt_count",
          "args": [
            "rs"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_format_only",
          "args": [
            "s"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sb_umount_state",
          "args": [
            "rs",
            "REISERFS_ERROR_FS"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_umount_state",
          "args": [
            "rs"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_prepare_for_journal",
          "args": [
            "s",
            "SB_BUFFER_WITH_SB(s)",
            "1"
          ],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_prepare_for_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3951-3968",
          "snippet": "int reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "s",
            "10"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_umount_state",
          "args": [
            "rs"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_barrier_mode",
          "args": [
            "s",
            "mount_options"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "handle_barrier_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "1329-1345",
          "snippet": "static void handle_barrier_mode(struct super_block *s, unsigned long bits)\n{\n\tint flush = (1 << REISERFS_BARRIER_FLUSH);\n\tint none = (1 << REISERFS_BARRIER_NONE);\n\tint all_barrier = flush | none;\n\n\tif (bits & all_barrier) {\n\t\tREISERFS_SB(s)->s_mount_opt &= ~all_barrier;\n\t\tif (bits & flush) {\n\t\t\tREISERFS_SB(s)->s_mount_opt |= flush;\n\t\t\tprintk(\"reiserfs: enabling write barrier flush mode\\n\");\n\t\t} else if (bits & none) {\n\t\t\tREISERFS_SB(s)->s_mount_opt |= none;\n\t\t\tprintk(\"reiserfs: write barriers turned off\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void handle_barrier_mode(struct super_block *s, unsigned long bits)\n{\n\tint flush = (1 << REISERFS_BARRIER_FLUSH);\n\tint none = (1 << REISERFS_BARRIER_NONE);\n\tint all_barrier = flush | none;\n\n\tif (bits & all_barrier) {\n\t\tREISERFS_SB(s)->s_mount_opt &= ~all_barrier;\n\t\tif (bits & flush) {\n\t\t\tREISERFS_SB(s)->s_mount_opt |= flush;\n\t\t\tprintk(\"reiserfs: enabling write barrier flush mode\\n\");\n\t\t} else if (bits & none) {\n\t\t\tREISERFS_SB(s)->s_mount_opt |= none;\n\t\t\tprintk(\"reiserfs: write barriers turned off\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_data_mode",
          "args": [
            "s",
            "mount_options"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "handle_data_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "1309-1327",
          "snippet": "static void handle_data_mode(struct super_block *s, unsigned long mount_options)\n{\n\tif (mount_options & (1 << REISERFS_DATA_LOG)) {\n\t\tif (!reiserfs_data_log(s)) {\n\t\t\tswitch_data_mode(s, REISERFS_DATA_LOG);\n\t\t\treiserfs_info(s, \"switching to journaled data mode\\n\");\n\t\t}\n\t} else if (mount_options & (1 << REISERFS_DATA_ORDERED)) {\n\t\tif (!reiserfs_data_ordered(s)) {\n\t\t\tswitch_data_mode(s, REISERFS_DATA_ORDERED);\n\t\t\treiserfs_info(s, \"switching to ordered data mode\\n\");\n\t\t}\n\t} else if (mount_options & (1 << REISERFS_DATA_WRITEBACK)) {\n\t\tif (!reiserfs_data_writeback(s)) {\n\t\t\tswitch_data_mode(s, REISERFS_DATA_WRITEBACK);\n\t\t\treiserfs_info(s, \"switching to writeback data mode\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int reiserfs_remount(struct super_block *s, int *flags, char *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int reiserfs_remount(struct super_block *s, int *flags, char *data);\n\nstatic void handle_data_mode(struct super_block *s, unsigned long mount_options)\n{\n\tif (mount_options & (1 << REISERFS_DATA_LOG)) {\n\t\tif (!reiserfs_data_log(s)) {\n\t\t\tswitch_data_mode(s, REISERFS_DATA_LOG);\n\t\t\treiserfs_info(s, \"switching to journaled data mode\\n\");\n\t\t}\n\t} else if (mount_options & (1 << REISERFS_DATA_ORDERED)) {\n\t\tif (!reiserfs_data_ordered(s)) {\n\t\t\tswitch_data_mode(s, REISERFS_DATA_ORDERED);\n\t\t\treiserfs_info(s, \"switching to ordered data mode\\n\");\n\t\t}\n\t} else if (mount_options & (1 << REISERFS_DATA_WRITEBACK)) {\n\t\tif (!reiserfs_data_writeback(s)) {\n\t\t\tswitch_data_mode(s, REISERFS_DATA_WRITEBACK);\n\t\t\treiserfs_info(s, \"switching to writeback data mode\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_is_journal_aborted",
          "args": [
            "journal"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_is_journal_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "760-764",
          "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sb_umount_state",
          "args": [
            "rs",
            "REISERFS_SB(s)->s_mount_state"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_umount_state",
          "args": [
            "rs"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_suspend",
          "args": [
            "s",
            "-1"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_resize",
          "args": [
            "s",
            "blocks"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_resize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/resize.c",
          "lines": "19-229",
          "snippet": "int reiserfs_resize(struct super_block *s, unsigned long block_count_new)\n{\n\tint err = 0;\n\tstruct reiserfs_super_block *sb;\n\tstruct reiserfs_bitmap_info *bitmap;\n\tstruct reiserfs_bitmap_info *info;\n\tstruct reiserfs_bitmap_info *old_bitmap = SB_AP_BITMAP(s);\n\tstruct buffer_head *bh;\n\tstruct reiserfs_transaction_handle th;\n\tunsigned int bmap_nr_new, bmap_nr;\n\tunsigned int block_r_new, block_r;\n\n\tstruct reiserfs_list_bitmap *jb;\n\tstruct reiserfs_list_bitmap jbitmap[JOURNAL_NUM_BITMAPS];\n\n\tunsigned long int block_count, free_blocks;\n\tint i;\n\tint copy_size;\n\tint depth;\n\n\tsb = SB_DISK_SUPER_BLOCK(s);\n\n\tif (SB_BLOCK_COUNT(s) >= block_count_new) {\n\t\tprintk(\"can\\'t shrink filesystem on-line\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check the device size */\n\tdepth = reiserfs_write_unlock_nested(s);\n\tbh = sb_bread(s, block_count_new - 1);\n\treiserfs_write_lock_nested(s, depth);\n\tif (!bh) {\n\t\tprintk(\"reiserfs_resize: can\\'t read last block\\n\");\n\t\treturn -EINVAL;\n\t}\n\tbforget(bh);\n\n\t/*\n\t * old disk layout detection; those partitions can be mounted, but\n\t * cannot be resized\n\t */\n\tif (SB_BUFFER_WITH_SB(s)->b_blocknr * SB_BUFFER_WITH_SB(s)->b_size\n\t    != REISERFS_DISK_OFFSET_IN_BYTES) {\n\t\tprintk\n\t\t    (\"reiserfs_resize: unable to resize a reiserfs without distributed bitmap (fs version < 3.5.12)\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\t/* count used bits in last bitmap block */\n\tblock_r = SB_BLOCK_COUNT(s) -\n\t\t\t(reiserfs_bmap_count(s) - 1) * s->s_blocksize * 8;\n\n\t/* count bitmap blocks in new fs */\n\tbmap_nr_new = block_count_new / (s->s_blocksize * 8);\n\tblock_r_new = block_count_new - bmap_nr_new * s->s_blocksize * 8;\n\tif (block_r_new)\n\t\tbmap_nr_new++;\n\telse\n\t\tblock_r_new = s->s_blocksize * 8;\n\n\t/* save old values */\n\tblock_count = SB_BLOCK_COUNT(s);\n\tbmap_nr = reiserfs_bmap_count(s);\n\n\t/* resizing of reiserfs bitmaps (journal and real), if needed */\n\tif (bmap_nr_new > bmap_nr) {\n\t\t/* reallocate journal bitmaps */\n\t\tif (reiserfs_allocate_list_bitmaps(s, jbitmap, bmap_nr_new) < 0) {\n\t\t\tprintk\n\t\t\t    (\"reiserfs_resize: unable to allocate memory for journal bitmaps\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\t/*\n\t\t * the new journal bitmaps are zero filled, now we copy i\n\t\t * the bitmap node pointers from the old journal bitmap\n\t\t * structs, and then transfer the new data structures\n\t\t * into the journal struct.\n\t\t *\n\t\t * using the copy_size var below allows this code to work for\n\t\t * both shrinking and expanding the FS.\n\t\t */\n\t\tcopy_size = bmap_nr_new < bmap_nr ? bmap_nr_new : bmap_nr;\n\t\tcopy_size =\n\t\t    copy_size * sizeof(struct reiserfs_list_bitmap_node *);\n\t\tfor (i = 0; i < JOURNAL_NUM_BITMAPS; i++) {\n\t\t\tstruct reiserfs_bitmap_node **node_tmp;\n\t\t\tjb = SB_JOURNAL(s)->j_list_bitmap + i;\n\t\t\tmemcpy(jbitmap[i].bitmaps, jb->bitmaps, copy_size);\n\n\t\t\t/*\n\t\t\t * just in case vfree schedules on us, copy the new\n\t\t\t * pointer into the journal struct before freeing the\n\t\t\t * old one\n\t\t\t */\n\t\t\tnode_tmp = jb->bitmaps;\n\t\t\tjb->bitmaps = jbitmap[i].bitmaps;\n\t\t\tvfree(node_tmp);\n\t\t}\n\n\t\t/*\n\t\t * allocate additional bitmap blocks, reallocate\n\t\t * array of bitmap block pointers\n\t\t */\n\t\tbitmap =\n\t\t    vzalloc(sizeof(struct reiserfs_bitmap_info) * bmap_nr_new);\n\t\tif (!bitmap) {\n\t\t\t/*\n\t\t\t * Journal bitmaps are still supersized, but the\n\t\t\t * memory isn't leaked, so I guess it's ok\n\t\t\t */\n\t\t\tprintk(\"reiserfs_resize: unable to allocate memory.\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tfor (i = 0; i < bmap_nr; i++)\n\t\t\tbitmap[i] = old_bitmap[i];\n\n\t\t/*\n\t\t * This doesn't go through the journal, but it doesn't have to.\n\t\t * The changes are still atomic: We're synced up when the\n\t\t * journal transaction begins, and the new bitmaps don't\n\t\t * matter if the transaction fails.\n\t\t */\n\t\tfor (i = bmap_nr; i < bmap_nr_new; i++) {\n\t\t\tint depth;\n\t\t\t/*\n\t\t\t * don't use read_bitmap_block since it will cache\n\t\t\t * the uninitialized bitmap\n\t\t\t */\n\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tbh = sb_bread(s, i * s->s_blocksize * 8);\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t\tif (!bh) {\n\t\t\t\tvfree(bitmap);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tmemset(bh->b_data, 0, sb_blocksize(sb));\n\t\t\treiserfs_set_le_bit(0, bh->b_data);\n\t\t\treiserfs_cache_bitmap_metadata(s, bh, bitmap + i);\n\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tsync_dirty_buffer(bh);\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t\t/* update bitmap_info stuff */\n\t\t\tbitmap[i].free_count = sb_blocksize(sb) * 8 - 1;\n\t\t\tbrelse(bh);\n\t\t}\n\t\t/* free old bitmap blocks array */\n\t\tSB_AP_BITMAP(s) = bitmap;\n\t\tvfree(old_bitmap);\n\t}\n\n\t/*\n\t * begin transaction, if there was an error, it's fine. Yes, we have\n\t * incorrect bitmaps now, but none of it is ever going to touch the\n\t * disk anyway.\n\t */\n\terr = journal_begin(&th, s, 10);\n\tif (err)\n\t\treturn err;\n\n\t/* Extend old last bitmap block - new blocks have been made available */\n\tinfo = SB_AP_BITMAP(s) + bmap_nr - 1;\n\tbh = reiserfs_read_bitmap_block(s, bmap_nr - 1);\n\tif (!bh) {\n\t\tint jerr = journal_end(&th);\n\t\tif (jerr)\n\t\t\treturn jerr;\n\t\treturn -EIO;\n\t}\n\n\treiserfs_prepare_for_journal(s, bh, 1);\n\tfor (i = block_r; i < s->s_blocksize * 8; i++)\n\t\treiserfs_clear_le_bit(i, bh->b_data);\n\tinfo->free_count += s->s_blocksize * 8 - block_r;\n\n\tjournal_mark_dirty(&th, bh);\n\tbrelse(bh);\n\n\t/* Correct new last bitmap block - It may not be full */\n\tinfo = SB_AP_BITMAP(s) + bmap_nr_new - 1;\n\tbh = reiserfs_read_bitmap_block(s, bmap_nr_new - 1);\n\tif (!bh) {\n\t\tint jerr = journal_end(&th);\n\t\tif (jerr)\n\t\t\treturn jerr;\n\t\treturn -EIO;\n\t}\n\n\treiserfs_prepare_for_journal(s, bh, 1);\n\tfor (i = block_r_new; i < s->s_blocksize * 8; i++)\n\t\treiserfs_set_le_bit(i, bh->b_data);\n\tjournal_mark_dirty(&th, bh);\n\tbrelse(bh);\n\n\tinfo->free_count -= s->s_blocksize * 8 - block_r_new;\n\t/* update super */\n\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);\n\tfree_blocks = SB_FREE_BLOCKS(s);\n\tPUT_SB_FREE_BLOCKS(s,\n\t\t\t   free_blocks + (block_count_new - block_count -\n\t\t\t\t\t  (bmap_nr_new - bmap_nr)));\n\tPUT_SB_BLOCK_COUNT(s, block_count_new);\n\tPUT_SB_BMAP_NR(s, bmap_would_wrap(bmap_nr_new) ? : bmap_nr_new);\n\n\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(s));\n\n\tSB_JOURNAL(s)->j_must_wait = 1;\n\treturn journal_end(&th);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint reiserfs_resize(struct super_block *s, unsigned long block_count_new)\n{\n\tint err = 0;\n\tstruct reiserfs_super_block *sb;\n\tstruct reiserfs_bitmap_info *bitmap;\n\tstruct reiserfs_bitmap_info *info;\n\tstruct reiserfs_bitmap_info *old_bitmap = SB_AP_BITMAP(s);\n\tstruct buffer_head *bh;\n\tstruct reiserfs_transaction_handle th;\n\tunsigned int bmap_nr_new, bmap_nr;\n\tunsigned int block_r_new, block_r;\n\n\tstruct reiserfs_list_bitmap *jb;\n\tstruct reiserfs_list_bitmap jbitmap[JOURNAL_NUM_BITMAPS];\n\n\tunsigned long int block_count, free_blocks;\n\tint i;\n\tint copy_size;\n\tint depth;\n\n\tsb = SB_DISK_SUPER_BLOCK(s);\n\n\tif (SB_BLOCK_COUNT(s) >= block_count_new) {\n\t\tprintk(\"can\\'t shrink filesystem on-line\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check the device size */\n\tdepth = reiserfs_write_unlock_nested(s);\n\tbh = sb_bread(s, block_count_new - 1);\n\treiserfs_write_lock_nested(s, depth);\n\tif (!bh) {\n\t\tprintk(\"reiserfs_resize: can\\'t read last block\\n\");\n\t\treturn -EINVAL;\n\t}\n\tbforget(bh);\n\n\t/*\n\t * old disk layout detection; those partitions can be mounted, but\n\t * cannot be resized\n\t */\n\tif (SB_BUFFER_WITH_SB(s)->b_blocknr * SB_BUFFER_WITH_SB(s)->b_size\n\t    != REISERFS_DISK_OFFSET_IN_BYTES) {\n\t\tprintk\n\t\t    (\"reiserfs_resize: unable to resize a reiserfs without distributed bitmap (fs version < 3.5.12)\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\t/* count used bits in last bitmap block */\n\tblock_r = SB_BLOCK_COUNT(s) -\n\t\t\t(reiserfs_bmap_count(s) - 1) * s->s_blocksize * 8;\n\n\t/* count bitmap blocks in new fs */\n\tbmap_nr_new = block_count_new / (s->s_blocksize * 8);\n\tblock_r_new = block_count_new - bmap_nr_new * s->s_blocksize * 8;\n\tif (block_r_new)\n\t\tbmap_nr_new++;\n\telse\n\t\tblock_r_new = s->s_blocksize * 8;\n\n\t/* save old values */\n\tblock_count = SB_BLOCK_COUNT(s);\n\tbmap_nr = reiserfs_bmap_count(s);\n\n\t/* resizing of reiserfs bitmaps (journal and real), if needed */\n\tif (bmap_nr_new > bmap_nr) {\n\t\t/* reallocate journal bitmaps */\n\t\tif (reiserfs_allocate_list_bitmaps(s, jbitmap, bmap_nr_new) < 0) {\n\t\t\tprintk\n\t\t\t    (\"reiserfs_resize: unable to allocate memory for journal bitmaps\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\t/*\n\t\t * the new journal bitmaps are zero filled, now we copy i\n\t\t * the bitmap node pointers from the old journal bitmap\n\t\t * structs, and then transfer the new data structures\n\t\t * into the journal struct.\n\t\t *\n\t\t * using the copy_size var below allows this code to work for\n\t\t * both shrinking and expanding the FS.\n\t\t */\n\t\tcopy_size = bmap_nr_new < bmap_nr ? bmap_nr_new : bmap_nr;\n\t\tcopy_size =\n\t\t    copy_size * sizeof(struct reiserfs_list_bitmap_node *);\n\t\tfor (i = 0; i < JOURNAL_NUM_BITMAPS; i++) {\n\t\t\tstruct reiserfs_bitmap_node **node_tmp;\n\t\t\tjb = SB_JOURNAL(s)->j_list_bitmap + i;\n\t\t\tmemcpy(jbitmap[i].bitmaps, jb->bitmaps, copy_size);\n\n\t\t\t/*\n\t\t\t * just in case vfree schedules on us, copy the new\n\t\t\t * pointer into the journal struct before freeing the\n\t\t\t * old one\n\t\t\t */\n\t\t\tnode_tmp = jb->bitmaps;\n\t\t\tjb->bitmaps = jbitmap[i].bitmaps;\n\t\t\tvfree(node_tmp);\n\t\t}\n\n\t\t/*\n\t\t * allocate additional bitmap blocks, reallocate\n\t\t * array of bitmap block pointers\n\t\t */\n\t\tbitmap =\n\t\t    vzalloc(sizeof(struct reiserfs_bitmap_info) * bmap_nr_new);\n\t\tif (!bitmap) {\n\t\t\t/*\n\t\t\t * Journal bitmaps are still supersized, but the\n\t\t\t * memory isn't leaked, so I guess it's ok\n\t\t\t */\n\t\t\tprintk(\"reiserfs_resize: unable to allocate memory.\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tfor (i = 0; i < bmap_nr; i++)\n\t\t\tbitmap[i] = old_bitmap[i];\n\n\t\t/*\n\t\t * This doesn't go through the journal, but it doesn't have to.\n\t\t * The changes are still atomic: We're synced up when the\n\t\t * journal transaction begins, and the new bitmaps don't\n\t\t * matter if the transaction fails.\n\t\t */\n\t\tfor (i = bmap_nr; i < bmap_nr_new; i++) {\n\t\t\tint depth;\n\t\t\t/*\n\t\t\t * don't use read_bitmap_block since it will cache\n\t\t\t * the uninitialized bitmap\n\t\t\t */\n\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tbh = sb_bread(s, i * s->s_blocksize * 8);\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t\tif (!bh) {\n\t\t\t\tvfree(bitmap);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tmemset(bh->b_data, 0, sb_blocksize(sb));\n\t\t\treiserfs_set_le_bit(0, bh->b_data);\n\t\t\treiserfs_cache_bitmap_metadata(s, bh, bitmap + i);\n\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tsync_dirty_buffer(bh);\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t\t/* update bitmap_info stuff */\n\t\t\tbitmap[i].free_count = sb_blocksize(sb) * 8 - 1;\n\t\t\tbrelse(bh);\n\t\t}\n\t\t/* free old bitmap blocks array */\n\t\tSB_AP_BITMAP(s) = bitmap;\n\t\tvfree(old_bitmap);\n\t}\n\n\t/*\n\t * begin transaction, if there was an error, it's fine. Yes, we have\n\t * incorrect bitmaps now, but none of it is ever going to touch the\n\t * disk anyway.\n\t */\n\terr = journal_begin(&th, s, 10);\n\tif (err)\n\t\treturn err;\n\n\t/* Extend old last bitmap block - new blocks have been made available */\n\tinfo = SB_AP_BITMAP(s) + bmap_nr - 1;\n\tbh = reiserfs_read_bitmap_block(s, bmap_nr - 1);\n\tif (!bh) {\n\t\tint jerr = journal_end(&th);\n\t\tif (jerr)\n\t\t\treturn jerr;\n\t\treturn -EIO;\n\t}\n\n\treiserfs_prepare_for_journal(s, bh, 1);\n\tfor (i = block_r; i < s->s_blocksize * 8; i++)\n\t\treiserfs_clear_le_bit(i, bh->b_data);\n\tinfo->free_count += s->s_blocksize * 8 - block_r;\n\n\tjournal_mark_dirty(&th, bh);\n\tbrelse(bh);\n\n\t/* Correct new last bitmap block - It may not be full */\n\tinfo = SB_AP_BITMAP(s) + bmap_nr_new - 1;\n\tbh = reiserfs_read_bitmap_block(s, bmap_nr_new - 1);\n\tif (!bh) {\n\t\tint jerr = journal_end(&th);\n\t\tif (jerr)\n\t\t\treturn jerr;\n\t\treturn -EIO;\n\t}\n\n\treiserfs_prepare_for_journal(s, bh, 1);\n\tfor (i = block_r_new; i < s->s_blocksize * 8; i++)\n\t\treiserfs_set_le_bit(i, bh->b_data);\n\tjournal_mark_dirty(&th, bh);\n\tbrelse(bh);\n\n\tinfo->free_count -= s->s_blocksize * 8 - block_r_new;\n\t/* update super */\n\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);\n\tfree_blocks = SB_FREE_BLOCKS(s);\n\tPUT_SB_FREE_BLOCKS(s,\n\t\t\t   free_blocks + (block_count_new - block_count -\n\t\t\t\t\t  (bmap_nr_new - bmap_nr)));\n\tPUT_SB_BLOCK_COUNT(s, block_count_new);\n\tPUT_SB_BMAP_NR(s, bmap_would_wrap(bmap_nr_new) ? : bmap_nr_new);\n\n\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(s));\n\n\tSB_JOURNAL(s)->j_must_wait = 1;\n\treturn journal_end(&th);\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_attrs",
          "args": [
            "s"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "handle_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "1347-1365",
          "snippet": "static void handle_attrs(struct super_block *s)\n{\n\tstruct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(s);\n\n\tif (reiserfs_attrs(s)) {\n\t\tif (old_format_only(s)) {\n\t\t\treiserfs_warning(s, \"super-6517\", \"cannot support \"\n\t\t\t\t\t \"attributes on 3.5.x disk format\");\n\t\t\tREISERFS_SB(s)->s_mount_opt &= ~(1 << REISERFS_ATTRS);\n\t\t\treturn;\n\t\t}\n\t\tif (!(le32_to_cpu(rs->s_flags) & reiserfs_attrs_cleared)) {\n\t\t\treiserfs_warning(s, \"super-6518\", \"cannot support \"\n\t\t\t\t\t \"attributes until flag is set in \"\n\t\t\t\t\t \"super-block\");\n\t\t\tREISERFS_SB(s)->s_mount_opt &= ~(1 << REISERFS_ATTRS);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void handle_attrs(struct super_block *s)\n{\n\tstruct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(s);\n\n\tif (reiserfs_attrs(s)) {\n\t\tif (old_format_only(s)) {\n\t\t\treiserfs_warning(s, \"super-6517\", \"cannot support \"\n\t\t\t\t\t \"attributes on 3.5.x disk format\");\n\t\t\tREISERFS_SB(s)->s_mount_opt &= ~(1 << REISERFS_ATTRS);\n\t\t\treturn;\n\t\t}\n\t\tif (!(le32_to_cpu(rs->s_flags) & reiserfs_attrs_cleared)) {\n\t\t\treiserfs_warning(s, \"super-6518\", \"cannot support \"\n\t\t\t\t\t \"attributes until flag is set in \"\n\t\t\t\t\t \"super-block\");\n\t\t\tREISERFS_SB(s)->s_mount_opt &= ~(1 << REISERFS_ATTRS);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_quota_files",
          "args": [
            "s",
            "qf_names",
            "&qfmt"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "handle_quota_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "1368-1380",
          "snippet": "static void handle_quota_files(struct super_block *s, char **qf_names,\n\t\t\t       unsigned int *qfmt)\n{\n\tint i;\n\n\tfor (i = 0; i < REISERFS_MAXQUOTAS; i++) {\n\t\tif (qf_names[i] != REISERFS_SB(s)->s_qf_names[i])\n\t\t\tkfree(REISERFS_SB(s)->s_qf_names[i]);\n\t\tREISERFS_SB(s)->s_qf_names[i] = qf_names[i];\n\t}\n\tif (*qfmt)\n\t\tREISERFS_SB(s)->s_jquota_fmt = *qfmt;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void handle_quota_files(struct super_block *s, char **qf_names,\n\t\t\t       unsigned int *qfmt)\n{\n\tint i;\n\n\tfor (i = 0; i < REISERFS_MAXQUOTAS; i++) {\n\t\tif (qf_names[i] != REISERFS_SB(s)->s_qf_names[i])\n\t\t\tkfree(REISERFS_SB(s)->s_qf_names[i]);\n\t\tREISERFS_SB(s)->s_qf_names[i] = qf_names[i];\n\t}\n\tif (*qfmt)\n\t\tREISERFS_SB(s)->s_jquota_fmt = *qfmt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "qf_names[i]"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_parse_options",
          "args": [
            "s",
            "arg",
            "&mount_options",
            "&blocks",
            "NULL",
            "&commit_max_age",
            "qf_names",
            "&qfmt"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "1063-1299",
          "snippet": "static int reiserfs_parse_options(struct super_block *s,\n\n\t\t\t\t  /* string given via mount's -o */\n\t\t\t\t  char *options,\n\n\t\t\t\t  /*\n\t\t\t\t   * after the parsing phase, contains the\n\t\t\t\t   * collection of bitflags defining what\n\t\t\t\t   * mount options were selected.\n\t\t\t\t   */\n\t\t\t\t  unsigned long *mount_options,\n\n\t\t\t\t  /* strtol-ed from NNN of resize=NNN */\n\t\t\t\t  unsigned long *blocks,\n\t\t\t\t  char **jdev_name,\n\t\t\t\t  unsigned int *commit_max_age,\n\t\t\t\t  char **qf_names,\n\t\t\t\t  unsigned int *qfmt)\n{\n\tint c;\n\tchar *arg = NULL;\n\tchar *pos;\n\topt_desc_t opts[] = {\n\t\t/*\n\t\t * Compatibility stuff, so that -o notail for old\n\t\t * setups still work\n\t\t */\n\t\t{\"tails\",.arg_required = 't',.values = tails},\n\t\t{\"notail\",.clrmask =\n\t\t (1 << REISERFS_LARGETAIL) | (1 << REISERFS_SMALLTAIL)},\n\t\t{\"conv\",.setmask = 1 << REISERFS_CONVERT},\n\t\t{\"attrs\",.setmask = 1 << REISERFS_ATTRS},\n\t\t{\"noattrs\",.clrmask = 1 << REISERFS_ATTRS},\n\t\t{\"expose_privroot\", .setmask = 1 << REISERFS_EXPOSE_PRIVROOT},\n#ifdef CONFIG_REISERFS_FS_XATTR\n\t\t{\"user_xattr\",.setmask = 1 << REISERFS_XATTRS_USER},\n\t\t{\"nouser_xattr\",.clrmask = 1 << REISERFS_XATTRS_USER},\n#else\n\t\t{\"user_xattr\",.setmask = 1 << REISERFS_UNSUPPORTED_OPT},\n\t\t{\"nouser_xattr\",.clrmask = 1 << REISERFS_UNSUPPORTED_OPT},\n#endif\n#ifdef CONFIG_REISERFS_FS_POSIX_ACL\n\t\t{\"acl\",.setmask = 1 << REISERFS_POSIXACL},\n\t\t{\"noacl\",.clrmask = 1 << REISERFS_POSIXACL},\n#else\n\t\t{\"acl\",.setmask = 1 << REISERFS_UNSUPPORTED_OPT},\n\t\t{\"noacl\",.clrmask = 1 << REISERFS_UNSUPPORTED_OPT},\n#endif\n\t\t{.option_name = \"nolog\"},\n\t\t{\"replayonly\",.setmask = 1 << REPLAYONLY},\n\t\t{\"block-allocator\",.arg_required = 'a',.values = balloc},\n\t\t{\"data\",.arg_required = 'd',.values = logging_mode},\n\t\t{\"barrier\",.arg_required = 'b',.values = barrier_mode},\n\t\t{\"resize\",.arg_required = 'r',.values = NULL},\n\t\t{\"jdev\",.arg_required = 'j',.values = NULL},\n\t\t{\"nolargeio\",.arg_required = 'w',.values = NULL},\n\t\t{\"commit\",.arg_required = 'c',.values = NULL},\n\t\t{\"usrquota\",.setmask = 1 << REISERFS_USRQUOTA},\n\t\t{\"grpquota\",.setmask = 1 << REISERFS_GRPQUOTA},\n\t\t{\"noquota\",.clrmask = 1 << REISERFS_USRQUOTA | 1 << REISERFS_GRPQUOTA},\n\t\t{\"errors\",.arg_required = 'e',.values = error_actions},\n\t\t{\"usrjquota\",.arg_required =\n\t\t 'u' | (1 << REISERFS_OPT_ALLOWEMPTY),.values = NULL},\n\t\t{\"grpjquota\",.arg_required =\n\t\t 'g' | (1 << REISERFS_OPT_ALLOWEMPTY),.values = NULL},\n\t\t{\"jqfmt\",.arg_required = 'f',.values = NULL},\n\t\t{.option_name = NULL}\n\t};\n\n\t*blocks = 0;\n\tif (!options || !*options)\n\t\t/*\n\t\t * use default configuration: create tails, journaling on, no\n\t\t * conversion to newest format\n\t\t */\n\t\treturn 1;\n\n\tfor (pos = options; pos;) {\n\t\tc = reiserfs_getopt(s, &pos, opts, &arg, mount_options);\n\t\tif (c == -1)\n\t\t\t/* wrong option is given */\n\t\t\treturn 0;\n\n\t\tif (c == 'r') {\n\t\t\tchar *p;\n\n\t\t\tp = NULL;\n\t\t\t/* \"resize=NNN\" or \"resize=auto\" */\n\n\t\t\tif (!strcmp(arg, \"auto\")) {\n\t\t\t\t/* From JFS code, to auto-get the size. */\n\t\t\t\t*blocks =\n\t\t\t\t    s->s_bdev->bd_inode->i_size >> s->\n\t\t\t\t    s_blocksize_bits;\n\t\t\t} else {\n\t\t\t\t*blocks = simple_strtoul(arg, &p, 0);\n\t\t\t\tif (*p != '\\0') {\n\t\t\t\t\t/* NNN does not look like a number */\n\t\t\t\t\treiserfs_warning(s, \"super-6507\",\n\t\t\t\t\t\t\t \"bad value %s for \"\n\t\t\t\t\t\t\t \"-oresize\\n\", arg);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (c == 'c') {\n\t\t\tchar *p = NULL;\n\t\t\tunsigned long val = simple_strtoul(arg, &p, 0);\n\t\t\t/* commit=NNN (time in seconds) */\n\t\t\tif (*p != '\\0' || val >= (unsigned int)-1) {\n\t\t\t\treiserfs_warning(s, \"super-6508\",\n\t\t\t\t\t\t \"bad value %s for -ocommit\\n\",\n\t\t\t\t\t\t arg);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t*commit_max_age = (unsigned int)val;\n\t\t}\n\n\t\tif (c == 'w') {\n\t\t\treiserfs_warning(s, \"super-6509\", \"nolargeio option \"\n\t\t\t\t\t \"is no longer supported\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (c == 'j') {\n\t\t\tif (arg && *arg && jdev_name) {\n\t\t\t\t/* Hm, already assigned? */\n\t\t\t\tif (*jdev_name) {\n\t\t\t\t\treiserfs_warning(s, \"super-6510\",\n\t\t\t\t\t\t\t \"journal device was \"\n\t\t\t\t\t\t\t \"already specified to \"\n\t\t\t\t\t\t\t \"be %s\", *jdev_name);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t*jdev_name = arg;\n\t\t\t}\n\t\t}\n#ifdef CONFIG_QUOTA\n\t\tif (c == 'u' || c == 'g') {\n\t\t\tint qtype = c == 'u' ? USRQUOTA : GRPQUOTA;\n\n\t\t\tif (sb_any_quota_loaded(s) &&\n\t\t\t    (!*arg != !REISERFS_SB(s)->s_qf_names[qtype])) {\n\t\t\t\treiserfs_warning(s, \"super-6511\",\n\t\t\t\t\t\t \"cannot change journaled \"\n\t\t\t\t\t\t \"quota options when quota \"\n\t\t\t\t\t\t \"turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (*arg) {\t/* Some filename specified? */\n\t\t\t\tif (REISERFS_SB(s)->s_qf_names[qtype]\n\t\t\t\t    && strcmp(REISERFS_SB(s)->s_qf_names[qtype],\n\t\t\t\t\t      arg)) {\n\t\t\t\t\treiserfs_warning(s, \"super-6512\",\n\t\t\t\t\t\t\t \"%s quota file \"\n\t\t\t\t\t\t\t \"already specified.\",\n\t\t\t\t\t\t\t QTYPE2NAME(qtype));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (strchr(arg, '/')) {\n\t\t\t\t\treiserfs_warning(s, \"super-6513\",\n\t\t\t\t\t\t\t \"quotafile must be \"\n\t\t\t\t\t\t\t \"on filesystem root.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tqf_names[qtype] = kstrdup(arg, GFP_KERNEL);\n\t\t\t\tif (!qf_names[qtype]) {\n\t\t\t\t\treiserfs_warning(s, \"reiserfs-2502\",\n\t\t\t\t\t\t\t \"not enough memory \"\n\t\t\t\t\t\t\t \"for storing \"\n\t\t\t\t\t\t\t \"quotafile name.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (qtype == USRQUOTA)\n\t\t\t\t\t*mount_options |= 1 << REISERFS_USRQUOTA;\n\t\t\t\telse\n\t\t\t\t\t*mount_options |= 1 << REISERFS_GRPQUOTA;\n\t\t\t} else {\n\t\t\t\tif (qf_names[qtype] !=\n\t\t\t\t    REISERFS_SB(s)->s_qf_names[qtype])\n\t\t\t\t\tkfree(qf_names[qtype]);\n\t\t\t\tqf_names[qtype] = NULL;\n\t\t\t\tif (qtype == USRQUOTA)\n\t\t\t\t\t*mount_options &= ~(1 << REISERFS_USRQUOTA);\n\t\t\t\telse\n\t\t\t\t\t*mount_options &= ~(1 << REISERFS_GRPQUOTA);\n\t\t\t}\n\t\t}\n\t\tif (c == 'f') {\n\t\t\tif (!strcmp(arg, \"vfsold\"))\n\t\t\t\t*qfmt = QFMT_VFS_OLD;\n\t\t\telse if (!strcmp(arg, \"vfsv0\"))\n\t\t\t\t*qfmt = QFMT_VFS_V0;\n\t\t\telse {\n\t\t\t\treiserfs_warning(s, \"super-6514\",\n\t\t\t\t\t\t \"unknown quota format \"\n\t\t\t\t\t\t \"specified.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (sb_any_quota_loaded(s) &&\n\t\t\t    *qfmt != REISERFS_SB(s)->s_jquota_fmt) {\n\t\t\t\treiserfs_warning(s, \"super-6515\",\n\t\t\t\t\t\t \"cannot change journaled \"\n\t\t\t\t\t\t \"quota options when quota \"\n\t\t\t\t\t\t \"turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n#else\n\t\tif (c == 'u' || c == 'g' || c == 'f') {\n\t\t\treiserfs_warning(s, \"reiserfs-2503\", \"journaled \"\n\t\t\t\t\t \"quota options not supported.\");\n\t\t\treturn 0;\n\t\t}\n#endif\n\t}\n\n#ifdef CONFIG_QUOTA\n\tif (!REISERFS_SB(s)->s_jquota_fmt && !*qfmt\n\t    && (qf_names[USRQUOTA] || qf_names[GRPQUOTA])) {\n\t\treiserfs_warning(s, \"super-6515\",\n\t\t\t\t \"journaled quota format not specified.\");\n\t\treturn 0;\n\t}\n\tif ((!(*mount_options & (1 << REISERFS_USRQUOTA)) &&\n\t       sb_has_quota_loaded(s, USRQUOTA)) ||\n\t    (!(*mount_options & (1 << REISERFS_GRPQUOTA)) &&\n\t       sb_has_quota_loaded(s, GRPQUOTA))) {\n\t\treiserfs_warning(s, \"super-6516\", \"quota options must \"\n\t\t\t\t \"be present when quota is turned on.\");\n\t\treturn 0;\n\t}\n#endif\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define REISERFS_OPT_ALLOWEMPTY 31"
          ],
          "globals_used": [
            "static int reiserfs_remount(struct super_block *s, int *flags, char *data);",
            "static const arg_desc_t logging_mode[] = {\n\t{\"ordered\", 1 << REISERFS_DATA_ORDERED,\n\t (1 << REISERFS_DATA_LOG | 1 << REISERFS_DATA_WRITEBACK)},\n\t{\"journal\", 1 << REISERFS_DATA_LOG,\n\t (1 << REISERFS_DATA_ORDERED | 1 << REISERFS_DATA_WRITEBACK)},\n\t{\"writeback\", 1 << REISERFS_DATA_WRITEBACK,\n\t (1 << REISERFS_DATA_ORDERED | 1 << REISERFS_DATA_LOG)},\n\t{.value = NULL}\n};",
            "static const arg_desc_t barrier_mode[] = {\n\t{\"none\", 1 << REISERFS_BARRIER_NONE, 1 << REISERFS_BARRIER_FLUSH},\n\t{\"flush\", 1 << REISERFS_BARRIER_FLUSH, 1 << REISERFS_BARRIER_NONE},\n\t{.value = NULL}\n};",
            "static const arg_desc_t balloc[] = {\n\t{\"noborder\", 1 << REISERFS_NO_BORDER, 0},\n\t{\"border\", 0, 1 << REISERFS_NO_BORDER},\n\t{\"no_unhashed_relocation\", 1 << REISERFS_NO_UNHASHED_RELOCATION, 0},\n\t{\"hashed_relocation\", 1 << REISERFS_HASHED_RELOCATION, 0},\n\t{\"test4\", 1 << REISERFS_TEST4, 0},\n\t{\"notest4\", 0, 1 << REISERFS_TEST4},\n\t{NULL, 0, 0}\n};",
            "static const arg_desc_t tails[] = {\n\t{\"on\", 1 << REISERFS_LARGETAIL, 1 << REISERFS_SMALLTAIL},\n\t{\"off\", 0, (1 << REISERFS_LARGETAIL) | (1 << REISERFS_SMALLTAIL)},\n\t{\"small\", 1 << REISERFS_SMALLTAIL, 1 << REISERFS_LARGETAIL},\n\t{NULL, 0, 0}\n};",
            "static const arg_desc_t error_actions[] = {\n\t{\"panic\", 1 << REISERFS_ERROR_PANIC,\n\t (1 << REISERFS_ERROR_RO | 1 << REISERFS_ERROR_CONTINUE)},\n\t{\"ro-remount\", 1 << REISERFS_ERROR_RO,\n\t (1 << REISERFS_ERROR_PANIC | 1 << REISERFS_ERROR_CONTINUE)},\n#ifdef REISERFS_JOURNAL_ERROR_ALLOWS_NO_LOG\n\t{\"continue\", 1 << REISERFS_ERROR_CONTINUE,\n\t (1 << REISERFS_ERROR_PANIC | 1 << REISERFS_ERROR_RO)},\n#endif\n\t{NULL, 0, 0},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define REISERFS_OPT_ALLOWEMPTY 31\n\nstatic int reiserfs_remount(struct super_block *s, int *flags, char *data);\nstatic const arg_desc_t logging_mode[] = {\n\t{\"ordered\", 1 << REISERFS_DATA_ORDERED,\n\t (1 << REISERFS_DATA_LOG | 1 << REISERFS_DATA_WRITEBACK)},\n\t{\"journal\", 1 << REISERFS_DATA_LOG,\n\t (1 << REISERFS_DATA_ORDERED | 1 << REISERFS_DATA_WRITEBACK)},\n\t{\"writeback\", 1 << REISERFS_DATA_WRITEBACK,\n\t (1 << REISERFS_DATA_ORDERED | 1 << REISERFS_DATA_LOG)},\n\t{.value = NULL}\n};\nstatic const arg_desc_t barrier_mode[] = {\n\t{\"none\", 1 << REISERFS_BARRIER_NONE, 1 << REISERFS_BARRIER_FLUSH},\n\t{\"flush\", 1 << REISERFS_BARRIER_FLUSH, 1 << REISERFS_BARRIER_NONE},\n\t{.value = NULL}\n};\nstatic const arg_desc_t balloc[] = {\n\t{\"noborder\", 1 << REISERFS_NO_BORDER, 0},\n\t{\"border\", 0, 1 << REISERFS_NO_BORDER},\n\t{\"no_unhashed_relocation\", 1 << REISERFS_NO_UNHASHED_RELOCATION, 0},\n\t{\"hashed_relocation\", 1 << REISERFS_HASHED_RELOCATION, 0},\n\t{\"test4\", 1 << REISERFS_TEST4, 0},\n\t{\"notest4\", 0, 1 << REISERFS_TEST4},\n\t{NULL, 0, 0}\n};\nstatic const arg_desc_t tails[] = {\n\t{\"on\", 1 << REISERFS_LARGETAIL, 1 << REISERFS_SMALLTAIL},\n\t{\"off\", 0, (1 << REISERFS_LARGETAIL) | (1 << REISERFS_SMALLTAIL)},\n\t{\"small\", 1 << REISERFS_SMALLTAIL, 1 << REISERFS_LARGETAIL},\n\t{NULL, 0, 0}\n};\nstatic const arg_desc_t error_actions[] = {\n\t{\"panic\", 1 << REISERFS_ERROR_PANIC,\n\t (1 << REISERFS_ERROR_RO | 1 << REISERFS_ERROR_CONTINUE)},\n\t{\"ro-remount\", 1 << REISERFS_ERROR_RO,\n\t (1 << REISERFS_ERROR_PANIC | 1 << REISERFS_ERROR_CONTINUE)},\n#ifdef REISERFS_JOURNAL_ERROR_ALLOWS_NO_LOG\n\t{\"continue\", 1 << REISERFS_ERROR_CONTINUE,\n\t (1 << REISERFS_ERROR_PANIC | 1 << REISERFS_ERROR_RO)},\n#endif\n\t{NULL, 0, 0},\n};\n\nstatic int reiserfs_parse_options(struct super_block *s,\n\n\t\t\t\t  /* string given via mount's -o */\n\t\t\t\t  char *options,\n\n\t\t\t\t  /*\n\t\t\t\t   * after the parsing phase, contains the\n\t\t\t\t   * collection of bitflags defining what\n\t\t\t\t   * mount options were selected.\n\t\t\t\t   */\n\t\t\t\t  unsigned long *mount_options,\n\n\t\t\t\t  /* strtol-ed from NNN of resize=NNN */\n\t\t\t\t  unsigned long *blocks,\n\t\t\t\t  char **jdev_name,\n\t\t\t\t  unsigned int *commit_max_age,\n\t\t\t\t  char **qf_names,\n\t\t\t\t  unsigned int *qfmt)\n{\n\tint c;\n\tchar *arg = NULL;\n\tchar *pos;\n\topt_desc_t opts[] = {\n\t\t/*\n\t\t * Compatibility stuff, so that -o notail for old\n\t\t * setups still work\n\t\t */\n\t\t{\"tails\",.arg_required = 't',.values = tails},\n\t\t{\"notail\",.clrmask =\n\t\t (1 << REISERFS_LARGETAIL) | (1 << REISERFS_SMALLTAIL)},\n\t\t{\"conv\",.setmask = 1 << REISERFS_CONVERT},\n\t\t{\"attrs\",.setmask = 1 << REISERFS_ATTRS},\n\t\t{\"noattrs\",.clrmask = 1 << REISERFS_ATTRS},\n\t\t{\"expose_privroot\", .setmask = 1 << REISERFS_EXPOSE_PRIVROOT},\n#ifdef CONFIG_REISERFS_FS_XATTR\n\t\t{\"user_xattr\",.setmask = 1 << REISERFS_XATTRS_USER},\n\t\t{\"nouser_xattr\",.clrmask = 1 << REISERFS_XATTRS_USER},\n#else\n\t\t{\"user_xattr\",.setmask = 1 << REISERFS_UNSUPPORTED_OPT},\n\t\t{\"nouser_xattr\",.clrmask = 1 << REISERFS_UNSUPPORTED_OPT},\n#endif\n#ifdef CONFIG_REISERFS_FS_POSIX_ACL\n\t\t{\"acl\",.setmask = 1 << REISERFS_POSIXACL},\n\t\t{\"noacl\",.clrmask = 1 << REISERFS_POSIXACL},\n#else\n\t\t{\"acl\",.setmask = 1 << REISERFS_UNSUPPORTED_OPT},\n\t\t{\"noacl\",.clrmask = 1 << REISERFS_UNSUPPORTED_OPT},\n#endif\n\t\t{.option_name = \"nolog\"},\n\t\t{\"replayonly\",.setmask = 1 << REPLAYONLY},\n\t\t{\"block-allocator\",.arg_required = 'a',.values = balloc},\n\t\t{\"data\",.arg_required = 'd',.values = logging_mode},\n\t\t{\"barrier\",.arg_required = 'b',.values = barrier_mode},\n\t\t{\"resize\",.arg_required = 'r',.values = NULL},\n\t\t{\"jdev\",.arg_required = 'j',.values = NULL},\n\t\t{\"nolargeio\",.arg_required = 'w',.values = NULL},\n\t\t{\"commit\",.arg_required = 'c',.values = NULL},\n\t\t{\"usrquota\",.setmask = 1 << REISERFS_USRQUOTA},\n\t\t{\"grpquota\",.setmask = 1 << REISERFS_GRPQUOTA},\n\t\t{\"noquota\",.clrmask = 1 << REISERFS_USRQUOTA | 1 << REISERFS_GRPQUOTA},\n\t\t{\"errors\",.arg_required = 'e',.values = error_actions},\n\t\t{\"usrjquota\",.arg_required =\n\t\t 'u' | (1 << REISERFS_OPT_ALLOWEMPTY),.values = NULL},\n\t\t{\"grpjquota\",.arg_required =\n\t\t 'g' | (1 << REISERFS_OPT_ALLOWEMPTY),.values = NULL},\n\t\t{\"jqfmt\",.arg_required = 'f',.values = NULL},\n\t\t{.option_name = NULL}\n\t};\n\n\t*blocks = 0;\n\tif (!options || !*options)\n\t\t/*\n\t\t * use default configuration: create tails, journaling on, no\n\t\t * conversion to newest format\n\t\t */\n\t\treturn 1;\n\n\tfor (pos = options; pos;) {\n\t\tc = reiserfs_getopt(s, &pos, opts, &arg, mount_options);\n\t\tif (c == -1)\n\t\t\t/* wrong option is given */\n\t\t\treturn 0;\n\n\t\tif (c == 'r') {\n\t\t\tchar *p;\n\n\t\t\tp = NULL;\n\t\t\t/* \"resize=NNN\" or \"resize=auto\" */\n\n\t\t\tif (!strcmp(arg, \"auto\")) {\n\t\t\t\t/* From JFS code, to auto-get the size. */\n\t\t\t\t*blocks =\n\t\t\t\t    s->s_bdev->bd_inode->i_size >> s->\n\t\t\t\t    s_blocksize_bits;\n\t\t\t} else {\n\t\t\t\t*blocks = simple_strtoul(arg, &p, 0);\n\t\t\t\tif (*p != '\\0') {\n\t\t\t\t\t/* NNN does not look like a number */\n\t\t\t\t\treiserfs_warning(s, \"super-6507\",\n\t\t\t\t\t\t\t \"bad value %s for \"\n\t\t\t\t\t\t\t \"-oresize\\n\", arg);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (c == 'c') {\n\t\t\tchar *p = NULL;\n\t\t\tunsigned long val = simple_strtoul(arg, &p, 0);\n\t\t\t/* commit=NNN (time in seconds) */\n\t\t\tif (*p != '\\0' || val >= (unsigned int)-1) {\n\t\t\t\treiserfs_warning(s, \"super-6508\",\n\t\t\t\t\t\t \"bad value %s for -ocommit\\n\",\n\t\t\t\t\t\t arg);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t*commit_max_age = (unsigned int)val;\n\t\t}\n\n\t\tif (c == 'w') {\n\t\t\treiserfs_warning(s, \"super-6509\", \"nolargeio option \"\n\t\t\t\t\t \"is no longer supported\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (c == 'j') {\n\t\t\tif (arg && *arg && jdev_name) {\n\t\t\t\t/* Hm, already assigned? */\n\t\t\t\tif (*jdev_name) {\n\t\t\t\t\treiserfs_warning(s, \"super-6510\",\n\t\t\t\t\t\t\t \"journal device was \"\n\t\t\t\t\t\t\t \"already specified to \"\n\t\t\t\t\t\t\t \"be %s\", *jdev_name);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t*jdev_name = arg;\n\t\t\t}\n\t\t}\n#ifdef CONFIG_QUOTA\n\t\tif (c == 'u' || c == 'g') {\n\t\t\tint qtype = c == 'u' ? USRQUOTA : GRPQUOTA;\n\n\t\t\tif (sb_any_quota_loaded(s) &&\n\t\t\t    (!*arg != !REISERFS_SB(s)->s_qf_names[qtype])) {\n\t\t\t\treiserfs_warning(s, \"super-6511\",\n\t\t\t\t\t\t \"cannot change journaled \"\n\t\t\t\t\t\t \"quota options when quota \"\n\t\t\t\t\t\t \"turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (*arg) {\t/* Some filename specified? */\n\t\t\t\tif (REISERFS_SB(s)->s_qf_names[qtype]\n\t\t\t\t    && strcmp(REISERFS_SB(s)->s_qf_names[qtype],\n\t\t\t\t\t      arg)) {\n\t\t\t\t\treiserfs_warning(s, \"super-6512\",\n\t\t\t\t\t\t\t \"%s quota file \"\n\t\t\t\t\t\t\t \"already specified.\",\n\t\t\t\t\t\t\t QTYPE2NAME(qtype));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (strchr(arg, '/')) {\n\t\t\t\t\treiserfs_warning(s, \"super-6513\",\n\t\t\t\t\t\t\t \"quotafile must be \"\n\t\t\t\t\t\t\t \"on filesystem root.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tqf_names[qtype] = kstrdup(arg, GFP_KERNEL);\n\t\t\t\tif (!qf_names[qtype]) {\n\t\t\t\t\treiserfs_warning(s, \"reiserfs-2502\",\n\t\t\t\t\t\t\t \"not enough memory \"\n\t\t\t\t\t\t\t \"for storing \"\n\t\t\t\t\t\t\t \"quotafile name.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (qtype == USRQUOTA)\n\t\t\t\t\t*mount_options |= 1 << REISERFS_USRQUOTA;\n\t\t\t\telse\n\t\t\t\t\t*mount_options |= 1 << REISERFS_GRPQUOTA;\n\t\t\t} else {\n\t\t\t\tif (qf_names[qtype] !=\n\t\t\t\t    REISERFS_SB(s)->s_qf_names[qtype])\n\t\t\t\t\tkfree(qf_names[qtype]);\n\t\t\t\tqf_names[qtype] = NULL;\n\t\t\t\tif (qtype == USRQUOTA)\n\t\t\t\t\t*mount_options &= ~(1 << REISERFS_USRQUOTA);\n\t\t\t\telse\n\t\t\t\t\t*mount_options &= ~(1 << REISERFS_GRPQUOTA);\n\t\t\t}\n\t\t}\n\t\tif (c == 'f') {\n\t\t\tif (!strcmp(arg, \"vfsold\"))\n\t\t\t\t*qfmt = QFMT_VFS_OLD;\n\t\t\telse if (!strcmp(arg, \"vfsv0\"))\n\t\t\t\t*qfmt = QFMT_VFS_V0;\n\t\t\telse {\n\t\t\t\treiserfs_warning(s, \"super-6514\",\n\t\t\t\t\t\t \"unknown quota format \"\n\t\t\t\t\t\t \"specified.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (sb_any_quota_loaded(s) &&\n\t\t\t    *qfmt != REISERFS_SB(s)->s_jquota_fmt) {\n\t\t\t\treiserfs_warning(s, \"super-6515\",\n\t\t\t\t\t\t \"cannot change journaled \"\n\t\t\t\t\t\t \"quota options when quota \"\n\t\t\t\t\t\t \"turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n#else\n\t\tif (c == 'u' || c == 'g' || c == 'f') {\n\t\t\treiserfs_warning(s, \"reiserfs-2503\", \"journaled \"\n\t\t\t\t\t \"quota options not supported.\");\n\t\t\treturn 0;\n\t\t}\n#endif\n\t}\n\n#ifdef CONFIG_QUOTA\n\tif (!REISERFS_SB(s)->s_jquota_fmt && !*qfmt\n\t    && (qf_names[USRQUOTA] || qf_names[GRPQUOTA])) {\n\t\treiserfs_warning(s, \"super-6515\",\n\t\t\t\t \"journaled quota format not specified.\");\n\t\treturn 0;\n\t}\n\tif ((!(*mount_options & (1 << REISERFS_USRQUOTA)) &&\n\t       sb_has_quota_loaded(s, USRQUOTA)) ||\n\t    (!(*mount_options & (1 << REISERFS_GRPQUOTA)) &&\n\t       sb_has_quota_loaded(s, GRPQUOTA))) {\n\t\treiserfs_warning(s, \"super-6516\", \"quota options must \"\n\t\t\t\t \"be present when quota is turned on.\");\n\t\treturn 0;\n\t}\n#endif\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_DISK_SUPER_BLOCK",
          "args": [
            "s"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "qf_names",
            "REISERFS_SB(s)->s_qf_names",
            "sizeof(qf_names)"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "s"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "arg",
            "GFP_KERNEL"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "s"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int reiserfs_remount(struct super_block *s, int *mount_flags, char *arg)\n{\n\tstruct reiserfs_super_block *rs;\n\tstruct reiserfs_transaction_handle th;\n\tunsigned long blocks;\n\tunsigned long mount_options = REISERFS_SB(s)->s_mount_opt;\n\tunsigned long safe_mask = 0;\n\tunsigned int commit_max_age = (unsigned int)-1;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tchar *new_opts = kstrdup(arg, GFP_KERNEL);\n\tint err;\n\tchar *qf_names[REISERFS_MAXQUOTAS];\n\tunsigned int qfmt = 0;\n#ifdef CONFIG_QUOTA\n\tint i;\n#endif\n\n\tsync_filesystem(s);\n\treiserfs_write_lock(s);\n\n#ifdef CONFIG_QUOTA\n\tmemcpy(qf_names, REISERFS_SB(s)->s_qf_names, sizeof(qf_names));\n#endif\n\n\trs = SB_DISK_SUPER_BLOCK(s);\n\n\tif (!reiserfs_parse_options\n\t    (s, arg, &mount_options, &blocks, NULL, &commit_max_age,\n\t    qf_names, &qfmt)) {\n#ifdef CONFIG_QUOTA\n\t\tfor (i = 0; i < REISERFS_MAXQUOTAS; i++)\n\t\t\tif (qf_names[i] != REISERFS_SB(s)->s_qf_names[i])\n\t\t\t\tkfree(qf_names[i]);\n#endif\n\t\terr = -EINVAL;\n\t\tgoto out_err_unlock;\n\t}\n#ifdef CONFIG_QUOTA\n\thandle_quota_files(s, qf_names, &qfmt);\n#endif\n\n\thandle_attrs(s);\n\n\t/* Add options that are safe here */\n\tsafe_mask |= 1 << REISERFS_SMALLTAIL;\n\tsafe_mask |= 1 << REISERFS_LARGETAIL;\n\tsafe_mask |= 1 << REISERFS_NO_BORDER;\n\tsafe_mask |= 1 << REISERFS_NO_UNHASHED_RELOCATION;\n\tsafe_mask |= 1 << REISERFS_HASHED_RELOCATION;\n\tsafe_mask |= 1 << REISERFS_TEST4;\n\tsafe_mask |= 1 << REISERFS_ATTRS;\n\tsafe_mask |= 1 << REISERFS_XATTRS_USER;\n\tsafe_mask |= 1 << REISERFS_POSIXACL;\n\tsafe_mask |= 1 << REISERFS_BARRIER_FLUSH;\n\tsafe_mask |= 1 << REISERFS_BARRIER_NONE;\n\tsafe_mask |= 1 << REISERFS_ERROR_RO;\n\tsafe_mask |= 1 << REISERFS_ERROR_CONTINUE;\n\tsafe_mask |= 1 << REISERFS_ERROR_PANIC;\n\tsafe_mask |= 1 << REISERFS_USRQUOTA;\n\tsafe_mask |= 1 << REISERFS_GRPQUOTA;\n\n\t/*\n\t * Update the bitmask, taking care to keep\n\t * the bits we're not allowed to change here\n\t */\n\tREISERFS_SB(s)->s_mount_opt =\n\t    (REISERFS_SB(s)->\n\t     s_mount_opt & ~safe_mask) | (mount_options & safe_mask);\n\n\tif (commit_max_age != 0 && commit_max_age != (unsigned int)-1) {\n\t\tjournal->j_max_commit_age = commit_max_age;\n\t\tjournal->j_max_trans_age = commit_max_age;\n\t} else if (commit_max_age == 0) {\n\t\t/* 0 means restore defaults. */\n\t\tjournal->j_max_commit_age = journal->j_default_max_commit_age;\n\t\tjournal->j_max_trans_age = JOURNAL_MAX_TRANS_AGE;\n\t}\n\n\tif (blocks) {\n\t\terr = reiserfs_resize(s, blocks);\n\t\tif (err != 0)\n\t\t\tgoto out_err_unlock;\n\t}\n\n\tif (*mount_flags & MS_RDONLY) {\n\t\treiserfs_write_unlock(s);\n\t\treiserfs_xattr_init(s, *mount_flags);\n\t\t/* remount read-only */\n\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t/* it is read-only already */\n\t\t\tgoto out_ok_unlocked;\n\n\t\terr = dquot_suspend(s, -1);\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\n\t\t/* try to remount file system with read-only permissions */\n\t\tif (sb_umount_state(rs) == REISERFS_VALID_FS\n\t\t    || REISERFS_SB(s)->s_mount_state != REISERFS_VALID_FS) {\n\t\t\tgoto out_ok_unlocked;\n\t\t}\n\n\t\treiserfs_write_lock(s);\n\n\t\terr = journal_begin(&th, s, 10);\n\t\tif (err)\n\t\t\tgoto out_err_unlock;\n\n\t\t/* Mounting a rw partition read-only. */\n\t\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);\n\t\tset_sb_umount_state(rs, REISERFS_SB(s)->s_mount_state);\n\t\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(s));\n\t} else {\n\t\t/* remount read-write */\n\t\tif (!(s->s_flags & MS_RDONLY)) {\n\t\t\treiserfs_write_unlock(s);\n\t\t\treiserfs_xattr_init(s, *mount_flags);\n\t\t\tgoto out_ok_unlocked;\t/* We are read-write already */\n\t\t}\n\n\t\tif (reiserfs_is_journal_aborted(journal)) {\n\t\t\terr = journal->j_errno;\n\t\t\tgoto out_err_unlock;\n\t\t}\n\n\t\thandle_data_mode(s, mount_options);\n\t\thandle_barrier_mode(s, mount_options);\n\t\tREISERFS_SB(s)->s_mount_state = sb_umount_state(rs);\n\n\t\t/* now it is safe to call journal_begin */\n\t\ts->s_flags &= ~MS_RDONLY;\n\t\terr = journal_begin(&th, s, 10);\n\t\tif (err)\n\t\t\tgoto out_err_unlock;\n\n\t\t/* Mount a partition which is read-only, read-write */\n\t\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);\n\t\tREISERFS_SB(s)->s_mount_state = sb_umount_state(rs);\n\t\ts->s_flags &= ~MS_RDONLY;\n\t\tset_sb_umount_state(rs, REISERFS_ERROR_FS);\n\t\tif (!old_format_only(s))\n\t\t\tset_sb_mnt_count(rs, sb_mnt_count(rs) + 1);\n\t\t/* mark_buffer_dirty (SB_BUFFER_WITH_SB (s), 1); */\n\t\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(s));\n\t\tREISERFS_SB(s)->s_mount_state = REISERFS_VALID_FS;\n\t}\n\t/* this will force a full flush of all journal lists */\n\tSB_JOURNAL(s)->j_must_wait = 1;\n\terr = journal_end(&th);\n\tif (err)\n\t\tgoto out_err_unlock;\n\n\treiserfs_write_unlock(s);\n\tif (!(*mount_flags & MS_RDONLY)) {\n\t\tdquot_resume(s, -1);\n\t\treiserfs_write_lock(s);\n\t\tfinish_unfinished(s);\n\t\treiserfs_write_unlock(s);\n\t\treiserfs_xattr_init(s, *mount_flags);\n\t}\n\nout_ok_unlocked:\n\treplace_mount_options(s, new_opts);\n\treturn 0;\n\nout_err_unlock:\n\treiserfs_write_unlock(s);\nout_err:\n\tkfree(new_opts);\n\treturn err;\n}"
  },
  {
    "function_name": "handle_quota_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "1368-1380",
    "snippet": "static void handle_quota_files(struct super_block *s, char **qf_names,\n\t\t\t       unsigned int *qfmt)\n{\n\tint i;\n\n\tfor (i = 0; i < REISERFS_MAXQUOTAS; i++) {\n\t\tif (qf_names[i] != REISERFS_SB(s)->s_qf_names[i])\n\t\t\tkfree(REISERFS_SB(s)->s_qf_names[i]);\n\t\tREISERFS_SB(s)->s_qf_names[i] = qf_names[i];\n\t}\n\tif (*qfmt)\n\t\tREISERFS_SB(s)->s_jquota_fmt = *qfmt;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "s"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "REISERFS_SB(s)->s_qf_names[i]"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void handle_quota_files(struct super_block *s, char **qf_names,\n\t\t\t       unsigned int *qfmt)\n{\n\tint i;\n\n\tfor (i = 0; i < REISERFS_MAXQUOTAS; i++) {\n\t\tif (qf_names[i] != REISERFS_SB(s)->s_qf_names[i])\n\t\t\tkfree(REISERFS_SB(s)->s_qf_names[i]);\n\t\tREISERFS_SB(s)->s_qf_names[i] = qf_names[i];\n\t}\n\tif (*qfmt)\n\t\tREISERFS_SB(s)->s_jquota_fmt = *qfmt;\n}"
  },
  {
    "function_name": "handle_attrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "1347-1365",
    "snippet": "static void handle_attrs(struct super_block *s)\n{\n\tstruct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(s);\n\n\tif (reiserfs_attrs(s)) {\n\t\tif (old_format_only(s)) {\n\t\t\treiserfs_warning(s, \"super-6517\", \"cannot support \"\n\t\t\t\t\t \"attributes on 3.5.x disk format\");\n\t\t\tREISERFS_SB(s)->s_mount_opt &= ~(1 << REISERFS_ATTRS);\n\t\t\treturn;\n\t\t}\n\t\tif (!(le32_to_cpu(rs->s_flags) & reiserfs_attrs_cleared)) {\n\t\t\treiserfs_warning(s, \"super-6518\", \"cannot support \"\n\t\t\t\t\t \"attributes until flag is set in \"\n\t\t\t\t\t \"super-block\");\n\t\t\tREISERFS_SB(s)->s_mount_opt &= ~(1 << REISERFS_ATTRS);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "s"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"super-6518\"",
            "\"cannot support \"\n\t\t\t\t\t \"attributes until flag is set in \"\n\t\t\t\t\t \"super-block\""
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rs->s_flags"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"super-6517\"",
            "\"cannot support \"\n\t\t\t\t\t \"attributes on 3.5.x disk format\""
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_format_only",
          "args": [
            "s"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_attrs",
          "args": [
            "s"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_DISK_SUPER_BLOCK",
          "args": [
            "s"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void handle_attrs(struct super_block *s)\n{\n\tstruct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(s);\n\n\tif (reiserfs_attrs(s)) {\n\t\tif (old_format_only(s)) {\n\t\t\treiserfs_warning(s, \"super-6517\", \"cannot support \"\n\t\t\t\t\t \"attributes on 3.5.x disk format\");\n\t\t\tREISERFS_SB(s)->s_mount_opt &= ~(1 << REISERFS_ATTRS);\n\t\t\treturn;\n\t\t}\n\t\tif (!(le32_to_cpu(rs->s_flags) & reiserfs_attrs_cleared)) {\n\t\t\treiserfs_warning(s, \"super-6518\", \"cannot support \"\n\t\t\t\t\t \"attributes until flag is set in \"\n\t\t\t\t\t \"super-block\");\n\t\t\tREISERFS_SB(s)->s_mount_opt &= ~(1 << REISERFS_ATTRS);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "handle_barrier_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "1329-1345",
    "snippet": "static void handle_barrier_mode(struct super_block *s, unsigned long bits)\n{\n\tint flush = (1 << REISERFS_BARRIER_FLUSH);\n\tint none = (1 << REISERFS_BARRIER_NONE);\n\tint all_barrier = flush | none;\n\n\tif (bits & all_barrier) {\n\t\tREISERFS_SB(s)->s_mount_opt &= ~all_barrier;\n\t\tif (bits & flush) {\n\t\t\tREISERFS_SB(s)->s_mount_opt |= flush;\n\t\t\tprintk(\"reiserfs: enabling write barrier flush mode\\n\");\n\t\t} else if (bits & none) {\n\t\t\tREISERFS_SB(s)->s_mount_opt |= none;\n\t\t\tprintk(\"reiserfs: write barriers turned off\\n\");\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"reiserfs: write barriers turned off\\n\""
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "291-295",
          "snippet": "static void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nstatic void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "s"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void handle_barrier_mode(struct super_block *s, unsigned long bits)\n{\n\tint flush = (1 << REISERFS_BARRIER_FLUSH);\n\tint none = (1 << REISERFS_BARRIER_NONE);\n\tint all_barrier = flush | none;\n\n\tif (bits & all_barrier) {\n\t\tREISERFS_SB(s)->s_mount_opt &= ~all_barrier;\n\t\tif (bits & flush) {\n\t\t\tREISERFS_SB(s)->s_mount_opt |= flush;\n\t\t\tprintk(\"reiserfs: enabling write barrier flush mode\\n\");\n\t\t} else if (bits & none) {\n\t\t\tREISERFS_SB(s)->s_mount_opt |= none;\n\t\t\tprintk(\"reiserfs: write barriers turned off\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "handle_data_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "1309-1327",
    "snippet": "static void handle_data_mode(struct super_block *s, unsigned long mount_options)\n{\n\tif (mount_options & (1 << REISERFS_DATA_LOG)) {\n\t\tif (!reiserfs_data_log(s)) {\n\t\t\tswitch_data_mode(s, REISERFS_DATA_LOG);\n\t\t\treiserfs_info(s, \"switching to journaled data mode\\n\");\n\t\t}\n\t} else if (mount_options & (1 << REISERFS_DATA_ORDERED)) {\n\t\tif (!reiserfs_data_ordered(s)) {\n\t\t\tswitch_data_mode(s, REISERFS_DATA_ORDERED);\n\t\t\treiserfs_info(s, \"switching to ordered data mode\\n\");\n\t\t}\n\t} else if (mount_options & (1 << REISERFS_DATA_WRITEBACK)) {\n\t\tif (!reiserfs_data_writeback(s)) {\n\t\t\tswitch_data_mode(s, REISERFS_DATA_WRITEBACK);\n\t\t\treiserfs_info(s, \"switching to writeback data mode\\n\");\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int reiserfs_remount(struct super_block *s, int *flags, char *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_info",
          "args": [
            "s",
            "\"switching to writeback data mode\\n\""
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "280-288",
          "snippet": "void reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "switch_data_mode",
          "args": [
            "s",
            "REISERFS_DATA_WRITEBACK"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "switch_data_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "1301-1307",
          "snippet": "static void switch_data_mode(struct super_block *s, unsigned long mode)\n{\n\tREISERFS_SB(s)->s_mount_opt &= ~((1 << REISERFS_DATA_LOG) |\n\t\t\t\t\t (1 << REISERFS_DATA_ORDERED) |\n\t\t\t\t\t (1 << REISERFS_DATA_WRITEBACK));\n\tREISERFS_SB(s)->s_mount_opt |= (1 << mode);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void switch_data_mode(struct super_block *s, unsigned long mode)\n{\n\tREISERFS_SB(s)->s_mount_opt &= ~((1 << REISERFS_DATA_LOG) |\n\t\t\t\t\t (1 << REISERFS_DATA_ORDERED) |\n\t\t\t\t\t (1 << REISERFS_DATA_WRITEBACK));\n\tREISERFS_SB(s)->s_mount_opt |= (1 << mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_data_writeback",
          "args": [
            "s"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_data_ordered",
          "args": [
            "s"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_data_log",
          "args": [
            "s"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int reiserfs_remount(struct super_block *s, int *flags, char *data);\n\nstatic void handle_data_mode(struct super_block *s, unsigned long mount_options)\n{\n\tif (mount_options & (1 << REISERFS_DATA_LOG)) {\n\t\tif (!reiserfs_data_log(s)) {\n\t\t\tswitch_data_mode(s, REISERFS_DATA_LOG);\n\t\t\treiserfs_info(s, \"switching to journaled data mode\\n\");\n\t\t}\n\t} else if (mount_options & (1 << REISERFS_DATA_ORDERED)) {\n\t\tif (!reiserfs_data_ordered(s)) {\n\t\t\tswitch_data_mode(s, REISERFS_DATA_ORDERED);\n\t\t\treiserfs_info(s, \"switching to ordered data mode\\n\");\n\t\t}\n\t} else if (mount_options & (1 << REISERFS_DATA_WRITEBACK)) {\n\t\tif (!reiserfs_data_writeback(s)) {\n\t\t\tswitch_data_mode(s, REISERFS_DATA_WRITEBACK);\n\t\t\treiserfs_info(s, \"switching to writeback data mode\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "switch_data_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "1301-1307",
    "snippet": "static void switch_data_mode(struct super_block *s, unsigned long mode)\n{\n\tREISERFS_SB(s)->s_mount_opt &= ~((1 << REISERFS_DATA_LOG) |\n\t\t\t\t\t (1 << REISERFS_DATA_ORDERED) |\n\t\t\t\t\t (1 << REISERFS_DATA_WRITEBACK));\n\tREISERFS_SB(s)->s_mount_opt |= (1 << mode);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "s"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void switch_data_mode(struct super_block *s, unsigned long mode)\n{\n\tREISERFS_SB(s)->s_mount_opt &= ~((1 << REISERFS_DATA_LOG) |\n\t\t\t\t\t (1 << REISERFS_DATA_ORDERED) |\n\t\t\t\t\t (1 << REISERFS_DATA_WRITEBACK));\n\tREISERFS_SB(s)->s_mount_opt |= (1 << mode);\n}"
  },
  {
    "function_name": "reiserfs_parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "1063-1299",
    "snippet": "static int reiserfs_parse_options(struct super_block *s,\n\n\t\t\t\t  /* string given via mount's -o */\n\t\t\t\t  char *options,\n\n\t\t\t\t  /*\n\t\t\t\t   * after the parsing phase, contains the\n\t\t\t\t   * collection of bitflags defining what\n\t\t\t\t   * mount options were selected.\n\t\t\t\t   */\n\t\t\t\t  unsigned long *mount_options,\n\n\t\t\t\t  /* strtol-ed from NNN of resize=NNN */\n\t\t\t\t  unsigned long *blocks,\n\t\t\t\t  char **jdev_name,\n\t\t\t\t  unsigned int *commit_max_age,\n\t\t\t\t  char **qf_names,\n\t\t\t\t  unsigned int *qfmt)\n{\n\tint c;\n\tchar *arg = NULL;\n\tchar *pos;\n\topt_desc_t opts[] = {\n\t\t/*\n\t\t * Compatibility stuff, so that -o notail for old\n\t\t * setups still work\n\t\t */\n\t\t{\"tails\",.arg_required = 't',.values = tails},\n\t\t{\"notail\",.clrmask =\n\t\t (1 << REISERFS_LARGETAIL) | (1 << REISERFS_SMALLTAIL)},\n\t\t{\"conv\",.setmask = 1 << REISERFS_CONVERT},\n\t\t{\"attrs\",.setmask = 1 << REISERFS_ATTRS},\n\t\t{\"noattrs\",.clrmask = 1 << REISERFS_ATTRS},\n\t\t{\"expose_privroot\", .setmask = 1 << REISERFS_EXPOSE_PRIVROOT},\n#ifdef CONFIG_REISERFS_FS_XATTR\n\t\t{\"user_xattr\",.setmask = 1 << REISERFS_XATTRS_USER},\n\t\t{\"nouser_xattr\",.clrmask = 1 << REISERFS_XATTRS_USER},\n#else\n\t\t{\"user_xattr\",.setmask = 1 << REISERFS_UNSUPPORTED_OPT},\n\t\t{\"nouser_xattr\",.clrmask = 1 << REISERFS_UNSUPPORTED_OPT},\n#endif\n#ifdef CONFIG_REISERFS_FS_POSIX_ACL\n\t\t{\"acl\",.setmask = 1 << REISERFS_POSIXACL},\n\t\t{\"noacl\",.clrmask = 1 << REISERFS_POSIXACL},\n#else\n\t\t{\"acl\",.setmask = 1 << REISERFS_UNSUPPORTED_OPT},\n\t\t{\"noacl\",.clrmask = 1 << REISERFS_UNSUPPORTED_OPT},\n#endif\n\t\t{.option_name = \"nolog\"},\n\t\t{\"replayonly\",.setmask = 1 << REPLAYONLY},\n\t\t{\"block-allocator\",.arg_required = 'a',.values = balloc},\n\t\t{\"data\",.arg_required = 'd',.values = logging_mode},\n\t\t{\"barrier\",.arg_required = 'b',.values = barrier_mode},\n\t\t{\"resize\",.arg_required = 'r',.values = NULL},\n\t\t{\"jdev\",.arg_required = 'j',.values = NULL},\n\t\t{\"nolargeio\",.arg_required = 'w',.values = NULL},\n\t\t{\"commit\",.arg_required = 'c',.values = NULL},\n\t\t{\"usrquota\",.setmask = 1 << REISERFS_USRQUOTA},\n\t\t{\"grpquota\",.setmask = 1 << REISERFS_GRPQUOTA},\n\t\t{\"noquota\",.clrmask = 1 << REISERFS_USRQUOTA | 1 << REISERFS_GRPQUOTA},\n\t\t{\"errors\",.arg_required = 'e',.values = error_actions},\n\t\t{\"usrjquota\",.arg_required =\n\t\t 'u' | (1 << REISERFS_OPT_ALLOWEMPTY),.values = NULL},\n\t\t{\"grpjquota\",.arg_required =\n\t\t 'g' | (1 << REISERFS_OPT_ALLOWEMPTY),.values = NULL},\n\t\t{\"jqfmt\",.arg_required = 'f',.values = NULL},\n\t\t{.option_name = NULL}\n\t};\n\n\t*blocks = 0;\n\tif (!options || !*options)\n\t\t/*\n\t\t * use default configuration: create tails, journaling on, no\n\t\t * conversion to newest format\n\t\t */\n\t\treturn 1;\n\n\tfor (pos = options; pos;) {\n\t\tc = reiserfs_getopt(s, &pos, opts, &arg, mount_options);\n\t\tif (c == -1)\n\t\t\t/* wrong option is given */\n\t\t\treturn 0;\n\n\t\tif (c == 'r') {\n\t\t\tchar *p;\n\n\t\t\tp = NULL;\n\t\t\t/* \"resize=NNN\" or \"resize=auto\" */\n\n\t\t\tif (!strcmp(arg, \"auto\")) {\n\t\t\t\t/* From JFS code, to auto-get the size. */\n\t\t\t\t*blocks =\n\t\t\t\t    s->s_bdev->bd_inode->i_size >> s->\n\t\t\t\t    s_blocksize_bits;\n\t\t\t} else {\n\t\t\t\t*blocks = simple_strtoul(arg, &p, 0);\n\t\t\t\tif (*p != '\\0') {\n\t\t\t\t\t/* NNN does not look like a number */\n\t\t\t\t\treiserfs_warning(s, \"super-6507\",\n\t\t\t\t\t\t\t \"bad value %s for \"\n\t\t\t\t\t\t\t \"-oresize\\n\", arg);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (c == 'c') {\n\t\t\tchar *p = NULL;\n\t\t\tunsigned long val = simple_strtoul(arg, &p, 0);\n\t\t\t/* commit=NNN (time in seconds) */\n\t\t\tif (*p != '\\0' || val >= (unsigned int)-1) {\n\t\t\t\treiserfs_warning(s, \"super-6508\",\n\t\t\t\t\t\t \"bad value %s for -ocommit\\n\",\n\t\t\t\t\t\t arg);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t*commit_max_age = (unsigned int)val;\n\t\t}\n\n\t\tif (c == 'w') {\n\t\t\treiserfs_warning(s, \"super-6509\", \"nolargeio option \"\n\t\t\t\t\t \"is no longer supported\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (c == 'j') {\n\t\t\tif (arg && *arg && jdev_name) {\n\t\t\t\t/* Hm, already assigned? */\n\t\t\t\tif (*jdev_name) {\n\t\t\t\t\treiserfs_warning(s, \"super-6510\",\n\t\t\t\t\t\t\t \"journal device was \"\n\t\t\t\t\t\t\t \"already specified to \"\n\t\t\t\t\t\t\t \"be %s\", *jdev_name);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t*jdev_name = arg;\n\t\t\t}\n\t\t}\n#ifdef CONFIG_QUOTA\n\t\tif (c == 'u' || c == 'g') {\n\t\t\tint qtype = c == 'u' ? USRQUOTA : GRPQUOTA;\n\n\t\t\tif (sb_any_quota_loaded(s) &&\n\t\t\t    (!*arg != !REISERFS_SB(s)->s_qf_names[qtype])) {\n\t\t\t\treiserfs_warning(s, \"super-6511\",\n\t\t\t\t\t\t \"cannot change journaled \"\n\t\t\t\t\t\t \"quota options when quota \"\n\t\t\t\t\t\t \"turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (*arg) {\t/* Some filename specified? */\n\t\t\t\tif (REISERFS_SB(s)->s_qf_names[qtype]\n\t\t\t\t    && strcmp(REISERFS_SB(s)->s_qf_names[qtype],\n\t\t\t\t\t      arg)) {\n\t\t\t\t\treiserfs_warning(s, \"super-6512\",\n\t\t\t\t\t\t\t \"%s quota file \"\n\t\t\t\t\t\t\t \"already specified.\",\n\t\t\t\t\t\t\t QTYPE2NAME(qtype));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (strchr(arg, '/')) {\n\t\t\t\t\treiserfs_warning(s, \"super-6513\",\n\t\t\t\t\t\t\t \"quotafile must be \"\n\t\t\t\t\t\t\t \"on filesystem root.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tqf_names[qtype] = kstrdup(arg, GFP_KERNEL);\n\t\t\t\tif (!qf_names[qtype]) {\n\t\t\t\t\treiserfs_warning(s, \"reiserfs-2502\",\n\t\t\t\t\t\t\t \"not enough memory \"\n\t\t\t\t\t\t\t \"for storing \"\n\t\t\t\t\t\t\t \"quotafile name.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (qtype == USRQUOTA)\n\t\t\t\t\t*mount_options |= 1 << REISERFS_USRQUOTA;\n\t\t\t\telse\n\t\t\t\t\t*mount_options |= 1 << REISERFS_GRPQUOTA;\n\t\t\t} else {\n\t\t\t\tif (qf_names[qtype] !=\n\t\t\t\t    REISERFS_SB(s)->s_qf_names[qtype])\n\t\t\t\t\tkfree(qf_names[qtype]);\n\t\t\t\tqf_names[qtype] = NULL;\n\t\t\t\tif (qtype == USRQUOTA)\n\t\t\t\t\t*mount_options &= ~(1 << REISERFS_USRQUOTA);\n\t\t\t\telse\n\t\t\t\t\t*mount_options &= ~(1 << REISERFS_GRPQUOTA);\n\t\t\t}\n\t\t}\n\t\tif (c == 'f') {\n\t\t\tif (!strcmp(arg, \"vfsold\"))\n\t\t\t\t*qfmt = QFMT_VFS_OLD;\n\t\t\telse if (!strcmp(arg, \"vfsv0\"))\n\t\t\t\t*qfmt = QFMT_VFS_V0;\n\t\t\telse {\n\t\t\t\treiserfs_warning(s, \"super-6514\",\n\t\t\t\t\t\t \"unknown quota format \"\n\t\t\t\t\t\t \"specified.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (sb_any_quota_loaded(s) &&\n\t\t\t    *qfmt != REISERFS_SB(s)->s_jquota_fmt) {\n\t\t\t\treiserfs_warning(s, \"super-6515\",\n\t\t\t\t\t\t \"cannot change journaled \"\n\t\t\t\t\t\t \"quota options when quota \"\n\t\t\t\t\t\t \"turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n#else\n\t\tif (c == 'u' || c == 'g' || c == 'f') {\n\t\t\treiserfs_warning(s, \"reiserfs-2503\", \"journaled \"\n\t\t\t\t\t \"quota options not supported.\");\n\t\t\treturn 0;\n\t\t}\n#endif\n\t}\n\n#ifdef CONFIG_QUOTA\n\tif (!REISERFS_SB(s)->s_jquota_fmt && !*qfmt\n\t    && (qf_names[USRQUOTA] || qf_names[GRPQUOTA])) {\n\t\treiserfs_warning(s, \"super-6515\",\n\t\t\t\t \"journaled quota format not specified.\");\n\t\treturn 0;\n\t}\n\tif ((!(*mount_options & (1 << REISERFS_USRQUOTA)) &&\n\t       sb_has_quota_loaded(s, USRQUOTA)) ||\n\t    (!(*mount_options & (1 << REISERFS_GRPQUOTA)) &&\n\t       sb_has_quota_loaded(s, GRPQUOTA))) {\n\t\treiserfs_warning(s, \"super-6516\", \"quota options must \"\n\t\t\t\t \"be present when quota is turned on.\");\n\t\treturn 0;\n\t}\n#endif\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define REISERFS_OPT_ALLOWEMPTY 31"
    ],
    "globals_used": [
      "static int reiserfs_remount(struct super_block *s, int *flags, char *data);",
      "static const arg_desc_t logging_mode[] = {\n\t{\"ordered\", 1 << REISERFS_DATA_ORDERED,\n\t (1 << REISERFS_DATA_LOG | 1 << REISERFS_DATA_WRITEBACK)},\n\t{\"journal\", 1 << REISERFS_DATA_LOG,\n\t (1 << REISERFS_DATA_ORDERED | 1 << REISERFS_DATA_WRITEBACK)},\n\t{\"writeback\", 1 << REISERFS_DATA_WRITEBACK,\n\t (1 << REISERFS_DATA_ORDERED | 1 << REISERFS_DATA_LOG)},\n\t{.value = NULL}\n};",
      "static const arg_desc_t barrier_mode[] = {\n\t{\"none\", 1 << REISERFS_BARRIER_NONE, 1 << REISERFS_BARRIER_FLUSH},\n\t{\"flush\", 1 << REISERFS_BARRIER_FLUSH, 1 << REISERFS_BARRIER_NONE},\n\t{.value = NULL}\n};",
      "static const arg_desc_t balloc[] = {\n\t{\"noborder\", 1 << REISERFS_NO_BORDER, 0},\n\t{\"border\", 0, 1 << REISERFS_NO_BORDER},\n\t{\"no_unhashed_relocation\", 1 << REISERFS_NO_UNHASHED_RELOCATION, 0},\n\t{\"hashed_relocation\", 1 << REISERFS_HASHED_RELOCATION, 0},\n\t{\"test4\", 1 << REISERFS_TEST4, 0},\n\t{\"notest4\", 0, 1 << REISERFS_TEST4},\n\t{NULL, 0, 0}\n};",
      "static const arg_desc_t tails[] = {\n\t{\"on\", 1 << REISERFS_LARGETAIL, 1 << REISERFS_SMALLTAIL},\n\t{\"off\", 0, (1 << REISERFS_LARGETAIL) | (1 << REISERFS_SMALLTAIL)},\n\t{\"small\", 1 << REISERFS_SMALLTAIL, 1 << REISERFS_LARGETAIL},\n\t{NULL, 0, 0}\n};",
      "static const arg_desc_t error_actions[] = {\n\t{\"panic\", 1 << REISERFS_ERROR_PANIC,\n\t (1 << REISERFS_ERROR_RO | 1 << REISERFS_ERROR_CONTINUE)},\n\t{\"ro-remount\", 1 << REISERFS_ERROR_RO,\n\t (1 << REISERFS_ERROR_PANIC | 1 << REISERFS_ERROR_CONTINUE)},\n#ifdef REISERFS_JOURNAL_ERROR_ALLOWS_NO_LOG\n\t{\"continue\", 1 << REISERFS_ERROR_CONTINUE,\n\t (1 << REISERFS_ERROR_PANIC | 1 << REISERFS_ERROR_RO)},\n#endif\n\t{NULL, 0, 0},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"super-6516\"",
            "\"quota options must \"\n\t\t\t\t \"be present when quota is turned on.\""
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_has_quota_loaded",
          "args": [
            "s",
            "GRPQUOTA"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_has_quota_loaded",
          "args": [
            "s",
            "USRQUOTA"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"super-6515\"",
            "\"journaled quota format not specified.\""
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "s"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"reiserfs-2503\"",
            "\"journaled \"\n\t\t\t\t\t \"quota options not supported.\""
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"super-6515\"",
            "\"cannot change journaled \"\n\t\t\t\t\t\t \"quota options when quota \"\n\t\t\t\t\t\t \"turned on.\""
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_any_quota_loaded",
          "args": [
            "s"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"super-6514\"",
            "\"unknown quota format \"\n\t\t\t\t\t\t \"specified.\""
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"vfsv0\""
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "292-301",
          "snippet": "static int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/string.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "qf_names[qtype]"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"reiserfs-2502\"",
            "\"not enough memory \"\n\t\t\t\t\t\t\t \"for storing \"\n\t\t\t\t\t\t\t \"quotafile name.\""
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "arg",
            "GFP_KERNEL"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"super-6513\"",
            "\"quotafile must be \"\n\t\t\t\t\t\t\t \"on filesystem root.\""
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "arg",
            "'/'"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"super-6512\"",
            "\"%s quota file \"\n\t\t\t\t\t\t\t \"already specified.\"",
            "QTYPE2NAME(qtype)"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QTYPE2NAME",
          "args": [
            "qtype"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"super-6511\"",
            "\"cannot change journaled \"\n\t\t\t\t\t\t \"quota options when quota \"\n\t\t\t\t\t\t \"turned on.\""
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_any_quota_loaded",
          "args": [
            "s"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"super-6509\"",
            "\"nolargeio option \"\n\t\t\t\t\t \"is no longer supported\""
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "arg",
            "&p",
            "0"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "arg",
            "&p",
            "0"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_getopt",
          "args": [
            "s",
            "&pos",
            "opts",
            "&arg",
            "mount_options"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_getopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "931-1060",
          "snippet": "static int reiserfs_getopt(struct super_block *s, char **cur, opt_desc_t * opts,\n\t\t\t   char **opt_arg, unsigned long *bit_flags)\n{\n\tchar *p;\n\t/*\n\t * foo=bar,\n\t * ^   ^  ^\n\t * |   |  +-- option_end\n\t * |   +-- arg_start\n\t * +-- option_start\n\t */\n\tconst opt_desc_t *opt;\n\tconst arg_desc_t *arg;\n\n\tp = *cur;\n\n\t/* assume argument cannot contain commas */\n\t*cur = strchr(p, ',');\n\tif (*cur) {\n\t\t*(*cur) = '\\0';\n\t\t(*cur)++;\n\t}\n\n\tif (!strncmp(p, \"alloc=\", 6)) {\n\t\t/*\n\t\t * Ugly special case, probably we should redo options\n\t\t * parser so that it can understand several arguments for\n\t\t * some options, also so that it can fill several bitfields\n\t\t * with option values.\n\t\t */\n\t\tif (reiserfs_parse_alloc_options(s, p + 6)) {\n\t\t\treturn -1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* for every option in the list */\n\tfor (opt = opts; opt->option_name; opt++) {\n\t\tif (!strncmp(p, opt->option_name, strlen(opt->option_name))) {\n\t\t\tif (bit_flags) {\n\t\t\t\tif (opt->clrmask ==\n\t\t\t\t    (1 << REISERFS_UNSUPPORTED_OPT))\n\t\t\t\t\treiserfs_warning(s, \"super-6500\",\n\t\t\t\t\t\t\t \"%s not supported.\\n\",\n\t\t\t\t\t\t\t p);\n\t\t\t\telse\n\t\t\t\t\t*bit_flags &= ~opt->clrmask;\n\t\t\t\tif (opt->setmask ==\n\t\t\t\t    (1 << REISERFS_UNSUPPORTED_OPT))\n\t\t\t\t\treiserfs_warning(s, \"super-6501\",\n\t\t\t\t\t\t\t \"%s not supported.\\n\",\n\t\t\t\t\t\t\t p);\n\t\t\t\telse\n\t\t\t\t\t*bit_flags |= opt->setmask;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!opt->option_name) {\n\t\treiserfs_warning(s, \"super-6502\",\n\t\t\t\t \"unknown mount option \\\"%s\\\"\", p);\n\t\treturn -1;\n\t}\n\n\tp += strlen(opt->option_name);\n\tswitch (*p) {\n\tcase '=':\n\t\tif (!opt->arg_required) {\n\t\t\treiserfs_warning(s, \"super-6503\",\n\t\t\t\t\t \"the option \\\"%s\\\" does not \"\n\t\t\t\t\t \"require an argument\\n\",\n\t\t\t\t\t opt->option_name);\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\n\tcase 0:\n\t\tif (opt->arg_required) {\n\t\t\treiserfs_warning(s, \"super-6504\",\n\t\t\t\t\t \"the option \\\"%s\\\" requires an \"\n\t\t\t\t\t \"argument\\n\", opt->option_name);\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treiserfs_warning(s, \"super-6505\",\n\t\t\t\t \"head of option \\\"%s\\\" is only correct\\n\",\n\t\t\t\t opt->option_name);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * move to the argument, or to next option if argument is not\n\t * required\n\t */\n\tp++;\n\n\tif (opt->arg_required\n\t    && !(opt->arg_required & (1 << REISERFS_OPT_ALLOWEMPTY))\n\t    && !strlen(p)) {\n\t\t/* this catches \"option=,\" if not allowed */\n\t\treiserfs_warning(s, \"super-6506\",\n\t\t\t\t \"empty argument for \\\"%s\\\"\\n\",\n\t\t\t\t opt->option_name);\n\t\treturn -1;\n\t}\n\n\tif (!opt->values) {\n\t\t/* *=NULLopt_arg contains pointer to argument */\n\t\t*opt_arg = p;\n\t\treturn opt->arg_required & ~(1 << REISERFS_OPT_ALLOWEMPTY);\n\t}\n\n\t/* values possible for this option are listed in opt->values */\n\tfor (arg = opt->values; arg->value; arg++) {\n\t\tif (!strcmp(p, arg->value)) {\n\t\t\tif (bit_flags) {\n\t\t\t\t*bit_flags &= ~arg->clrmask;\n\t\t\t\t*bit_flags |= arg->setmask;\n\t\t\t}\n\t\t\treturn opt->arg_required;\n\t\t}\n\t}\n\n\treiserfs_warning(s, \"super-6506\",\n\t\t\t \"bad value \\\"%s\\\" for option \\\"%s\\\"\\n\", p,\n\t\t\t opt->option_name);\n\treturn -1;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define REISERFS_OPT_ALLOWEMPTY 31"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define REISERFS_OPT_ALLOWEMPTY 31\n\nstatic int reiserfs_getopt(struct super_block *s, char **cur, opt_desc_t * opts,\n\t\t\t   char **opt_arg, unsigned long *bit_flags)\n{\n\tchar *p;\n\t/*\n\t * foo=bar,\n\t * ^   ^  ^\n\t * |   |  +-- option_end\n\t * |   +-- arg_start\n\t * +-- option_start\n\t */\n\tconst opt_desc_t *opt;\n\tconst arg_desc_t *arg;\n\n\tp = *cur;\n\n\t/* assume argument cannot contain commas */\n\t*cur = strchr(p, ',');\n\tif (*cur) {\n\t\t*(*cur) = '\\0';\n\t\t(*cur)++;\n\t}\n\n\tif (!strncmp(p, \"alloc=\", 6)) {\n\t\t/*\n\t\t * Ugly special case, probably we should redo options\n\t\t * parser so that it can understand several arguments for\n\t\t * some options, also so that it can fill several bitfields\n\t\t * with option values.\n\t\t */\n\t\tif (reiserfs_parse_alloc_options(s, p + 6)) {\n\t\t\treturn -1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* for every option in the list */\n\tfor (opt = opts; opt->option_name; opt++) {\n\t\tif (!strncmp(p, opt->option_name, strlen(opt->option_name))) {\n\t\t\tif (bit_flags) {\n\t\t\t\tif (opt->clrmask ==\n\t\t\t\t    (1 << REISERFS_UNSUPPORTED_OPT))\n\t\t\t\t\treiserfs_warning(s, \"super-6500\",\n\t\t\t\t\t\t\t \"%s not supported.\\n\",\n\t\t\t\t\t\t\t p);\n\t\t\t\telse\n\t\t\t\t\t*bit_flags &= ~opt->clrmask;\n\t\t\t\tif (opt->setmask ==\n\t\t\t\t    (1 << REISERFS_UNSUPPORTED_OPT))\n\t\t\t\t\treiserfs_warning(s, \"super-6501\",\n\t\t\t\t\t\t\t \"%s not supported.\\n\",\n\t\t\t\t\t\t\t p);\n\t\t\t\telse\n\t\t\t\t\t*bit_flags |= opt->setmask;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!opt->option_name) {\n\t\treiserfs_warning(s, \"super-6502\",\n\t\t\t\t \"unknown mount option \\\"%s\\\"\", p);\n\t\treturn -1;\n\t}\n\n\tp += strlen(opt->option_name);\n\tswitch (*p) {\n\tcase '=':\n\t\tif (!opt->arg_required) {\n\t\t\treiserfs_warning(s, \"super-6503\",\n\t\t\t\t\t \"the option \\\"%s\\\" does not \"\n\t\t\t\t\t \"require an argument\\n\",\n\t\t\t\t\t opt->option_name);\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\n\tcase 0:\n\t\tif (opt->arg_required) {\n\t\t\treiserfs_warning(s, \"super-6504\",\n\t\t\t\t\t \"the option \\\"%s\\\" requires an \"\n\t\t\t\t\t \"argument\\n\", opt->option_name);\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treiserfs_warning(s, \"super-6505\",\n\t\t\t\t \"head of option \\\"%s\\\" is only correct\\n\",\n\t\t\t\t opt->option_name);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * move to the argument, or to next option if argument is not\n\t * required\n\t */\n\tp++;\n\n\tif (opt->arg_required\n\t    && !(opt->arg_required & (1 << REISERFS_OPT_ALLOWEMPTY))\n\t    && !strlen(p)) {\n\t\t/* this catches \"option=,\" if not allowed */\n\t\treiserfs_warning(s, \"super-6506\",\n\t\t\t\t \"empty argument for \\\"%s\\\"\\n\",\n\t\t\t\t opt->option_name);\n\t\treturn -1;\n\t}\n\n\tif (!opt->values) {\n\t\t/* *=NULLopt_arg contains pointer to argument */\n\t\t*opt_arg = p;\n\t\treturn opt->arg_required & ~(1 << REISERFS_OPT_ALLOWEMPTY);\n\t}\n\n\t/* values possible for this option are listed in opt->values */\n\tfor (arg = opt->values; arg->value; arg++) {\n\t\tif (!strcmp(p, arg->value)) {\n\t\t\tif (bit_flags) {\n\t\t\t\t*bit_flags &= ~arg->clrmask;\n\t\t\t\t*bit_flags |= arg->setmask;\n\t\t\t}\n\t\t\treturn opt->arg_required;\n\t\t}\n\t}\n\n\treiserfs_warning(s, \"super-6506\",\n\t\t\t \"bad value \\\"%s\\\" for option \\\"%s\\\"\\n\", p,\n\t\t\t opt->option_name);\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define REISERFS_OPT_ALLOWEMPTY 31\n\nstatic int reiserfs_remount(struct super_block *s, int *flags, char *data);\nstatic const arg_desc_t logging_mode[] = {\n\t{\"ordered\", 1 << REISERFS_DATA_ORDERED,\n\t (1 << REISERFS_DATA_LOG | 1 << REISERFS_DATA_WRITEBACK)},\n\t{\"journal\", 1 << REISERFS_DATA_LOG,\n\t (1 << REISERFS_DATA_ORDERED | 1 << REISERFS_DATA_WRITEBACK)},\n\t{\"writeback\", 1 << REISERFS_DATA_WRITEBACK,\n\t (1 << REISERFS_DATA_ORDERED | 1 << REISERFS_DATA_LOG)},\n\t{.value = NULL}\n};\nstatic const arg_desc_t barrier_mode[] = {\n\t{\"none\", 1 << REISERFS_BARRIER_NONE, 1 << REISERFS_BARRIER_FLUSH},\n\t{\"flush\", 1 << REISERFS_BARRIER_FLUSH, 1 << REISERFS_BARRIER_NONE},\n\t{.value = NULL}\n};\nstatic const arg_desc_t balloc[] = {\n\t{\"noborder\", 1 << REISERFS_NO_BORDER, 0},\n\t{\"border\", 0, 1 << REISERFS_NO_BORDER},\n\t{\"no_unhashed_relocation\", 1 << REISERFS_NO_UNHASHED_RELOCATION, 0},\n\t{\"hashed_relocation\", 1 << REISERFS_HASHED_RELOCATION, 0},\n\t{\"test4\", 1 << REISERFS_TEST4, 0},\n\t{\"notest4\", 0, 1 << REISERFS_TEST4},\n\t{NULL, 0, 0}\n};\nstatic const arg_desc_t tails[] = {\n\t{\"on\", 1 << REISERFS_LARGETAIL, 1 << REISERFS_SMALLTAIL},\n\t{\"off\", 0, (1 << REISERFS_LARGETAIL) | (1 << REISERFS_SMALLTAIL)},\n\t{\"small\", 1 << REISERFS_SMALLTAIL, 1 << REISERFS_LARGETAIL},\n\t{NULL, 0, 0}\n};\nstatic const arg_desc_t error_actions[] = {\n\t{\"panic\", 1 << REISERFS_ERROR_PANIC,\n\t (1 << REISERFS_ERROR_RO | 1 << REISERFS_ERROR_CONTINUE)},\n\t{\"ro-remount\", 1 << REISERFS_ERROR_RO,\n\t (1 << REISERFS_ERROR_PANIC | 1 << REISERFS_ERROR_CONTINUE)},\n#ifdef REISERFS_JOURNAL_ERROR_ALLOWS_NO_LOG\n\t{\"continue\", 1 << REISERFS_ERROR_CONTINUE,\n\t (1 << REISERFS_ERROR_PANIC | 1 << REISERFS_ERROR_RO)},\n#endif\n\t{NULL, 0, 0},\n};\n\nstatic int reiserfs_parse_options(struct super_block *s,\n\n\t\t\t\t  /* string given via mount's -o */\n\t\t\t\t  char *options,\n\n\t\t\t\t  /*\n\t\t\t\t   * after the parsing phase, contains the\n\t\t\t\t   * collection of bitflags defining what\n\t\t\t\t   * mount options were selected.\n\t\t\t\t   */\n\t\t\t\t  unsigned long *mount_options,\n\n\t\t\t\t  /* strtol-ed from NNN of resize=NNN */\n\t\t\t\t  unsigned long *blocks,\n\t\t\t\t  char **jdev_name,\n\t\t\t\t  unsigned int *commit_max_age,\n\t\t\t\t  char **qf_names,\n\t\t\t\t  unsigned int *qfmt)\n{\n\tint c;\n\tchar *arg = NULL;\n\tchar *pos;\n\topt_desc_t opts[] = {\n\t\t/*\n\t\t * Compatibility stuff, so that -o notail for old\n\t\t * setups still work\n\t\t */\n\t\t{\"tails\",.arg_required = 't',.values = tails},\n\t\t{\"notail\",.clrmask =\n\t\t (1 << REISERFS_LARGETAIL) | (1 << REISERFS_SMALLTAIL)},\n\t\t{\"conv\",.setmask = 1 << REISERFS_CONVERT},\n\t\t{\"attrs\",.setmask = 1 << REISERFS_ATTRS},\n\t\t{\"noattrs\",.clrmask = 1 << REISERFS_ATTRS},\n\t\t{\"expose_privroot\", .setmask = 1 << REISERFS_EXPOSE_PRIVROOT},\n#ifdef CONFIG_REISERFS_FS_XATTR\n\t\t{\"user_xattr\",.setmask = 1 << REISERFS_XATTRS_USER},\n\t\t{\"nouser_xattr\",.clrmask = 1 << REISERFS_XATTRS_USER},\n#else\n\t\t{\"user_xattr\",.setmask = 1 << REISERFS_UNSUPPORTED_OPT},\n\t\t{\"nouser_xattr\",.clrmask = 1 << REISERFS_UNSUPPORTED_OPT},\n#endif\n#ifdef CONFIG_REISERFS_FS_POSIX_ACL\n\t\t{\"acl\",.setmask = 1 << REISERFS_POSIXACL},\n\t\t{\"noacl\",.clrmask = 1 << REISERFS_POSIXACL},\n#else\n\t\t{\"acl\",.setmask = 1 << REISERFS_UNSUPPORTED_OPT},\n\t\t{\"noacl\",.clrmask = 1 << REISERFS_UNSUPPORTED_OPT},\n#endif\n\t\t{.option_name = \"nolog\"},\n\t\t{\"replayonly\",.setmask = 1 << REPLAYONLY},\n\t\t{\"block-allocator\",.arg_required = 'a',.values = balloc},\n\t\t{\"data\",.arg_required = 'd',.values = logging_mode},\n\t\t{\"barrier\",.arg_required = 'b',.values = barrier_mode},\n\t\t{\"resize\",.arg_required = 'r',.values = NULL},\n\t\t{\"jdev\",.arg_required = 'j',.values = NULL},\n\t\t{\"nolargeio\",.arg_required = 'w',.values = NULL},\n\t\t{\"commit\",.arg_required = 'c',.values = NULL},\n\t\t{\"usrquota\",.setmask = 1 << REISERFS_USRQUOTA},\n\t\t{\"grpquota\",.setmask = 1 << REISERFS_GRPQUOTA},\n\t\t{\"noquota\",.clrmask = 1 << REISERFS_USRQUOTA | 1 << REISERFS_GRPQUOTA},\n\t\t{\"errors\",.arg_required = 'e',.values = error_actions},\n\t\t{\"usrjquota\",.arg_required =\n\t\t 'u' | (1 << REISERFS_OPT_ALLOWEMPTY),.values = NULL},\n\t\t{\"grpjquota\",.arg_required =\n\t\t 'g' | (1 << REISERFS_OPT_ALLOWEMPTY),.values = NULL},\n\t\t{\"jqfmt\",.arg_required = 'f',.values = NULL},\n\t\t{.option_name = NULL}\n\t};\n\n\t*blocks = 0;\n\tif (!options || !*options)\n\t\t/*\n\t\t * use default configuration: create tails, journaling on, no\n\t\t * conversion to newest format\n\t\t */\n\t\treturn 1;\n\n\tfor (pos = options; pos;) {\n\t\tc = reiserfs_getopt(s, &pos, opts, &arg, mount_options);\n\t\tif (c == -1)\n\t\t\t/* wrong option is given */\n\t\t\treturn 0;\n\n\t\tif (c == 'r') {\n\t\t\tchar *p;\n\n\t\t\tp = NULL;\n\t\t\t/* \"resize=NNN\" or \"resize=auto\" */\n\n\t\t\tif (!strcmp(arg, \"auto\")) {\n\t\t\t\t/* From JFS code, to auto-get the size. */\n\t\t\t\t*blocks =\n\t\t\t\t    s->s_bdev->bd_inode->i_size >> s->\n\t\t\t\t    s_blocksize_bits;\n\t\t\t} else {\n\t\t\t\t*blocks = simple_strtoul(arg, &p, 0);\n\t\t\t\tif (*p != '\\0') {\n\t\t\t\t\t/* NNN does not look like a number */\n\t\t\t\t\treiserfs_warning(s, \"super-6507\",\n\t\t\t\t\t\t\t \"bad value %s for \"\n\t\t\t\t\t\t\t \"-oresize\\n\", arg);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (c == 'c') {\n\t\t\tchar *p = NULL;\n\t\t\tunsigned long val = simple_strtoul(arg, &p, 0);\n\t\t\t/* commit=NNN (time in seconds) */\n\t\t\tif (*p != '\\0' || val >= (unsigned int)-1) {\n\t\t\t\treiserfs_warning(s, \"super-6508\",\n\t\t\t\t\t\t \"bad value %s for -ocommit\\n\",\n\t\t\t\t\t\t arg);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t*commit_max_age = (unsigned int)val;\n\t\t}\n\n\t\tif (c == 'w') {\n\t\t\treiserfs_warning(s, \"super-6509\", \"nolargeio option \"\n\t\t\t\t\t \"is no longer supported\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (c == 'j') {\n\t\t\tif (arg && *arg && jdev_name) {\n\t\t\t\t/* Hm, already assigned? */\n\t\t\t\tif (*jdev_name) {\n\t\t\t\t\treiserfs_warning(s, \"super-6510\",\n\t\t\t\t\t\t\t \"journal device was \"\n\t\t\t\t\t\t\t \"already specified to \"\n\t\t\t\t\t\t\t \"be %s\", *jdev_name);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t*jdev_name = arg;\n\t\t\t}\n\t\t}\n#ifdef CONFIG_QUOTA\n\t\tif (c == 'u' || c == 'g') {\n\t\t\tint qtype = c == 'u' ? USRQUOTA : GRPQUOTA;\n\n\t\t\tif (sb_any_quota_loaded(s) &&\n\t\t\t    (!*arg != !REISERFS_SB(s)->s_qf_names[qtype])) {\n\t\t\t\treiserfs_warning(s, \"super-6511\",\n\t\t\t\t\t\t \"cannot change journaled \"\n\t\t\t\t\t\t \"quota options when quota \"\n\t\t\t\t\t\t \"turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (*arg) {\t/* Some filename specified? */\n\t\t\t\tif (REISERFS_SB(s)->s_qf_names[qtype]\n\t\t\t\t    && strcmp(REISERFS_SB(s)->s_qf_names[qtype],\n\t\t\t\t\t      arg)) {\n\t\t\t\t\treiserfs_warning(s, \"super-6512\",\n\t\t\t\t\t\t\t \"%s quota file \"\n\t\t\t\t\t\t\t \"already specified.\",\n\t\t\t\t\t\t\t QTYPE2NAME(qtype));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (strchr(arg, '/')) {\n\t\t\t\t\treiserfs_warning(s, \"super-6513\",\n\t\t\t\t\t\t\t \"quotafile must be \"\n\t\t\t\t\t\t\t \"on filesystem root.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tqf_names[qtype] = kstrdup(arg, GFP_KERNEL);\n\t\t\t\tif (!qf_names[qtype]) {\n\t\t\t\t\treiserfs_warning(s, \"reiserfs-2502\",\n\t\t\t\t\t\t\t \"not enough memory \"\n\t\t\t\t\t\t\t \"for storing \"\n\t\t\t\t\t\t\t \"quotafile name.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (qtype == USRQUOTA)\n\t\t\t\t\t*mount_options |= 1 << REISERFS_USRQUOTA;\n\t\t\t\telse\n\t\t\t\t\t*mount_options |= 1 << REISERFS_GRPQUOTA;\n\t\t\t} else {\n\t\t\t\tif (qf_names[qtype] !=\n\t\t\t\t    REISERFS_SB(s)->s_qf_names[qtype])\n\t\t\t\t\tkfree(qf_names[qtype]);\n\t\t\t\tqf_names[qtype] = NULL;\n\t\t\t\tif (qtype == USRQUOTA)\n\t\t\t\t\t*mount_options &= ~(1 << REISERFS_USRQUOTA);\n\t\t\t\telse\n\t\t\t\t\t*mount_options &= ~(1 << REISERFS_GRPQUOTA);\n\t\t\t}\n\t\t}\n\t\tif (c == 'f') {\n\t\t\tif (!strcmp(arg, \"vfsold\"))\n\t\t\t\t*qfmt = QFMT_VFS_OLD;\n\t\t\telse if (!strcmp(arg, \"vfsv0\"))\n\t\t\t\t*qfmt = QFMT_VFS_V0;\n\t\t\telse {\n\t\t\t\treiserfs_warning(s, \"super-6514\",\n\t\t\t\t\t\t \"unknown quota format \"\n\t\t\t\t\t\t \"specified.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (sb_any_quota_loaded(s) &&\n\t\t\t    *qfmt != REISERFS_SB(s)->s_jquota_fmt) {\n\t\t\t\treiserfs_warning(s, \"super-6515\",\n\t\t\t\t\t\t \"cannot change journaled \"\n\t\t\t\t\t\t \"quota options when quota \"\n\t\t\t\t\t\t \"turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n#else\n\t\tif (c == 'u' || c == 'g' || c == 'f') {\n\t\t\treiserfs_warning(s, \"reiserfs-2503\", \"journaled \"\n\t\t\t\t\t \"quota options not supported.\");\n\t\t\treturn 0;\n\t\t}\n#endif\n\t}\n\n#ifdef CONFIG_QUOTA\n\tif (!REISERFS_SB(s)->s_jquota_fmt && !*qfmt\n\t    && (qf_names[USRQUOTA] || qf_names[GRPQUOTA])) {\n\t\treiserfs_warning(s, \"super-6515\",\n\t\t\t\t \"journaled quota format not specified.\");\n\t\treturn 0;\n\t}\n\tif ((!(*mount_options & (1 << REISERFS_USRQUOTA)) &&\n\t       sb_has_quota_loaded(s, USRQUOTA)) ||\n\t    (!(*mount_options & (1 << REISERFS_GRPQUOTA)) &&\n\t       sb_has_quota_loaded(s, GRPQUOTA))) {\n\t\treiserfs_warning(s, \"super-6516\", \"quota options must \"\n\t\t\t\t \"be present when quota is turned on.\");\n\t\treturn 0;\n\t}\n#endif\n\n\treturn 1;\n}"
  },
  {
    "function_name": "reiserfs_getopt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "931-1060",
    "snippet": "static int reiserfs_getopt(struct super_block *s, char **cur, opt_desc_t * opts,\n\t\t\t   char **opt_arg, unsigned long *bit_flags)\n{\n\tchar *p;\n\t/*\n\t * foo=bar,\n\t * ^   ^  ^\n\t * |   |  +-- option_end\n\t * |   +-- arg_start\n\t * +-- option_start\n\t */\n\tconst opt_desc_t *opt;\n\tconst arg_desc_t *arg;\n\n\tp = *cur;\n\n\t/* assume argument cannot contain commas */\n\t*cur = strchr(p, ',');\n\tif (*cur) {\n\t\t*(*cur) = '\\0';\n\t\t(*cur)++;\n\t}\n\n\tif (!strncmp(p, \"alloc=\", 6)) {\n\t\t/*\n\t\t * Ugly special case, probably we should redo options\n\t\t * parser so that it can understand several arguments for\n\t\t * some options, also so that it can fill several bitfields\n\t\t * with option values.\n\t\t */\n\t\tif (reiserfs_parse_alloc_options(s, p + 6)) {\n\t\t\treturn -1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* for every option in the list */\n\tfor (opt = opts; opt->option_name; opt++) {\n\t\tif (!strncmp(p, opt->option_name, strlen(opt->option_name))) {\n\t\t\tif (bit_flags) {\n\t\t\t\tif (opt->clrmask ==\n\t\t\t\t    (1 << REISERFS_UNSUPPORTED_OPT))\n\t\t\t\t\treiserfs_warning(s, \"super-6500\",\n\t\t\t\t\t\t\t \"%s not supported.\\n\",\n\t\t\t\t\t\t\t p);\n\t\t\t\telse\n\t\t\t\t\t*bit_flags &= ~opt->clrmask;\n\t\t\t\tif (opt->setmask ==\n\t\t\t\t    (1 << REISERFS_UNSUPPORTED_OPT))\n\t\t\t\t\treiserfs_warning(s, \"super-6501\",\n\t\t\t\t\t\t\t \"%s not supported.\\n\",\n\t\t\t\t\t\t\t p);\n\t\t\t\telse\n\t\t\t\t\t*bit_flags |= opt->setmask;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!opt->option_name) {\n\t\treiserfs_warning(s, \"super-6502\",\n\t\t\t\t \"unknown mount option \\\"%s\\\"\", p);\n\t\treturn -1;\n\t}\n\n\tp += strlen(opt->option_name);\n\tswitch (*p) {\n\tcase '=':\n\t\tif (!opt->arg_required) {\n\t\t\treiserfs_warning(s, \"super-6503\",\n\t\t\t\t\t \"the option \\\"%s\\\" does not \"\n\t\t\t\t\t \"require an argument\\n\",\n\t\t\t\t\t opt->option_name);\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\n\tcase 0:\n\t\tif (opt->arg_required) {\n\t\t\treiserfs_warning(s, \"super-6504\",\n\t\t\t\t\t \"the option \\\"%s\\\" requires an \"\n\t\t\t\t\t \"argument\\n\", opt->option_name);\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treiserfs_warning(s, \"super-6505\",\n\t\t\t\t \"head of option \\\"%s\\\" is only correct\\n\",\n\t\t\t\t opt->option_name);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * move to the argument, or to next option if argument is not\n\t * required\n\t */\n\tp++;\n\n\tif (opt->arg_required\n\t    && !(opt->arg_required & (1 << REISERFS_OPT_ALLOWEMPTY))\n\t    && !strlen(p)) {\n\t\t/* this catches \"option=,\" if not allowed */\n\t\treiserfs_warning(s, \"super-6506\",\n\t\t\t\t \"empty argument for \\\"%s\\\"\\n\",\n\t\t\t\t opt->option_name);\n\t\treturn -1;\n\t}\n\n\tif (!opt->values) {\n\t\t/* *=NULLopt_arg contains pointer to argument */\n\t\t*opt_arg = p;\n\t\treturn opt->arg_required & ~(1 << REISERFS_OPT_ALLOWEMPTY);\n\t}\n\n\t/* values possible for this option are listed in opt->values */\n\tfor (arg = opt->values; arg->value; arg++) {\n\t\tif (!strcmp(p, arg->value)) {\n\t\t\tif (bit_flags) {\n\t\t\t\t*bit_flags &= ~arg->clrmask;\n\t\t\t\t*bit_flags |= arg->setmask;\n\t\t\t}\n\t\t\treturn opt->arg_required;\n\t\t}\n\t}\n\n\treiserfs_warning(s, \"super-6506\",\n\t\t\t \"bad value \\\"%s\\\" for option \\\"%s\\\"\\n\", p,\n\t\t\t opt->option_name);\n\treturn -1;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define REISERFS_OPT_ALLOWEMPTY 31"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"super-6506\"",
            "\"bad value \\\"%s\\\" for option \\\"%s\\\"\\n\"",
            "p",
            "opt->option_name"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "arg->value"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "292-301",
          "snippet": "static int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/string.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "p",
            "opt->option_name",
            "strlen(opt->option_name)"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_parse_alloc_options",
          "args": [
            "s",
            "p + 6"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_parse_alloc_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "566-673",
          "snippet": "int reiserfs_parse_alloc_options(struct super_block *s, char *options)\n{\n\tchar *this_char, *value;\n\n\t/* clear default settings */\n\tREISERFS_SB(s)->s_alloc_options.bits = 0;\n\n\twhile ((this_char = strsep(&options, \":\")) != NULL) {\n\t\tif ((value = strchr(this_char, '=')) != NULL)\n\t\t\t*value++ = 0;\n\n\t\tif (!strcmp(this_char, \"concentrating_formatted_nodes\")) {\n\t\t\tint temp;\n\t\t\tSET_OPTION(concentrating_formatted_nodes);\n\t\t\ttemp = (value\n\t\t\t\t&& *value) ? simple_strtoul(value, &value,\n\t\t\t\t\t\t\t    0) : 10;\n\t\t\tif (temp <= 0 || temp > 100) {\n\t\t\t\tREISERFS_SB(s)->s_alloc_options.border = 10;\n\t\t\t} else {\n\t\t\t\tREISERFS_SB(s)->s_alloc_options.border =\n\t\t\t\t    100 / temp;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(this_char, \"displacing_large_files\")) {\n\t\t\tSET_OPTION(displacing_large_files);\n\t\t\tREISERFS_SB(s)->s_alloc_options.large_file_size =\n\t\t\t    (value\n\t\t\t     && *value) ? simple_strtoul(value, &value, 0) : 16;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(this_char, \"displacing_new_packing_localities\")) {\n\t\t\tSET_OPTION(displacing_new_packing_localities);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"old_hashed_relocation\")) {\n\t\t\tSET_OPTION(old_hashed_relocation);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"new_hashed_relocation\")) {\n\t\t\tSET_OPTION(new_hashed_relocation);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"dirid_groups\")) {\n\t\t\tSET_OPTION(dirid_groups);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(this_char, \"oid_groups\")) {\n\t\t\tSET_OPTION(oid_groups);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(this_char, \"packing_groups\")) {\n\t\t\tSET_OPTION(packing_groups);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(this_char, \"hashed_formatted_nodes\")) {\n\t\t\tSET_OPTION(hashed_formatted_nodes);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"skip_busy\")) {\n\t\t\tSET_OPTION(skip_busy);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"hundredth_slices\")) {\n\t\t\tSET_OPTION(hundredth_slices);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"old_way\")) {\n\t\t\tSET_OPTION(old_way);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"displace_based_on_dirid\")) {\n\t\t\tSET_OPTION(displace_based_on_dirid);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"preallocmin\")) {\n\t\t\tREISERFS_SB(s)->s_alloc_options.preallocmin =\n\t\t\t    (value\n\t\t\t     && *value) ? simple_strtoul(value, &value, 0) : 4;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"preallocsize\")) {\n\t\t\tREISERFS_SB(s)->s_alloc_options.preallocsize =\n\t\t\t    (value\n\t\t\t     && *value) ? simple_strtoul(value, &value,\n\t\t\t\t\t\t\t 0) :\n\t\t\t    PREALLOCATION_SIZE;\n\t\t\tcontinue;\n\t\t}\n\n\t\treiserfs_warning(s, \"zam-4001\", \"unknown option - %s\",\n\t\t\t\t this_char);\n\t\treturn 1;\n\t}\n\n\treiserfs_info(s, \"allocator options = [%08x]\\n\", SB_ALLOC_OPTS(s));\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define PREALLOCATION_SIZE 9"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\n#define PREALLOCATION_SIZE 9\n\nint reiserfs_parse_alloc_options(struct super_block *s, char *options)\n{\n\tchar *this_char, *value;\n\n\t/* clear default settings */\n\tREISERFS_SB(s)->s_alloc_options.bits = 0;\n\n\twhile ((this_char = strsep(&options, \":\")) != NULL) {\n\t\tif ((value = strchr(this_char, '=')) != NULL)\n\t\t\t*value++ = 0;\n\n\t\tif (!strcmp(this_char, \"concentrating_formatted_nodes\")) {\n\t\t\tint temp;\n\t\t\tSET_OPTION(concentrating_formatted_nodes);\n\t\t\ttemp = (value\n\t\t\t\t&& *value) ? simple_strtoul(value, &value,\n\t\t\t\t\t\t\t    0) : 10;\n\t\t\tif (temp <= 0 || temp > 100) {\n\t\t\t\tREISERFS_SB(s)->s_alloc_options.border = 10;\n\t\t\t} else {\n\t\t\t\tREISERFS_SB(s)->s_alloc_options.border =\n\t\t\t\t    100 / temp;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(this_char, \"displacing_large_files\")) {\n\t\t\tSET_OPTION(displacing_large_files);\n\t\t\tREISERFS_SB(s)->s_alloc_options.large_file_size =\n\t\t\t    (value\n\t\t\t     && *value) ? simple_strtoul(value, &value, 0) : 16;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(this_char, \"displacing_new_packing_localities\")) {\n\t\t\tSET_OPTION(displacing_new_packing_localities);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"old_hashed_relocation\")) {\n\t\t\tSET_OPTION(old_hashed_relocation);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"new_hashed_relocation\")) {\n\t\t\tSET_OPTION(new_hashed_relocation);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"dirid_groups\")) {\n\t\t\tSET_OPTION(dirid_groups);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(this_char, \"oid_groups\")) {\n\t\t\tSET_OPTION(oid_groups);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(this_char, \"packing_groups\")) {\n\t\t\tSET_OPTION(packing_groups);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(this_char, \"hashed_formatted_nodes\")) {\n\t\t\tSET_OPTION(hashed_formatted_nodes);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"skip_busy\")) {\n\t\t\tSET_OPTION(skip_busy);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"hundredth_slices\")) {\n\t\t\tSET_OPTION(hundredth_slices);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"old_way\")) {\n\t\t\tSET_OPTION(old_way);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"displace_based_on_dirid\")) {\n\t\t\tSET_OPTION(displace_based_on_dirid);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"preallocmin\")) {\n\t\t\tREISERFS_SB(s)->s_alloc_options.preallocmin =\n\t\t\t    (value\n\t\t\t     && *value) ? simple_strtoul(value, &value, 0) : 4;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"preallocsize\")) {\n\t\t\tREISERFS_SB(s)->s_alloc_options.preallocsize =\n\t\t\t    (value\n\t\t\t     && *value) ? simple_strtoul(value, &value,\n\t\t\t\t\t\t\t 0) :\n\t\t\t    PREALLOCATION_SIZE;\n\t\t\tcontinue;\n\t\t}\n\n\t\treiserfs_warning(s, \"zam-4001\", \"unknown option - %s\",\n\t\t\t\t this_char);\n\t\treturn 1;\n\t}\n\n\treiserfs_info(s, \"allocator options = [%08x]\\n\", SB_ALLOC_OPTS(s));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "p",
            "\"alloc=\"",
            "6"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "','"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define REISERFS_OPT_ALLOWEMPTY 31\n\nstatic int reiserfs_getopt(struct super_block *s, char **cur, opt_desc_t * opts,\n\t\t\t   char **opt_arg, unsigned long *bit_flags)\n{\n\tchar *p;\n\t/*\n\t * foo=bar,\n\t * ^   ^  ^\n\t * |   |  +-- option_end\n\t * |   +-- arg_start\n\t * +-- option_start\n\t */\n\tconst opt_desc_t *opt;\n\tconst arg_desc_t *arg;\n\n\tp = *cur;\n\n\t/* assume argument cannot contain commas */\n\t*cur = strchr(p, ',');\n\tif (*cur) {\n\t\t*(*cur) = '\\0';\n\t\t(*cur)++;\n\t}\n\n\tif (!strncmp(p, \"alloc=\", 6)) {\n\t\t/*\n\t\t * Ugly special case, probably we should redo options\n\t\t * parser so that it can understand several arguments for\n\t\t * some options, also so that it can fill several bitfields\n\t\t * with option values.\n\t\t */\n\t\tif (reiserfs_parse_alloc_options(s, p + 6)) {\n\t\t\treturn -1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* for every option in the list */\n\tfor (opt = opts; opt->option_name; opt++) {\n\t\tif (!strncmp(p, opt->option_name, strlen(opt->option_name))) {\n\t\t\tif (bit_flags) {\n\t\t\t\tif (opt->clrmask ==\n\t\t\t\t    (1 << REISERFS_UNSUPPORTED_OPT))\n\t\t\t\t\treiserfs_warning(s, \"super-6500\",\n\t\t\t\t\t\t\t \"%s not supported.\\n\",\n\t\t\t\t\t\t\t p);\n\t\t\t\telse\n\t\t\t\t\t*bit_flags &= ~opt->clrmask;\n\t\t\t\tif (opt->setmask ==\n\t\t\t\t    (1 << REISERFS_UNSUPPORTED_OPT))\n\t\t\t\t\treiserfs_warning(s, \"super-6501\",\n\t\t\t\t\t\t\t \"%s not supported.\\n\",\n\t\t\t\t\t\t\t p);\n\t\t\t\telse\n\t\t\t\t\t*bit_flags |= opt->setmask;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!opt->option_name) {\n\t\treiserfs_warning(s, \"super-6502\",\n\t\t\t\t \"unknown mount option \\\"%s\\\"\", p);\n\t\treturn -1;\n\t}\n\n\tp += strlen(opt->option_name);\n\tswitch (*p) {\n\tcase '=':\n\t\tif (!opt->arg_required) {\n\t\t\treiserfs_warning(s, \"super-6503\",\n\t\t\t\t\t \"the option \\\"%s\\\" does not \"\n\t\t\t\t\t \"require an argument\\n\",\n\t\t\t\t\t opt->option_name);\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\n\tcase 0:\n\t\tif (opt->arg_required) {\n\t\t\treiserfs_warning(s, \"super-6504\",\n\t\t\t\t\t \"the option \\\"%s\\\" requires an \"\n\t\t\t\t\t \"argument\\n\", opt->option_name);\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treiserfs_warning(s, \"super-6505\",\n\t\t\t\t \"head of option \\\"%s\\\" is only correct\\n\",\n\t\t\t\t opt->option_name);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * move to the argument, or to next option if argument is not\n\t * required\n\t */\n\tp++;\n\n\tif (opt->arg_required\n\t    && !(opt->arg_required & (1 << REISERFS_OPT_ALLOWEMPTY))\n\t    && !strlen(p)) {\n\t\t/* this catches \"option=,\" if not allowed */\n\t\treiserfs_warning(s, \"super-6506\",\n\t\t\t\t \"empty argument for \\\"%s\\\"\\n\",\n\t\t\t\t opt->option_name);\n\t\treturn -1;\n\t}\n\n\tif (!opt->values) {\n\t\t/* *=NULLopt_arg contains pointer to argument */\n\t\t*opt_arg = p;\n\t\treturn opt->arg_required & ~(1 << REISERFS_OPT_ALLOWEMPTY);\n\t}\n\n\t/* values possible for this option are listed in opt->values */\n\tfor (arg = opt->values; arg->value; arg++) {\n\t\tif (!strcmp(p, arg->value)) {\n\t\t\tif (bit_flags) {\n\t\t\t\t*bit_flags &= ~arg->clrmask;\n\t\t\t\t*bit_flags |= arg->setmask;\n\t\t\t}\n\t\t\treturn opt->arg_required;\n\t\t}\n\t}\n\n\treiserfs_warning(s, \"super-6506\",\n\t\t\t \"bad value \\\"%s\\\" for option \\\"%s\\\"\\n\", p,\n\t\t\t opt->option_name);\n\treturn -1;\n}"
  },
  {
    "function_name": "reiserfs_get_dquots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "758-761",
    "snippet": "static struct dquot **reiserfs_get_dquots(struct inode *inode)\n{\n\treturn REISERFS_I(inode)->i_dquot;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic struct dquot **reiserfs_get_dquots(struct inode *inode)\n{\n\treturn REISERFS_I(inode)->i_dquot;\n}"
  },
  {
    "function_name": "reiserfs_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "676-750",
    "snippet": "static int reiserfs_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct super_block *s = root->d_sb;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tlong opts = REISERFS_SB(s)->s_mount_opt;\n\n\tif (opts & (1 << REISERFS_LARGETAIL))\n\t\tseq_puts(seq, \",tails=on\");\n\telse if (!(opts & (1 << REISERFS_SMALLTAIL)))\n\t\tseq_puts(seq, \",notail\");\n\t/* tails=small is default so we don't show it */\n\n\tif (!(opts & (1 << REISERFS_BARRIER_FLUSH)))\n\t\tseq_puts(seq, \",barrier=none\");\n\t/* barrier=flush is default so we don't show it */\n\n\tif (opts & (1 << REISERFS_ERROR_CONTINUE))\n\t\tseq_puts(seq, \",errors=continue\");\n\telse if (opts & (1 << REISERFS_ERROR_PANIC))\n\t\tseq_puts(seq, \",errors=panic\");\n\t/* errors=ro is default so we don't show it */\n\n\tif (opts & (1 << REISERFS_DATA_LOG))\n\t\tseq_puts(seq, \",data=journal\");\n\telse if (opts & (1 << REISERFS_DATA_WRITEBACK))\n\t\tseq_puts(seq, \",data=writeback\");\n\t/* data=ordered is default so we don't show it */\n\n\tif (opts & (1 << REISERFS_ATTRS))\n\t\tseq_puts(seq, \",attrs\");\n\n\tif (opts & (1 << REISERFS_XATTRS_USER))\n\t\tseq_puts(seq, \",user_xattr\");\n\n\tif (opts & (1 << REISERFS_EXPOSE_PRIVROOT))\n\t\tseq_puts(seq, \",expose_privroot\");\n\n\tif (opts & (1 << REISERFS_POSIXACL))\n\t\tseq_puts(seq, \",acl\");\n\n\tif (REISERFS_SB(s)->s_jdev)\n\t\tseq_printf(seq, \",jdev=%s\", REISERFS_SB(s)->s_jdev);\n\n\tif (journal->j_max_commit_age != journal->j_default_max_commit_age)\n\t\tseq_printf(seq, \",commit=%d\", journal->j_max_commit_age);\n\n#ifdef CONFIG_QUOTA\n\tif (REISERFS_SB(s)->s_qf_names[USRQUOTA])\n\t\tseq_printf(seq, \",usrjquota=%s\", REISERFS_SB(s)->s_qf_names[USRQUOTA]);\n\telse if (opts & (1 << REISERFS_USRQUOTA))\n\t\tseq_puts(seq, \",usrquota\");\n\tif (REISERFS_SB(s)->s_qf_names[GRPQUOTA])\n\t\tseq_printf(seq, \",grpjquota=%s\", REISERFS_SB(s)->s_qf_names[GRPQUOTA]);\n\telse if (opts & (1 << REISERFS_GRPQUOTA))\n\t\tseq_puts(seq, \",grpquota\");\n\tif (REISERFS_SB(s)->s_jquota_fmt) {\n\t\tif (REISERFS_SB(s)->s_jquota_fmt == QFMT_VFS_OLD)\n\t\t\tseq_puts(seq, \",jqfmt=vfsold\");\n\t\telse if (REISERFS_SB(s)->s_jquota_fmt == QFMT_VFS_V0)\n\t\t\tseq_puts(seq, \",jqfmt=vfsv0\");\n\t}\n#endif\n\n\t/* Block allocator options */\n\tif (opts & (1 << REISERFS_NO_BORDER))\n\t\tseq_puts(seq, \",block-allocator=noborder\");\n\tif (opts & (1 << REISERFS_NO_UNHASHED_RELOCATION))\n\t\tseq_puts(seq, \",block-allocator=no_unhashed_relocation\");\n\tif (opts & (1 << REISERFS_HASHED_RELOCATION))\n\t\tseq_puts(seq, \",block-allocator=hashed_relocation\");\n\tif (opts & (1 << REISERFS_TEST4))\n\t\tseq_puts(seq, \",block-allocator=test4\");\n\tshow_alloc_options(seq, s);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int reiserfs_remount(struct super_block *s, int *flags, char *data);",
      "static const arg_desc_t tails[] = {\n\t{\"on\", 1 << REISERFS_LARGETAIL, 1 << REISERFS_SMALLTAIL},\n\t{\"off\", 0, (1 << REISERFS_LARGETAIL) | (1 << REISERFS_SMALLTAIL)},\n\t{\"small\", 1 << REISERFS_SMALLTAIL, 1 << REISERFS_LARGETAIL},\n\t{NULL, 0, 0}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_alloc_options",
          "args": [
            "seq",
            "s"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "show_alloc_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "683-763",
          "snippet": "void show_alloc_options(struct seq_file *seq, struct super_block *s)\n{\n\tint first = 1;\n\n\tif (SB_ALLOC_OPTS(s) == ((1 << _ALLOC_skip_busy) |\n\t\t(1 << _ALLOC_dirid_groups) | (1 << _ALLOC_packing_groups)))\n\t\treturn;\n\n\tseq_puts(seq, \",alloc=\");\n\n\tif (TEST_OPTION(concentrating_formatted_nodes, s)) {\n\t\tprint_sep(seq, &first);\n\t\tif (REISERFS_SB(s)->s_alloc_options.border != 10) {\n\t\t\tseq_printf(seq, \"concentrating_formatted_nodes=%d\",\n\t\t\t\t100 / REISERFS_SB(s)->s_alloc_options.border);\n\t\t} else\n\t\t\tseq_puts(seq, \"concentrating_formatted_nodes\");\n\t}\n\tif (TEST_OPTION(displacing_large_files, s)) {\n\t\tprint_sep(seq, &first);\n\t\tif (REISERFS_SB(s)->s_alloc_options.large_file_size != 16) {\n\t\t\tseq_printf(seq, \"displacing_large_files=%lu\",\n\t\t\t    REISERFS_SB(s)->s_alloc_options.large_file_size);\n\t\t} else\n\t\t\tseq_puts(seq, \"displacing_large_files\");\n\t}\n\tif (TEST_OPTION(displacing_new_packing_localities, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"displacing_new_packing_localities\");\n\t}\n\tif (TEST_OPTION(old_hashed_relocation, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"old_hashed_relocation\");\n\t}\n\tif (TEST_OPTION(new_hashed_relocation, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"new_hashed_relocation\");\n\t}\n\tif (TEST_OPTION(dirid_groups, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"dirid_groups\");\n\t}\n\tif (TEST_OPTION(oid_groups, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"oid_groups\");\n\t}\n\tif (TEST_OPTION(packing_groups, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"packing_groups\");\n\t}\n\tif (TEST_OPTION(hashed_formatted_nodes, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"hashed_formatted_nodes\");\n\t}\n\tif (TEST_OPTION(skip_busy, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"skip_busy\");\n\t}\n\tif (TEST_OPTION(hundredth_slices, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"hundredth_slices\");\n\t}\n\tif (TEST_OPTION(old_way, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"old_way\");\n\t}\n\tif (TEST_OPTION(displace_based_on_dirid, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"displace_based_on_dirid\");\n\t}\n\tif (REISERFS_SB(s)->s_alloc_options.preallocmin != 0) {\n\t\tprint_sep(seq, &first);\n\t\tseq_printf(seq, \"preallocmin=%d\",\n\t\t\t\tREISERFS_SB(s)->s_alloc_options.preallocmin);\n\t}\n\tif (REISERFS_SB(s)->s_alloc_options.preallocsize != 17) {\n\t\tprint_sep(seq, &first);\n\t\tseq_printf(seq, \"preallocsize=%d\",\n\t\t\t\tREISERFS_SB(s)->s_alloc_options.preallocsize);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define  _ALLOC_packing_groups 12",
            "#define  _ALLOC_dirid_groups 10",
            "#define  _ALLOC_skip_busy 5"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\n#define  _ALLOC_packing_groups 12\n#define  _ALLOC_dirid_groups 10\n#define  _ALLOC_skip_busy 5\n\nvoid show_alloc_options(struct seq_file *seq, struct super_block *s)\n{\n\tint first = 1;\n\n\tif (SB_ALLOC_OPTS(s) == ((1 << _ALLOC_skip_busy) |\n\t\t(1 << _ALLOC_dirid_groups) | (1 << _ALLOC_packing_groups)))\n\t\treturn;\n\n\tseq_puts(seq, \",alloc=\");\n\n\tif (TEST_OPTION(concentrating_formatted_nodes, s)) {\n\t\tprint_sep(seq, &first);\n\t\tif (REISERFS_SB(s)->s_alloc_options.border != 10) {\n\t\t\tseq_printf(seq, \"concentrating_formatted_nodes=%d\",\n\t\t\t\t100 / REISERFS_SB(s)->s_alloc_options.border);\n\t\t} else\n\t\t\tseq_puts(seq, \"concentrating_formatted_nodes\");\n\t}\n\tif (TEST_OPTION(displacing_large_files, s)) {\n\t\tprint_sep(seq, &first);\n\t\tif (REISERFS_SB(s)->s_alloc_options.large_file_size != 16) {\n\t\t\tseq_printf(seq, \"displacing_large_files=%lu\",\n\t\t\t    REISERFS_SB(s)->s_alloc_options.large_file_size);\n\t\t} else\n\t\t\tseq_puts(seq, \"displacing_large_files\");\n\t}\n\tif (TEST_OPTION(displacing_new_packing_localities, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"displacing_new_packing_localities\");\n\t}\n\tif (TEST_OPTION(old_hashed_relocation, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"old_hashed_relocation\");\n\t}\n\tif (TEST_OPTION(new_hashed_relocation, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"new_hashed_relocation\");\n\t}\n\tif (TEST_OPTION(dirid_groups, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"dirid_groups\");\n\t}\n\tif (TEST_OPTION(oid_groups, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"oid_groups\");\n\t}\n\tif (TEST_OPTION(packing_groups, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"packing_groups\");\n\t}\n\tif (TEST_OPTION(hashed_formatted_nodes, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"hashed_formatted_nodes\");\n\t}\n\tif (TEST_OPTION(skip_busy, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"skip_busy\");\n\t}\n\tif (TEST_OPTION(hundredth_slices, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"hundredth_slices\");\n\t}\n\tif (TEST_OPTION(old_way, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"old_way\");\n\t}\n\tif (TEST_OPTION(displace_based_on_dirid, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"displace_based_on_dirid\");\n\t}\n\tif (REISERFS_SB(s)->s_alloc_options.preallocmin != 0) {\n\t\tprint_sep(seq, &first);\n\t\tseq_printf(seq, \"preallocmin=%d\",\n\t\t\t\tREISERFS_SB(s)->s_alloc_options.preallocmin);\n\t}\n\tif (REISERFS_SB(s)->s_alloc_options.preallocsize != 17) {\n\t\tprint_sep(seq, &first);\n\t\tseq_printf(seq, \"preallocsize=%d\",\n\t\t\t\tREISERFS_SB(s)->s_alloc_options.preallocsize);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\",block-allocator=test4\""
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "s"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\",grpjquota=%s\"",
            "REISERFS_SB(s)->s_qf_names[GRPQUOTA]"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "s"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int reiserfs_remount(struct super_block *s, int *flags, char *data);\nstatic const arg_desc_t tails[] = {\n\t{\"on\", 1 << REISERFS_LARGETAIL, 1 << REISERFS_SMALLTAIL},\n\t{\"off\", 0, (1 << REISERFS_LARGETAIL) | (1 << REISERFS_SMALLTAIL)},\n\t{\"small\", 1 << REISERFS_SMALLTAIL, 1 << REISERFS_LARGETAIL},\n\t{NULL, 0, 0}\n};\n\nstatic int reiserfs_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct super_block *s = root->d_sb;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tlong opts = REISERFS_SB(s)->s_mount_opt;\n\n\tif (opts & (1 << REISERFS_LARGETAIL))\n\t\tseq_puts(seq, \",tails=on\");\n\telse if (!(opts & (1 << REISERFS_SMALLTAIL)))\n\t\tseq_puts(seq, \",notail\");\n\t/* tails=small is default so we don't show it */\n\n\tif (!(opts & (1 << REISERFS_BARRIER_FLUSH)))\n\t\tseq_puts(seq, \",barrier=none\");\n\t/* barrier=flush is default so we don't show it */\n\n\tif (opts & (1 << REISERFS_ERROR_CONTINUE))\n\t\tseq_puts(seq, \",errors=continue\");\n\telse if (opts & (1 << REISERFS_ERROR_PANIC))\n\t\tseq_puts(seq, \",errors=panic\");\n\t/* errors=ro is default so we don't show it */\n\n\tif (opts & (1 << REISERFS_DATA_LOG))\n\t\tseq_puts(seq, \",data=journal\");\n\telse if (opts & (1 << REISERFS_DATA_WRITEBACK))\n\t\tseq_puts(seq, \",data=writeback\");\n\t/* data=ordered is default so we don't show it */\n\n\tif (opts & (1 << REISERFS_ATTRS))\n\t\tseq_puts(seq, \",attrs\");\n\n\tif (opts & (1 << REISERFS_XATTRS_USER))\n\t\tseq_puts(seq, \",user_xattr\");\n\n\tif (opts & (1 << REISERFS_EXPOSE_PRIVROOT))\n\t\tseq_puts(seq, \",expose_privroot\");\n\n\tif (opts & (1 << REISERFS_POSIXACL))\n\t\tseq_puts(seq, \",acl\");\n\n\tif (REISERFS_SB(s)->s_jdev)\n\t\tseq_printf(seq, \",jdev=%s\", REISERFS_SB(s)->s_jdev);\n\n\tif (journal->j_max_commit_age != journal->j_default_max_commit_age)\n\t\tseq_printf(seq, \",commit=%d\", journal->j_max_commit_age);\n\n#ifdef CONFIG_QUOTA\n\tif (REISERFS_SB(s)->s_qf_names[USRQUOTA])\n\t\tseq_printf(seq, \",usrjquota=%s\", REISERFS_SB(s)->s_qf_names[USRQUOTA]);\n\telse if (opts & (1 << REISERFS_USRQUOTA))\n\t\tseq_puts(seq, \",usrquota\");\n\tif (REISERFS_SB(s)->s_qf_names[GRPQUOTA])\n\t\tseq_printf(seq, \",grpjquota=%s\", REISERFS_SB(s)->s_qf_names[GRPQUOTA]);\n\telse if (opts & (1 << REISERFS_GRPQUOTA))\n\t\tseq_puts(seq, \",grpquota\");\n\tif (REISERFS_SB(s)->s_jquota_fmt) {\n\t\tif (REISERFS_SB(s)->s_jquota_fmt == QFMT_VFS_OLD)\n\t\t\tseq_puts(seq, \",jqfmt=vfsold\");\n\t\telse if (REISERFS_SB(s)->s_jquota_fmt == QFMT_VFS_V0)\n\t\t\tseq_puts(seq, \",jqfmt=vfsv0\");\n\t}\n#endif\n\n\t/* Block allocator options */\n\tif (opts & (1 << REISERFS_NO_BORDER))\n\t\tseq_puts(seq, \",block-allocator=noborder\");\n\tif (opts & (1 << REISERFS_NO_UNHASHED_RELOCATION))\n\t\tseq_puts(seq, \",block-allocator=no_unhashed_relocation\");\n\tif (opts & (1 << REISERFS_HASHED_RELOCATION))\n\t\tseq_puts(seq, \",block-allocator=hashed_relocation\");\n\tif (opts & (1 << REISERFS_TEST4))\n\t\tseq_puts(seq, \",block-allocator=test4\");\n\tshow_alloc_options(seq, s);\n\treturn 0;\n}"
  },
  {
    "function_name": "reiserfs_dirty_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "647-674",
    "snippet": "static void reiserfs_dirty_inode(struct inode *inode, int flags)\n{\n\tstruct reiserfs_transaction_handle th;\n\n\tint err = 0;\n\n\tif (inode->i_sb->s_flags & MS_RDONLY) {\n\t\treiserfs_warning(inode->i_sb, \"clm-6006\",\n\t\t\t\t \"writing inode %lu on readonly FS\",\n\t\t\t\t inode->i_ino);\n\t\treturn;\n\t}\n\treiserfs_write_lock(inode->i_sb);\n\n\t/*\n\t * this is really only used for atime updates, so they don't have\n\t * to be included in O_SYNC or fsync\n\t */\n\terr = journal_begin(&th, inode->i_sb, 1);\n\tif (err)\n\t\tgoto out;\n\n\treiserfs_update_sd(&th, inode);\n\tjournal_end(&th);\n\nout:\n\treiserfs_write_unlock(inode->i_sb);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "inode->i_sb"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "&th"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_sd",
          "args": [
            "&th",
            "inode"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_sd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "3096-3100",
          "snippet": "static inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
            "int journal_end(struct reiserfs_transaction_handle *);",
            "int journal_end_sync(struct reiserfs_transaction_handle *);",
            "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
            "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "inode->i_sb",
            "1"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "inode->i_sb"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "inode->i_sb",
            "\"clm-6006\"",
            "\"writing inode %lu on readonly FS\"",
            "inode->i_ino"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void reiserfs_dirty_inode(struct inode *inode, int flags)\n{\n\tstruct reiserfs_transaction_handle th;\n\n\tint err = 0;\n\n\tif (inode->i_sb->s_flags & MS_RDONLY) {\n\t\treiserfs_warning(inode->i_sb, \"clm-6006\",\n\t\t\t\t \"writing inode %lu on readonly FS\",\n\t\t\t\t inode->i_ino);\n\t\treturn;\n\t}\n\treiserfs_write_lock(inode->i_sb);\n\n\t/*\n\t * this is really only used for atime updates, so they don't have\n\t * to be included in O_SYNC or fsync\n\t */\n\terr = journal_begin(&th, inode->i_sb, 1);\n\tif (err)\n\t\tgoto out;\n\n\treiserfs_update_sd(&th, inode);\n\tjournal_end(&th);\n\nout:\n\treiserfs_write_unlock(inode->i_sb);\n}"
  },
  {
    "function_name": "destroy_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "636-644",
    "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(reiserfs_inode_cachep);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *reiserfs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "reiserfs_inode_cachep"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *reiserfs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(reiserfs_inode_cachep);\n}"
  },
  {
    "function_name": "init_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "623-634",
    "snippet": "static int __init init_inodecache(void)\n{\n\treiserfs_inode_cachep = kmem_cache_create(\"reiser_inode_cache\",\n\t\t\t\t\t\t  sizeof(struct\n\t\t\t\t\t\t\t reiserfs_inode_info),\n\t\t\t\t\t\t  0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t\t  init_once);\n\tif (reiserfs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *reiserfs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"reiser_inode_cache\"",
            "sizeof(struct\n\t\t\t\t\t\t\t reiserfs_inode_info)",
            "0",
            "(SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\t\tSLAB_MEM_SPREAD)",
            "init_once"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *reiserfs_inode_cachep;\n\nstatic int __init init_inodecache(void)\n{\n\treiserfs_inode_cachep = kmem_cache_create(\"reiser_inode_cache\",\n\t\t\t\t\t\t  sizeof(struct\n\t\t\t\t\t\t\t reiserfs_inode_info),\n\t\t\t\t\t\t  0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t\t  init_once);\n\tif (reiserfs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "615-621",
    "snippet": "static void init_once(void *foo)\n{\n\tstruct reiserfs_inode_info *ei = (struct reiserfs_inode_info *)foo;\n\n\tINIT_LIST_HEAD(&ei->i_prealloc_list);\n\tinode_init_once(&ei->vfs_inode);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&ei->vfs_inode"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1725-1755",
          "snippet": "static void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_remount(struct super_block *sb, int *flags, char *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_remount(struct super_block *sb, int *flags, char *data);\n\nstatic void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ei->i_prealloc_list"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void init_once(void *foo)\n{\n\tstruct reiserfs_inode_info *ei = (struct reiserfs_inode_info *)foo;\n\n\tINIT_LIST_HEAD(&ei->i_prealloc_list);\n\tinode_init_once(&ei->vfs_inode);\n}"
  },
  {
    "function_name": "reiserfs_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "610-613",
    "snippet": "static void reiserfs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, reiserfs_i_callback);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "reiserfs_i_callback"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void reiserfs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, reiserfs_i_callback);\n}"
  },
  {
    "function_name": "reiserfs_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "604-608",
    "snippet": "static void reiserfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(reiserfs_inode_cachep, REISERFS_I(inode));\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *reiserfs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "reiserfs_inode_cachep",
            "REISERFS_I(inode)"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *reiserfs_inode_cachep;\n\nstatic void reiserfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(reiserfs_inode_cachep, REISERFS_I(inode));\n}"
  },
  {
    "function_name": "reiserfs_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "588-602",
    "snippet": "static struct inode *reiserfs_alloc_inode(struct super_block *sb)\n{\n\tstruct reiserfs_inode_info *ei;\n\tei = (struct reiserfs_inode_info *)\n\t    kmem_cache_alloc(reiserfs_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\tatomic_set(&ei->openers, 0);\n\tmutex_init(&ei->tailpack);\n#ifdef CONFIG_QUOTA\n\tmemset(&ei->i_dquot, 0, sizeof(ei->i_dquot));\n#endif\n\n\treturn &ei->vfs_inode;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *reiserfs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ei->i_dquot",
            "0",
            "sizeof(ei->i_dquot)"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ei->tailpack"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ei->openers",
            "0"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "reiserfs_inode_cachep",
            "GFP_KERNEL"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *reiserfs_inode_cachep;\n\nstatic struct inode *reiserfs_alloc_inode(struct super_block *sb)\n{\n\tstruct reiserfs_inode_info *ei;\n\tei = (struct reiserfs_inode_info *)\n\t    kmem_cache_alloc(reiserfs_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\tatomic_set(&ei->openers, 0);\n\tmutex_init(&ei->tailpack);\n#ifdef CONFIG_QUOTA\n\tmemset(&ei->i_dquot, 0, sizeof(ei->i_dquot));\n#endif\n\n\treturn &ei->vfs_inode;\n}"
  },
  {
    "function_name": "reiserfs_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "539-584",
    "snippet": "static void reiserfs_put_super(struct super_block *s)\n{\n\tstruct reiserfs_transaction_handle th;\n\tth.t_trans_id = 0;\n\n\tdquot_disable(s, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\n\treiserfs_write_lock(s);\n\n\t/*\n\t * change file system state to current state if it was mounted\n\t * with read-write permissions\n\t */\n\tif (!(s->s_flags & MS_RDONLY)) {\n\t\tif (!journal_begin(&th, s, 10)) {\n\t\t\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s),\n\t\t\t\t\t\t     1);\n\t\t\tset_sb_umount_state(SB_DISK_SUPER_BLOCK(s),\n\t\t\t\t\t    REISERFS_SB(s)->s_mount_state);\n\t\t\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(s));\n\t\t}\n\t}\n\n\t/*\n\t * note, journal_release checks for readonly mount, and can\n\t * decide not to do a journal_end\n\t */\n\tjournal_release(&th, s);\n\n\treiserfs_free_bitmap_cache(s);\n\n\tbrelse(SB_BUFFER_WITH_SB(s));\n\n\tprint_statistics(s);\n\n\tif (REISERFS_SB(s)->reserved_blocks != 0) {\n\t\treiserfs_warning(s, \"green-2005\", \"reserved blocks left %d\",\n\t\t\t\t REISERFS_SB(s)->reserved_blocks);\n\t}\n\n\treiserfs_write_unlock(s);\n\tmutex_destroy(&REISERFS_SB(s)->lock);\n\tdestroy_workqueue(REISERFS_SB(s)->commit_wq);\n\tkfree(s->s_fs_info);\n\ts->s_fs_info = NULL;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s->s_fs_info"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "REISERFS_SB(s)->commit_wq"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "s"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_destroy",
          "args": [
            "&REISERFS_SB(s)->lock"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "s"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"green-2005\"",
            "\"reserved blocks left %d\"",
            "REISERFS_SB(s)->reserved_blocks"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_statistics",
          "args": [
            "s"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "print_statistics",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "766-777",
          "snippet": "void print_statistics(struct super_block *s)\n{\n\n\t/*\n\t   printk (\"reiserfs_put_super: session statistics: balances %d, fix_nodes %d, \\\n\t   bmap with search %d, without %d, dir2ind %d, ind2dir %d\\n\",\n\t   REISERFS_SB(s)->s_do_balance, REISERFS_SB(s)->s_fix_nodes,\n\t   REISERFS_SB(s)->s_bmaps, REISERFS_SB(s)->s_bmaps_without_search,\n\t   REISERFS_SB(s)->s_direct2indirect, REISERFS_SB(s)->s_indirect2direct);\n\t */\n\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid print_statistics(struct super_block *s)\n{\n\n\t/*\n\t   printk (\"reiserfs_put_super: session statistics: balances %d, fix_nodes %d, \\\n\t   bmap with search %d, without %d, dir2ind %d, ind2dir %d\\n\",\n\t   REISERFS_SB(s)->s_do_balance, REISERFS_SB(s)->s_fix_nodes,\n\t   REISERFS_SB(s)->s_bmaps, REISERFS_SB(s)->s_bmaps_without_search,\n\t   REISERFS_SB(s)->s_direct2indirect, REISERFS_SB(s)->s_indirect2direct);\n\t */\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "SB_BUFFER_WITH_SB(s)"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_free_bitmap_cache",
          "args": [
            "s"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_free_bitmap_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "1462-1468",
          "snippet": "void reiserfs_free_bitmap_cache(struct super_block *sb)\n{\n\tif (SB_AP_BITMAP(sb)) {\n\t\tvfree(SB_AP_BITMAP(sb));\n\t\tSB_AP_BITMAP(sb) = NULL;\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nvoid reiserfs_free_bitmap_cache(struct super_block *sb)\n{\n\tif (SB_AP_BITMAP(sb)) {\n\t\tvfree(SB_AP_BITMAP(sb));\n\t\tSB_AP_BITMAP(sb) = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_release",
          "args": [
            "&th",
            "s"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "journal_release_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "1983-1987",
          "snippet": "int journal_release_error(struct reiserfs_transaction_handle *th,\n\t\t\t  struct super_block *sb)\n{\n\treturn do_journal_release(th, sb, 1);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_release_error(struct reiserfs_transaction_handle *th,\n\t\t\t  struct super_block *sb)\n{\n\treturn do_journal_release(th, sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_mark_dirty",
          "args": [
            "&th",
            "SB_BUFFER_WITH_SB(s)"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "journal_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3274-3379",
          "snippet": "int journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sb_umount_state",
          "args": [
            "SB_DISK_SUPER_BLOCK(s)",
            "REISERFS_SB(s)->s_mount_state"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_DISK_SUPER_BLOCK",
          "args": [
            "s"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_prepare_for_journal",
          "args": [
            "s",
            "SB_BUFFER_WITH_SB(s)",
            "1"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_prepare_for_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3951-3968",
          "snippet": "int reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "s",
            "10"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "s"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_disable",
          "args": [
            "s",
            "-1",
            "DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1999-2127",
          "snippet": "int dquot_disable(struct super_block *sb, int type, unsigned int flags)\n{\n\tint cnt, ret = 0;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct inode *toputinode[MAXQUOTAS];\n\n\t/* Cannot turn off usage accounting without turning off limits, or\n\t * suspend quotas and simultaneously turn quotas off. */\n\tif ((flags & DQUOT_USAGE_ENABLED && !(flags & DQUOT_LIMITS_ENABLED))\n\t    || (flags & DQUOT_SUSPENDED && flags & (DQUOT_LIMITS_ENABLED |\n\t    DQUOT_USAGE_ENABLED)))\n\t\treturn -EINVAL;\n\n\t/* We need to serialize quota_off() for device */\n\tmutex_lock(&dqopt->dqonoff_mutex);\n\n\t/*\n\t * Skip everything if there's nothing to do. We have to do this because\n\t * sometimes we are called when fill_super() failed and calling\n\t * sync_fs() in such cases does no good.\n\t */\n\tif (!sb_any_quota_loaded(sb)) {\n\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\treturn 0;\n\t}\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\ttoputinode[cnt] = NULL;\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\t\tif (!sb_has_quota_loaded(sb, cnt))\n\t\t\tcontinue;\n\n\t\tif (flags & DQUOT_SUSPENDED) {\n\t\t\tspin_lock(&dq_state_lock);\n\t\t\tdqopt->flags |=\n\t\t\t\tdquot_state_flag(DQUOT_SUSPENDED, cnt);\n\t\t\tspin_unlock(&dq_state_lock);\n\t\t} else {\n\t\t\tspin_lock(&dq_state_lock);\n\t\t\tdqopt->flags &= ~dquot_state_flag(flags, cnt);\n\t\t\t/* Turning off suspended quotas? */\n\t\t\tif (!sb_has_quota_loaded(sb, cnt) &&\n\t\t\t    sb_has_quota_suspended(sb, cnt)) {\n\t\t\t\tdqopt->flags &=\t~dquot_state_flag(\n\t\t\t\t\t\t\tDQUOT_SUSPENDED, cnt);\n\t\t\t\tspin_unlock(&dq_state_lock);\n\t\t\t\tiput(dqopt->files[cnt]);\n\t\t\t\tdqopt->files[cnt] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_unlock(&dq_state_lock);\n\t\t}\n\n\t\t/* We still have to keep quota loaded? */\n\t\tif (sb_has_quota_loaded(sb, cnt) && !(flags & DQUOT_SUSPENDED))\n\t\t\tcontinue;\n\n\t\t/* Note: these are blocking operations */\n\t\tdrop_dquot_ref(sb, cnt);\n\t\tinvalidate_dquots(sb, cnt);\n\t\t/*\n\t\t * Now all dquots should be invalidated, all writes done so we\n\t\t * should be only users of the info. No locks needed.\n\t\t */\n\t\tif (info_dirty(&dqopt->info[cnt]))\n\t\t\tsb->dq_op->write_info(sb, cnt);\n\t\tif (dqopt->ops[cnt]->free_file_info)\n\t\t\tdqopt->ops[cnt]->free_file_info(sb, cnt);\n\t\tput_quota_format(dqopt->info[cnt].dqi_format);\n\n\t\ttoputinode[cnt] = dqopt->files[cnt];\n\t\tif (!sb_has_quota_loaded(sb, cnt))\n\t\t\tdqopt->files[cnt] = NULL;\n\t\tdqopt->info[cnt].dqi_flags = 0;\n\t\tdqopt->info[cnt].dqi_igrace = 0;\n\t\tdqopt->info[cnt].dqi_bgrace = 0;\n\t\tdqopt->ops[cnt] = NULL;\n\t}\n\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\t/* Skip syncing and setting flags if quota files are hidden */\n\tif (dqopt->flags & DQUOT_QUOTA_SYS_FILE)\n\t\tgoto put_inodes;\n\n\t/* Sync the superblock so that buffers with quota data are written to\n\t * disk (and so userspace sees correct data afterwards). */\n\tif (sb->s_op->sync_fs)\n\t\tsb->s_op->sync_fs(sb, 1);\n\tsync_blockdev(sb->s_bdev);\n\t/* Now the quota files are just ordinary files and we can set the\n\t * inode flags back. Moreover we discard the pagecache so that\n\t * userspace sees the writes we did bypassing the pagecache. We\n\t * must also discard the blockdev buffers so that we see the\n\t * changes done by userspace on the next quotaon() */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (toputinode[cnt]) {\n\t\t\tmutex_lock(&dqopt->dqonoff_mutex);\n\t\t\t/* If quota was reenabled in the meantime, we have\n\t\t\t * nothing to do */\n\t\t\tif (!sb_has_quota_loaded(sb, cnt)) {\n\t\t\t\tmutex_lock(&toputinode[cnt]->i_mutex);\n\t\t\t\ttoputinode[cnt]->i_flags &= ~(S_IMMUTABLE |\n\t\t\t\t  S_NOATIME | S_NOQUOTA);\n\t\t\t\ttruncate_inode_pages(&toputinode[cnt]->i_data,\n\t\t\t\t\t\t     0);\n\t\t\t\tmutex_unlock(&toputinode[cnt]->i_mutex);\n\t\t\t\tmark_inode_dirty_sync(toputinode[cnt]);\n\t\t\t}\n\t\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\t}\n\tif (sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\nput_inodes:\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (toputinode[cnt]) {\n\t\t\t/* On remount RO, we keep the inode pointer so that we\n\t\t\t * can reenable quota on the subsequent remount RW. We\n\t\t\t * have to check 'flags' variable and not use sb_has_\n\t\t\t * function because another quotaon / quotaoff could\n\t\t\t * change global state before we got here. We refuse\n\t\t\t * to suspend quotas when there is pending delete on\n\t\t\t * the quota file... */\n\t\t\tif (!(flags & DQUOT_SUSPENDED))\n\t\t\t\tiput(toputinode[cnt]);\n\t\t\telse if (!toputinode[cnt]->i_nlink)\n\t\t\t\tret = -EBUSY;\n\t\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_disable(struct super_block *sb, int type, unsigned int flags)\n{\n\tint cnt, ret = 0;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct inode *toputinode[MAXQUOTAS];\n\n\t/* Cannot turn off usage accounting without turning off limits, or\n\t * suspend quotas and simultaneously turn quotas off. */\n\tif ((flags & DQUOT_USAGE_ENABLED && !(flags & DQUOT_LIMITS_ENABLED))\n\t    || (flags & DQUOT_SUSPENDED && flags & (DQUOT_LIMITS_ENABLED |\n\t    DQUOT_USAGE_ENABLED)))\n\t\treturn -EINVAL;\n\n\t/* We need to serialize quota_off() for device */\n\tmutex_lock(&dqopt->dqonoff_mutex);\n\n\t/*\n\t * Skip everything if there's nothing to do. We have to do this because\n\t * sometimes we are called when fill_super() failed and calling\n\t * sync_fs() in such cases does no good.\n\t */\n\tif (!sb_any_quota_loaded(sb)) {\n\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\treturn 0;\n\t}\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\ttoputinode[cnt] = NULL;\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\t\tif (!sb_has_quota_loaded(sb, cnt))\n\t\t\tcontinue;\n\n\t\tif (flags & DQUOT_SUSPENDED) {\n\t\t\tspin_lock(&dq_state_lock);\n\t\t\tdqopt->flags |=\n\t\t\t\tdquot_state_flag(DQUOT_SUSPENDED, cnt);\n\t\t\tspin_unlock(&dq_state_lock);\n\t\t} else {\n\t\t\tspin_lock(&dq_state_lock);\n\t\t\tdqopt->flags &= ~dquot_state_flag(flags, cnt);\n\t\t\t/* Turning off suspended quotas? */\n\t\t\tif (!sb_has_quota_loaded(sb, cnt) &&\n\t\t\t    sb_has_quota_suspended(sb, cnt)) {\n\t\t\t\tdqopt->flags &=\t~dquot_state_flag(\n\t\t\t\t\t\t\tDQUOT_SUSPENDED, cnt);\n\t\t\t\tspin_unlock(&dq_state_lock);\n\t\t\t\tiput(dqopt->files[cnt]);\n\t\t\t\tdqopt->files[cnt] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_unlock(&dq_state_lock);\n\t\t}\n\n\t\t/* We still have to keep quota loaded? */\n\t\tif (sb_has_quota_loaded(sb, cnt) && !(flags & DQUOT_SUSPENDED))\n\t\t\tcontinue;\n\n\t\t/* Note: these are blocking operations */\n\t\tdrop_dquot_ref(sb, cnt);\n\t\tinvalidate_dquots(sb, cnt);\n\t\t/*\n\t\t * Now all dquots should be invalidated, all writes done so we\n\t\t * should be only users of the info. No locks needed.\n\t\t */\n\t\tif (info_dirty(&dqopt->info[cnt]))\n\t\t\tsb->dq_op->write_info(sb, cnt);\n\t\tif (dqopt->ops[cnt]->free_file_info)\n\t\t\tdqopt->ops[cnt]->free_file_info(sb, cnt);\n\t\tput_quota_format(dqopt->info[cnt].dqi_format);\n\n\t\ttoputinode[cnt] = dqopt->files[cnt];\n\t\tif (!sb_has_quota_loaded(sb, cnt))\n\t\t\tdqopt->files[cnt] = NULL;\n\t\tdqopt->info[cnt].dqi_flags = 0;\n\t\tdqopt->info[cnt].dqi_igrace = 0;\n\t\tdqopt->info[cnt].dqi_bgrace = 0;\n\t\tdqopt->ops[cnt] = NULL;\n\t}\n\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\t/* Skip syncing and setting flags if quota files are hidden */\n\tif (dqopt->flags & DQUOT_QUOTA_SYS_FILE)\n\t\tgoto put_inodes;\n\n\t/* Sync the superblock so that buffers with quota data are written to\n\t * disk (and so userspace sees correct data afterwards). */\n\tif (sb->s_op->sync_fs)\n\t\tsb->s_op->sync_fs(sb, 1);\n\tsync_blockdev(sb->s_bdev);\n\t/* Now the quota files are just ordinary files and we can set the\n\t * inode flags back. Moreover we discard the pagecache so that\n\t * userspace sees the writes we did bypassing the pagecache. We\n\t * must also discard the blockdev buffers so that we see the\n\t * changes done by userspace on the next quotaon() */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (toputinode[cnt]) {\n\t\t\tmutex_lock(&dqopt->dqonoff_mutex);\n\t\t\t/* If quota was reenabled in the meantime, we have\n\t\t\t * nothing to do */\n\t\t\tif (!sb_has_quota_loaded(sb, cnt)) {\n\t\t\t\tmutex_lock(&toputinode[cnt]->i_mutex);\n\t\t\t\ttoputinode[cnt]->i_flags &= ~(S_IMMUTABLE |\n\t\t\t\t  S_NOATIME | S_NOQUOTA);\n\t\t\t\ttruncate_inode_pages(&toputinode[cnt]->i_data,\n\t\t\t\t\t\t     0);\n\t\t\t\tmutex_unlock(&toputinode[cnt]->i_mutex);\n\t\t\t\tmark_inode_dirty_sync(toputinode[cnt]);\n\t\t\t}\n\t\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\t}\n\tif (sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\nput_inodes:\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (toputinode[cnt]) {\n\t\t\t/* On remount RO, we keep the inode pointer so that we\n\t\t\t * can reenable quota on the subsequent remount RW. We\n\t\t\t * have to check 'flags' variable and not use sb_has_\n\t\t\t * function because another quotaon / quotaoff could\n\t\t\t * change global state before we got here. We refuse\n\t\t\t * to suspend quotas when there is pending delete on\n\t\t\t * the quota file... */\n\t\t\tif (!(flags & DQUOT_SUSPENDED))\n\t\t\t\tiput(toputinode[cnt]);\n\t\t\telse if (!toputinode[cnt]->i_nlink)\n\t\t\t\tret = -EBUSY;\n\t\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void reiserfs_put_super(struct super_block *s)\n{\n\tstruct reiserfs_transaction_handle th;\n\tth.t_trans_id = 0;\n\n\tdquot_disable(s, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\n\treiserfs_write_lock(s);\n\n\t/*\n\t * change file system state to current state if it was mounted\n\t * with read-write permissions\n\t */\n\tif (!(s->s_flags & MS_RDONLY)) {\n\t\tif (!journal_begin(&th, s, 10)) {\n\t\t\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s),\n\t\t\t\t\t\t     1);\n\t\t\tset_sb_umount_state(SB_DISK_SUPER_BLOCK(s),\n\t\t\t\t\t    REISERFS_SB(s)->s_mount_state);\n\t\t\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(s));\n\t\t}\n\t}\n\n\t/*\n\t * note, journal_release checks for readonly mount, and can\n\t * decide not to do a journal_end\n\t */\n\tjournal_release(&th, s);\n\n\treiserfs_free_bitmap_cache(s);\n\n\tbrelse(SB_BUFFER_WITH_SB(s));\n\n\tprint_statistics(s);\n\n\tif (REISERFS_SB(s)->reserved_blocks != 0) {\n\t\treiserfs_warning(s, \"green-2005\", \"reserved blocks left %d\",\n\t\t\t\t REISERFS_SB(s)->reserved_blocks);\n\t}\n\n\treiserfs_write_unlock(s);\n\tmutex_destroy(&REISERFS_SB(s)->lock);\n\tdestroy_workqueue(REISERFS_SB(s)->commit_wq);\n\tkfree(s->s_fs_info);\n\ts->s_fs_info = NULL;\n}"
  },
  {
    "function_name": "reiserfs_kill_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "516-537",
    "snippet": "static void reiserfs_kill_sb(struct super_block *s)\n{\n\tif (REISERFS_SB(s)) {\n\t\treiserfs_proc_info_done(s);\n\t\t/*\n\t\t * Force any pending inode evictions to occur now. Any\n\t\t * inodes to be removed that have extended attributes\n\t\t * associated with them need to clean them up before\n\t\t * we can release the extended attribute root dentries.\n\t\t * shrink_dcache_for_umount will BUG if we don't release\n\t\t * those before it's called so ->put_super is too late.\n\t\t */\n\t\tshrink_dcache_sb(s);\n\n\t\tdput(REISERFS_SB(s)->xattr_root);\n\t\tREISERFS_SB(s)->xattr_root = NULL;\n\t\tdput(REISERFS_SB(s)->priv_root);\n\t\tREISERFS_SB(s)->priv_root = NULL;\n\t}\n\n\tkill_block_super(s);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_block_super",
          "args": [
            "s"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_kill_block_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "629-638",
          "snippet": "static void ecryptfs_kill_block_super(struct super_block *sb)\n{\n\tstruct ecryptfs_sb_info *sb_info = ecryptfs_superblock_to_private(sb);\n\tkill_anon_super(sb);\n\tif (!sb_info)\n\t\treturn;\n\tecryptfs_destroy_mount_crypt_stat(&sb_info->mount_crypt_stat);\n\tbdi_destroy(&sb_info->bdi);\n\tkmem_cache_free(ecryptfs_sb_info_cache, sb_info);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *ecryptfs_sb_info_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstruct kmem_cache *ecryptfs_sb_info_cache;\n\nstatic void ecryptfs_kill_block_super(struct super_block *sb)\n{\n\tstruct ecryptfs_sb_info *sb_info = ecryptfs_superblock_to_private(sb);\n\tkill_anon_super(sb);\n\tif (!sb_info)\n\t\treturn;\n\tecryptfs_destroy_mount_crypt_stat(&sb_info->mount_crypt_stat);\n\tbdi_destroy(&sb_info->bdi);\n\tkmem_cache_free(ecryptfs_sb_info_cache, sb_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "s"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "REISERFS_SB(s)->priv_root"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shrink_dcache_sb",
          "args": [
            "s"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_dcache_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1094-1107",
          "snippet": "void shrink_dcache_sb(struct super_block *sb)\n{\n\tlong freed;\n\n\tdo {\n\t\tLIST_HEAD(dispose);\n\n\t\tfreed = list_lru_walk(&sb->s_dentry_lru,\n\t\t\tdentry_lru_isolate_shrink, &dispose, UINT_MAX);\n\n\t\tthis_cpu_sub(nr_dentry_unused, freed);\n\t\tshrink_dentry_list(&dispose);\n\t} while (freed > 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(long, nr_dentry_unused);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic DEFINE_PER_CPU(long, nr_dentry_unused);\n\nvoid shrink_dcache_sb(struct super_block *sb)\n{\n\tlong freed;\n\n\tdo {\n\t\tLIST_HEAD(dispose);\n\n\t\tfreed = list_lru_walk(&sb->s_dentry_lru,\n\t\t\tdentry_lru_isolate_shrink, &dispose, UINT_MAX);\n\n\t\tthis_cpu_sub(nr_dentry_unused, freed);\n\t\tshrink_dentry_list(&dispose);\n\t} while (freed > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_proc_info_done",
          "args": [
            "s"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_proc_info_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "3138-3141",
          "snippet": "static inline int reiserfs_proc_info_done(struct super_block *sb)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline int reiserfs_proc_info_done(struct super_block *sb)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void reiserfs_kill_sb(struct super_block *s)\n{\n\tif (REISERFS_SB(s)) {\n\t\treiserfs_proc_info_done(s);\n\t\t/*\n\t\t * Force any pending inode evictions to occur now. Any\n\t\t * inodes to be removed that have extended attributes\n\t\t * associated with them need to clean them up before\n\t\t * we can release the extended attribute root dentries.\n\t\t * shrink_dcache_for_umount will BUG if we don't release\n\t\t * those before it's called so ->put_super is too late.\n\t\t */\n\t\tshrink_dcache_sb(s);\n\n\t\tdput(REISERFS_SB(s)->xattr_root);\n\t\tREISERFS_SB(s)->xattr_root = NULL;\n\t\tdput(REISERFS_SB(s)->priv_root);\n\t\tREISERFS_SB(s)->priv_root = NULL;\n\t}\n\n\tkill_block_super(s);\n}"
  },
  {
    "function_name": "remove_save_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "476-514",
    "snippet": "int remove_save_link(struct inode *inode, int truncate)\n{\n\tstruct reiserfs_transaction_handle th;\n\tstruct reiserfs_key key;\n\tint err;\n\n\t/* we are going to do one balancing only */\n\terr = journal_begin(&th, inode->i_sb, JOURNAL_PER_BALANCE_CNT);\n\tif (err)\n\t\treturn err;\n\n\t/* setup key of \"save\" link */\n\tkey.k_dir_id = cpu_to_le32(MAX_KEY_OBJECTID);\n\tkey.k_objectid = INODE_PKEY(inode)->k_objectid;\n\tif (!truncate) {\n\t\t/* unlink, rmdir, rename */\n\t\tset_le_key_k_offset(KEY_FORMAT_3_5, &key,\n\t\t\t\t    1 + inode->i_sb->s_blocksize);\n\t\tset_le_key_k_type(KEY_FORMAT_3_5, &key, TYPE_DIRECT);\n\t} else {\n\t\t/* truncate */\n\t\tset_le_key_k_offset(KEY_FORMAT_3_5, &key, 1);\n\t\tset_le_key_k_type(KEY_FORMAT_3_5, &key, TYPE_INDIRECT);\n\t}\n\n\tif ((truncate &&\n\t     (REISERFS_I(inode)->i_flags & i_link_saved_truncate_mask)) ||\n\t    (!truncate &&\n\t     (REISERFS_I(inode)->i_flags & i_link_saved_unlink_mask)))\n\t\t/* don't take quota bytes from anywhere */\n\t\treiserfs_delete_solid_item(&th, NULL, &key);\n\tif (!truncate) {\n\t\treiserfs_release_objectid(&th, inode->i_ino);\n\t\tREISERFS_I(inode)->i_flags &= ~i_link_saved_unlink_mask;\n\t} else\n\t\tREISERFS_I(inode)->i_flags &= ~i_link_saved_truncate_mask;\n\n\treturn journal_end(&th);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "&th"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_release_objectid",
          "args": [
            "&th",
            "inode->i_ino"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_release_objectid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/objectid.c",
          "lines": "97-177",
          "snippet": "void reiserfs_release_objectid(struct reiserfs_transaction_handle *th,\n\t\t\t       __u32 objectid_to_release)\n{\n\tstruct super_block *s = th->t_super;\n\tstruct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(s);\n\t__le32 *map = objectid_map(s, rs);\n\tint i = 0;\n\n\tBUG_ON(!th->t_trans_id);\n\t/*return; */\n\tcheck_objectid_map(s, map);\n\n\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);\n\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(s));\n\n\t/*\n\t * start at the beginning of the objectid map (i = 0) and go to\n\t * the end of it (i = disk_sb->s_oid_cursize).  Linear search is\n\t * what we use, though it is possible that binary search would be\n\t * more efficient after performing lots of deletions (which is\n\t * when oids is large.)  We only check even i's.\n\t */\n\twhile (i < sb_oid_cursize(rs)) {\n\t\tif (objectid_to_release == le32_to_cpu(map[i])) {\n\t\t\t/* This incrementation unallocates the objectid. */\n\t\t\tle32_add_cpu(&map[i], 1);\n\n\t\t\t/*\n\t\t\t * Did we unallocate the last member of an\n\t\t\t * odd sequence, and can shrink oids?\n\t\t\t */\n\t\t\tif (map[i] == map[i + 1]) {\n\t\t\t\t/* shrink objectid map */\n\t\t\t\tmemmove(map + i, map + i + 2,\n\t\t\t\t\t(sb_oid_cursize(rs) - i -\n\t\t\t\t\t 2) * sizeof(__u32));\n\t\t\t\tset_sb_oid_cursize(rs, sb_oid_cursize(rs) - 2);\n\n\t\t\t\tRFALSE(sb_oid_cursize(rs) < 2 ||\n\t\t\t\t       sb_oid_cursize(rs) > sb_oid_maxsize(rs),\n\t\t\t\t       \"vs-15005: objectid map corrupted cur_size == %d (max == %d)\",\n\t\t\t\t       sb_oid_cursize(rs), sb_oid_maxsize(rs));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (objectid_to_release > le32_to_cpu(map[i]) &&\n\t\t    objectid_to_release < le32_to_cpu(map[i + 1])) {\n\t\t\t/* size of objectid map is not changed */\n\t\t\tif (objectid_to_release + 1 == le32_to_cpu(map[i + 1])) {\n\t\t\t\tle32_add_cpu(&map[i + 1], -1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * JDM comparing two little-endian values for\n\t\t\t * equality -- safe\n\t\t\t */\n\t\t\t/*\n\t\t\t * objectid map must be expanded, but\n\t\t\t * there is no space\n\t\t\t */\n\t\t\tif (sb_oid_cursize(rs) == sb_oid_maxsize(rs)) {\n\t\t\t\tPROC_INFO_INC(s, leaked_oid);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* expand the objectid map */\n\t\t\tmemmove(map + i + 3, map + i + 1,\n\t\t\t\t(sb_oid_cursize(rs) - i - 1) * sizeof(__u32));\n\t\t\tmap[i + 1] = cpu_to_le32(objectid_to_release);\n\t\t\tmap[i + 2] = cpu_to_le32(objectid_to_release + 1);\n\t\t\tset_sb_oid_cursize(rs, sb_oid_cursize(rs) + 2);\n\t\t\treturn;\n\t\t}\n\t\ti += 2;\n\t}\n\n\treiserfs_error(s, \"vs-15011\", \"tried to free free object id (%lu)\",\n\t\t       (long unsigned)objectid_to_release);\n}",
          "includes": [
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/random.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/random.h>\n#include <linux/string.h>\n\nvoid reiserfs_release_objectid(struct reiserfs_transaction_handle *th,\n\t\t\t       __u32 objectid_to_release)\n{\n\tstruct super_block *s = th->t_super;\n\tstruct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(s);\n\t__le32 *map = objectid_map(s, rs);\n\tint i = 0;\n\n\tBUG_ON(!th->t_trans_id);\n\t/*return; */\n\tcheck_objectid_map(s, map);\n\n\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);\n\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(s));\n\n\t/*\n\t * start at the beginning of the objectid map (i = 0) and go to\n\t * the end of it (i = disk_sb->s_oid_cursize).  Linear search is\n\t * what we use, though it is possible that binary search would be\n\t * more efficient after performing lots of deletions (which is\n\t * when oids is large.)  We only check even i's.\n\t */\n\twhile (i < sb_oid_cursize(rs)) {\n\t\tif (objectid_to_release == le32_to_cpu(map[i])) {\n\t\t\t/* This incrementation unallocates the objectid. */\n\t\t\tle32_add_cpu(&map[i], 1);\n\n\t\t\t/*\n\t\t\t * Did we unallocate the last member of an\n\t\t\t * odd sequence, and can shrink oids?\n\t\t\t */\n\t\t\tif (map[i] == map[i + 1]) {\n\t\t\t\t/* shrink objectid map */\n\t\t\t\tmemmove(map + i, map + i + 2,\n\t\t\t\t\t(sb_oid_cursize(rs) - i -\n\t\t\t\t\t 2) * sizeof(__u32));\n\t\t\t\tset_sb_oid_cursize(rs, sb_oid_cursize(rs) - 2);\n\n\t\t\t\tRFALSE(sb_oid_cursize(rs) < 2 ||\n\t\t\t\t       sb_oid_cursize(rs) > sb_oid_maxsize(rs),\n\t\t\t\t       \"vs-15005: objectid map corrupted cur_size == %d (max == %d)\",\n\t\t\t\t       sb_oid_cursize(rs), sb_oid_maxsize(rs));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (objectid_to_release > le32_to_cpu(map[i]) &&\n\t\t    objectid_to_release < le32_to_cpu(map[i + 1])) {\n\t\t\t/* size of objectid map is not changed */\n\t\t\tif (objectid_to_release + 1 == le32_to_cpu(map[i + 1])) {\n\t\t\t\tle32_add_cpu(&map[i + 1], -1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * JDM comparing two little-endian values for\n\t\t\t * equality -- safe\n\t\t\t */\n\t\t\t/*\n\t\t\t * objectid map must be expanded, but\n\t\t\t * there is no space\n\t\t\t */\n\t\t\tif (sb_oid_cursize(rs) == sb_oid_maxsize(rs)) {\n\t\t\t\tPROC_INFO_INC(s, leaked_oid);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* expand the objectid map */\n\t\t\tmemmove(map + i + 3, map + i + 1,\n\t\t\t\t(sb_oid_cursize(rs) - i - 1) * sizeof(__u32));\n\t\t\tmap[i + 1] = cpu_to_le32(objectid_to_release);\n\t\t\tmap[i + 2] = cpu_to_le32(objectid_to_release + 1);\n\t\t\tset_sb_oid_cursize(rs, sb_oid_cursize(rs) + 2);\n\t\t\treturn;\n\t\t}\n\t\ti += 2;\n\t}\n\n\treiserfs_error(s, \"vs-15011\", \"tried to free free object id (%lu)\",\n\t\t       (long unsigned)objectid_to_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_delete_solid_item",
          "args": [
            "&th",
            "NULL",
            "&key"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_le_key_k_type",
          "args": [
            "KEY_FORMAT_3_5",
            "&key",
            "TYPE_INDIRECT"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "set_le_key_k_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1526-1534",
          "snippet": "static inline void set_le_key_k_type(int version, struct reiserfs_key *key,\n\t\t\t\t     int type)\n{\n\tif (version == KEY_FORMAT_3_5) {\n\t\ttype = type2uniqueness(type);\n\t\tkey->u.k_offset_v1.k_uniqueness = cpu_to_le32(type);\n\t} else\n\t       set_offset_v2_k_type(&key->u.k_offset_v2, type);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline void set_le_key_k_type(int version, struct reiserfs_key *key,\n\t\t\t\t     int type)\n{\n\tif (version == KEY_FORMAT_3_5) {\n\t\ttype = type2uniqueness(type);\n\t\tkey->u.k_offset_v1.k_uniqueness = cpu_to_le32(type);\n\t} else\n\t       set_offset_v2_k_type(&key->u.k_offset_v2, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_le_key_k_offset",
          "args": [
            "KEY_FORMAT_3_5",
            "&key",
            "1"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "set_le_key_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1500-1507",
          "snippet": "static inline void set_le_key_k_offset(int version, struct reiserfs_key *key,\n\t\t\t\t       loff_t offset)\n{\n\tif (version == KEY_FORMAT_3_5)\n\t\tkey->u.k_offset_v1.k_offset = cpu_to_le32(offset);\n\telse\n\t\tset_offset_v2_k_offset(&key->u.k_offset_v2, offset);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void set_le_key_k_offset(int version, struct reiserfs_key *key,\n\t\t\t\t       loff_t offset)\n{\n\tif (version == KEY_FORMAT_3_5)\n\t\tkey->u.k_offset_v1.k_offset = cpu_to_le32(offset);\n\telse\n\t\tset_offset_v2_k_offset(&key->u.k_offset_v2, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "MAX_KEY_OBJECTID"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "inode->i_sb",
            "JOURNAL_PER_BALANCE_CNT"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint remove_save_link(struct inode *inode, int truncate)\n{\n\tstruct reiserfs_transaction_handle th;\n\tstruct reiserfs_key key;\n\tint err;\n\n\t/* we are going to do one balancing only */\n\terr = journal_begin(&th, inode->i_sb, JOURNAL_PER_BALANCE_CNT);\n\tif (err)\n\t\treturn err;\n\n\t/* setup key of \"save\" link */\n\tkey.k_dir_id = cpu_to_le32(MAX_KEY_OBJECTID);\n\tkey.k_objectid = INODE_PKEY(inode)->k_objectid;\n\tif (!truncate) {\n\t\t/* unlink, rmdir, rename */\n\t\tset_le_key_k_offset(KEY_FORMAT_3_5, &key,\n\t\t\t\t    1 + inode->i_sb->s_blocksize);\n\t\tset_le_key_k_type(KEY_FORMAT_3_5, &key, TYPE_DIRECT);\n\t} else {\n\t\t/* truncate */\n\t\tset_le_key_k_offset(KEY_FORMAT_3_5, &key, 1);\n\t\tset_le_key_k_type(KEY_FORMAT_3_5, &key, TYPE_INDIRECT);\n\t}\n\n\tif ((truncate &&\n\t     (REISERFS_I(inode)->i_flags & i_link_saved_truncate_mask)) ||\n\t    (!truncate &&\n\t     (REISERFS_I(inode)->i_flags & i_link_saved_unlink_mask)))\n\t\t/* don't take quota bytes from anywhere */\n\t\treiserfs_delete_solid_item(&th, NULL, &key);\n\tif (!truncate) {\n\t\treiserfs_release_objectid(&th, inode->i_ino);\n\t\tREISERFS_I(inode)->i_flags &= ~i_link_saved_unlink_mask;\n\t} else\n\t\tREISERFS_I(inode)->i_flags &= ~i_link_saved_truncate_mask;\n\n\treturn journal_end(&th);\n}"
  },
  {
    "function_name": "add_save_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "395-473",
    "snippet": "void add_save_link(struct reiserfs_transaction_handle *th,\n\t\t   struct inode *inode, int truncate)\n{\n\tINITIALIZE_PATH(path);\n\tint retval;\n\tstruct cpu_key key;\n\tstruct item_head ih;\n\t__le32 link;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* file can only get one \"save link\" of each kind */\n\tRFALSE(truncate &&\n\t       (REISERFS_I(inode)->i_flags & i_link_saved_truncate_mask),\n\t       \"saved link already exists for truncated inode %lx\",\n\t       (long)inode->i_ino);\n\tRFALSE(!truncate &&\n\t       (REISERFS_I(inode)->i_flags & i_link_saved_unlink_mask),\n\t       \"saved link already exists for unlinked inode %lx\",\n\t       (long)inode->i_ino);\n\n\t/* setup key of \"save\" link */\n\tkey.version = KEY_FORMAT_3_5;\n\tkey.on_disk_key.k_dir_id = MAX_KEY_OBJECTID;\n\tkey.on_disk_key.k_objectid = inode->i_ino;\n\tif (!truncate) {\n\t\t/* unlink, rmdir, rename */\n\t\tset_cpu_key_k_offset(&key, 1 + inode->i_sb->s_blocksize);\n\t\tset_cpu_key_k_type(&key, TYPE_DIRECT);\n\n\t\t/* item head of \"safe\" link */\n\t\tmake_le_item_head(&ih, &key, key.version,\n\t\t\t\t  1 + inode->i_sb->s_blocksize, TYPE_DIRECT,\n\t\t\t\t  4 /*length */ , 0xffff /*free space */ );\n\t} else {\n\t\t/* truncate */\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\treiserfs_warning(inode->i_sb, \"green-2102\",\n\t\t\t\t\t \"Adding a truncate savelink for \"\n\t\t\t\t\t \"a directory %k! Please report\",\n\t\t\t\t\t INODE_PKEY(inode));\n\t\tset_cpu_key_k_offset(&key, 1);\n\t\tset_cpu_key_k_type(&key, TYPE_INDIRECT);\n\n\t\t/* item head of \"safe\" link */\n\t\tmake_le_item_head(&ih, &key, key.version, 1, TYPE_INDIRECT,\n\t\t\t\t  4 /*length */ , 0 /*free space */ );\n\t}\n\tkey.key_length = 3;\n\n\t/* look for its place in the tree */\n\tretval = search_item(inode->i_sb, &key, &path);\n\tif (retval != ITEM_NOT_FOUND) {\n\t\tif (retval != -ENOSPC)\n\t\t\treiserfs_error(inode->i_sb, \"vs-2100\",\n\t\t\t\t       \"search_by_key (%K) returned %d\", &key,\n\t\t\t\t       retval);\n\t\tpathrelse(&path);\n\t\treturn;\n\t}\n\n\t/* body of \"save\" link */\n\tlink = INODE_PKEY(inode)->k_dir_id;\n\n\t/* put \"save\" link into tree, don't charge quota to anyone */\n\tretval =\n\t    reiserfs_insert_item(th, &path, &key, &ih, NULL, (char *)&link);\n\tif (retval) {\n\t\tif (retval != -ENOSPC)\n\t\t\treiserfs_error(inode->i_sb, \"vs-2120\",\n\t\t\t\t       \"insert_item returned %d\", retval);\n\t} else {\n\t\tif (truncate)\n\t\t\tREISERFS_I(inode)->i_flags |=\n\t\t\t    i_link_saved_truncate_mask;\n\t\telse\n\t\t\tREISERFS_I(inode)->i_flags |= i_link_saved_unlink_mask;\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_error",
          "args": [
            "inode->i_sb",
            "\"vs-2120\"",
            "\"insert_item returned %d\"",
            "retval"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "374-397",
          "snippet": "void __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_insert_item",
          "args": [
            "th",
            "&path",
            "&key",
            "&ih",
            "NULL",
            "(char *)&link"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pathrelse",
          "args": [
            "&path"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "376-387",
          "snippet": "void pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "search_item",
          "args": [
            "inode->i_sb",
            "&key",
            "&path"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_le_item_head",
          "args": [
            "&ih",
            "&key",
            "key.version",
            "1",
            "TYPE_INDIRECT",
            "4/*length */",
            "0/*free space */"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "make_le_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "136-156",
          "snippet": "inline void make_le_item_head(struct item_head *ih, const struct cpu_key *key,\n\t\t\t      int version,\n\t\t\t      loff_t offset, int type, int length,\n\t\t\t      int entry_count /*or ih_free_space */ )\n{\n\tif (key) {\n\t\tih->ih_key.k_dir_id = cpu_to_le32(key->on_disk_key.k_dir_id);\n\t\tih->ih_key.k_objectid =\n\t\t    cpu_to_le32(key->on_disk_key.k_objectid);\n\t}\n\tput_ih_version(ih, version);\n\tset_le_ih_k_offset(ih, offset);\n\tset_le_ih_k_type(ih, type);\n\tput_ih_item_len(ih, length);\n\t/*    set_ih_free_space (ih, 0); */\n\t/*\n\t * for directory items it is entry count, for directs and stat\n\t * datas - 0xffff, for indirects - 0\n\t */\n\tput_ih_entry_count(ih, entry_count);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\ninline void make_le_item_head(struct item_head *ih, const struct cpu_key *key,\n\t\t\t      int version,\n\t\t\t      loff_t offset, int type, int length,\n\t\t\t      int entry_count /*or ih_free_space */ )\n{\n\tif (key) {\n\t\tih->ih_key.k_dir_id = cpu_to_le32(key->on_disk_key.k_dir_id);\n\t\tih->ih_key.k_objectid =\n\t\t    cpu_to_le32(key->on_disk_key.k_objectid);\n\t}\n\tput_ih_version(ih, version);\n\tset_le_ih_k_offset(ih, offset);\n\tset_le_ih_k_type(ih, type);\n\tput_ih_item_len(ih, length);\n\t/*    set_ih_free_space (ih, 0); */\n\t/*\n\t * for directory items it is entry count, for directs and stat\n\t * datas - 0xffff, for indirects - 0\n\t */\n\tput_ih_entry_count(ih, entry_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cpu_key_k_type",
          "args": [
            "&key",
            "TYPE_INDIRECT"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpu_key_k_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1598-1601",
          "snippet": "static inline void set_cpu_key_k_type(struct cpu_key *key, int type)\n{\n\tkey->on_disk_key.k_type = type;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline void set_cpu_key_k_type(struct cpu_key *key, int type)\n{\n\tkey->on_disk_key.k_type = type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cpu_key_k_offset",
          "args": [
            "&key",
            "1"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpu_key_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1593-1596",
          "snippet": "static inline void set_cpu_key_k_offset(struct cpu_key *key, loff_t offset)\n{\n\tkey->on_disk_key.k_offset = offset;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void set_cpu_key_k_offset(struct cpu_key *key, loff_t offset)\n{\n\tkey->on_disk_key.k_offset = offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "inode->i_sb",
            "\"green-2102\"",
            "\"Adding a truncate savelink for \"\n\t\t\t\t\t \"a directory %k! Please report\"",
            "INODE_PKEY(inode)"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!truncate &&\n\t       (REISERFS_I(inode)->i_flags & i_link_saved_unlink_mask)",
            "\"saved link already exists for unlinked inode %lx\"",
            "(long)inode->i_ino"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "truncate &&\n\t       (REISERFS_I(inode)->i_flags & i_link_saved_truncate_mask)",
            "\"saved link already exists for truncated inode %lx\"",
            "(long)inode->i_ino"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INITIALIZE_PATH",
          "args": [
            "path"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid add_save_link(struct reiserfs_transaction_handle *th,\n\t\t   struct inode *inode, int truncate)\n{\n\tINITIALIZE_PATH(path);\n\tint retval;\n\tstruct cpu_key key;\n\tstruct item_head ih;\n\t__le32 link;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* file can only get one \"save link\" of each kind */\n\tRFALSE(truncate &&\n\t       (REISERFS_I(inode)->i_flags & i_link_saved_truncate_mask),\n\t       \"saved link already exists for truncated inode %lx\",\n\t       (long)inode->i_ino);\n\tRFALSE(!truncate &&\n\t       (REISERFS_I(inode)->i_flags & i_link_saved_unlink_mask),\n\t       \"saved link already exists for unlinked inode %lx\",\n\t       (long)inode->i_ino);\n\n\t/* setup key of \"save\" link */\n\tkey.version = KEY_FORMAT_3_5;\n\tkey.on_disk_key.k_dir_id = MAX_KEY_OBJECTID;\n\tkey.on_disk_key.k_objectid = inode->i_ino;\n\tif (!truncate) {\n\t\t/* unlink, rmdir, rename */\n\t\tset_cpu_key_k_offset(&key, 1 + inode->i_sb->s_blocksize);\n\t\tset_cpu_key_k_type(&key, TYPE_DIRECT);\n\n\t\t/* item head of \"safe\" link */\n\t\tmake_le_item_head(&ih, &key, key.version,\n\t\t\t\t  1 + inode->i_sb->s_blocksize, TYPE_DIRECT,\n\t\t\t\t  4 /*length */ , 0xffff /*free space */ );\n\t} else {\n\t\t/* truncate */\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\treiserfs_warning(inode->i_sb, \"green-2102\",\n\t\t\t\t\t \"Adding a truncate savelink for \"\n\t\t\t\t\t \"a directory %k! Please report\",\n\t\t\t\t\t INODE_PKEY(inode));\n\t\tset_cpu_key_k_offset(&key, 1);\n\t\tset_cpu_key_k_type(&key, TYPE_INDIRECT);\n\n\t\t/* item head of \"safe\" link */\n\t\tmake_le_item_head(&ih, &key, key.version, 1, TYPE_INDIRECT,\n\t\t\t\t  4 /*length */ , 0 /*free space */ );\n\t}\n\tkey.key_length = 3;\n\n\t/* look for its place in the tree */\n\tretval = search_item(inode->i_sb, &key, &path);\n\tif (retval != ITEM_NOT_FOUND) {\n\t\tif (retval != -ENOSPC)\n\t\t\treiserfs_error(inode->i_sb, \"vs-2100\",\n\t\t\t\t       \"search_by_key (%K) returned %d\", &key,\n\t\t\t\t       retval);\n\t\tpathrelse(&path);\n\t\treturn;\n\t}\n\n\t/* body of \"save\" link */\n\tlink = INODE_PKEY(inode)->k_dir_id;\n\n\t/* put \"save\" link into tree, don't charge quota to anyone */\n\tretval =\n\t    reiserfs_insert_item(th, &path, &key, &ih, NULL, (char *)&link);\n\tif (retval) {\n\t\tif (retval != -ENOSPC)\n\t\t\treiserfs_error(inode->i_sb, \"vs-2120\",\n\t\t\t\t       \"insert_item returned %d\", retval);\n\t} else {\n\t\tif (truncate)\n\t\t\tREISERFS_I(inode)->i_flags |=\n\t\t\t    i_link_saved_truncate_mask;\n\t\telse\n\t\t\tREISERFS_I(inode)->i_flags |= i_link_saved_unlink_mask;\n\t}\n}"
  },
  {
    "function_name": "finish_unfinished",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "193-387",
    "snippet": "static int finish_unfinished(struct super_block *s)\n{\n\tINITIALIZE_PATH(path);\n\tstruct cpu_key max_cpu_key, obj_key;\n\tstruct reiserfs_key save_link_key, last_inode_key;\n\tint retval = 0;\n\tstruct item_head *ih;\n\tstruct buffer_head *bh;\n\tint item_pos;\n\tchar *item;\n\tint done;\n\tstruct inode *inode;\n\tint truncate;\n#ifdef CONFIG_QUOTA\n\tint i;\n\tint ms_active_set;\n\tint quota_enabled[REISERFS_MAXQUOTAS];\n#endif\n\n\t/* compose key to look for \"save\" links */\n\tmax_cpu_key.version = KEY_FORMAT_3_5;\n\tmax_cpu_key.on_disk_key.k_dir_id = ~0U;\n\tmax_cpu_key.on_disk_key.k_objectid = ~0U;\n\tset_cpu_key_k_offset(&max_cpu_key, ~0U);\n\tmax_cpu_key.key_length = 3;\n\n\tmemset(&last_inode_key, 0, sizeof(last_inode_key));\n\n#ifdef CONFIG_QUOTA\n\t/* Needed for iput() to work correctly and not trash data */\n\tif (s->s_flags & MS_ACTIVE) {\n\t\tms_active_set = 0;\n\t} else {\n\t\tms_active_set = 1;\n\t\ts->s_flags |= MS_ACTIVE;\n\t}\n\t/* Turn on quotas so that they are updated correctly */\n\tfor (i = 0; i < REISERFS_MAXQUOTAS; i++) {\n\t\tquota_enabled[i] = 1;\n\t\tif (REISERFS_SB(s)->s_qf_names[i]) {\n\t\t\tint ret;\n\n\t\t\tif (sb_has_quota_active(s, i)) {\n\t\t\t\tquota_enabled[i] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tret = reiserfs_quota_on_mount(s, i);\n\t\t\tif (ret < 0)\n\t\t\t\treiserfs_warning(s, \"reiserfs-2500\",\n\t\t\t\t\t\t \"cannot turn on journaled \"\n\t\t\t\t\t\t \"quota: error %d\", ret);\n\t\t}\n\t}\n#endif\n\n\tdone = 0;\n\tREISERFS_SB(s)->s_is_unlinked_ok = 1;\n\twhile (!retval) {\n\t\tint depth;\n\t\tretval = search_item(s, &max_cpu_key, &path);\n\t\tif (retval != ITEM_NOT_FOUND) {\n\t\t\treiserfs_error(s, \"vs-2140\",\n\t\t\t\t       \"search_by_key returned %d\", retval);\n\t\t\tbreak;\n\t\t}\n\n\t\tbh = get_last_bh(&path);\n\t\titem_pos = get_item_pos(&path);\n\t\tif (item_pos != B_NR_ITEMS(bh)) {\n\t\t\treiserfs_warning(s, \"vs-2060\",\n\t\t\t\t\t \"wrong position found\");\n\t\t\tbreak;\n\t\t}\n\t\titem_pos--;\n\t\tih = item_head(bh, item_pos);\n\n\t\tif (le32_to_cpu(ih->ih_key.k_dir_id) != MAX_KEY_OBJECTID)\n\t\t\t/* there are no \"save\" links anymore */\n\t\t\tbreak;\n\n\t\tsave_link_key = ih->ih_key;\n\t\tif (is_indirect_le_ih(ih))\n\t\t\ttruncate = 1;\n\t\telse\n\t\t\ttruncate = 0;\n\n\t\t/* reiserfs_iget needs k_dirid and k_objectid only */\n\t\titem = ih_item_body(bh, ih);\n\t\tobj_key.on_disk_key.k_dir_id = le32_to_cpu(*(__le32 *) item);\n\t\tobj_key.on_disk_key.k_objectid =\n\t\t    le32_to_cpu(ih->ih_key.k_objectid);\n\t\tobj_key.on_disk_key.k_offset = 0;\n\t\tobj_key.on_disk_key.k_type = 0;\n\n\t\tpathrelse(&path);\n\n\t\tinode = reiserfs_iget(s, &obj_key);\n\t\tif (!inode) {\n\t\t\t/*\n\t\t\t * the unlink almost completed, it just did not\n\t\t\t * manage to remove \"save\" link and release objectid\n\t\t\t */\n\t\t\treiserfs_warning(s, \"vs-2180\", \"iget failed for %K\",\n\t\t\t\t\t &obj_key);\n\t\t\tretval = remove_save_link_only(s, &save_link_key, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!truncate && inode->i_nlink) {\n\t\t\t/* file is not unlinked */\n\t\t\treiserfs_warning(s, \"vs-2185\",\n\t\t\t\t\t \"file %K is not unlinked\",\n\t\t\t\t\t &obj_key);\n\t\t\tretval = remove_save_link_only(s, &save_link_key, 0);\n\t\t\tcontinue;\n\t\t}\n\t\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\tdquot_initialize(inode);\n\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\t\tif (truncate && S_ISDIR(inode->i_mode)) {\n\t\t\t/*\n\t\t\t * We got a truncate request for a dir which\n\t\t\t * is impossible.  The only imaginable way is to\n\t\t\t * execute unfinished truncate request then boot\n\t\t\t * into old kernel, remove the file and create dir\n\t\t\t * with the same key.\n\t\t\t */\n\t\t\treiserfs_warning(s, \"green-2101\",\n\t\t\t\t\t \"impossible truncate on a \"\n\t\t\t\t\t \"directory %k. Please report\",\n\t\t\t\t\t INODE_PKEY(inode));\n\t\t\tretval = remove_save_link_only(s, &save_link_key, 0);\n\t\t\ttruncate = 0;\n\t\t\tiput(inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (truncate) {\n\t\t\tREISERFS_I(inode)->i_flags |=\n\t\t\t    i_link_saved_truncate_mask;\n\t\t\t/*\n\t\t\t * not completed truncate found. New size was\n\t\t\t * committed together with \"save\" link\n\t\t\t */\n\t\t\treiserfs_info(s, \"Truncating %k to %lld ..\",\n\t\t\t\t      INODE_PKEY(inode), inode->i_size);\n\n\t\t\t/* don't update modification time */\n\t\t\treiserfs_truncate_file(inode, 0);\n\n\t\t\tretval = remove_save_link(inode, truncate);\n\t\t} else {\n\t\t\tREISERFS_I(inode)->i_flags |= i_link_saved_unlink_mask;\n\t\t\t/* not completed unlink (rmdir) found */\n\t\t\treiserfs_info(s, \"Removing %k..\", INODE_PKEY(inode));\n\t\t\tif (memcmp(&last_inode_key, INODE_PKEY(inode),\n\t\t\t\t\tsizeof(last_inode_key))){\n\t\t\t\tlast_inode_key = *INODE_PKEY(inode);\n\t\t\t\t/* removal gets completed in iput */\n\t\t\t\tretval = 0;\n\t\t\t} else {\n\t\t\t\treiserfs_warning(s, \"super-2189\", \"Dead loop \"\n\t\t\t\t\t\t \"in finish_unfinished \"\n\t\t\t\t\t\t \"detected, just remove \"\n\t\t\t\t\t\t \"save link\\n\");\n\t\t\t\tretval = remove_save_link_only(s,\n\t\t\t\t\t\t\t&save_link_key, 0);\n\t\t\t}\n\t\t}\n\n\t\tiput(inode);\n\t\tprintk(\"done\\n\");\n\t\tdone++;\n\t}\n\tREISERFS_SB(s)->s_is_unlinked_ok = 0;\n\n#ifdef CONFIG_QUOTA\n\t/* Turn quotas off */\n\treiserfs_write_unlock(s);\n\tfor (i = 0; i < REISERFS_MAXQUOTAS; i++) {\n\t\tif (sb_dqopt(s)->files[i] && quota_enabled[i])\n\t\t\tdquot_quota_off(s, i);\n\t}\n\treiserfs_write_lock(s);\n\tif (ms_active_set)\n\t\t/* Restore the flag back */\n\t\ts->s_flags &= ~MS_ACTIVE;\n#endif\n\tpathrelse(&path);\n\tif (done)\n\t\treiserfs_info(s, \"There were %d uncompleted unlinks/truncates. \"\n\t\t\t      \"Completed\\n\", done);\n\treturn retval;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int reiserfs_remount(struct super_block *s, int *flags, char *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_info",
          "args": [
            "s",
            "\"There were %d uncompleted unlinks/truncates. \"\n\t\t\t      \"Completed\\n\"",
            "done"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "280-288",
          "snippet": "void reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pathrelse",
          "args": [
            "&path"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "376-387",
          "snippet": "void pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "s"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_quota_off",
          "args": [
            "s",
            "i"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_quota_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "2130-2134",
          "snippet": "int dquot_quota_off(struct super_block *sb, int type)\n{\n\treturn dquot_disable(sb, type,\n\t\t\t     DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_quota_off(struct super_block *sb, int type)\n{\n\treturn dquot_disable(sb, type,\n\t\t\t     DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "s"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "s"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "s"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"done\\n\""
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "291-295",
          "snippet": "static void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nstatic void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_save_link_only",
          "args": [
            "s",
            "&save_link_key",
            "0"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "remove_save_link_only",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "169-186",
          "snippet": "static int remove_save_link_only(struct super_block *s,\n\t\t\t\t struct reiserfs_key *key, int oid_free)\n{\n\tstruct reiserfs_transaction_handle th;\n\tint err;\n\n\t/* we are going to do one balancing */\n\terr = journal_begin(&th, s, JOURNAL_PER_BALANCE_CNT);\n\tif (err)\n\t\treturn err;\n\n\treiserfs_delete_solid_item(&th, NULL, key);\n\tif (oid_free)\n\t\t/* removals are protected by direct items */\n\t\treiserfs_release_objectid(&th, le32_to_cpu(key->k_objectid));\n\n\treturn journal_end(&th);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int remove_save_link_only(struct super_block *s,\n\t\t\t\t struct reiserfs_key *key, int oid_free)\n{\n\tstruct reiserfs_transaction_handle th;\n\tint err;\n\n\t/* we are going to do one balancing */\n\terr = journal_begin(&th, s, JOURNAL_PER_BALANCE_CNT);\n\tif (err)\n\t\treturn err;\n\n\treiserfs_delete_solid_item(&th, NULL, key);\n\tif (oid_free)\n\t\t/* removals are protected by direct items */\n\t\treiserfs_release_objectid(&th, le32_to_cpu(key->k_objectid));\n\n\treturn journal_end(&th);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"super-2189\"",
            "\"Dead loop \"\n\t\t\t\t\t\t \"in finish_unfinished \"\n\t\t\t\t\t\t \"detected, just remove \"\n\t\t\t\t\t\t \"save link\\n\""
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&last_inode_key",
            "INODE_PKEY(inode)",
            "sizeof(last_inode_key)"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_save_link",
          "args": [
            "inode",
            "truncate"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "remove_save_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "476-514",
          "snippet": "int remove_save_link(struct inode *inode, int truncate)\n{\n\tstruct reiserfs_transaction_handle th;\n\tstruct reiserfs_key key;\n\tint err;\n\n\t/* we are going to do one balancing only */\n\terr = journal_begin(&th, inode->i_sb, JOURNAL_PER_BALANCE_CNT);\n\tif (err)\n\t\treturn err;\n\n\t/* setup key of \"save\" link */\n\tkey.k_dir_id = cpu_to_le32(MAX_KEY_OBJECTID);\n\tkey.k_objectid = INODE_PKEY(inode)->k_objectid;\n\tif (!truncate) {\n\t\t/* unlink, rmdir, rename */\n\t\tset_le_key_k_offset(KEY_FORMAT_3_5, &key,\n\t\t\t\t    1 + inode->i_sb->s_blocksize);\n\t\tset_le_key_k_type(KEY_FORMAT_3_5, &key, TYPE_DIRECT);\n\t} else {\n\t\t/* truncate */\n\t\tset_le_key_k_offset(KEY_FORMAT_3_5, &key, 1);\n\t\tset_le_key_k_type(KEY_FORMAT_3_5, &key, TYPE_INDIRECT);\n\t}\n\n\tif ((truncate &&\n\t     (REISERFS_I(inode)->i_flags & i_link_saved_truncate_mask)) ||\n\t    (!truncate &&\n\t     (REISERFS_I(inode)->i_flags & i_link_saved_unlink_mask)))\n\t\t/* don't take quota bytes from anywhere */\n\t\treiserfs_delete_solid_item(&th, NULL, &key);\n\tif (!truncate) {\n\t\treiserfs_release_objectid(&th, inode->i_ino);\n\t\tREISERFS_I(inode)->i_flags &= ~i_link_saved_unlink_mask;\n\t} else\n\t\tREISERFS_I(inode)->i_flags &= ~i_link_saved_truncate_mask;\n\n\treturn journal_end(&th);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint remove_save_link(struct inode *inode, int truncate)\n{\n\tstruct reiserfs_transaction_handle th;\n\tstruct reiserfs_key key;\n\tint err;\n\n\t/* we are going to do one balancing only */\n\terr = journal_begin(&th, inode->i_sb, JOURNAL_PER_BALANCE_CNT);\n\tif (err)\n\t\treturn err;\n\n\t/* setup key of \"save\" link */\n\tkey.k_dir_id = cpu_to_le32(MAX_KEY_OBJECTID);\n\tkey.k_objectid = INODE_PKEY(inode)->k_objectid;\n\tif (!truncate) {\n\t\t/* unlink, rmdir, rename */\n\t\tset_le_key_k_offset(KEY_FORMAT_3_5, &key,\n\t\t\t\t    1 + inode->i_sb->s_blocksize);\n\t\tset_le_key_k_type(KEY_FORMAT_3_5, &key, TYPE_DIRECT);\n\t} else {\n\t\t/* truncate */\n\t\tset_le_key_k_offset(KEY_FORMAT_3_5, &key, 1);\n\t\tset_le_key_k_type(KEY_FORMAT_3_5, &key, TYPE_INDIRECT);\n\t}\n\n\tif ((truncate &&\n\t     (REISERFS_I(inode)->i_flags & i_link_saved_truncate_mask)) ||\n\t    (!truncate &&\n\t     (REISERFS_I(inode)->i_flags & i_link_saved_unlink_mask)))\n\t\t/* don't take quota bytes from anywhere */\n\t\treiserfs_delete_solid_item(&th, NULL, &key);\n\tif (!truncate) {\n\t\treiserfs_release_objectid(&th, inode->i_ino);\n\t\tREISERFS_I(inode)->i_flags &= ~i_link_saved_unlink_mask;\n\t} else\n\t\tREISERFS_I(inode)->i_flags &= ~i_link_saved_truncate_mask;\n\n\treturn journal_end(&th);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_truncate_file",
          "args": [
            "inode",
            "0"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_truncate_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "2263-2362",
          "snippet": "int reiserfs_truncate_file(struct inode *inode, int update_timestamps)\n{\n\tstruct reiserfs_transaction_handle th;\n\t/* we want the offset for the first byte after the end of the file */\n\tunsigned long offset = inode->i_size & (PAGE_CACHE_SIZE - 1);\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\tunsigned length;\n\tstruct page *page = NULL;\n\tint error;\n\tstruct buffer_head *bh = NULL;\n\tint err2;\n\n\treiserfs_write_lock(inode->i_sb);\n\n\tif (inode->i_size > 0) {\n\t\terror = grab_tail_page(inode, &page, &bh);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * -ENOENT means we truncated past the end of the\n\t\t\t * file, and get_block_create_0 could not find a\n\t\t\t * block to read in, which is ok.\n\t\t\t */\n\t\t\tif (error != -ENOENT)\n\t\t\t\treiserfs_error(inode->i_sb, \"clm-6001\",\n\t\t\t\t\t       \"grab_tail_page failed %d\",\n\t\t\t\t\t       error);\n\t\t\tpage = NULL;\n\t\t\tbh = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * so, if page != NULL, we have a buffer head for the offset at\n\t * the end of the file. if the bh is mapped, and bh->b_blocknr != 0,\n\t * then we have an unformatted node.  Otherwise, we have a direct item,\n\t * and no zeroing is required on disk.  We zero after the truncate,\n\t * because the truncate might pack the item anyway\n\t * (it will unmap bh if it packs).\n\t *\n\t * it is enough to reserve space in transaction for 2 balancings:\n\t * one for \"save\" link adding and another for the first\n\t * cut_from_item. 1 is for update_sd\n\t */\n\terror = journal_begin(&th, inode->i_sb,\n\t\t\t      JOURNAL_PER_BALANCE_CNT * 2 + 1);\n\tif (error)\n\t\tgoto out;\n\treiserfs_update_inode_transaction(inode);\n\tif (update_timestamps)\n\t\t/*\n\t\t * we are doing real truncate: if the system crashes\n\t\t * before the last transaction of truncating gets committed\n\t\t * - on reboot the file either appears truncated properly\n\t\t * or not truncated at all\n\t\t */\n\t\tadd_save_link(&th, inode, 1);\n\terr2 = reiserfs_do_truncate(&th, inode, page, update_timestamps);\n\terror = journal_end(&th);\n\tif (error)\n\t\tgoto out;\n\n\t/* check reiserfs_do_truncate after ending the transaction */\n\tif (err2) {\n\t\terror = err2;\n  \t\tgoto out;\n\t}\n\t\n\tif (update_timestamps) {\n\t\terror = remove_save_link(inode, 1 /* truncate */);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif (page) {\n\t\tlength = offset & (blocksize - 1);\n\t\t/* if we are not on a block boundary */\n\t\tif (length) {\n\t\t\tlength = blocksize - length;\n\t\t\tzero_user(page, offset, length);\n\t\t\tif (buffer_mapped(bh) && bh->b_blocknr != 0) {\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\n\treturn 0;\nout:\n\tif (page) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint reiserfs_truncate_file(struct inode *inode, int update_timestamps)\n{\n\tstruct reiserfs_transaction_handle th;\n\t/* we want the offset for the first byte after the end of the file */\n\tunsigned long offset = inode->i_size & (PAGE_CACHE_SIZE - 1);\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\tunsigned length;\n\tstruct page *page = NULL;\n\tint error;\n\tstruct buffer_head *bh = NULL;\n\tint err2;\n\n\treiserfs_write_lock(inode->i_sb);\n\n\tif (inode->i_size > 0) {\n\t\terror = grab_tail_page(inode, &page, &bh);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * -ENOENT means we truncated past the end of the\n\t\t\t * file, and get_block_create_0 could not find a\n\t\t\t * block to read in, which is ok.\n\t\t\t */\n\t\t\tif (error != -ENOENT)\n\t\t\t\treiserfs_error(inode->i_sb, \"clm-6001\",\n\t\t\t\t\t       \"grab_tail_page failed %d\",\n\t\t\t\t\t       error);\n\t\t\tpage = NULL;\n\t\t\tbh = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * so, if page != NULL, we have a buffer head for the offset at\n\t * the end of the file. if the bh is mapped, and bh->b_blocknr != 0,\n\t * then we have an unformatted node.  Otherwise, we have a direct item,\n\t * and no zeroing is required on disk.  We zero after the truncate,\n\t * because the truncate might pack the item anyway\n\t * (it will unmap bh if it packs).\n\t *\n\t * it is enough to reserve space in transaction for 2 balancings:\n\t * one for \"save\" link adding and another for the first\n\t * cut_from_item. 1 is for update_sd\n\t */\n\terror = journal_begin(&th, inode->i_sb,\n\t\t\t      JOURNAL_PER_BALANCE_CNT * 2 + 1);\n\tif (error)\n\t\tgoto out;\n\treiserfs_update_inode_transaction(inode);\n\tif (update_timestamps)\n\t\t/*\n\t\t * we are doing real truncate: if the system crashes\n\t\t * before the last transaction of truncating gets committed\n\t\t * - on reboot the file either appears truncated properly\n\t\t * or not truncated at all\n\t\t */\n\t\tadd_save_link(&th, inode, 1);\n\terr2 = reiserfs_do_truncate(&th, inode, page, update_timestamps);\n\terror = journal_end(&th);\n\tif (error)\n\t\tgoto out;\n\n\t/* check reiserfs_do_truncate after ending the transaction */\n\tif (err2) {\n\t\terror = err2;\n  \t\tgoto out;\n\t}\n\t\n\tif (update_timestamps) {\n\t\terror = remove_save_link(inode, 1 /* truncate */);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif (page) {\n\t\tlength = offset & (blocksize - 1);\n\t\t/* if we are not on a block boundary */\n\t\tif (length) {\n\t\t\tlength = blocksize - length;\n\t\t\tzero_user(page, offset, length);\n\t\t\tif (buffer_mapped(bh) && bh->b_blocknr != 0) {\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\n\treturn 0;\nout:\n\tif (page) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"green-2101\"",
            "\"impossible truncate on a \"\n\t\t\t\t\t \"directory %k. Please report\"",
            "INODE_PKEY(inode)"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "inode->i_sb",
            "depth"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "inode"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_iget",
          "args": [
            "s",
            "&obj_key"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1642-1669",
          "snippet": "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key)\n{\n\tstruct inode *inode;\n\tstruct reiserfs_iget_args args;\n\tint depth;\n\n\targs.objectid = key->on_disk_key.k_objectid;\n\targs.dirid = key->on_disk_key.k_dir_id;\n\tdepth = reiserfs_write_unlock_nested(s);\n\tinode = iget5_locked(s, key->on_disk_key.k_objectid,\n\t\t\t     reiserfs_find_actor, reiserfs_init_locked_inode,\n\t\t\t     (void *)(&args));\n\treiserfs_write_lock_nested(s, depth);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\treiserfs_read_locked_inode(inode, &args);\n\t\tunlock_new_inode(inode);\n\t}\n\n\tif (comp_short_keys(INODE_PKEY(inode), key) || is_bad_inode(inode)) {\n\t\t/* either due to i/o error or a stale NFS handle */\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key)\n{\n\tstruct inode *inode;\n\tstruct reiserfs_iget_args args;\n\tint depth;\n\n\targs.objectid = key->on_disk_key.k_objectid;\n\targs.dirid = key->on_disk_key.k_dir_id;\n\tdepth = reiserfs_write_unlock_nested(s);\n\tinode = iget5_locked(s, key->on_disk_key.k_objectid,\n\t\t\t     reiserfs_find_actor, reiserfs_init_locked_inode,\n\t\t\t     (void *)(&args));\n\treiserfs_write_lock_nested(s, depth);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\treiserfs_read_locked_inode(inode, &args);\n\t\tunlock_new_inode(inode);\n\t}\n\n\tif (comp_short_keys(INODE_PKEY(inode), key) || is_bad_inode(inode)) {\n\t\t/* either due to i/o error or a stale NFS handle */\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ih->ih_key.k_objectid"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_item_body",
          "args": [
            "bh",
            "ih"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "ih_item_body",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2213-2217",
          "snippet": "static inline void *ih_item_body(const struct buffer_head *bh,\n\t\t\t\t const struct item_head *ih)\n{\n\treturn bh->b_data + ih_location(ih);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline void *ih_item_body(const struct buffer_head *bh,\n\t\t\t\t const struct item_head *ih)\n{\n\treturn bh->b_data + ih_location(ih);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_indirect_le_ih",
          "args": [
            "ih"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "is_indirect_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1572-1575",
          "snippet": "static inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "bh",
            "item_pos"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"vs-2060\"",
            "\"wrong position found\""
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "bh"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_item_pos",
          "args": [
            "&path"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_last_bh",
          "args": [
            "&path"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_error",
          "args": [
            "s",
            "\"vs-2140\"",
            "\"search_by_key returned %d\"",
            "retval"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "374-397",
          "snippet": "void __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "search_item",
          "args": [
            "s",
            "&max_cpu_key",
            "&path"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_quota_on_mount",
          "args": [
            "s",
            "i"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_quota_on_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "2322-2326",
          "snippet": "static int reiserfs_quota_on_mount(struct super_block *sb, int type)\n{\n\treturn dquot_quota_on_mount(sb, REISERFS_SB(sb)->s_qf_names[type],\n\t\t\t\t\tREISERFS_SB(sb)->s_jquota_fmt, type);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int reiserfs_quota_on_mount(struct super_block *sb, int type)\n{\n\treturn dquot_quota_on_mount(sb, REISERFS_SB(sb)->s_qf_names[type],\n\t\t\t\t\tREISERFS_SB(sb)->s_jquota_fmt, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_has_quota_active",
          "args": [
            "s",
            "i"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&last_inode_key",
            "0",
            "sizeof(last_inode_key)"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpu_key_k_offset",
          "args": [
            "&max_cpu_key",
            "~0U"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpu_key_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1593-1596",
          "snippet": "static inline void set_cpu_key_k_offset(struct cpu_key *key, loff_t offset)\n{\n\tkey->on_disk_key.k_offset = offset;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void set_cpu_key_k_offset(struct cpu_key *key, loff_t offset)\n{\n\tkey->on_disk_key.k_offset = offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INITIALIZE_PATH",
          "args": [
            "path"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int reiserfs_remount(struct super_block *s, int *flags, char *data);\n\nstatic int finish_unfinished(struct super_block *s)\n{\n\tINITIALIZE_PATH(path);\n\tstruct cpu_key max_cpu_key, obj_key;\n\tstruct reiserfs_key save_link_key, last_inode_key;\n\tint retval = 0;\n\tstruct item_head *ih;\n\tstruct buffer_head *bh;\n\tint item_pos;\n\tchar *item;\n\tint done;\n\tstruct inode *inode;\n\tint truncate;\n#ifdef CONFIG_QUOTA\n\tint i;\n\tint ms_active_set;\n\tint quota_enabled[REISERFS_MAXQUOTAS];\n#endif\n\n\t/* compose key to look for \"save\" links */\n\tmax_cpu_key.version = KEY_FORMAT_3_5;\n\tmax_cpu_key.on_disk_key.k_dir_id = ~0U;\n\tmax_cpu_key.on_disk_key.k_objectid = ~0U;\n\tset_cpu_key_k_offset(&max_cpu_key, ~0U);\n\tmax_cpu_key.key_length = 3;\n\n\tmemset(&last_inode_key, 0, sizeof(last_inode_key));\n\n#ifdef CONFIG_QUOTA\n\t/* Needed for iput() to work correctly and not trash data */\n\tif (s->s_flags & MS_ACTIVE) {\n\t\tms_active_set = 0;\n\t} else {\n\t\tms_active_set = 1;\n\t\ts->s_flags |= MS_ACTIVE;\n\t}\n\t/* Turn on quotas so that they are updated correctly */\n\tfor (i = 0; i < REISERFS_MAXQUOTAS; i++) {\n\t\tquota_enabled[i] = 1;\n\t\tif (REISERFS_SB(s)->s_qf_names[i]) {\n\t\t\tint ret;\n\n\t\t\tif (sb_has_quota_active(s, i)) {\n\t\t\t\tquota_enabled[i] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tret = reiserfs_quota_on_mount(s, i);\n\t\t\tif (ret < 0)\n\t\t\t\treiserfs_warning(s, \"reiserfs-2500\",\n\t\t\t\t\t\t \"cannot turn on journaled \"\n\t\t\t\t\t\t \"quota: error %d\", ret);\n\t\t}\n\t}\n#endif\n\n\tdone = 0;\n\tREISERFS_SB(s)->s_is_unlinked_ok = 1;\n\twhile (!retval) {\n\t\tint depth;\n\t\tretval = search_item(s, &max_cpu_key, &path);\n\t\tif (retval != ITEM_NOT_FOUND) {\n\t\t\treiserfs_error(s, \"vs-2140\",\n\t\t\t\t       \"search_by_key returned %d\", retval);\n\t\t\tbreak;\n\t\t}\n\n\t\tbh = get_last_bh(&path);\n\t\titem_pos = get_item_pos(&path);\n\t\tif (item_pos != B_NR_ITEMS(bh)) {\n\t\t\treiserfs_warning(s, \"vs-2060\",\n\t\t\t\t\t \"wrong position found\");\n\t\t\tbreak;\n\t\t}\n\t\titem_pos--;\n\t\tih = item_head(bh, item_pos);\n\n\t\tif (le32_to_cpu(ih->ih_key.k_dir_id) != MAX_KEY_OBJECTID)\n\t\t\t/* there are no \"save\" links anymore */\n\t\t\tbreak;\n\n\t\tsave_link_key = ih->ih_key;\n\t\tif (is_indirect_le_ih(ih))\n\t\t\ttruncate = 1;\n\t\telse\n\t\t\ttruncate = 0;\n\n\t\t/* reiserfs_iget needs k_dirid and k_objectid only */\n\t\titem = ih_item_body(bh, ih);\n\t\tobj_key.on_disk_key.k_dir_id = le32_to_cpu(*(__le32 *) item);\n\t\tobj_key.on_disk_key.k_objectid =\n\t\t    le32_to_cpu(ih->ih_key.k_objectid);\n\t\tobj_key.on_disk_key.k_offset = 0;\n\t\tobj_key.on_disk_key.k_type = 0;\n\n\t\tpathrelse(&path);\n\n\t\tinode = reiserfs_iget(s, &obj_key);\n\t\tif (!inode) {\n\t\t\t/*\n\t\t\t * the unlink almost completed, it just did not\n\t\t\t * manage to remove \"save\" link and release objectid\n\t\t\t */\n\t\t\treiserfs_warning(s, \"vs-2180\", \"iget failed for %K\",\n\t\t\t\t\t &obj_key);\n\t\t\tretval = remove_save_link_only(s, &save_link_key, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!truncate && inode->i_nlink) {\n\t\t\t/* file is not unlinked */\n\t\t\treiserfs_warning(s, \"vs-2185\",\n\t\t\t\t\t \"file %K is not unlinked\",\n\t\t\t\t\t &obj_key);\n\t\t\tretval = remove_save_link_only(s, &save_link_key, 0);\n\t\t\tcontinue;\n\t\t}\n\t\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\tdquot_initialize(inode);\n\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\t\tif (truncate && S_ISDIR(inode->i_mode)) {\n\t\t\t/*\n\t\t\t * We got a truncate request for a dir which\n\t\t\t * is impossible.  The only imaginable way is to\n\t\t\t * execute unfinished truncate request then boot\n\t\t\t * into old kernel, remove the file and create dir\n\t\t\t * with the same key.\n\t\t\t */\n\t\t\treiserfs_warning(s, \"green-2101\",\n\t\t\t\t\t \"impossible truncate on a \"\n\t\t\t\t\t \"directory %k. Please report\",\n\t\t\t\t\t INODE_PKEY(inode));\n\t\t\tretval = remove_save_link_only(s, &save_link_key, 0);\n\t\t\ttruncate = 0;\n\t\t\tiput(inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (truncate) {\n\t\t\tREISERFS_I(inode)->i_flags |=\n\t\t\t    i_link_saved_truncate_mask;\n\t\t\t/*\n\t\t\t * not completed truncate found. New size was\n\t\t\t * committed together with \"save\" link\n\t\t\t */\n\t\t\treiserfs_info(s, \"Truncating %k to %lld ..\",\n\t\t\t\t      INODE_PKEY(inode), inode->i_size);\n\n\t\t\t/* don't update modification time */\n\t\t\treiserfs_truncate_file(inode, 0);\n\n\t\t\tretval = remove_save_link(inode, truncate);\n\t\t} else {\n\t\t\tREISERFS_I(inode)->i_flags |= i_link_saved_unlink_mask;\n\t\t\t/* not completed unlink (rmdir) found */\n\t\t\treiserfs_info(s, \"Removing %k..\", INODE_PKEY(inode));\n\t\t\tif (memcmp(&last_inode_key, INODE_PKEY(inode),\n\t\t\t\t\tsizeof(last_inode_key))){\n\t\t\t\tlast_inode_key = *INODE_PKEY(inode);\n\t\t\t\t/* removal gets completed in iput */\n\t\t\t\tretval = 0;\n\t\t\t} else {\n\t\t\t\treiserfs_warning(s, \"super-2189\", \"Dead loop \"\n\t\t\t\t\t\t \"in finish_unfinished \"\n\t\t\t\t\t\t \"detected, just remove \"\n\t\t\t\t\t\t \"save link\\n\");\n\t\t\t\tretval = remove_save_link_only(s,\n\t\t\t\t\t\t\t&save_link_key, 0);\n\t\t\t}\n\t\t}\n\n\t\tiput(inode);\n\t\tprintk(\"done\\n\");\n\t\tdone++;\n\t}\n\tREISERFS_SB(s)->s_is_unlinked_ok = 0;\n\n#ifdef CONFIG_QUOTA\n\t/* Turn quotas off */\n\treiserfs_write_unlock(s);\n\tfor (i = 0; i < REISERFS_MAXQUOTAS; i++) {\n\t\tif (sb_dqopt(s)->files[i] && quota_enabled[i])\n\t\t\tdquot_quota_off(s, i);\n\t}\n\treiserfs_write_lock(s);\n\tif (ms_active_set)\n\t\t/* Restore the flag back */\n\t\ts->s_flags &= ~MS_ACTIVE;\n#endif\n\tpathrelse(&path);\n\tif (done)\n\t\treiserfs_info(s, \"There were %d uncompleted unlinks/truncates. \"\n\t\t\t      \"Completed\\n\", done);\n\treturn retval;\n}"
  },
  {
    "function_name": "remove_save_link_only",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "169-186",
    "snippet": "static int remove_save_link_only(struct super_block *s,\n\t\t\t\t struct reiserfs_key *key, int oid_free)\n{\n\tstruct reiserfs_transaction_handle th;\n\tint err;\n\n\t/* we are going to do one balancing */\n\terr = journal_begin(&th, s, JOURNAL_PER_BALANCE_CNT);\n\tif (err)\n\t\treturn err;\n\n\treiserfs_delete_solid_item(&th, NULL, key);\n\tif (oid_free)\n\t\t/* removals are protected by direct items */\n\t\treiserfs_release_objectid(&th, le32_to_cpu(key->k_objectid));\n\n\treturn journal_end(&th);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "&th"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_release_objectid",
          "args": [
            "&th",
            "le32_to_cpu(key->k_objectid)"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_release_objectid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/objectid.c",
          "lines": "97-177",
          "snippet": "void reiserfs_release_objectid(struct reiserfs_transaction_handle *th,\n\t\t\t       __u32 objectid_to_release)\n{\n\tstruct super_block *s = th->t_super;\n\tstruct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(s);\n\t__le32 *map = objectid_map(s, rs);\n\tint i = 0;\n\n\tBUG_ON(!th->t_trans_id);\n\t/*return; */\n\tcheck_objectid_map(s, map);\n\n\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);\n\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(s));\n\n\t/*\n\t * start at the beginning of the objectid map (i = 0) and go to\n\t * the end of it (i = disk_sb->s_oid_cursize).  Linear search is\n\t * what we use, though it is possible that binary search would be\n\t * more efficient after performing lots of deletions (which is\n\t * when oids is large.)  We only check even i's.\n\t */\n\twhile (i < sb_oid_cursize(rs)) {\n\t\tif (objectid_to_release == le32_to_cpu(map[i])) {\n\t\t\t/* This incrementation unallocates the objectid. */\n\t\t\tle32_add_cpu(&map[i], 1);\n\n\t\t\t/*\n\t\t\t * Did we unallocate the last member of an\n\t\t\t * odd sequence, and can shrink oids?\n\t\t\t */\n\t\t\tif (map[i] == map[i + 1]) {\n\t\t\t\t/* shrink objectid map */\n\t\t\t\tmemmove(map + i, map + i + 2,\n\t\t\t\t\t(sb_oid_cursize(rs) - i -\n\t\t\t\t\t 2) * sizeof(__u32));\n\t\t\t\tset_sb_oid_cursize(rs, sb_oid_cursize(rs) - 2);\n\n\t\t\t\tRFALSE(sb_oid_cursize(rs) < 2 ||\n\t\t\t\t       sb_oid_cursize(rs) > sb_oid_maxsize(rs),\n\t\t\t\t       \"vs-15005: objectid map corrupted cur_size == %d (max == %d)\",\n\t\t\t\t       sb_oid_cursize(rs), sb_oid_maxsize(rs));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (objectid_to_release > le32_to_cpu(map[i]) &&\n\t\t    objectid_to_release < le32_to_cpu(map[i + 1])) {\n\t\t\t/* size of objectid map is not changed */\n\t\t\tif (objectid_to_release + 1 == le32_to_cpu(map[i + 1])) {\n\t\t\t\tle32_add_cpu(&map[i + 1], -1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * JDM comparing two little-endian values for\n\t\t\t * equality -- safe\n\t\t\t */\n\t\t\t/*\n\t\t\t * objectid map must be expanded, but\n\t\t\t * there is no space\n\t\t\t */\n\t\t\tif (sb_oid_cursize(rs) == sb_oid_maxsize(rs)) {\n\t\t\t\tPROC_INFO_INC(s, leaked_oid);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* expand the objectid map */\n\t\t\tmemmove(map + i + 3, map + i + 1,\n\t\t\t\t(sb_oid_cursize(rs) - i - 1) * sizeof(__u32));\n\t\t\tmap[i + 1] = cpu_to_le32(objectid_to_release);\n\t\t\tmap[i + 2] = cpu_to_le32(objectid_to_release + 1);\n\t\t\tset_sb_oid_cursize(rs, sb_oid_cursize(rs) + 2);\n\t\t\treturn;\n\t\t}\n\t\ti += 2;\n\t}\n\n\treiserfs_error(s, \"vs-15011\", \"tried to free free object id (%lu)\",\n\t\t       (long unsigned)objectid_to_release);\n}",
          "includes": [
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/random.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/random.h>\n#include <linux/string.h>\n\nvoid reiserfs_release_objectid(struct reiserfs_transaction_handle *th,\n\t\t\t       __u32 objectid_to_release)\n{\n\tstruct super_block *s = th->t_super;\n\tstruct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(s);\n\t__le32 *map = objectid_map(s, rs);\n\tint i = 0;\n\n\tBUG_ON(!th->t_trans_id);\n\t/*return; */\n\tcheck_objectid_map(s, map);\n\n\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);\n\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(s));\n\n\t/*\n\t * start at the beginning of the objectid map (i = 0) and go to\n\t * the end of it (i = disk_sb->s_oid_cursize).  Linear search is\n\t * what we use, though it is possible that binary search would be\n\t * more efficient after performing lots of deletions (which is\n\t * when oids is large.)  We only check even i's.\n\t */\n\twhile (i < sb_oid_cursize(rs)) {\n\t\tif (objectid_to_release == le32_to_cpu(map[i])) {\n\t\t\t/* This incrementation unallocates the objectid. */\n\t\t\tle32_add_cpu(&map[i], 1);\n\n\t\t\t/*\n\t\t\t * Did we unallocate the last member of an\n\t\t\t * odd sequence, and can shrink oids?\n\t\t\t */\n\t\t\tif (map[i] == map[i + 1]) {\n\t\t\t\t/* shrink objectid map */\n\t\t\t\tmemmove(map + i, map + i + 2,\n\t\t\t\t\t(sb_oid_cursize(rs) - i -\n\t\t\t\t\t 2) * sizeof(__u32));\n\t\t\t\tset_sb_oid_cursize(rs, sb_oid_cursize(rs) - 2);\n\n\t\t\t\tRFALSE(sb_oid_cursize(rs) < 2 ||\n\t\t\t\t       sb_oid_cursize(rs) > sb_oid_maxsize(rs),\n\t\t\t\t       \"vs-15005: objectid map corrupted cur_size == %d (max == %d)\",\n\t\t\t\t       sb_oid_cursize(rs), sb_oid_maxsize(rs));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (objectid_to_release > le32_to_cpu(map[i]) &&\n\t\t    objectid_to_release < le32_to_cpu(map[i + 1])) {\n\t\t\t/* size of objectid map is not changed */\n\t\t\tif (objectid_to_release + 1 == le32_to_cpu(map[i + 1])) {\n\t\t\t\tle32_add_cpu(&map[i + 1], -1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * JDM comparing two little-endian values for\n\t\t\t * equality -- safe\n\t\t\t */\n\t\t\t/*\n\t\t\t * objectid map must be expanded, but\n\t\t\t * there is no space\n\t\t\t */\n\t\t\tif (sb_oid_cursize(rs) == sb_oid_maxsize(rs)) {\n\t\t\t\tPROC_INFO_INC(s, leaked_oid);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* expand the objectid map */\n\t\t\tmemmove(map + i + 3, map + i + 1,\n\t\t\t\t(sb_oid_cursize(rs) - i - 1) * sizeof(__u32));\n\t\t\tmap[i + 1] = cpu_to_le32(objectid_to_release);\n\t\t\tmap[i + 2] = cpu_to_le32(objectid_to_release + 1);\n\t\t\tset_sb_oid_cursize(rs, sb_oid_cursize(rs) + 2);\n\t\t\treturn;\n\t\t}\n\t\ti += 2;\n\t}\n\n\treiserfs_error(s, \"vs-15011\", \"tried to free free object id (%lu)\",\n\t\t       (long unsigned)objectid_to_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "key->k_objectid"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_delete_solid_item",
          "args": [
            "&th",
            "NULL",
            "key"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "s",
            "JOURNAL_PER_BALANCE_CNT"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int remove_save_link_only(struct super_block *s,\n\t\t\t\t struct reiserfs_key *key, int oid_free)\n{\n\tstruct reiserfs_transaction_handle th;\n\tint err;\n\n\t/* we are going to do one balancing */\n\terr = journal_begin(&th, s, JOURNAL_PER_BALANCE_CNT);\n\tif (err)\n\t\treturn err;\n\n\treiserfs_delete_solid_item(&th, NULL, key);\n\tif (oid_free)\n\t\t/* removals are protected by direct items */\n\t\treiserfs_release_objectid(&th, le32_to_cpu(key->k_objectid));\n\n\treturn journal_end(&th);\n}"
  },
  {
    "function_name": "reiserfs_unfreeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "152-156",
    "snippet": "static int reiserfs_unfreeze(struct super_block *s)\n{\n\treiserfs_allow_writes(s);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_allow_writes",
          "args": [
            "s"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_allow_writes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "2944-2949",
          "snippet": "void reiserfs_allow_writes(struct super_block *s)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tclear_bit(J_WRITERS_BLOCKED, &journal->j_state);\n\twake_up(&journal->j_join_wait);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static void queue_log_writer(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic void queue_log_writer(struct super_block *s);\n\nvoid reiserfs_allow_writes(struct super_block *s)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tclear_bit(J_WRITERS_BLOCKED, &journal->j_state);\n\twake_up(&journal->j_join_wait);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int reiserfs_unfreeze(struct super_block *s)\n{\n\treiserfs_allow_writes(s);\n\treturn 0;\n}"
  },
  {
    "function_name": "reiserfs_freeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "129-150",
    "snippet": "static int reiserfs_freeze(struct super_block *s)\n{\n\tstruct reiserfs_transaction_handle th;\n\n\tcancel_old_flush(s);\n\n\treiserfs_write_lock(s);\n\tif (!(s->s_flags & MS_RDONLY)) {\n\t\tint err = journal_begin(&th, s, 1);\n\t\tif (err) {\n\t\t\treiserfs_block_writes(&th);\n\t\t} else {\n\t\t\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s),\n\t\t\t\t\t\t     1);\n\t\t\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(s));\n\t\t\treiserfs_block_writes(&th);\n\t\t\tjournal_end_sync(&th);\n\t\t}\n\t}\n\treiserfs_write_unlock(s);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "s"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end_sync",
          "args": [
            "&th"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_block_writes",
          "args": [
            "&th"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_block_writes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "2934-2941",
          "snippet": "void reiserfs_block_writes(struct reiserfs_transaction_handle *th)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(th->t_super);\n\tBUG_ON(!th->t_trans_id);\n\tjournal->j_must_wait = 1;\n\tset_bit(J_WRITERS_BLOCKED, &journal->j_state);\n\treturn;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(th->t_super);\n\tBUG_ON(!th->t_trans_id);\n\tjournal->j_must_wait = 1;\n\tset_bit(J_WRITERS_BLOCKED, &journal->j_state);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_mark_dirty",
          "args": [
            "&th",
            "SB_BUFFER_WITH_SB(s)"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "journal_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3274-3379",
          "snippet": "int journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_prepare_for_journal",
          "args": [
            "s",
            "SB_BUFFER_WITH_SB(s)",
            "1"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_prepare_for_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3951-3968",
          "snippet": "int reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "s",
            "1"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "s"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_old_flush",
          "args": [
            "s"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "cancel_old_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "119-127",
          "snippet": "static void cancel_old_flush(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sbi = REISERFS_SB(s);\n\n\tcancel_delayed_work_sync(&REISERFS_SB(s)->old_work);\n\tspin_lock(&sbi->old_work_lock);\n\tsbi->work_queued = 0;\n\tspin_unlock(&sbi->old_work_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void cancel_old_flush(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sbi = REISERFS_SB(s);\n\n\tcancel_delayed_work_sync(&REISERFS_SB(s)->old_work);\n\tspin_lock(&sbi->old_work_lock);\n\tsbi->work_queued = 0;\n\tspin_unlock(&sbi->old_work_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int reiserfs_freeze(struct super_block *s)\n{\n\tstruct reiserfs_transaction_handle th;\n\n\tcancel_old_flush(s);\n\n\treiserfs_write_lock(s);\n\tif (!(s->s_flags & MS_RDONLY)) {\n\t\tint err = journal_begin(&th, s, 1);\n\t\tif (err) {\n\t\t\treiserfs_block_writes(&th);\n\t\t} else {\n\t\t\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s),\n\t\t\t\t\t\t     1);\n\t\t\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(s));\n\t\t\treiserfs_block_writes(&th);\n\t\t\tjournal_end_sync(&th);\n\t\t}\n\t}\n\treiserfs_write_unlock(s);\n\treturn 0;\n}"
  },
  {
    "function_name": "cancel_old_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "119-127",
    "snippet": "static void cancel_old_flush(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sbi = REISERFS_SB(s);\n\n\tcancel_delayed_work_sync(&REISERFS_SB(s)->old_work);\n\tspin_lock(&sbi->old_work_lock);\n\tsbi->work_queued = 0;\n\tspin_unlock(&sbi->old_work_lock);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->old_work_lock"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->old_work_lock"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&REISERFS_SB(s)->old_work"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "s"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void cancel_old_flush(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sbi = REISERFS_SB(s);\n\n\tcancel_delayed_work_sync(&REISERFS_SB(s)->old_work);\n\tspin_lock(&sbi->old_work_lock);\n\tsbi->work_queued = 0;\n\tspin_unlock(&sbi->old_work_lock);\n}"
  },
  {
    "function_name": "reiserfs_schedule_old_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "98-117",
    "snippet": "void reiserfs_schedule_old_flush(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sbi = REISERFS_SB(s);\n\tunsigned long delay;\n\n\t/*\n\t * Avoid scheduling flush when sb is being shut down. It can race\n\t * with journal shutdown and free still queued delayed work.\n\t */\n\tif (s->s_flags & MS_RDONLY || !(s->s_flags & MS_ACTIVE))\n\t\treturn;\n\n\tspin_lock(&sbi->old_work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->old_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->old_work_lock);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->old_work_lock"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "system_long_wq",
            "&sbi->old_work",
            "delay"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "dirty_writeback_interval * 10"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->old_work_lock"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "s"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid reiserfs_schedule_old_flush(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sbi = REISERFS_SB(s);\n\tunsigned long delay;\n\n\t/*\n\t * Avoid scheduling flush when sb is being shut down. It can race\n\t * with journal shutdown and free still queued delayed work.\n\t */\n\tif (s->s_flags & MS_RDONLY || !(s->s_flags & MS_ACTIVE))\n\t\treturn;\n\n\tspin_lock(&sbi->old_work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->old_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->old_work_lock);\n}"
  },
  {
    "function_name": "flush_old_commits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "83-96",
    "snippet": "static void flush_old_commits(struct work_struct *work)\n{\n\tstruct reiserfs_sb_info *sbi;\n\tstruct super_block *s;\n\n\tsbi = container_of(work, struct reiserfs_sb_info, old_work.work);\n\ts = sbi->s_journal->j_work_sb;\n\n\tspin_lock(&sbi->old_work_lock);\n\tsbi->work_queued = 0;\n\tspin_unlock(&sbi->old_work_lock);\n\n\treiserfs_sync_fs(s, 1);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_sync_fs",
          "args": [
            "s",
            "1"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_sync_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "66-81",
          "snippet": "static int reiserfs_sync_fs(struct super_block *s, int wait)\n{\n\tstruct reiserfs_transaction_handle th;\n\n\t/*\n\t * Writeback quota in non-journalled quota case - journalled quota has\n\t * no dirty dquots\n\t */\n\tdquot_writeback_dquots(s, -1);\n\treiserfs_write_lock(s);\n\tif (!journal_begin(&th, s, 1))\n\t\tif (!journal_end_sync(&th))\n\t\t\treiserfs_flush_old_commits(s);\n\treiserfs_write_unlock(s);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int reiserfs_sync_fs(struct super_block *s, int wait)\n{\n\tstruct reiserfs_transaction_handle th;\n\n\t/*\n\t * Writeback quota in non-journalled quota case - journalled quota has\n\t * no dirty dquots\n\t */\n\tdquot_writeback_dquots(s, -1);\n\treiserfs_write_lock(s);\n\tif (!journal_begin(&th, s, 1))\n\t\tif (!journal_end_sync(&th))\n\t\t\treiserfs_flush_old_commits(s);\n\treiserfs_write_unlock(s);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->old_work_lock"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->old_work_lock"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structreiserfs_sb_info",
            "old_work.work"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void flush_old_commits(struct work_struct *work)\n{\n\tstruct reiserfs_sb_info *sbi;\n\tstruct super_block *s;\n\n\tsbi = container_of(work, struct reiserfs_sb_info, old_work.work);\n\ts = sbi->s_journal->j_work_sb;\n\n\tspin_lock(&sbi->old_work_lock);\n\tsbi->work_queued = 0;\n\tspin_unlock(&sbi->old_work_lock);\n\n\treiserfs_sync_fs(s, 1);\n}"
  },
  {
    "function_name": "reiserfs_sync_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "66-81",
    "snippet": "static int reiserfs_sync_fs(struct super_block *s, int wait)\n{\n\tstruct reiserfs_transaction_handle th;\n\n\t/*\n\t * Writeback quota in non-journalled quota case - journalled quota has\n\t * no dirty dquots\n\t */\n\tdquot_writeback_dquots(s, -1);\n\treiserfs_write_lock(s);\n\tif (!journal_begin(&th, s, 1))\n\t\tif (!journal_end_sync(&th))\n\t\t\treiserfs_flush_old_commits(s);\n\treiserfs_write_unlock(s);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "s"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_flush_old_commits",
          "args": [
            "s"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_flush_old_commits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3558-3594",
          "snippet": "void reiserfs_flush_old_commits(struct super_block *sb)\n{\n\ttime_t now;\n\tstruct reiserfs_transaction_handle th;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tnow = get_seconds();\n\t/*\n\t * safety check so we don't flush while we are replaying the log during\n\t * mount\n\t */\n\tif (list_empty(&journal->j_journal_list))\n\t\treturn;\n\n\t/*\n\t * check the current transaction.  If there are no writers, and it is\n\t * too old, finish it, and force the commit blocks to disk\n\t */\n\tif (atomic_read(&journal->j_wcount) <= 0 &&\n\t    journal->j_trans_start_time > 0 &&\n\t    journal->j_len > 0 &&\n\t    (now - journal->j_trans_start_time) > journal->j_max_trans_age) {\n\t\tif (!journal_join(&th, sb)) {\n\t\t\treiserfs_prepare_for_journal(sb,\n\t\t\t\t\t\t     SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t\t     1);\n\t\t\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(sb));\n\n\t\t\t/*\n\t\t\t * we're only being called from kreiserfsd, it makes\n\t\t\t * no sense to do an async commit so that kreiserfsd\n\t\t\t * can do it later\n\t\t\t */\n\t\t\tdo_journal_end(&th, COMMIT_NOW | WAIT);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_flush_old_commits(struct super_block *sb)\n{\n\ttime_t now;\n\tstruct reiserfs_transaction_handle th;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tnow = get_seconds();\n\t/*\n\t * safety check so we don't flush while we are replaying the log during\n\t * mount\n\t */\n\tif (list_empty(&journal->j_journal_list))\n\t\treturn;\n\n\t/*\n\t * check the current transaction.  If there are no writers, and it is\n\t * too old, finish it, and force the commit blocks to disk\n\t */\n\tif (atomic_read(&journal->j_wcount) <= 0 &&\n\t    journal->j_trans_start_time > 0 &&\n\t    journal->j_len > 0 &&\n\t    (now - journal->j_trans_start_time) > journal->j_max_trans_age) {\n\t\tif (!journal_join(&th, sb)) {\n\t\t\treiserfs_prepare_for_journal(sb,\n\t\t\t\t\t\t     SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t\t     1);\n\t\t\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(sb));\n\n\t\t\t/*\n\t\t\t * we're only being called from kreiserfsd, it makes\n\t\t\t * no sense to do an async commit so that kreiserfsd\n\t\t\t * can do it later\n\t\t\t */\n\t\t\tdo_journal_end(&th, COMMIT_NOW | WAIT);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end_sync",
          "args": [
            "&th"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "s",
            "1"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "s"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_writeback_dquots",
          "args": [
            "s",
            "-1"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_writeback_dquots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "605-652",
          "snippet": "int dquot_writeback_dquots(struct super_block *sb, int type)\n{\n\tstruct list_head *dirty;\n\tstruct dquot *dquot;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tint cnt;\n\tint err, ret = 0;\n\n\tmutex_lock(&dqopt->dqonoff_mutex);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\t\tif (!sb_has_quota_active(sb, cnt))\n\t\t\tcontinue;\n\t\tspin_lock(&dq_list_lock);\n\t\tdirty = &dqopt->info[cnt].dqi_dirty_list;\n\t\twhile (!list_empty(dirty)) {\n\t\t\tdquot = list_first_entry(dirty, struct dquot,\n\t\t\t\t\t\t dq_dirty);\n\t\t\t/* Dirty and inactive can be only bad dquot... */\n\t\t\tif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {\n\t\t\t\tclear_dquot_dirty(dquot);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Now we have active dquot from which someone is\n \t\t\t * holding reference so we can safely just increase\n\t\t\t * use count */\n\t\t\tdqgrab(dquot);\n\t\t\tspin_unlock(&dq_list_lock);\n\t\t\tdqstats_inc(DQST_LOOKUPS);\n\t\t\terr = sb->dq_op->write_dquot(dquot);\n\t\t\tif (!ret && err)\n\t\t\t\tret = err;\n\t\t\tdqput(dquot);\n\t\t\tspin_lock(&dq_list_lock);\n\t\t}\n\t\tspin_unlock(&dq_list_lock);\n\t}\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif ((cnt == type || type == -1) && sb_has_quota_active(sb, cnt)\n\t\t    && info_dirty(&dqopt->info[cnt]))\n\t\t\tsb->dq_op->write_info(sb, cnt);\n\tdqstats_inc(DQST_SYNCS);\n\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_writeback_dquots(struct super_block *sb, int type)\n{\n\tstruct list_head *dirty;\n\tstruct dquot *dquot;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tint cnt;\n\tint err, ret = 0;\n\n\tmutex_lock(&dqopt->dqonoff_mutex);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\t\tif (!sb_has_quota_active(sb, cnt))\n\t\t\tcontinue;\n\t\tspin_lock(&dq_list_lock);\n\t\tdirty = &dqopt->info[cnt].dqi_dirty_list;\n\t\twhile (!list_empty(dirty)) {\n\t\t\tdquot = list_first_entry(dirty, struct dquot,\n\t\t\t\t\t\t dq_dirty);\n\t\t\t/* Dirty and inactive can be only bad dquot... */\n\t\t\tif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {\n\t\t\t\tclear_dquot_dirty(dquot);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Now we have active dquot from which someone is\n \t\t\t * holding reference so we can safely just increase\n\t\t\t * use count */\n\t\t\tdqgrab(dquot);\n\t\t\tspin_unlock(&dq_list_lock);\n\t\t\tdqstats_inc(DQST_LOOKUPS);\n\t\t\terr = sb->dq_op->write_dquot(dquot);\n\t\t\tif (!ret && err)\n\t\t\t\tret = err;\n\t\t\tdqput(dquot);\n\t\t\tspin_lock(&dq_list_lock);\n\t\t}\n\t\tspin_unlock(&dq_list_lock);\n\t}\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif ((cnt == type || type == -1) && sb_has_quota_active(sb, cnt)\n\t\t    && info_dirty(&dqopt->info[cnt]))\n\t\t\tsb->dq_op->write_info(sb, cnt);\n\tdqstats_inc(DQST_SYNCS);\n\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int reiserfs_sync_fs(struct super_block *s, int wait)\n{\n\tstruct reiserfs_transaction_handle th;\n\n\t/*\n\t * Writeback quota in non-journalled quota case - journalled quota has\n\t * no dirty dquots\n\t */\n\tdquot_writeback_dquots(s, -1);\n\treiserfs_write_lock(s);\n\tif (!journal_begin(&th, s, 1))\n\t\tif (!journal_end_sync(&th))\n\t\t\treiserfs_flush_old_commits(s);\n\treiserfs_write_unlock(s);\n\treturn 0;\n}"
  },
  {
    "function_name": "is_any_reiserfs_magic_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "57-61",
    "snippet": "static int is_any_reiserfs_magic_string(struct reiserfs_super_block *rs)\n{\n\treturn (is_reiserfs_3_5(rs) || is_reiserfs_3_6(rs) ||\n\t\tis_reiserfs_jr(rs));\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_reiserfs_jr",
          "args": [
            "rs"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "is_reiserfs_jr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "51-55",
          "snippet": "int is_reiserfs_jr(struct reiserfs_super_block *rs)\n{\n\treturn !strncmp(rs->s_v1.s_magic, reiserfs_jr_magic_string,\n\t\t\tstrlen(reiserfs_jr_magic_string));\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char reiserfs_jr_magic_string[] = REISER2FS_JR_SUPER_MAGIC_STRING;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const char reiserfs_jr_magic_string[] = REISER2FS_JR_SUPER_MAGIC_STRING;\n\nint is_reiserfs_jr(struct reiserfs_super_block *rs)\n{\n\treturn !strncmp(rs->s_v1.s_magic, reiserfs_jr_magic_string,\n\t\t\tstrlen(reiserfs_jr_magic_string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_reiserfs_3_6",
          "args": [
            "rs"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "is_reiserfs_3_6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "45-49",
          "snippet": "int is_reiserfs_3_6(struct reiserfs_super_block *rs)\n{\n\treturn !strncmp(rs->s_v1.s_magic, reiserfs_3_6_magic_string,\n\t\t\tstrlen(reiserfs_3_6_magic_string));\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char reiserfs_3_6_magic_string[] = REISER2FS_SUPER_MAGIC_STRING;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const char reiserfs_3_6_magic_string[] = REISER2FS_SUPER_MAGIC_STRING;\n\nint is_reiserfs_3_6(struct reiserfs_super_block *rs)\n{\n\treturn !strncmp(rs->s_v1.s_magic, reiserfs_3_6_magic_string,\n\t\t\tstrlen(reiserfs_3_6_magic_string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_reiserfs_3_5",
          "args": [
            "rs"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "is_reiserfs_3_5",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "39-43",
          "snippet": "int is_reiserfs_3_5(struct reiserfs_super_block *rs)\n{\n\treturn !strncmp(rs->s_v1.s_magic, reiserfs_3_5_magic_string,\n\t\t\tstrlen(reiserfs_3_5_magic_string));\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char reiserfs_3_5_magic_string[] = REISERFS_SUPER_MAGIC_STRING;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const char reiserfs_3_5_magic_string[] = REISERFS_SUPER_MAGIC_STRING;\n\nint is_reiserfs_3_5(struct reiserfs_super_block *rs)\n{\n\treturn !strncmp(rs->s_v1.s_magic, reiserfs_3_5_magic_string,\n\t\t\tstrlen(reiserfs_3_5_magic_string));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int is_any_reiserfs_magic_string(struct reiserfs_super_block *rs)\n{\n\treturn (is_reiserfs_3_5(rs) || is_reiserfs_3_6(rs) ||\n\t\tis_reiserfs_jr(rs));\n}"
  },
  {
    "function_name": "is_reiserfs_jr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "51-55",
    "snippet": "int is_reiserfs_jr(struct reiserfs_super_block *rs)\n{\n\treturn !strncmp(rs->s_v1.s_magic, reiserfs_jr_magic_string,\n\t\t\tstrlen(reiserfs_jr_magic_string));\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char reiserfs_jr_magic_string[] = REISER2FS_JR_SUPER_MAGIC_STRING;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "rs->s_v1.s_magic",
            "reiserfs_jr_magic_string",
            "strlen(reiserfs_jr_magic_string)"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "reiserfs_jr_magic_string"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const char reiserfs_jr_magic_string[] = REISER2FS_JR_SUPER_MAGIC_STRING;\n\nint is_reiserfs_jr(struct reiserfs_super_block *rs)\n{\n\treturn !strncmp(rs->s_v1.s_magic, reiserfs_jr_magic_string,\n\t\t\tstrlen(reiserfs_jr_magic_string));\n}"
  },
  {
    "function_name": "is_reiserfs_3_6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "45-49",
    "snippet": "int is_reiserfs_3_6(struct reiserfs_super_block *rs)\n{\n\treturn !strncmp(rs->s_v1.s_magic, reiserfs_3_6_magic_string,\n\t\t\tstrlen(reiserfs_3_6_magic_string));\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char reiserfs_3_6_magic_string[] = REISER2FS_SUPER_MAGIC_STRING;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "rs->s_v1.s_magic",
            "reiserfs_3_6_magic_string",
            "strlen(reiserfs_3_6_magic_string)"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "reiserfs_3_6_magic_string"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const char reiserfs_3_6_magic_string[] = REISER2FS_SUPER_MAGIC_STRING;\n\nint is_reiserfs_3_6(struct reiserfs_super_block *rs)\n{\n\treturn !strncmp(rs->s_v1.s_magic, reiserfs_3_6_magic_string,\n\t\t\tstrlen(reiserfs_3_6_magic_string));\n}"
  },
  {
    "function_name": "is_reiserfs_3_5",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
    "lines": "39-43",
    "snippet": "int is_reiserfs_3_5(struct reiserfs_super_block *rs)\n{\n\treturn !strncmp(rs->s_v1.s_magic, reiserfs_3_5_magic_string,\n\t\t\tstrlen(reiserfs_3_5_magic_string));\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/crc32.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char reiserfs_3_5_magic_string[] = REISERFS_SUPER_MAGIC_STRING;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "rs->s_v1.s_magic",
            "reiserfs_3_5_magic_string",
            "strlen(reiserfs_3_5_magic_string)"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "reiserfs_3_5_magic_string"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const char reiserfs_3_5_magic_string[] = REISERFS_SUPER_MAGIC_STRING;\n\nint is_reiserfs_3_5(struct reiserfs_super_block *rs)\n{\n\treturn !strncmp(rs->s_v1.s_magic, reiserfs_3_5_magic_string,\n\t\t\tstrlen(reiserfs_3_5_magic_string));\n}"
  }
]