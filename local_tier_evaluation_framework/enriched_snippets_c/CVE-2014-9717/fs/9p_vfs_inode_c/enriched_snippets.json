[
  {
    "function_name": "v9fs_refresh_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "1462-1495",
    "snippet": "int v9fs_refresh_inode(struct p9_fid *fid, struct inode *inode)\n{\n\tint umode;\n\tdev_t rdev;\n\tloff_t i_size;\n\tstruct p9_wstat *st;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tst = p9_client_stat(fid);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\t/*\n\t * Don't update inode if the file type is different\n\t */\n\tumode = p9mode2unixmode(v9ses, st, &rdev);\n\tif ((inode->i_mode & S_IFMT) != (umode & S_IFMT))\n\t\tgoto out;\n\n\tspin_lock(&inode->i_lock);\n\t/*\n\t * We don't want to refresh inode->i_size,\n\t * because we may have cached data\n\t */\n\ti_size = inode->i_size;\n\tv9fs_stat2inode(st, inode, inode->i_sb);\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n\t\tinode->i_size = i_size;\n\tspin_unlock(&inode->i_lock);\nout:\n\tp9stat_free(st);\n\tkfree(st);\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "st"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9stat_free",
          "args": [
            "st"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_stat2inode",
          "args": [
            "st",
            "inode",
            "inode->i_sb"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_stat2inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "1156-1204",
          "snippet": "void\nv9fs_stat2inode(struct p9_wstat *stat, struct inode *inode,\n\tstruct super_block *sb)\n{\n\tumode_t mode;\n\tchar ext[32];\n\tchar tag_name[14];\n\tunsigned int i_nlink;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tset_nlink(inode, 1);\n\n\tinode->i_atime.tv_sec = stat->atime;\n\tinode->i_mtime.tv_sec = stat->mtime;\n\tinode->i_ctime.tv_sec = stat->mtime;\n\n\tinode->i_uid = v9ses->dfltuid;\n\tinode->i_gid = v9ses->dfltgid;\n\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tinode->i_uid = stat->n_uid;\n\t\tinode->i_gid = stat->n_gid;\n\t}\n\tif ((S_ISREG(inode->i_mode)) || (S_ISDIR(inode->i_mode))) {\n\t\tif (v9fs_proto_dotu(v9ses) && (stat->extension[0] != '\\0')) {\n\t\t\t/*\n\t\t\t * Hadlink support got added later to\n\t\t\t * to the .u extension. So there can be\n\t\t\t * server out there that doesn't support\n\t\t\t * this even with .u extension. So check\n\t\t\t * for non NULL stat->extension\n\t\t\t */\n\t\t\tstrlcpy(ext, stat->extension, sizeof(ext));\n\t\t\t/* HARDLINKCOUNT %u */\n\t\t\tsscanf(ext, \"%13s %u\", tag_name, &i_nlink);\n\t\t\tif (!strncmp(tag_name, \"HARDLINKCOUNT\", 13))\n\t\t\t\tset_nlink(inode, i_nlink);\n\t\t}\n\t}\n\tmode = p9mode2perm(v9ses, stat);\n\tmode |= inode->i_mode & ~S_IALLUGO;\n\tinode->i_mode = mode;\n\ti_size_write(inode, stat->length);\n\n\t/* not real number of blocks, but 512 byte ones ... */\n\tinode->i_blocks = (i_size_read(inode) + 512 - 1) >> 9;\n\tv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid\nv9fs_stat2inode(struct p9_wstat *stat, struct inode *inode,\n\tstruct super_block *sb)\n{\n\tumode_t mode;\n\tchar ext[32];\n\tchar tag_name[14];\n\tunsigned int i_nlink;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tset_nlink(inode, 1);\n\n\tinode->i_atime.tv_sec = stat->atime;\n\tinode->i_mtime.tv_sec = stat->mtime;\n\tinode->i_ctime.tv_sec = stat->mtime;\n\n\tinode->i_uid = v9ses->dfltuid;\n\tinode->i_gid = v9ses->dfltgid;\n\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tinode->i_uid = stat->n_uid;\n\t\tinode->i_gid = stat->n_gid;\n\t}\n\tif ((S_ISREG(inode->i_mode)) || (S_ISDIR(inode->i_mode))) {\n\t\tif (v9fs_proto_dotu(v9ses) && (stat->extension[0] != '\\0')) {\n\t\t\t/*\n\t\t\t * Hadlink support got added later to\n\t\t\t * to the .u extension. So there can be\n\t\t\t * server out there that doesn't support\n\t\t\t * this even with .u extension. So check\n\t\t\t * for non NULL stat->extension\n\t\t\t */\n\t\t\tstrlcpy(ext, stat->extension, sizeof(ext));\n\t\t\t/* HARDLINKCOUNT %u */\n\t\t\tsscanf(ext, \"%13s %u\", tag_name, &i_nlink);\n\t\t\tif (!strncmp(tag_name, \"HARDLINKCOUNT\", 13))\n\t\t\t\tset_nlink(inode, i_nlink);\n\t\t}\n\t}\n\tmode = p9mode2perm(v9ses, stat);\n\tmode |= inode->i_mode & ~S_IALLUGO;\n\tinode->i_mode = mode;\n\ti_size_write(inode, stat->length);\n\n\t/* not real number of blocks, but 512 byte ones ... */\n\tinode->i_blocks = (i_size_read(inode) + 512 - 1) >> 9;\n\tv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9mode2unixmode",
          "args": [
            "v9ses",
            "st",
            "&rdev"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "p9mode2unixmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "125-167",
          "snippet": "static umode_t p9mode2unixmode(struct v9fs_session_info *v9ses,\n\t\t\t       struct p9_wstat *stat, dev_t *rdev)\n{\n\tint res;\n\tu32 mode = stat->mode;\n\n\t*rdev = 0;\n\tres = p9mode2perm(v9ses, stat);\n\n\tif ((mode & P9_DMDIR) == P9_DMDIR)\n\t\tres |= S_IFDIR;\n\telse if ((mode & P9_DMSYMLINK) && (v9fs_proto_dotu(v9ses)))\n\t\tres |= S_IFLNK;\n\telse if ((mode & P9_DMSOCKET) && (v9fs_proto_dotu(v9ses))\n\t\t && (v9ses->nodev == 0))\n\t\tres |= S_IFSOCK;\n\telse if ((mode & P9_DMNAMEDPIPE) && (v9fs_proto_dotu(v9ses))\n\t\t && (v9ses->nodev == 0))\n\t\tres |= S_IFIFO;\n\telse if ((mode & P9_DMDEVICE) && (v9fs_proto_dotu(v9ses))\n\t\t && (v9ses->nodev == 0)) {\n\t\tchar type = 0, ext[32];\n\t\tint major = -1, minor = -1;\n\n\t\tstrlcpy(ext, stat->extension, sizeof(ext));\n\t\tsscanf(ext, \"%c %i %i\", &type, &major, &minor);\n\t\tswitch (type) {\n\t\tcase 'c':\n\t\t\tres |= S_IFCHR;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tres |= S_IFBLK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp9_debug(P9_DEBUG_ERROR, \"Unknown special type %c %s\\n\",\n\t\t\t\t type, stat->extension);\n\t\t};\n\t\t*rdev = MKDEV(major, minor);\n\t} else\n\t\tres |= S_IFREG;\n\n\treturn res;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic umode_t p9mode2unixmode(struct v9fs_session_info *v9ses,\n\t\t\t       struct p9_wstat *stat, dev_t *rdev)\n{\n\tint res;\n\tu32 mode = stat->mode;\n\n\t*rdev = 0;\n\tres = p9mode2perm(v9ses, stat);\n\n\tif ((mode & P9_DMDIR) == P9_DMDIR)\n\t\tres |= S_IFDIR;\n\telse if ((mode & P9_DMSYMLINK) && (v9fs_proto_dotu(v9ses)))\n\t\tres |= S_IFLNK;\n\telse if ((mode & P9_DMSOCKET) && (v9fs_proto_dotu(v9ses))\n\t\t && (v9ses->nodev == 0))\n\t\tres |= S_IFSOCK;\n\telse if ((mode & P9_DMNAMEDPIPE) && (v9fs_proto_dotu(v9ses))\n\t\t && (v9ses->nodev == 0))\n\t\tres |= S_IFIFO;\n\telse if ((mode & P9_DMDEVICE) && (v9fs_proto_dotu(v9ses))\n\t\t && (v9ses->nodev == 0)) {\n\t\tchar type = 0, ext[32];\n\t\tint major = -1, minor = -1;\n\n\t\tstrlcpy(ext, stat->extension, sizeof(ext));\n\t\tsscanf(ext, \"%c %i %i\", &type, &major, &minor);\n\t\tswitch (type) {\n\t\tcase 'c':\n\t\t\tres |= S_IFCHR;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tres |= S_IFBLK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp9_debug(P9_DEBUG_ERROR, \"Unknown special type %c %s\\n\",\n\t\t\t\t type, stat->extension);\n\t\t};\n\t\t*rdev = MKDEV(major, minor);\n\t} else\n\t\tres |= S_IFREG;\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "st"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "st"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_stat",
          "args": [
            "fid"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_inode2v9ses",
          "args": [
            "inode"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_inode2v9ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "172-175",
          "snippet": "static inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nint v9fs_refresh_inode(struct p9_fid *fid, struct inode *inode)\n{\n\tint umode;\n\tdev_t rdev;\n\tloff_t i_size;\n\tstruct p9_wstat *st;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tst = p9_client_stat(fid);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\t/*\n\t * Don't update inode if the file type is different\n\t */\n\tumode = p9mode2unixmode(v9ses, st, &rdev);\n\tif ((inode->i_mode & S_IFMT) != (umode & S_IFMT))\n\t\tgoto out;\n\n\tspin_lock(&inode->i_lock);\n\t/*\n\t * We don't want to refresh inode->i_size,\n\t * because we may have cached data\n\t */\n\ti_size = inode->i_size;\n\tv9fs_stat2inode(st, inode, inode->i_sb);\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n\t\tinode->i_size = i_size;\n\tspin_unlock(&inode->i_lock);\nout:\n\tp9stat_free(st);\n\tkfree(st);\n\treturn 0;\n}"
  },
  {
    "function_name": "v9fs_vfs_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "1423-1460",
    "snippet": "static int\nv9fs_vfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tstruct v9fs_session_info *v9ses = v9fs_inode2v9ses(dir);\n\tint retval;\n\tchar *name;\n\tu32 perm;\n\n\tp9_debug(P9_DEBUG_VFS, \" %lu,%pd mode: %hx MAJOR: %u MINOR: %u\\n\",\n\t\t dir->i_ino, dentry, mode,\n\t\t MAJOR(rdev), MINOR(rdev));\n\n\tif (!new_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tname = __getname();\n\tif (!name)\n\t\treturn -ENOMEM;\n\t/* build extension */\n\tif (S_ISBLK(mode))\n\t\tsprintf(name, \"b %u %u\", MAJOR(rdev), MINOR(rdev));\n\telse if (S_ISCHR(mode))\n\t\tsprintf(name, \"c %u %u\", MAJOR(rdev), MINOR(rdev));\n\telse if (S_ISFIFO(mode))\n\t\t*name = 0;\n\telse if (S_ISSOCK(mode))\n\t\t*name = 0;\n\telse {\n\t\t__putname(name);\n\t\treturn -EINVAL;\n\t}\n\n\tperm = unixmode2p9mode(v9ses, mode);\n\tretval = v9fs_vfs_mkspecial(dir, dentry, perm, name);\n\t__putname(name);\n\n\treturn retval;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "name"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_vfs_mkspecial",
          "args": [
            "dir",
            "dentry",
            "perm",
            "name"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_vfs_mkspecial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "1332-1352",
          "snippet": "static int v9fs_vfs_mkspecial(struct inode *dir, struct dentry *dentry,\n\tu32 perm, const char *extension)\n{\n\tstruct p9_fid *fid;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\tif (!v9fs_proto_dotu(v9ses)) {\n\t\tp9_debug(P9_DEBUG_ERROR, \"not extended\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tfid = v9fs_create(v9ses, dir, dentry, (char *) extension, perm,\n\t\t\t\t\t\t\t\tP9_OREAD);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\tv9fs_invalidate_inode_attr(dir);\n\tp9_client_clunk(fid);\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_vfs_mkspecial(struct inode *dir, struct dentry *dentry,\n\tu32 perm, const char *extension)\n{\n\tstruct p9_fid *fid;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\tif (!v9fs_proto_dotu(v9ses)) {\n\t\tp9_debug(P9_DEBUG_ERROR, \"not extended\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tfid = v9fs_create(v9ses, dir, dentry, (char *) extension, perm,\n\t\t\t\t\t\t\t\tP9_OREAD);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\tv9fs_invalidate_inode_attr(dir);\n\tp9_client_clunk(fid);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unixmode2p9mode",
          "args": [
            "v9ses",
            "mode"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "unixmode2p9mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "64-90",
          "snippet": "static u32 unixmode2p9mode(struct v9fs_session_info *v9ses, umode_t mode)\n{\n\tint res;\n\tres = mode & 0777;\n\tif (S_ISDIR(mode))\n\t\tres |= P9_DMDIR;\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tif (v9ses->nodev == 0) {\n\t\t\tif (S_ISSOCK(mode))\n\t\t\t\tres |= P9_DMSOCKET;\n\t\t\tif (S_ISFIFO(mode))\n\t\t\t\tres |= P9_DMNAMEDPIPE;\n\t\t\tif (S_ISBLK(mode))\n\t\t\t\tres |= P9_DMDEVICE;\n\t\t\tif (S_ISCHR(mode))\n\t\t\t\tres |= P9_DMDEVICE;\n\t\t}\n\n\t\tif ((mode & S_ISUID) == S_ISUID)\n\t\t\tres |= P9_DMSETUID;\n\t\tif ((mode & S_ISGID) == S_ISGID)\n\t\t\tres |= P9_DMSETGID;\n\t\tif ((mode & S_ISVTX) == S_ISVTX)\n\t\t\tres |= P9_DMSETVTX;\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic u32 unixmode2p9mode(struct v9fs_session_info *v9ses, umode_t mode)\n{\n\tint res;\n\tres = mode & 0777;\n\tif (S_ISDIR(mode))\n\t\tres |= P9_DMDIR;\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tif (v9ses->nodev == 0) {\n\t\t\tif (S_ISSOCK(mode))\n\t\t\t\tres |= P9_DMSOCKET;\n\t\t\tif (S_ISFIFO(mode))\n\t\t\t\tres |= P9_DMNAMEDPIPE;\n\t\t\tif (S_ISBLK(mode))\n\t\t\t\tres |= P9_DMDEVICE;\n\t\t\tif (S_ISCHR(mode))\n\t\t\t\tres |= P9_DMDEVICE;\n\t\t}\n\n\t\tif ((mode & S_ISUID) == S_ISUID)\n\t\t\tres |= P9_DMSETUID;\n\t\tif ((mode & S_ISGID) == S_ISGID)\n\t\t\tres |= P9_DMSETGID;\n\t\tif ((mode & S_ISVTX) == S_ISVTX)\n\t\t\tres |= P9_DMSETVTX;\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "name"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISSOCK",
          "args": [
            "mode"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISFIFO",
          "args": [
            "mode"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "name",
            "\"c %u %u\"",
            "MAJOR(rdev)",
            "MINOR(rdev)"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sprintf_system_inode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1609-1628",
          "snippet": "static inline int ocfs2_sprintf_system_inode_name(char *buf, int len,\n\t\t\t\t\t\t  int type, int slot)\n{\n\tint chars;\n\n        /*\n         * Global system inodes can only have one copy.  Everything\n         * after OCFS2_LAST_GLOBAL_SYSTEM_INODE in the system inode\n         * list has a copy per slot.\n         */\n\tif (type <= OCFS2_LAST_GLOBAL_SYSTEM_INODE)\n\t\tchars = snprintf(buf, len, \"%s\",\n\t\t\t\t ocfs2_system_inodes[type].si_name);\n\telse\n\t\tchars = snprintf(buf, len,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t slot);\n\n\treturn chars;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_sprintf_system_inode_name(char *buf, int len,\n\t\t\t\t\t\t  int type, int slot)\n{\n\tint chars;\n\n        /*\n         * Global system inodes can only have one copy.  Everything\n         * after OCFS2_LAST_GLOBAL_SYSTEM_INODE in the system inode\n         * list has a copy per slot.\n         */\n\tif (type <= OCFS2_LAST_GLOBAL_SYSTEM_INODE)\n\t\tchars = snprintf(buf, len, \"%s\",\n\t\t\t\t ocfs2_system_inodes[type].si_name);\n\telse\n\t\tchars = snprintf(buf, len,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t slot);\n\n\treturn chars;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "rdev"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "rdev"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "mode"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "rdev"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "rdev"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "mode"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__getname",
          "args": [],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_valid_dev",
          "args": [
            "rdev"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\" %lu,%pd mode: %hx MAJOR: %u MINOR: %u\\n\"",
            "dir->i_ino",
            "dentry",
            "mode",
            "MAJOR(rdev)",
            "MINOR(rdev)"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "rdev"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "rdev"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_inode2v9ses",
          "args": [
            "dir"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_inode2v9ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "172-175",
          "snippet": "static inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int\nv9fs_vfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tstruct v9fs_session_info *v9ses = v9fs_inode2v9ses(dir);\n\tint retval;\n\tchar *name;\n\tu32 perm;\n\n\tp9_debug(P9_DEBUG_VFS, \" %lu,%pd mode: %hx MAJOR: %u MINOR: %u\\n\",\n\t\t dir->i_ino, dentry, mode,\n\t\t MAJOR(rdev), MINOR(rdev));\n\n\tif (!new_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tname = __getname();\n\tif (!name)\n\t\treturn -ENOMEM;\n\t/* build extension */\n\tif (S_ISBLK(mode))\n\t\tsprintf(name, \"b %u %u\", MAJOR(rdev), MINOR(rdev));\n\telse if (S_ISCHR(mode))\n\t\tsprintf(name, \"c %u %u\", MAJOR(rdev), MINOR(rdev));\n\telse if (S_ISFIFO(mode))\n\t\t*name = 0;\n\telse if (S_ISSOCK(mode))\n\t\t*name = 0;\n\telse {\n\t\t__putname(name);\n\t\treturn -EINVAL;\n\t}\n\n\tperm = unixmode2p9mode(v9ses, mode);\n\tretval = v9fs_vfs_mkspecial(dir, dentry, perm, name);\n\t__putname(name);\n\n\treturn retval;\n}"
  },
  {
    "function_name": "v9fs_vfs_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "1381-1412",
    "snippet": "static int\nv9fs_vfs_link(struct dentry *old_dentry, struct inode *dir,\n\t      struct dentry *dentry)\n{\n\tint retval;\n\tchar *name;\n\tstruct p9_fid *oldfid;\n\n\tp9_debug(P9_DEBUG_VFS, \" %lu,%pd,%pd\\n\",\n\t\t dir->i_ino, dentry, old_dentry);\n\n\toldfid = v9fs_fid_clone(old_dentry);\n\tif (IS_ERR(oldfid))\n\t\treturn PTR_ERR(oldfid);\n\n\tname = __getname();\n\tif (unlikely(!name)) {\n\t\tretval = -ENOMEM;\n\t\tgoto clunk_fid;\n\t}\n\n\tsprintf(name, \"%d\\n\", oldfid->fid);\n\tretval = v9fs_vfs_mkspecial(dir, dentry, P9_DMLINK, name);\n\t__putname(name);\n\tif (!retval) {\n\t\tv9fs_refresh_inode(oldfid, old_dentry->d_inode);\n\t\tv9fs_invalidate_inode_attr(dir);\n\t}\nclunk_fid:\n\tp9_client_clunk(oldfid);\n\treturn retval;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p9_client_clunk",
          "args": [
            "oldfid"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_invalidate_inode_attr",
          "args": [
            "dir"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_invalidate_inode_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs_vfs.h",
          "lines": "81-87",
          "snippet": "static inline void v9fs_invalidate_inode_attr(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = V9FS_I(inode);\n\tv9inode->cache_validity |= V9FS_INO_INVALID_ATTR;\n\treturn;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void v9fs_invalidate_inode_attr(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = V9FS_I(inode);\n\tv9inode->cache_validity |= V9FS_INO_INVALID_ATTR;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_refresh_inode",
          "args": [
            "oldfid",
            "old_dentry->d_inode"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_refresh_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "1462-1495",
          "snippet": "int v9fs_refresh_inode(struct p9_fid *fid, struct inode *inode)\n{\n\tint umode;\n\tdev_t rdev;\n\tloff_t i_size;\n\tstruct p9_wstat *st;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tst = p9_client_stat(fid);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\t/*\n\t * Don't update inode if the file type is different\n\t */\n\tumode = p9mode2unixmode(v9ses, st, &rdev);\n\tif ((inode->i_mode & S_IFMT) != (umode & S_IFMT))\n\t\tgoto out;\n\n\tspin_lock(&inode->i_lock);\n\t/*\n\t * We don't want to refresh inode->i_size,\n\t * because we may have cached data\n\t */\n\ti_size = inode->i_size;\n\tv9fs_stat2inode(st, inode, inode->i_sb);\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n\t\tinode->i_size = i_size;\n\tspin_unlock(&inode->i_lock);\nout:\n\tp9stat_free(st);\n\tkfree(st);\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nint v9fs_refresh_inode(struct p9_fid *fid, struct inode *inode)\n{\n\tint umode;\n\tdev_t rdev;\n\tloff_t i_size;\n\tstruct p9_wstat *st;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tst = p9_client_stat(fid);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\t/*\n\t * Don't update inode if the file type is different\n\t */\n\tumode = p9mode2unixmode(v9ses, st, &rdev);\n\tif ((inode->i_mode & S_IFMT) != (umode & S_IFMT))\n\t\tgoto out;\n\n\tspin_lock(&inode->i_lock);\n\t/*\n\t * We don't want to refresh inode->i_size,\n\t * because we may have cached data\n\t */\n\ti_size = inode->i_size;\n\tv9fs_stat2inode(st, inode, inode->i_sb);\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n\t\tinode->i_size = i_size;\n\tspin_unlock(&inode->i_lock);\nout:\n\tp9stat_free(st);\n\tkfree(st);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "name"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_vfs_mkspecial",
          "args": [
            "dir",
            "dentry",
            "P9_DMLINK",
            "name"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_vfs_mkspecial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "1332-1352",
          "snippet": "static int v9fs_vfs_mkspecial(struct inode *dir, struct dentry *dentry,\n\tu32 perm, const char *extension)\n{\n\tstruct p9_fid *fid;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\tif (!v9fs_proto_dotu(v9ses)) {\n\t\tp9_debug(P9_DEBUG_ERROR, \"not extended\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tfid = v9fs_create(v9ses, dir, dentry, (char *) extension, perm,\n\t\t\t\t\t\t\t\tP9_OREAD);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\tv9fs_invalidate_inode_attr(dir);\n\tp9_client_clunk(fid);\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_vfs_mkspecial(struct inode *dir, struct dentry *dentry,\n\tu32 perm, const char *extension)\n{\n\tstruct p9_fid *fid;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\tif (!v9fs_proto_dotu(v9ses)) {\n\t\tp9_debug(P9_DEBUG_ERROR, \"not extended\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tfid = v9fs_create(v9ses, dir, dentry, (char *) extension, perm,\n\t\t\t\t\t\t\t\tP9_OREAD);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\tv9fs_invalidate_inode_attr(dir);\n\tp9_client_clunk(fid);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "name",
            "\"%d\\n\"",
            "oldfid->fid"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!name"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__getname",
          "args": [],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "oldfid"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "oldfid"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fid_clone",
          "args": [
            "old_dentry"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "260-270",
          "snippet": "struct p9_fid *v9fs_fid_clone(struct dentry *dentry)\n{\n\tstruct p9_fid *fid, *ret;\n\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn fid;\n\n\tret = p9_client_walk(fid, 0, NULL, 1);\n\treturn ret;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct p9_fid *v9fs_fid_clone(struct dentry *dentry)\n{\n\tstruct p9_fid *fid, *ret;\n\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn fid;\n\n\tret = p9_client_walk(fid, 0, NULL, 1);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\" %lu,%pd,%pd\\n\"",
            "dir->i_ino",
            "dentry",
            "old_dentry"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int\nv9fs_vfs_link(struct dentry *old_dentry, struct inode *dir,\n\t      struct dentry *dentry)\n{\n\tint retval;\n\tchar *name;\n\tstruct p9_fid *oldfid;\n\n\tp9_debug(P9_DEBUG_VFS, \" %lu,%pd,%pd\\n\",\n\t\t dir->i_ino, dentry, old_dentry);\n\n\toldfid = v9fs_fid_clone(old_dentry);\n\tif (IS_ERR(oldfid))\n\t\treturn PTR_ERR(oldfid);\n\n\tname = __getname();\n\tif (unlikely(!name)) {\n\t\tretval = -ENOMEM;\n\t\tgoto clunk_fid;\n\t}\n\n\tsprintf(name, \"%d\\n\", oldfid->fid);\n\tretval = v9fs_vfs_mkspecial(dir, dentry, P9_DMLINK, name);\n\t__putname(name);\n\tif (!retval) {\n\t\tv9fs_refresh_inode(oldfid, old_dentry->d_inode);\n\t\tv9fs_invalidate_inode_attr(dir);\n\t}\nclunk_fid:\n\tp9_client_clunk(oldfid);\n\treturn retval;\n}"
  },
  {
    "function_name": "v9fs_vfs_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "1364-1371",
    "snippet": "static int\nv9fs_vfs_symlink(struct inode *dir, struct dentry *dentry, const char *symname)\n{\n\tp9_debug(P9_DEBUG_VFS, \" %lu,%pd,%s\\n\",\n\t\t dir->i_ino, dentry, symname);\n\n\treturn v9fs_vfs_mkspecial(dir, dentry, P9_DMSYMLINK, symname);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v9fs_vfs_mkspecial",
          "args": [
            "dir",
            "dentry",
            "P9_DMSYMLINK",
            "symname"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_vfs_mkspecial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "1332-1352",
          "snippet": "static int v9fs_vfs_mkspecial(struct inode *dir, struct dentry *dentry,\n\tu32 perm, const char *extension)\n{\n\tstruct p9_fid *fid;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\tif (!v9fs_proto_dotu(v9ses)) {\n\t\tp9_debug(P9_DEBUG_ERROR, \"not extended\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tfid = v9fs_create(v9ses, dir, dentry, (char *) extension, perm,\n\t\t\t\t\t\t\t\tP9_OREAD);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\tv9fs_invalidate_inode_attr(dir);\n\tp9_client_clunk(fid);\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_vfs_mkspecial(struct inode *dir, struct dentry *dentry,\n\tu32 perm, const char *extension)\n{\n\tstruct p9_fid *fid;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\tif (!v9fs_proto_dotu(v9ses)) {\n\t\tp9_debug(P9_DEBUG_ERROR, \"not extended\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tfid = v9fs_create(v9ses, dir, dentry, (char *) extension, perm,\n\t\t\t\t\t\t\t\tP9_OREAD);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\tv9fs_invalidate_inode_attr(dir);\n\tp9_client_clunk(fid);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\" %lu,%pd,%s\\n\"",
            "dir->i_ino",
            "dentry",
            "symname"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int\nv9fs_vfs_symlink(struct inode *dir, struct dentry *dentry, const char *symname)\n{\n\tp9_debug(P9_DEBUG_VFS, \" %lu,%pd,%s\\n\",\n\t\t dir->i_ino, dentry, symname);\n\n\treturn v9fs_vfs_mkspecial(dir, dentry, P9_DMSYMLINK, symname);\n}"
  },
  {
    "function_name": "v9fs_vfs_mkspecial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "1332-1352",
    "snippet": "static int v9fs_vfs_mkspecial(struct inode *dir, struct dentry *dentry,\n\tu32 perm, const char *extension)\n{\n\tstruct p9_fid *fid;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\tif (!v9fs_proto_dotu(v9ses)) {\n\t\tp9_debug(P9_DEBUG_ERROR, \"not extended\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tfid = v9fs_create(v9ses, dir, dentry, (char *) extension, perm,\n\t\t\t\t\t\t\t\tP9_OREAD);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\tv9fs_invalidate_inode_attr(dir);\n\tp9_client_clunk(fid);\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p9_client_clunk",
          "args": [
            "fid"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_invalidate_inode_attr",
          "args": [
            "dir"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_invalidate_inode_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs_vfs.h",
          "lines": "81-87",
          "snippet": "static inline void v9fs_invalidate_inode_attr(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = V9FS_I(inode);\n\tv9inode->cache_validity |= V9FS_INO_INVALID_ATTR;\n\treturn;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void v9fs_invalidate_inode_attr(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = V9FS_I(inode);\n\tv9inode->cache_validity |= V9FS_INO_INVALID_ATTR;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fid"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fid"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_create",
          "args": [
            "v9ses",
            "dir",
            "dentry",
            "(char *) extension",
            "perm",
            "P9_OREAD"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "642-710",
          "snippet": "static struct p9_fid *\nv9fs_create(struct v9fs_session_info *v9ses, struct inode *dir,\n\t\tstruct dentry *dentry, char *extension, u32 perm, u8 mode)\n{\n\tint err;\n\tchar *name;\n\tstruct p9_fid *dfid, *ofid, *fid;\n\tstruct inode *inode;\n\n\tp9_debug(P9_DEBUG_VFS, \"name %pd\\n\", dentry);\n\n\terr = 0;\n\tofid = NULL;\n\tfid = NULL;\n\tname = (char *) dentry->d_name.name;\n\tdfid = v9fs_fid_lookup(dentry->d_parent);\n\tif (IS_ERR(dfid)) {\n\t\terr = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\n\t/* clone a fid to use for creation */\n\tofid = p9_client_walk(dfid, 0, NULL, 1);\n\tif (IS_ERR(ofid)) {\n\t\terr = PTR_ERR(ofid);\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_walk failed %d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = p9_client_fcreate(ofid, name, perm, mode, extension);\n\tif (err < 0) {\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_fcreate failed %d\\n\", err);\n\t\tgoto error;\n\t}\n\n\tif (!(perm & P9_DMLINK)) {\n\t\t/* now walk from the parent so we can get unopened fid */\n\t\tfid = p9_client_walk(dfid, 1, &name, 1);\n\t\tif (IS_ERR(fid)) {\n\t\t\terr = PTR_ERR(fid);\n\t\t\tp9_debug(P9_DEBUG_VFS,\n\t\t\t\t   \"p9_client_walk failed %d\\n\", err);\n\t\t\tfid = NULL;\n\t\t\tgoto error;\n\t\t}\n\t\t/*\n\t\t * instantiate inode and assign the unopened fid to the dentry\n\t\t */\n\t\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tp9_debug(P9_DEBUG_VFS,\n\t\t\t\t   \"inode creation failed %d\\n\", err);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_fid_add(dentry, fid);\n\t\td_instantiate(dentry, inode);\n\t}\n\treturn ofid;\nerror:\n\tif (ofid)\n\t\tp9_client_clunk(ofid);\n\n\tif (fid)\n\t\tp9_client_clunk(fid);\n\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic struct p9_fid *\nv9fs_create(struct v9fs_session_info *v9ses, struct inode *dir,\n\t\tstruct dentry *dentry, char *extension, u32 perm, u8 mode)\n{\n\tint err;\n\tchar *name;\n\tstruct p9_fid *dfid, *ofid, *fid;\n\tstruct inode *inode;\n\n\tp9_debug(P9_DEBUG_VFS, \"name %pd\\n\", dentry);\n\n\terr = 0;\n\tofid = NULL;\n\tfid = NULL;\n\tname = (char *) dentry->d_name.name;\n\tdfid = v9fs_fid_lookup(dentry->d_parent);\n\tif (IS_ERR(dfid)) {\n\t\terr = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\n\t/* clone a fid to use for creation */\n\tofid = p9_client_walk(dfid, 0, NULL, 1);\n\tif (IS_ERR(ofid)) {\n\t\terr = PTR_ERR(ofid);\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_walk failed %d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = p9_client_fcreate(ofid, name, perm, mode, extension);\n\tif (err < 0) {\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_fcreate failed %d\\n\", err);\n\t\tgoto error;\n\t}\n\n\tif (!(perm & P9_DMLINK)) {\n\t\t/* now walk from the parent so we can get unopened fid */\n\t\tfid = p9_client_walk(dfid, 1, &name, 1);\n\t\tif (IS_ERR(fid)) {\n\t\t\terr = PTR_ERR(fid);\n\t\t\tp9_debug(P9_DEBUG_VFS,\n\t\t\t\t   \"p9_client_walk failed %d\\n\", err);\n\t\t\tfid = NULL;\n\t\t\tgoto error;\n\t\t}\n\t\t/*\n\t\t * instantiate inode and assign the unopened fid to the dentry\n\t\t */\n\t\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tp9_debug(P9_DEBUG_VFS,\n\t\t\t\t   \"inode creation failed %d\\n\", err);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_fid_add(dentry, fid);\n\t\td_instantiate(dentry, inode);\n\t}\n\treturn ofid;\nerror:\n\tif (ofid)\n\t\tp9_client_clunk(ofid);\n\n\tif (fid)\n\t\tp9_client_clunk(fid);\n\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_ERROR",
            "\"not extended\\n\""
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_proto_dotu",
          "args": [
            "v9ses"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_proto_dotu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "182-185",
          "snippet": "static inline int v9fs_proto_dotu(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000U;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline int v9fs_proto_dotu(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000U;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_inode2v9ses",
          "args": [
            "dir"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_inode2v9ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "172-175",
          "snippet": "static inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_vfs_mkspecial(struct inode *dir, struct dentry *dentry,\n\tu32 perm, const char *extension)\n{\n\tstruct p9_fid *fid;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\tif (!v9fs_proto_dotu(v9ses)) {\n\t\tp9_debug(P9_DEBUG_ERROR, \"not extended\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tfid = v9fs_create(v9ses, dir, dentry, (char *) extension, perm,\n\t\t\t\t\t\t\t\tP9_OREAD);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\tv9fs_invalidate_inode_attr(dir);\n\tp9_client_clunk(fid);\n\treturn 0;\n}"
  },
  {
    "function_name": "v9fs_vfs_put_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "1312-1321",
    "snippet": "void\nv9fs_vfs_put_link(struct dentry *dentry, struct nameidata *nd, void *p)\n{\n\tchar *s = nd_get_link(nd);\n\n\tp9_debug(P9_DEBUG_VFS, \" %pd %s\\n\",\n\t\t dentry, IS_ERR(s) ? \"<error>\" : s);\n\tif (!IS_ERR(s))\n\t\t__putname(s);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "s"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "s"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\" %pd %s\\n\"",
            "dentry",
            "IS_ERR(s) ? \"<error>\" : s"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "s"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nd_get_link",
          "args": [
            "nd"
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "nd_get_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "723-726",
          "snippet": "char *nd_get_link(struct nameidata *nd)\n{\n\treturn nd->saved_names[nd->depth];\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nchar *nd_get_link(struct nameidata *nd)\n{\n\treturn nd->saved_names[nd->depth];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid\nv9fs_vfs_put_link(struct dentry *dentry, struct nameidata *nd, void *p)\n{\n\tchar *s = nd_get_link(nd);\n\n\tp9_debug(P9_DEBUG_VFS, \" %pd %s\\n\",\n\t\t dentry, IS_ERR(s) ? \"<error>\" : s);\n\tif (!IS_ERR(s))\n\t\t__putname(s);\n}"
  },
  {
    "function_name": "v9fs_vfs_follow_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "1281-1302",
    "snippet": "static void *v9fs_vfs_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tint len = 0;\n\tchar *link = __getname();\n\n\tp9_debug(P9_DEBUG_VFS, \"%pd\\n\", dentry);\n\n\tif (!link)\n\t\tlink = ERR_PTR(-ENOMEM);\n\telse {\n\t\tlen = v9fs_readlink(dentry, link, PATH_MAX);\n\n\t\tif (len < 0) {\n\t\t\t__putname(link);\n\t\t\tlink = ERR_PTR(len);\n\t\t} else\n\t\t\tlink[min(len, PATH_MAX-1)] = 0;\n\t}\n\tnd_set_link(nd, link);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nd_set_link",
          "args": [
            "nd",
            "link"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "nd_set_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "717-720",
          "snippet": "void nd_set_link(struct nameidata *nd, char *path)\n{\n\tnd->saved_names[nd->depth] = path;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nvoid nd_set_link(struct nameidata *nd, char *path)\n{\n\tnd->saved_names[nd->depth] = path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "len",
            "PATH_MAX-1"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "len"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "link"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_readlink",
          "args": [
            "dentry",
            "link",
            "PATH_MAX"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_readlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "1234-1272",
          "snippet": "static int v9fs_readlink(struct dentry *dentry, char *buffer, int buflen)\n{\n\tint retval;\n\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid;\n\tstruct p9_wstat *st;\n\n\tp9_debug(P9_DEBUG_VFS, \" %pd\\n\", dentry);\n\tretval = -EPERM;\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\tif (!v9fs_proto_dotu(v9ses))\n\t\treturn -EBADF;\n\n\tst = p9_client_stat(fid);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\n\tif (!(st->mode & P9_DMSYMLINK)) {\n\t\tretval = -EINVAL;\n\t\tgoto done;\n\t}\n\n\t/* copy extension buffer into buffer */\n\tretval = min(strlen(st->extension)+1, (size_t)buflen);\n\tmemcpy(buffer, st->extension, retval);\n\n\tp9_debug(P9_DEBUG_VFS, \"%pd -> %s (%.*s)\\n\",\n\t\t dentry, st->extension, buflen, buffer);\n\ndone:\n\tp9stat_free(st);\n\tkfree(st);\n\treturn retval;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_readlink(struct dentry *dentry, char *buffer, int buflen)\n{\n\tint retval;\n\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid;\n\tstruct p9_wstat *st;\n\n\tp9_debug(P9_DEBUG_VFS, \" %pd\\n\", dentry);\n\tretval = -EPERM;\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\tif (!v9fs_proto_dotu(v9ses))\n\t\treturn -EBADF;\n\n\tst = p9_client_stat(fid);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\n\tif (!(st->mode & P9_DMSYMLINK)) {\n\t\tretval = -EINVAL;\n\t\tgoto done;\n\t}\n\n\t/* copy extension buffer into buffer */\n\tretval = min(strlen(st->extension)+1, (size_t)buflen);\n\tmemcpy(buffer, st->extension, retval);\n\n\tp9_debug(P9_DEBUG_VFS, \"%pd -> %s (%.*s)\\n\",\n\t\t dentry, st->extension, buflen, buffer);\n\ndone:\n\tp9stat_free(st);\n\tkfree(st);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"%pd\\n\"",
            "dentry"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__getname",
          "args": [],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic void *v9fs_vfs_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tint len = 0;\n\tchar *link = __getname();\n\n\tp9_debug(P9_DEBUG_VFS, \"%pd\\n\", dentry);\n\n\tif (!link)\n\t\tlink = ERR_PTR(-ENOMEM);\n\telse {\n\t\tlen = v9fs_readlink(dentry, link, PATH_MAX);\n\n\t\tif (len < 0) {\n\t\t\t__putname(link);\n\t\t\tlink = ERR_PTR(len);\n\t\t} else\n\t\t\tlink[min(len, PATH_MAX-1)] = 0;\n\t}\n\tnd_set_link(nd, link);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "v9fs_readlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "1234-1272",
    "snippet": "static int v9fs_readlink(struct dentry *dentry, char *buffer, int buflen)\n{\n\tint retval;\n\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid;\n\tstruct p9_wstat *st;\n\n\tp9_debug(P9_DEBUG_VFS, \" %pd\\n\", dentry);\n\tretval = -EPERM;\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\tif (!v9fs_proto_dotu(v9ses))\n\t\treturn -EBADF;\n\n\tst = p9_client_stat(fid);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\n\tif (!(st->mode & P9_DMSYMLINK)) {\n\t\tretval = -EINVAL;\n\t\tgoto done;\n\t}\n\n\t/* copy extension buffer into buffer */\n\tretval = min(strlen(st->extension)+1, (size_t)buflen);\n\tmemcpy(buffer, st->extension, retval);\n\n\tp9_debug(P9_DEBUG_VFS, \"%pd -> %s (%.*s)\\n\",\n\t\t dentry, st->extension, buflen, buffer);\n\ndone:\n\tp9stat_free(st);\n\tkfree(st);\n\treturn retval;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "st"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9stat_free",
          "args": [
            "st"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"%pd -> %s (%.*s)\\n\"",
            "dentry",
            "st->extension",
            "buflen",
            "buffer"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "st->extension",
            "retval"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "strlen(st->extension)+1",
            "(size_t)buflen"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "st->extension"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "st"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "st"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_stat",
          "args": [
            "fid"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_proto_dotu",
          "args": [
            "v9ses"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_proto_dotu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "182-185",
          "snippet": "static inline int v9fs_proto_dotu(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000U;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline int v9fs_proto_dotu(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000U;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fid"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fid"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fid_lookup",
          "args": [
            "dentry"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "231-258",
          "snippet": "struct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_dentry2v9ses",
          "args": [
            "dentry"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_dentry2v9ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "177-180",
          "snippet": "static inline struct v9fs_session_info *v9fs_dentry2v9ses(struct dentry *dentry)\n{\n\treturn dentry->d_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_session_info *v9fs_dentry2v9ses(struct dentry *dentry)\n{\n\treturn dentry->d_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\" %pd\\n\"",
            "dentry"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_readlink(struct dentry *dentry, char *buffer, int buflen)\n{\n\tint retval;\n\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid;\n\tstruct p9_wstat *st;\n\n\tp9_debug(P9_DEBUG_VFS, \" %pd\\n\", dentry);\n\tretval = -EPERM;\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\tif (!v9fs_proto_dotu(v9ses))\n\t\treturn -EBADF;\n\n\tst = p9_client_stat(fid);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\n\tif (!(st->mode & P9_DMSYMLINK)) {\n\t\tretval = -EINVAL;\n\t\tgoto done;\n\t}\n\n\t/* copy extension buffer into buffer */\n\tretval = min(strlen(st->extension)+1, (size_t)buflen);\n\tmemcpy(buffer, st->extension, retval);\n\n\tp9_debug(P9_DEBUG_VFS, \"%pd -> %s (%.*s)\\n\",\n\t\t dentry, st->extension, buflen, buffer);\n\ndone:\n\tp9stat_free(st);\n\tkfree(st);\n\treturn retval;\n}"
  },
  {
    "function_name": "v9fs_qid2ino",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "1213-1224",
    "snippet": "ino_t v9fs_qid2ino(struct p9_qid *qid)\n{\n\tu64 path = qid->path + 2;\n\tino_t i = 0;\n\n\tif (sizeof(ino_t) == sizeof(path))\n\t\tmemcpy(&i, &path, sizeof(ino_t));\n\telse\n\t\ti = (ino_t) (path ^ (path >> 32));\n\n\treturn i;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "path ^ (path >> 32)"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&i",
            "&path",
            "sizeof(ino_t)"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nino_t v9fs_qid2ino(struct p9_qid *qid)\n{\n\tu64 path = qid->path + 2;\n\tino_t i = 0;\n\n\tif (sizeof(ino_t) == sizeof(path))\n\t\tmemcpy(&i, &path, sizeof(ino_t));\n\telse\n\t\ti = (ino_t) (path ^ (path >> 32));\n\n\treturn i;\n}"
  },
  {
    "function_name": "v9fs_stat2inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "1156-1204",
    "snippet": "void\nv9fs_stat2inode(struct p9_wstat *stat, struct inode *inode,\n\tstruct super_block *sb)\n{\n\tumode_t mode;\n\tchar ext[32];\n\tchar tag_name[14];\n\tunsigned int i_nlink;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tset_nlink(inode, 1);\n\n\tinode->i_atime.tv_sec = stat->atime;\n\tinode->i_mtime.tv_sec = stat->mtime;\n\tinode->i_ctime.tv_sec = stat->mtime;\n\n\tinode->i_uid = v9ses->dfltuid;\n\tinode->i_gid = v9ses->dfltgid;\n\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tinode->i_uid = stat->n_uid;\n\t\tinode->i_gid = stat->n_gid;\n\t}\n\tif ((S_ISREG(inode->i_mode)) || (S_ISDIR(inode->i_mode))) {\n\t\tif (v9fs_proto_dotu(v9ses) && (stat->extension[0] != '\\0')) {\n\t\t\t/*\n\t\t\t * Hadlink support got added later to\n\t\t\t * to the .u extension. So there can be\n\t\t\t * server out there that doesn't support\n\t\t\t * this even with .u extension. So check\n\t\t\t * for non NULL stat->extension\n\t\t\t */\n\t\t\tstrlcpy(ext, stat->extension, sizeof(ext));\n\t\t\t/* HARDLINKCOUNT %u */\n\t\t\tsscanf(ext, \"%13s %u\", tag_name, &i_nlink);\n\t\t\tif (!strncmp(tag_name, \"HARDLINKCOUNT\", 13))\n\t\t\t\tset_nlink(inode, i_nlink);\n\t\t}\n\t}\n\tmode = p9mode2perm(v9ses, stat);\n\tmode |= inode->i_mode & ~S_IALLUGO;\n\tinode->i_mode = mode;\n\ti_size_write(inode, stat->length);\n\n\t/* not real number of blocks, but 512 byte ones ... */\n\tinode->i_blocks = (i_size_read(inode) + 512 - 1) >> 9;\n\tv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "stat->length"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9mode2perm",
          "args": [
            "v9ses",
            "stat"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "p9mode2perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "98-116",
          "snippet": "static int p9mode2perm(struct v9fs_session_info *v9ses,\n\t\t       struct p9_wstat *stat)\n{\n\tint res;\n\tint mode = stat->mode;\n\n\tres = mode & S_IALLUGO;\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tif ((mode & P9_DMSETUID) == P9_DMSETUID)\n\t\t\tres |= S_ISUID;\n\n\t\tif ((mode & P9_DMSETGID) == P9_DMSETGID)\n\t\t\tres |= S_ISGID;\n\n\t\tif ((mode & P9_DMSETVTX) == P9_DMSETVTX)\n\t\t\tres |= S_ISVTX;\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int p9mode2perm(struct v9fs_session_info *v9ses,\n\t\t       struct p9_wstat *stat)\n{\n\tint res;\n\tint mode = stat->mode;\n\n\tres = mode & S_IALLUGO;\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tif ((mode & P9_DMSETUID) == P9_DMSETUID)\n\t\t\tres |= S_ISUID;\n\n\t\tif ((mode & P9_DMSETGID) == P9_DMSETGID)\n\t\t\tres |= S_ISGID;\n\n\t\tif ((mode & P9_DMSETVTX) == P9_DMSETVTX)\n\t\t\tres |= S_ISVTX;\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "i_nlink"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "tag_name",
            "\"HARDLINKCOUNT\"",
            "13"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ext",
            "\"%13s %u\"",
            "tag_name",
            "&i_nlink"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "ext",
            "stat->extension",
            "sizeof(ext)"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_proto_dotu",
          "args": [
            "v9ses"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_proto_dotu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "182-185",
          "snippet": "static inline int v9fs_proto_dotu(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000U;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline int v9fs_proto_dotu(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000U;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "V9FS_I",
          "args": [
            "inode"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "V9FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "137-140",
          "snippet": "static inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid\nv9fs_stat2inode(struct p9_wstat *stat, struct inode *inode,\n\tstruct super_block *sb)\n{\n\tumode_t mode;\n\tchar ext[32];\n\tchar tag_name[14];\n\tunsigned int i_nlink;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tset_nlink(inode, 1);\n\n\tinode->i_atime.tv_sec = stat->atime;\n\tinode->i_mtime.tv_sec = stat->mtime;\n\tinode->i_ctime.tv_sec = stat->mtime;\n\n\tinode->i_uid = v9ses->dfltuid;\n\tinode->i_gid = v9ses->dfltgid;\n\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tinode->i_uid = stat->n_uid;\n\t\tinode->i_gid = stat->n_gid;\n\t}\n\tif ((S_ISREG(inode->i_mode)) || (S_ISDIR(inode->i_mode))) {\n\t\tif (v9fs_proto_dotu(v9ses) && (stat->extension[0] != '\\0')) {\n\t\t\t/*\n\t\t\t * Hadlink support got added later to\n\t\t\t * to the .u extension. So there can be\n\t\t\t * server out there that doesn't support\n\t\t\t * this even with .u extension. So check\n\t\t\t * for non NULL stat->extension\n\t\t\t */\n\t\t\tstrlcpy(ext, stat->extension, sizeof(ext));\n\t\t\t/* HARDLINKCOUNT %u */\n\t\t\tsscanf(ext, \"%13s %u\", tag_name, &i_nlink);\n\t\t\tif (!strncmp(tag_name, \"HARDLINKCOUNT\", 13))\n\t\t\t\tset_nlink(inode, i_nlink);\n\t\t}\n\t}\n\tmode = p9mode2perm(v9ses, stat);\n\tmode |= inode->i_mode & ~S_IALLUGO;\n\tinode->i_mode = mode;\n\ti_size_write(inode, stat->length);\n\n\t/* not real number of blocks, but 512 byte ones ... */\n\tinode->i_blocks = (i_size_read(inode) + 512 - 1) >> 9;\n\tv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\n}"
  },
  {
    "function_name": "v9fs_vfs_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "1090-1146",
    "snippet": "static int v9fs_vfs_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tint retval;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid;\n\tstruct p9_wstat wstat;\n\n\tp9_debug(P9_DEBUG_VFS, \"\\n\");\n\tretval = inode_change_ok(dentry->d_inode, iattr);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = -EPERM;\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\tfid = v9fs_fid_lookup(dentry);\n\tif(IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\tv9fs_blank_wstat(&wstat);\n\tif (iattr->ia_valid & ATTR_MODE)\n\t\twstat.mode = unixmode2p9mode(v9ses, iattr->ia_mode);\n\n\tif (iattr->ia_valid & ATTR_MTIME)\n\t\twstat.mtime = iattr->ia_mtime.tv_sec;\n\n\tif (iattr->ia_valid & ATTR_ATIME)\n\t\twstat.atime = iattr->ia_atime.tv_sec;\n\n\tif (iattr->ia_valid & ATTR_SIZE)\n\t\twstat.length = iattr->ia_size;\n\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tif (iattr->ia_valid & ATTR_UID)\n\t\t\twstat.n_uid = iattr->ia_uid;\n\n\t\tif (iattr->ia_valid & ATTR_GID)\n\t\t\twstat.n_gid = iattr->ia_gid;\n\t}\n\n\t/* Write all dirty data */\n\tif (d_is_reg(dentry))\n\t\tfilemap_write_and_wait(dentry->d_inode->i_mapping);\n\n\tretval = p9_client_wstat(fid, &wstat);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tif ((iattr->ia_valid & ATTR_SIZE) &&\n\t    iattr->ia_size != i_size_read(dentry->d_inode))\n\t\ttruncate_setsize(dentry->d_inode, iattr->ia_size);\n\n\tv9fs_invalidate_inode_attr(dentry->d_inode);\n\n\tsetattr_copy(dentry->d_inode, iattr);\n\tmark_inode_dirty(dentry->d_inode);\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dentry->d_inode"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setattr_copy",
          "args": [
            "dentry->d_inode",
            "iattr"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "setattr_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "142-167",
          "snippet": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nvoid setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_invalidate_inode_attr",
          "args": [
            "dentry->d_inode"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_invalidate_inode_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs_vfs.h",
          "lines": "81-87",
          "snippet": "static inline void v9fs_invalidate_inode_attr(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = V9FS_I(inode);\n\tv9inode->cache_validity |= V9FS_INO_INVALID_ATTR;\n\treturn;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void v9fs_invalidate_inode_attr(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = V9FS_I(inode);\n\tv9inode->cache_validity |= V9FS_INO_INVALID_ATTR;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "dentry->d_inode",
            "iattr->ia_size"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "dentry->d_inode"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_wstat",
          "args": [
            "fid",
            "&wstat"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "dentry->d_inode->i_mapping"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_reg",
          "args": [
            "dentry"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_proto_dotu",
          "args": [
            "v9ses"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_proto_dotu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "182-185",
          "snippet": "static inline int v9fs_proto_dotu(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000U;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline int v9fs_proto_dotu(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000U;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unixmode2p9mode",
          "args": [
            "v9ses",
            "iattr->ia_mode"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "unixmode2p9mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "64-90",
          "snippet": "static u32 unixmode2p9mode(struct v9fs_session_info *v9ses, umode_t mode)\n{\n\tint res;\n\tres = mode & 0777;\n\tif (S_ISDIR(mode))\n\t\tres |= P9_DMDIR;\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tif (v9ses->nodev == 0) {\n\t\t\tif (S_ISSOCK(mode))\n\t\t\t\tres |= P9_DMSOCKET;\n\t\t\tif (S_ISFIFO(mode))\n\t\t\t\tres |= P9_DMNAMEDPIPE;\n\t\t\tif (S_ISBLK(mode))\n\t\t\t\tres |= P9_DMDEVICE;\n\t\t\tif (S_ISCHR(mode))\n\t\t\t\tres |= P9_DMDEVICE;\n\t\t}\n\n\t\tif ((mode & S_ISUID) == S_ISUID)\n\t\t\tres |= P9_DMSETUID;\n\t\tif ((mode & S_ISGID) == S_ISGID)\n\t\t\tres |= P9_DMSETGID;\n\t\tif ((mode & S_ISVTX) == S_ISVTX)\n\t\t\tres |= P9_DMSETVTX;\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic u32 unixmode2p9mode(struct v9fs_session_info *v9ses, umode_t mode)\n{\n\tint res;\n\tres = mode & 0777;\n\tif (S_ISDIR(mode))\n\t\tres |= P9_DMDIR;\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tif (v9ses->nodev == 0) {\n\t\t\tif (S_ISSOCK(mode))\n\t\t\t\tres |= P9_DMSOCKET;\n\t\t\tif (S_ISFIFO(mode))\n\t\t\t\tres |= P9_DMNAMEDPIPE;\n\t\t\tif (S_ISBLK(mode))\n\t\t\t\tres |= P9_DMDEVICE;\n\t\t\tif (S_ISCHR(mode))\n\t\t\t\tres |= P9_DMDEVICE;\n\t\t}\n\n\t\tif ((mode & S_ISUID) == S_ISUID)\n\t\t\tres |= P9_DMSETUID;\n\t\tif ((mode & S_ISGID) == S_ISGID)\n\t\t\tres |= P9_DMSETGID;\n\t\tif ((mode & S_ISVTX) == S_ISVTX)\n\t\t\tres |= P9_DMSETVTX;\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_blank_wstat",
          "args": [
            "&wstat"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_blank_wstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "212-232",
          "snippet": "void\nv9fs_blank_wstat(struct p9_wstat *wstat)\n{\n\twstat->type = ~0;\n\twstat->dev = ~0;\n\twstat->qid.type = ~0;\n\twstat->qid.version = ~0;\n\t*((long long *)&wstat->qid.path) = ~0;\n\twstat->mode = ~0;\n\twstat->atime = ~0;\n\twstat->mtime = ~0;\n\twstat->length = ~0;\n\twstat->name = NULL;\n\twstat->uid = NULL;\n\twstat->gid = NULL;\n\twstat->muid = NULL;\n\twstat->n_uid = INVALID_UID;\n\twstat->n_gid = INVALID_GID;\n\twstat->n_muid = INVALID_UID;\n\twstat->extension = NULL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid\nv9fs_blank_wstat(struct p9_wstat *wstat)\n{\n\twstat->type = ~0;\n\twstat->dev = ~0;\n\twstat->qid.type = ~0;\n\twstat->qid.version = ~0;\n\t*((long long *)&wstat->qid.path) = ~0;\n\twstat->mode = ~0;\n\twstat->atime = ~0;\n\twstat->mtime = ~0;\n\twstat->length = ~0;\n\twstat->name = NULL;\n\twstat->uid = NULL;\n\twstat->gid = NULL;\n\twstat->muid = NULL;\n\twstat->n_uid = INVALID_UID;\n\twstat->n_gid = INVALID_GID;\n\twstat->n_muid = INVALID_UID;\n\twstat->extension = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fid"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fid"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fid_lookup",
          "args": [
            "dentry"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "231-258",
          "snippet": "struct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_dentry2v9ses",
          "args": [
            "dentry"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_dentry2v9ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "177-180",
          "snippet": "static inline struct v9fs_session_info *v9fs_dentry2v9ses(struct dentry *dentry)\n{\n\treturn dentry->d_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_session_info *v9fs_dentry2v9ses(struct dentry *dentry)\n{\n\treturn dentry->d_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "dentry->d_inode",
            "iattr"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"\\n\""
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_vfs_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tint retval;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid;\n\tstruct p9_wstat wstat;\n\n\tp9_debug(P9_DEBUG_VFS, \"\\n\");\n\tretval = inode_change_ok(dentry->d_inode, iattr);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = -EPERM;\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\tfid = v9fs_fid_lookup(dentry);\n\tif(IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\tv9fs_blank_wstat(&wstat);\n\tif (iattr->ia_valid & ATTR_MODE)\n\t\twstat.mode = unixmode2p9mode(v9ses, iattr->ia_mode);\n\n\tif (iattr->ia_valid & ATTR_MTIME)\n\t\twstat.mtime = iattr->ia_mtime.tv_sec;\n\n\tif (iattr->ia_valid & ATTR_ATIME)\n\t\twstat.atime = iattr->ia_atime.tv_sec;\n\n\tif (iattr->ia_valid & ATTR_SIZE)\n\t\twstat.length = iattr->ia_size;\n\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tif (iattr->ia_valid & ATTR_UID)\n\t\t\twstat.n_uid = iattr->ia_uid;\n\n\t\tif (iattr->ia_valid & ATTR_GID)\n\t\t\twstat.n_gid = iattr->ia_gid;\n\t}\n\n\t/* Write all dirty data */\n\tif (d_is_reg(dentry))\n\t\tfilemap_write_and_wait(dentry->d_inode->i_mapping);\n\n\tretval = p9_client_wstat(fid, &wstat);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tif ((iattr->ia_valid & ATTR_SIZE) &&\n\t    iattr->ia_size != i_size_read(dentry->d_inode))\n\t\ttruncate_setsize(dentry->d_inode, iattr->ia_size);\n\n\tv9fs_invalidate_inode_attr(dentry->d_inode);\n\n\tsetattr_copy(dentry->d_inode, iattr);\n\tmark_inode_dirty(dentry->d_inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "v9fs_vfs_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "1053-1081",
    "snippet": "static int\nv9fs_vfs_getattr(struct vfsmount *mnt, struct dentry *dentry,\n\t\t struct kstat *stat)\n{\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid;\n\tstruct p9_wstat *st;\n\n\tp9_debug(P9_DEBUG_VFS, \"dentry: %p\\n\", dentry);\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {\n\t\tgeneric_fillattr(dentry->d_inode, stat);\n\t\treturn 0;\n\t}\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\tst = p9_client_stat(fid);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\n\tv9fs_stat2inode(st, dentry->d_inode, dentry->d_inode->i_sb);\n\tgeneric_fillattr(dentry->d_inode, stat);\n\n\tp9stat_free(st);\n\tkfree(st);\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "st"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9stat_free",
          "args": [
            "st"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_fillattr",
          "args": [
            "dentry->d_inode",
            "stat"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fillattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "21-36",
          "snippet": "void generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_stat2inode",
          "args": [
            "st",
            "dentry->d_inode",
            "dentry->d_inode->i_sb"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_stat2inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "1156-1204",
          "snippet": "void\nv9fs_stat2inode(struct p9_wstat *stat, struct inode *inode,\n\tstruct super_block *sb)\n{\n\tumode_t mode;\n\tchar ext[32];\n\tchar tag_name[14];\n\tunsigned int i_nlink;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tset_nlink(inode, 1);\n\n\tinode->i_atime.tv_sec = stat->atime;\n\tinode->i_mtime.tv_sec = stat->mtime;\n\tinode->i_ctime.tv_sec = stat->mtime;\n\n\tinode->i_uid = v9ses->dfltuid;\n\tinode->i_gid = v9ses->dfltgid;\n\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tinode->i_uid = stat->n_uid;\n\t\tinode->i_gid = stat->n_gid;\n\t}\n\tif ((S_ISREG(inode->i_mode)) || (S_ISDIR(inode->i_mode))) {\n\t\tif (v9fs_proto_dotu(v9ses) && (stat->extension[0] != '\\0')) {\n\t\t\t/*\n\t\t\t * Hadlink support got added later to\n\t\t\t * to the .u extension. So there can be\n\t\t\t * server out there that doesn't support\n\t\t\t * this even with .u extension. So check\n\t\t\t * for non NULL stat->extension\n\t\t\t */\n\t\t\tstrlcpy(ext, stat->extension, sizeof(ext));\n\t\t\t/* HARDLINKCOUNT %u */\n\t\t\tsscanf(ext, \"%13s %u\", tag_name, &i_nlink);\n\t\t\tif (!strncmp(tag_name, \"HARDLINKCOUNT\", 13))\n\t\t\t\tset_nlink(inode, i_nlink);\n\t\t}\n\t}\n\tmode = p9mode2perm(v9ses, stat);\n\tmode |= inode->i_mode & ~S_IALLUGO;\n\tinode->i_mode = mode;\n\ti_size_write(inode, stat->length);\n\n\t/* not real number of blocks, but 512 byte ones ... */\n\tinode->i_blocks = (i_size_read(inode) + 512 - 1) >> 9;\n\tv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid\nv9fs_stat2inode(struct p9_wstat *stat, struct inode *inode,\n\tstruct super_block *sb)\n{\n\tumode_t mode;\n\tchar ext[32];\n\tchar tag_name[14];\n\tunsigned int i_nlink;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tset_nlink(inode, 1);\n\n\tinode->i_atime.tv_sec = stat->atime;\n\tinode->i_mtime.tv_sec = stat->mtime;\n\tinode->i_ctime.tv_sec = stat->mtime;\n\n\tinode->i_uid = v9ses->dfltuid;\n\tinode->i_gid = v9ses->dfltgid;\n\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tinode->i_uid = stat->n_uid;\n\t\tinode->i_gid = stat->n_gid;\n\t}\n\tif ((S_ISREG(inode->i_mode)) || (S_ISDIR(inode->i_mode))) {\n\t\tif (v9fs_proto_dotu(v9ses) && (stat->extension[0] != '\\0')) {\n\t\t\t/*\n\t\t\t * Hadlink support got added later to\n\t\t\t * to the .u extension. So there can be\n\t\t\t * server out there that doesn't support\n\t\t\t * this even with .u extension. So check\n\t\t\t * for non NULL stat->extension\n\t\t\t */\n\t\t\tstrlcpy(ext, stat->extension, sizeof(ext));\n\t\t\t/* HARDLINKCOUNT %u */\n\t\t\tsscanf(ext, \"%13s %u\", tag_name, &i_nlink);\n\t\t\tif (!strncmp(tag_name, \"HARDLINKCOUNT\", 13))\n\t\t\t\tset_nlink(inode, i_nlink);\n\t\t}\n\t}\n\tmode = p9mode2perm(v9ses, stat);\n\tmode |= inode->i_mode & ~S_IALLUGO;\n\tinode->i_mode = mode;\n\ti_size_write(inode, stat->length);\n\n\t/* not real number of blocks, but 512 byte ones ... */\n\tinode->i_blocks = (i_size_read(inode) + 512 - 1) >> 9;\n\tv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "st"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "st"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_stat",
          "args": [
            "fid"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fid"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fid"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fid_lookup",
          "args": [
            "dentry"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "231-258",
          "snippet": "struct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_dentry2v9ses",
          "args": [
            "dentry"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_dentry2v9ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "177-180",
          "snippet": "static inline struct v9fs_session_info *v9fs_dentry2v9ses(struct dentry *dentry)\n{\n\treturn dentry->d_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_session_info *v9fs_dentry2v9ses(struct dentry *dentry)\n{\n\treturn dentry->d_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"dentry: %p\\n\"",
            "dentry"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int\nv9fs_vfs_getattr(struct vfsmount *mnt, struct dentry *dentry,\n\t\t struct kstat *stat)\n{\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid;\n\tstruct p9_wstat *st;\n\n\tp9_debug(P9_DEBUG_VFS, \"dentry: %p\\n\", dentry);\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {\n\t\tgeneric_fillattr(dentry->d_inode, stat);\n\t\treturn 0;\n\t}\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\tst = p9_client_stat(fid);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\n\tv9fs_stat2inode(st, dentry->d_inode, dentry->d_inode->i_sb);\n\tgeneric_fillattr(dentry->d_inode, stat);\n\n\tp9stat_free(st);\n\tkfree(st);\n\treturn 0;\n}"
  },
  {
    "function_name": "v9fs_vfs_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "957-1043",
    "snippet": "int\nv9fs_vfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\tstruct inode *new_dir, struct dentry *new_dentry)\n{\n\tint retval;\n\tstruct inode *old_inode;\n\tstruct inode *new_inode;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *oldfid;\n\tstruct p9_fid *olddirfid;\n\tstruct p9_fid *newdirfid;\n\tstruct p9_wstat wstat;\n\n\tp9_debug(P9_DEBUG_VFS, \"\\n\");\n\tretval = 0;\n\told_inode = old_dentry->d_inode;\n\tnew_inode = new_dentry->d_inode;\n\tv9ses = v9fs_inode2v9ses(old_inode);\n\toldfid = v9fs_fid_lookup(old_dentry);\n\tif (IS_ERR(oldfid))\n\t\treturn PTR_ERR(oldfid);\n\n\tolddirfid = v9fs_fid_clone(old_dentry->d_parent);\n\tif (IS_ERR(olddirfid)) {\n\t\tretval = PTR_ERR(olddirfid);\n\t\tgoto done;\n\t}\n\n\tnewdirfid = v9fs_fid_clone(new_dentry->d_parent);\n\tif (IS_ERR(newdirfid)) {\n\t\tretval = PTR_ERR(newdirfid);\n\t\tgoto clunk_olddir;\n\t}\n\n\tdown_write(&v9ses->rename_sem);\n\tif (v9fs_proto_dotl(v9ses)) {\n\t\tretval = p9_client_renameat(olddirfid, old_dentry->d_name.name,\n\t\t\t\t\t    newdirfid, new_dentry->d_name.name);\n\t\tif (retval == -EOPNOTSUPP)\n\t\t\tretval = p9_client_rename(oldfid, newdirfid,\n\t\t\t\t\t\t  new_dentry->d_name.name);\n\t\tif (retval != -EOPNOTSUPP)\n\t\t\tgoto clunk_newdir;\n\t}\n\tif (old_dentry->d_parent != new_dentry->d_parent) {\n\t\t/*\n\t\t * 9P .u can only handle file rename in the same directory\n\t\t */\n\n\t\tp9_debug(P9_DEBUG_ERROR, \"old dir and new dir are different\\n\");\n\t\tretval = -EXDEV;\n\t\tgoto clunk_newdir;\n\t}\n\tv9fs_blank_wstat(&wstat);\n\twstat.muid = v9ses->uname;\n\twstat.name = (char *) new_dentry->d_name.name;\n\tretval = p9_client_wstat(oldfid, &wstat);\n\nclunk_newdir:\n\tif (!retval) {\n\t\tif (new_inode) {\n\t\t\tif (S_ISDIR(new_inode->i_mode))\n\t\t\t\tclear_nlink(new_inode);\n\t\t\telse\n\t\t\t\tdrop_nlink(new_inode);\n\t\t}\n\t\tif (S_ISDIR(old_inode->i_mode)) {\n\t\t\tif (!new_inode)\n\t\t\t\tinc_nlink(new_dir);\n\t\t\tdrop_nlink(old_dir);\n\t\t}\n\t\tv9fs_invalidate_inode_attr(old_inode);\n\t\tv9fs_invalidate_inode_attr(old_dir);\n\t\tv9fs_invalidate_inode_attr(new_dir);\n\n\t\t/* successful rename */\n\t\td_move(old_dentry, new_dentry);\n\t}\n\tup_write(&v9ses->rename_sem);\n\tp9_client_clunk(newdirfid);\n\nclunk_olddir:\n\tp9_client_clunk(olddirfid);\n\ndone:\n\treturn retval;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p9_client_clunk",
          "args": [
            "olddirfid"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_clunk",
          "args": [
            "newdirfid"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&v9ses->rename_sem"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_move",
          "args": [
            "old_dentry",
            "new_dentry"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "d_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2634-2639",
          "snippet": "void d_move(struct dentry *dentry, struct dentry *target)\n{\n\twrite_seqlock(&rename_lock);\n\t__d_move(dentry, target, false);\n\twrite_sequnlock(&rename_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nvoid d_move(struct dentry *dentry, struct dentry *target)\n{\n\twrite_seqlock(&rename_lock);\n\t__d_move(dentry, target, false);\n\twrite_sequnlock(&rename_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_invalidate_inode_attr",
          "args": [
            "new_dir"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_invalidate_inode_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs_vfs.h",
          "lines": "81-87",
          "snippet": "static inline void v9fs_invalidate_inode_attr(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = V9FS_I(inode);\n\tv9inode->cache_validity |= V9FS_INO_INVALID_ATTR;\n\treturn;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void v9fs_invalidate_inode_attr(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = V9FS_I(inode);\n\tv9inode->cache_validity |= V9FS_INO_INVALID_ATTR;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "old_dir"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "new_dir"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "old_inode->i_mode"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "new_inode"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "new_inode->i_mode"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_wstat",
          "args": [
            "oldfid",
            "&wstat"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_blank_wstat",
          "args": [
            "&wstat"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_blank_wstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "212-232",
          "snippet": "void\nv9fs_blank_wstat(struct p9_wstat *wstat)\n{\n\twstat->type = ~0;\n\twstat->dev = ~0;\n\twstat->qid.type = ~0;\n\twstat->qid.version = ~0;\n\t*((long long *)&wstat->qid.path) = ~0;\n\twstat->mode = ~0;\n\twstat->atime = ~0;\n\twstat->mtime = ~0;\n\twstat->length = ~0;\n\twstat->name = NULL;\n\twstat->uid = NULL;\n\twstat->gid = NULL;\n\twstat->muid = NULL;\n\twstat->n_uid = INVALID_UID;\n\twstat->n_gid = INVALID_GID;\n\twstat->n_muid = INVALID_UID;\n\twstat->extension = NULL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid\nv9fs_blank_wstat(struct p9_wstat *wstat)\n{\n\twstat->type = ~0;\n\twstat->dev = ~0;\n\twstat->qid.type = ~0;\n\twstat->qid.version = ~0;\n\t*((long long *)&wstat->qid.path) = ~0;\n\twstat->mode = ~0;\n\twstat->atime = ~0;\n\twstat->mtime = ~0;\n\twstat->length = ~0;\n\twstat->name = NULL;\n\twstat->uid = NULL;\n\twstat->gid = NULL;\n\twstat->muid = NULL;\n\twstat->n_uid = INVALID_UID;\n\twstat->n_gid = INVALID_GID;\n\twstat->n_muid = INVALID_UID;\n\twstat->extension = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_ERROR",
            "\"old dir and new dir are different\\n\""
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_rename",
          "args": [
            "oldfid",
            "newdirfid",
            "new_dentry->d_name.name"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_renameat",
          "args": [
            "olddirfid",
            "old_dentry->d_name.name",
            "newdirfid",
            "new_dentry->d_name.name"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_proto_dotl",
          "args": [
            "v9ses"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_proto_dotl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "187-190",
          "snippet": "static inline int v9fs_proto_dotl(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000L;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline int v9fs_proto_dotl(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000L;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&v9ses->rename_sem"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "newdirfid"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "newdirfid"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fid_clone",
          "args": [
            "new_dentry->d_parent"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "260-270",
          "snippet": "struct p9_fid *v9fs_fid_clone(struct dentry *dentry)\n{\n\tstruct p9_fid *fid, *ret;\n\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn fid;\n\n\tret = p9_client_walk(fid, 0, NULL, 1);\n\treturn ret;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct p9_fid *v9fs_fid_clone(struct dentry *dentry)\n{\n\tstruct p9_fid *fid, *ret;\n\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn fid;\n\n\tret = p9_client_walk(fid, 0, NULL, 1);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "olddirfid"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "olddirfid"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "oldfid"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "oldfid"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fid_lookup",
          "args": [
            "old_dentry"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "231-258",
          "snippet": "struct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_inode2v9ses",
          "args": [
            "old_inode"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_inode2v9ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "172-175",
          "snippet": "static inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"\\n\""
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nint\nv9fs_vfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\tstruct inode *new_dir, struct dentry *new_dentry)\n{\n\tint retval;\n\tstruct inode *old_inode;\n\tstruct inode *new_inode;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *oldfid;\n\tstruct p9_fid *olddirfid;\n\tstruct p9_fid *newdirfid;\n\tstruct p9_wstat wstat;\n\n\tp9_debug(P9_DEBUG_VFS, \"\\n\");\n\tretval = 0;\n\told_inode = old_dentry->d_inode;\n\tnew_inode = new_dentry->d_inode;\n\tv9ses = v9fs_inode2v9ses(old_inode);\n\toldfid = v9fs_fid_lookup(old_dentry);\n\tif (IS_ERR(oldfid))\n\t\treturn PTR_ERR(oldfid);\n\n\tolddirfid = v9fs_fid_clone(old_dentry->d_parent);\n\tif (IS_ERR(olddirfid)) {\n\t\tretval = PTR_ERR(olddirfid);\n\t\tgoto done;\n\t}\n\n\tnewdirfid = v9fs_fid_clone(new_dentry->d_parent);\n\tif (IS_ERR(newdirfid)) {\n\t\tretval = PTR_ERR(newdirfid);\n\t\tgoto clunk_olddir;\n\t}\n\n\tdown_write(&v9ses->rename_sem);\n\tif (v9fs_proto_dotl(v9ses)) {\n\t\tretval = p9_client_renameat(olddirfid, old_dentry->d_name.name,\n\t\t\t\t\t    newdirfid, new_dentry->d_name.name);\n\t\tif (retval == -EOPNOTSUPP)\n\t\t\tretval = p9_client_rename(oldfid, newdirfid,\n\t\t\t\t\t\t  new_dentry->d_name.name);\n\t\tif (retval != -EOPNOTSUPP)\n\t\t\tgoto clunk_newdir;\n\t}\n\tif (old_dentry->d_parent != new_dentry->d_parent) {\n\t\t/*\n\t\t * 9P .u can only handle file rename in the same directory\n\t\t */\n\n\t\tp9_debug(P9_DEBUG_ERROR, \"old dir and new dir are different\\n\");\n\t\tretval = -EXDEV;\n\t\tgoto clunk_newdir;\n\t}\n\tv9fs_blank_wstat(&wstat);\n\twstat.muid = v9ses->uname;\n\twstat.name = (char *) new_dentry->d_name.name;\n\tretval = p9_client_wstat(oldfid, &wstat);\n\nclunk_newdir:\n\tif (!retval) {\n\t\tif (new_inode) {\n\t\t\tif (S_ISDIR(new_inode->i_mode))\n\t\t\t\tclear_nlink(new_inode);\n\t\t\telse\n\t\t\t\tdrop_nlink(new_inode);\n\t\t}\n\t\tif (S_ISDIR(old_inode->i_mode)) {\n\t\t\tif (!new_inode)\n\t\t\t\tinc_nlink(new_dir);\n\t\t\tdrop_nlink(old_dir);\n\t\t}\n\t\tv9fs_invalidate_inode_attr(old_inode);\n\t\tv9fs_invalidate_inode_attr(old_dir);\n\t\tv9fs_invalidate_inode_attr(new_dir);\n\n\t\t/* successful rename */\n\t\td_move(old_dentry, new_dentry);\n\t}\n\tup_write(&v9ses->rename_sem);\n\tp9_client_clunk(newdirfid);\n\nclunk_olddir:\n\tp9_client_clunk(olddirfid);\n\ndone:\n\treturn retval;\n}"
  },
  {
    "function_name": "v9fs_vfs_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "943-946",
    "snippet": "int v9fs_vfs_rmdir(struct inode *i, struct dentry *d)\n{\n\treturn v9fs_remove(i, d, AT_REMOVEDIR);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v9fs_remove",
          "args": [
            "i",
            "d",
            "AT_REMOVEDIR"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "587-630",
          "snippet": "static int v9fs_remove(struct inode *dir, struct dentry *dentry, int flags)\n{\n\tstruct inode *inode;\n\tint retval = -EOPNOTSUPP;\n\tstruct p9_fid *v9fid, *dfid;\n\tstruct v9fs_session_info *v9ses;\n\n\tp9_debug(P9_DEBUG_VFS, \"inode: %p dentry: %p rmdir: %x\\n\",\n\t\t dir, dentry, flags);\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\tinode = dentry->d_inode;\n\tdfid = v9fs_fid_lookup(dentry->d_parent);\n\tif (IS_ERR(dfid)) {\n\t\tretval = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", retval);\n\t\treturn retval;\n\t}\n\tif (v9fs_proto_dotl(v9ses))\n\t\tretval = p9_client_unlinkat(dfid, dentry->d_name.name,\n\t\t\t\t\t    v9fs_at_to_dotl_flags(flags));\n\tif (retval == -EOPNOTSUPP) {\n\t\t/* Try the one based on path */\n\t\tv9fid = v9fs_fid_clone(dentry);\n\t\tif (IS_ERR(v9fid))\n\t\t\treturn PTR_ERR(v9fid);\n\t\tretval = p9_client_remove(v9fid);\n\t}\n\tif (!retval) {\n\t\t/*\n\t\t * directories on unlink should have zero\n\t\t * link count\n\t\t */\n\t\tif (flags & AT_REMOVEDIR) {\n\t\t\tclear_nlink(inode);\n\t\t\tdrop_nlink(dir);\n\t\t} else\n\t\t\tdrop_nlink(inode);\n\n\t\tv9fs_invalidate_inode_attr(inode);\n\t\tv9fs_invalidate_inode_attr(dir);\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_remove(struct inode *dir, struct dentry *dentry, int flags)\n{\n\tstruct inode *inode;\n\tint retval = -EOPNOTSUPP;\n\tstruct p9_fid *v9fid, *dfid;\n\tstruct v9fs_session_info *v9ses;\n\n\tp9_debug(P9_DEBUG_VFS, \"inode: %p dentry: %p rmdir: %x\\n\",\n\t\t dir, dentry, flags);\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\tinode = dentry->d_inode;\n\tdfid = v9fs_fid_lookup(dentry->d_parent);\n\tif (IS_ERR(dfid)) {\n\t\tretval = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", retval);\n\t\treturn retval;\n\t}\n\tif (v9fs_proto_dotl(v9ses))\n\t\tretval = p9_client_unlinkat(dfid, dentry->d_name.name,\n\t\t\t\t\t    v9fs_at_to_dotl_flags(flags));\n\tif (retval == -EOPNOTSUPP) {\n\t\t/* Try the one based on path */\n\t\tv9fid = v9fs_fid_clone(dentry);\n\t\tif (IS_ERR(v9fid))\n\t\t\treturn PTR_ERR(v9fid);\n\t\tretval = p9_client_remove(v9fid);\n\t}\n\tif (!retval) {\n\t\t/*\n\t\t * directories on unlink should have zero\n\t\t * link count\n\t\t */\n\t\tif (flags & AT_REMOVEDIR) {\n\t\t\tclear_nlink(inode);\n\t\t\tdrop_nlink(dir);\n\t\t} else\n\t\t\tdrop_nlink(inode);\n\n\t\tv9fs_invalidate_inode_attr(inode);\n\t\tv9fs_invalidate_inode_attr(dir);\n\t}\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nint v9fs_vfs_rmdir(struct inode *i, struct dentry *d)\n{\n\treturn v9fs_remove(i, d, AT_REMOVEDIR);\n}"
  },
  {
    "function_name": "v9fs_vfs_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "931-934",
    "snippet": "int v9fs_vfs_unlink(struct inode *i, struct dentry *d)\n{\n\treturn v9fs_remove(i, d, 0);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v9fs_remove",
          "args": [
            "i",
            "d",
            "0"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "587-630",
          "snippet": "static int v9fs_remove(struct inode *dir, struct dentry *dentry, int flags)\n{\n\tstruct inode *inode;\n\tint retval = -EOPNOTSUPP;\n\tstruct p9_fid *v9fid, *dfid;\n\tstruct v9fs_session_info *v9ses;\n\n\tp9_debug(P9_DEBUG_VFS, \"inode: %p dentry: %p rmdir: %x\\n\",\n\t\t dir, dentry, flags);\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\tinode = dentry->d_inode;\n\tdfid = v9fs_fid_lookup(dentry->d_parent);\n\tif (IS_ERR(dfid)) {\n\t\tretval = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", retval);\n\t\treturn retval;\n\t}\n\tif (v9fs_proto_dotl(v9ses))\n\t\tretval = p9_client_unlinkat(dfid, dentry->d_name.name,\n\t\t\t\t\t    v9fs_at_to_dotl_flags(flags));\n\tif (retval == -EOPNOTSUPP) {\n\t\t/* Try the one based on path */\n\t\tv9fid = v9fs_fid_clone(dentry);\n\t\tif (IS_ERR(v9fid))\n\t\t\treturn PTR_ERR(v9fid);\n\t\tretval = p9_client_remove(v9fid);\n\t}\n\tif (!retval) {\n\t\t/*\n\t\t * directories on unlink should have zero\n\t\t * link count\n\t\t */\n\t\tif (flags & AT_REMOVEDIR) {\n\t\t\tclear_nlink(inode);\n\t\t\tdrop_nlink(dir);\n\t\t} else\n\t\t\tdrop_nlink(inode);\n\n\t\tv9fs_invalidate_inode_attr(inode);\n\t\tv9fs_invalidate_inode_attr(dir);\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_remove(struct inode *dir, struct dentry *dentry, int flags)\n{\n\tstruct inode *inode;\n\tint retval = -EOPNOTSUPP;\n\tstruct p9_fid *v9fid, *dfid;\n\tstruct v9fs_session_info *v9ses;\n\n\tp9_debug(P9_DEBUG_VFS, \"inode: %p dentry: %p rmdir: %x\\n\",\n\t\t dir, dentry, flags);\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\tinode = dentry->d_inode;\n\tdfid = v9fs_fid_lookup(dentry->d_parent);\n\tif (IS_ERR(dfid)) {\n\t\tretval = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", retval);\n\t\treturn retval;\n\t}\n\tif (v9fs_proto_dotl(v9ses))\n\t\tretval = p9_client_unlinkat(dfid, dentry->d_name.name,\n\t\t\t\t\t    v9fs_at_to_dotl_flags(flags));\n\tif (retval == -EOPNOTSUPP) {\n\t\t/* Try the one based on path */\n\t\tv9fid = v9fs_fid_clone(dentry);\n\t\tif (IS_ERR(v9fid))\n\t\t\treturn PTR_ERR(v9fid);\n\t\tretval = p9_client_remove(v9fid);\n\t}\n\tif (!retval) {\n\t\t/*\n\t\t * directories on unlink should have zero\n\t\t * link count\n\t\t */\n\t\tif (flags & AT_REMOVEDIR) {\n\t\t\tclear_nlink(inode);\n\t\t\tdrop_nlink(dir);\n\t\t} else\n\t\t\tdrop_nlink(inode);\n\n\t\tv9fs_invalidate_inode_attr(inode);\n\t\tv9fs_invalidate_inode_attr(dir);\n\t}\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nint v9fs_vfs_unlink(struct inode *i, struct dentry *d)\n{\n\treturn v9fs_remove(i, d, 0);\n}"
  },
  {
    "function_name": "v9fs_vfs_atomic_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "845-922",
    "snippet": "static int\nv9fs_vfs_atomic_open(struct inode *dir, struct dentry *dentry,\n\t\t     struct file *file, unsigned flags, umode_t mode,\n\t\t     int *opened)\n{\n\tint err;\n\tu32 perm;\n\tstruct v9fs_inode *v9inode;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid, *inode_fid;\n\tstruct dentry *res = NULL;\n\n\tif (d_unhashed(dentry)) {\n\t\tres = v9fs_vfs_lookup(dir, dentry, 0);\n\t\tif (IS_ERR(res))\n\t\t\treturn PTR_ERR(res);\n\n\t\tif (res)\n\t\t\tdentry = res;\n\t}\n\n\t/* Only creates */\n\tif (!(flags & O_CREAT) || dentry->d_inode)\n\t\treturn finish_no_open(file, res);\n\n\terr = 0;\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\tperm = unixmode2p9mode(v9ses, mode);\n\tfid = v9fs_create(v9ses, dir, dentry, NULL, perm,\n\t\t\t\tv9fs_uflags2omode(flags,\n\t\t\t\t\t\tv9fs_proto_dotu(v9ses)));\n\tif (IS_ERR(fid)) {\n\t\terr = PTR_ERR(fid);\n\t\tfid = NULL;\n\t\tgoto error;\n\t}\n\n\tv9fs_invalidate_inode_attr(dir);\n\tv9inode = V9FS_I(dentry->d_inode);\n\tmutex_lock(&v9inode->v_mutex);\n\tif ((v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) &&\n\t    !v9inode->writeback_fid &&\n\t    ((flags & O_ACCMODE) != O_RDONLY)) {\n\t\t/*\n\t\t * clone a fid and add it to writeback_fid\n\t\t * we do it during open time instead of\n\t\t * page dirty time via write_begin/page_mkwrite\n\t\t * because we want write after unlink usecase\n\t\t * to work.\n\t\t */\n\t\tinode_fid = v9fs_writeback_fid(dentry);\n\t\tif (IS_ERR(inode_fid)) {\n\t\t\terr = PTR_ERR(inode_fid);\n\t\t\tmutex_unlock(&v9inode->v_mutex);\n\t\t\tgoto error;\n\t\t}\n\t\tv9inode->writeback_fid = (void *) inode_fid;\n\t}\n\tmutex_unlock(&v9inode->v_mutex);\n\terr = finish_open(file, dentry, generic_file_open, opened);\n\tif (err)\n\t\tgoto error;\n\n\tfile->private_data = fid;\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n\t\tv9fs_cache_inode_set_cookie(dentry->d_inode, file);\n\n\t*opened |= FILE_CREATED;\nout:\n\tdput(res);\n\treturn err;\n\nerror:\n\tif (fid)\n\t\tp9_client_clunk(fid);\n\tgoto out;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p9_client_clunk",
          "args": [
            "fid"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "res"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_cache_inode_set_cookie",
          "args": [
            "dentry->d_inode",
            "file"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_cache_inode_set_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/cache.c",
          "lines": "239-254",
          "snippet": "void v9fs_cache_inode_set_cookie(struct inode *inode, struct file *filp)\n{\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tif (!v9inode->fscache)\n\t\treturn;\n\n\tspin_lock(&v9inode->fscache_lock);\n\n\tif ((filp->f_flags & O_ACCMODE) != O_RDONLY)\n\t\tv9fs_cache_inode_flush_cookie(inode);\n\telse\n\t\tv9fs_cache_inode_get_cookie(inode);\n\n\tspin_unlock(&v9inode->fscache_lock);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/jiffies.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs.h\"\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/jiffies.h>\n\nvoid v9fs_cache_inode_set_cookie(struct inode *inode, struct file *filp)\n{\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tif (!v9inode->fscache)\n\t\treturn;\n\n\tspin_lock(&v9inode->fscache_lock);\n\n\tif ((filp->f_flags & O_ACCMODE) != O_RDONLY)\n\t\tv9fs_cache_inode_flush_cookie(inode);\n\telse\n\t\tv9fs_cache_inode_get_cookie(inode);\n\n\tspin_unlock(&v9inode->fscache_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_open",
          "args": [
            "file",
            "dentry",
            "generic_file_open",
            "opened"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "finish_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "784-797",
          "snippet": "int finish_open(struct file *file, struct dentry *dentry,\n\t\tint (*open)(struct inode *, struct file *),\n\t\tint *opened)\n{\n\tint error;\n\tBUG_ON(*opened & FILE_OPENED); /* once it's opened, it's opened */\n\n\tfile->f_path.dentry = dentry;\n\terror = do_dentry_open(file, open, current_cred());\n\tif (!error)\n\t\t*opened |= FILE_OPENED;\n\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint finish_open(struct file *file, struct dentry *dentry,\n\t\tint (*open)(struct inode *, struct file *),\n\t\tint *opened)\n{\n\tint error;\n\tBUG_ON(*opened & FILE_OPENED); /* once it's opened, it's opened */\n\n\tfile->f_path.dentry = dentry;\n\terror = do_dentry_open(file, open, current_cred());\n\tif (!error)\n\t\t*opened |= FILE_OPENED;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&v9inode->v_mutex"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&v9inode->v_mutex"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode_fid"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode_fid"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_writeback_fid",
          "args": [
            "dentry"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_writeback_fid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "284-306",
          "snippet": "struct p9_fid *v9fs_writeback_fid(struct dentry *dentry)\n{\n\tint err;\n\tstruct p9_fid *fid;\n\n\tfid = v9fs_fid_clone_with_uid(dentry, GLOBAL_ROOT_UID);\n\tif (IS_ERR(fid))\n\t\tgoto error_out;\n\t/*\n\t * writeback fid will only be used to write back the\n\t * dirty pages. We always request for the open fid in read-write\n\t * mode so that a partial page write which result in page\n\t * read can work.\n\t */\n\terr = p9_client_open(fid, O_RDWR);\n\tif (err < 0) {\n\t\tp9_client_clunk(fid);\n\t\tfid = ERR_PTR(err);\n\t\tgoto error_out;\n\t}\nerror_out:\n\treturn fid;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct p9_fid *v9fs_writeback_fid(struct dentry *dentry)\n{\n\tint err;\n\tstruct p9_fid *fid;\n\n\tfid = v9fs_fid_clone_with_uid(dentry, GLOBAL_ROOT_UID);\n\tif (IS_ERR(fid))\n\t\tgoto error_out;\n\t/*\n\t * writeback fid will only be used to write back the\n\t * dirty pages. We always request for the open fid in read-write\n\t * mode so that a partial page write which result in page\n\t * read can work.\n\t */\n\terr = p9_client_open(fid, O_RDWR);\n\tif (err < 0) {\n\t\tp9_client_clunk(fid);\n\t\tfid = ERR_PTR(err);\n\t\tgoto error_out;\n\t}\nerror_out:\n\treturn fid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&v9inode->v_mutex"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "V9FS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "V9FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "137-140",
          "snippet": "static inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_invalidate_inode_attr",
          "args": [
            "dir"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_invalidate_inode_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs_vfs.h",
          "lines": "81-87",
          "snippet": "static inline void v9fs_invalidate_inode_attr(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = V9FS_I(inode);\n\tv9inode->cache_validity |= V9FS_INO_INVALID_ATTR;\n\treturn;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void v9fs_invalidate_inode_attr(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = V9FS_I(inode);\n\tv9inode->cache_validity |= V9FS_INO_INVALID_ATTR;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fid"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fid"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_create",
          "args": [
            "v9ses",
            "dir",
            "dentry",
            "NULL",
            "perm",
            "v9fs_uflags2omode(flags,\n\t\t\t\t\t\tv9fs_proto_dotu(v9ses))"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "642-710",
          "snippet": "static struct p9_fid *\nv9fs_create(struct v9fs_session_info *v9ses, struct inode *dir,\n\t\tstruct dentry *dentry, char *extension, u32 perm, u8 mode)\n{\n\tint err;\n\tchar *name;\n\tstruct p9_fid *dfid, *ofid, *fid;\n\tstruct inode *inode;\n\n\tp9_debug(P9_DEBUG_VFS, \"name %pd\\n\", dentry);\n\n\terr = 0;\n\tofid = NULL;\n\tfid = NULL;\n\tname = (char *) dentry->d_name.name;\n\tdfid = v9fs_fid_lookup(dentry->d_parent);\n\tif (IS_ERR(dfid)) {\n\t\terr = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\n\t/* clone a fid to use for creation */\n\tofid = p9_client_walk(dfid, 0, NULL, 1);\n\tif (IS_ERR(ofid)) {\n\t\terr = PTR_ERR(ofid);\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_walk failed %d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = p9_client_fcreate(ofid, name, perm, mode, extension);\n\tif (err < 0) {\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_fcreate failed %d\\n\", err);\n\t\tgoto error;\n\t}\n\n\tif (!(perm & P9_DMLINK)) {\n\t\t/* now walk from the parent so we can get unopened fid */\n\t\tfid = p9_client_walk(dfid, 1, &name, 1);\n\t\tif (IS_ERR(fid)) {\n\t\t\terr = PTR_ERR(fid);\n\t\t\tp9_debug(P9_DEBUG_VFS,\n\t\t\t\t   \"p9_client_walk failed %d\\n\", err);\n\t\t\tfid = NULL;\n\t\t\tgoto error;\n\t\t}\n\t\t/*\n\t\t * instantiate inode and assign the unopened fid to the dentry\n\t\t */\n\t\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tp9_debug(P9_DEBUG_VFS,\n\t\t\t\t   \"inode creation failed %d\\n\", err);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_fid_add(dentry, fid);\n\t\td_instantiate(dentry, inode);\n\t}\n\treturn ofid;\nerror:\n\tif (ofid)\n\t\tp9_client_clunk(ofid);\n\n\tif (fid)\n\t\tp9_client_clunk(fid);\n\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic struct p9_fid *\nv9fs_create(struct v9fs_session_info *v9ses, struct inode *dir,\n\t\tstruct dentry *dentry, char *extension, u32 perm, u8 mode)\n{\n\tint err;\n\tchar *name;\n\tstruct p9_fid *dfid, *ofid, *fid;\n\tstruct inode *inode;\n\n\tp9_debug(P9_DEBUG_VFS, \"name %pd\\n\", dentry);\n\n\terr = 0;\n\tofid = NULL;\n\tfid = NULL;\n\tname = (char *) dentry->d_name.name;\n\tdfid = v9fs_fid_lookup(dentry->d_parent);\n\tif (IS_ERR(dfid)) {\n\t\terr = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\n\t/* clone a fid to use for creation */\n\tofid = p9_client_walk(dfid, 0, NULL, 1);\n\tif (IS_ERR(ofid)) {\n\t\terr = PTR_ERR(ofid);\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_walk failed %d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = p9_client_fcreate(ofid, name, perm, mode, extension);\n\tif (err < 0) {\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_fcreate failed %d\\n\", err);\n\t\tgoto error;\n\t}\n\n\tif (!(perm & P9_DMLINK)) {\n\t\t/* now walk from the parent so we can get unopened fid */\n\t\tfid = p9_client_walk(dfid, 1, &name, 1);\n\t\tif (IS_ERR(fid)) {\n\t\t\terr = PTR_ERR(fid);\n\t\t\tp9_debug(P9_DEBUG_VFS,\n\t\t\t\t   \"p9_client_walk failed %d\\n\", err);\n\t\t\tfid = NULL;\n\t\t\tgoto error;\n\t\t}\n\t\t/*\n\t\t * instantiate inode and assign the unopened fid to the dentry\n\t\t */\n\t\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tp9_debug(P9_DEBUG_VFS,\n\t\t\t\t   \"inode creation failed %d\\n\", err);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_fid_add(dentry, fid);\n\t\td_instantiate(dentry, inode);\n\t}\n\treturn ofid;\nerror:\n\tif (ofid)\n\t\tp9_client_clunk(ofid);\n\n\tif (fid)\n\t\tp9_client_clunk(fid);\n\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_uflags2omode",
          "args": [
            "flags",
            "v9fs_proto_dotu(v9ses)"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_uflags2omode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "175-204",
          "snippet": "int v9fs_uflags2omode(int uflags, int extended)\n{\n\tint ret;\n\n\tret = 0;\n\tswitch (uflags&3) {\n\tdefault:\n\tcase O_RDONLY:\n\t\tret = P9_OREAD;\n\t\tbreak;\n\n\tcase O_WRONLY:\n\t\tret = P9_OWRITE;\n\t\tbreak;\n\n\tcase O_RDWR:\n\t\tret = P9_ORDWR;\n\t\tbreak;\n\t}\n\n\tif (extended) {\n\t\tif (uflags & O_EXCL)\n\t\t\tret |= P9_OEXCL;\n\n\t\tif (uflags & O_APPEND)\n\t\t\tret |= P9_OAPPEND;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nint v9fs_uflags2omode(int uflags, int extended)\n{\n\tint ret;\n\n\tret = 0;\n\tswitch (uflags&3) {\n\tdefault:\n\tcase O_RDONLY:\n\t\tret = P9_OREAD;\n\t\tbreak;\n\n\tcase O_WRONLY:\n\t\tret = P9_OWRITE;\n\t\tbreak;\n\n\tcase O_RDWR:\n\t\tret = P9_ORDWR;\n\t\tbreak;\n\t}\n\n\tif (extended) {\n\t\tif (uflags & O_EXCL)\n\t\t\tret |= P9_OEXCL;\n\n\t\tif (uflags & O_APPEND)\n\t\t\tret |= P9_OAPPEND;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_proto_dotu",
          "args": [
            "v9ses"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_proto_dotu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "182-185",
          "snippet": "static inline int v9fs_proto_dotu(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000U;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline int v9fs_proto_dotu(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000U;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unixmode2p9mode",
          "args": [
            "v9ses",
            "mode"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "unixmode2p9mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "64-90",
          "snippet": "static u32 unixmode2p9mode(struct v9fs_session_info *v9ses, umode_t mode)\n{\n\tint res;\n\tres = mode & 0777;\n\tif (S_ISDIR(mode))\n\t\tres |= P9_DMDIR;\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tif (v9ses->nodev == 0) {\n\t\t\tif (S_ISSOCK(mode))\n\t\t\t\tres |= P9_DMSOCKET;\n\t\t\tif (S_ISFIFO(mode))\n\t\t\t\tres |= P9_DMNAMEDPIPE;\n\t\t\tif (S_ISBLK(mode))\n\t\t\t\tres |= P9_DMDEVICE;\n\t\t\tif (S_ISCHR(mode))\n\t\t\t\tres |= P9_DMDEVICE;\n\t\t}\n\n\t\tif ((mode & S_ISUID) == S_ISUID)\n\t\t\tres |= P9_DMSETUID;\n\t\tif ((mode & S_ISGID) == S_ISGID)\n\t\t\tres |= P9_DMSETGID;\n\t\tif ((mode & S_ISVTX) == S_ISVTX)\n\t\t\tres |= P9_DMSETVTX;\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic u32 unixmode2p9mode(struct v9fs_session_info *v9ses, umode_t mode)\n{\n\tint res;\n\tres = mode & 0777;\n\tif (S_ISDIR(mode))\n\t\tres |= P9_DMDIR;\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tif (v9ses->nodev == 0) {\n\t\t\tif (S_ISSOCK(mode))\n\t\t\t\tres |= P9_DMSOCKET;\n\t\t\tif (S_ISFIFO(mode))\n\t\t\t\tres |= P9_DMNAMEDPIPE;\n\t\t\tif (S_ISBLK(mode))\n\t\t\t\tres |= P9_DMDEVICE;\n\t\t\tif (S_ISCHR(mode))\n\t\t\t\tres |= P9_DMDEVICE;\n\t\t}\n\n\t\tif ((mode & S_ISUID) == S_ISUID)\n\t\t\tres |= P9_DMSETUID;\n\t\tif ((mode & S_ISGID) == S_ISGID)\n\t\t\tres |= P9_DMSETGID;\n\t\tif ((mode & S_ISVTX) == S_ISVTX)\n\t\t\tres |= P9_DMSETVTX;\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_inode2v9ses",
          "args": [
            "dir"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_inode2v9ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "172-175",
          "snippet": "static inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_no_open",
          "args": [
            "file",
            "res"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "finish_no_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "814-818",
          "snippet": "int finish_no_open(struct file *file, struct dentry *dentry)\n{\n\tfile->f_path.dentry = dentry;\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint finish_no_open(struct file *file, struct dentry *dentry)\n{\n\tfile->f_path.dentry = dentry;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "res"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "res"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_vfs_lookup",
          "args": [
            "dir",
            "dentry",
            "0"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_vfs_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "785-843",
          "snippet": "struct dentry *v9fs_vfs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t      unsigned int flags)\n{\n\tstruct dentry *res;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *dfid, *fid;\n\tstruct inode *inode;\n\tchar *name;\n\n\tp9_debug(P9_DEBUG_VFS, \"dir: %p dentry: (%pd) %p flags: %x\\n\",\n\t\t dir, dentry, dentry, flags);\n\n\tif (dentry->d_name.len > NAME_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\t/* We can walk d_parent because we hold the dir->i_mutex */\n\tdfid = v9fs_fid_lookup(dentry->d_parent);\n\tif (IS_ERR(dfid))\n\t\treturn ERR_CAST(dfid);\n\n\tname = (char *) dentry->d_name.name;\n\tfid = p9_client_walk(dfid, 1, &name, 1);\n\tif (IS_ERR(fid)) {\n\t\tif (fid == ERR_PTR(-ENOENT)) {\n\t\t\td_add(dentry, NULL);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn ERR_CAST(fid);\n\t}\n\t/*\n\t * Make sure we don't use a wrong inode due to parallel\n\t * unlink. For cached mode create calls request for new\n\t * inode. But with cache disabled, lookup should do this.\n\t */\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n\t\tinode = v9fs_get_inode_from_fid(v9ses, fid, dir->i_sb);\n\telse\n\t\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\tif (IS_ERR(inode)) {\n\t\tp9_client_clunk(fid);\n\t\treturn ERR_CAST(inode);\n\t}\n\t/*\n\t * If we had a rename on the server and a parallel lookup\n\t * for the new name, then make sure we instantiate with\n\t * the new name. ie look up for a/b, while on server somebody\n\t * moved b under k and client parallely did a lookup for\n\t * k/b.\n\t */\n\tres = d_splice_alias(inode, dentry);\n\tif (!res)\n\t\tv9fs_fid_add(dentry, fid);\n\telse if (!IS_ERR(res))\n\t\tv9fs_fid_add(res, fid);\n\telse\n\t\tp9_client_clunk(fid);\n\treturn res;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct dentry *v9fs_vfs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t      unsigned int flags)\n{\n\tstruct dentry *res;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *dfid, *fid;\n\tstruct inode *inode;\n\tchar *name;\n\n\tp9_debug(P9_DEBUG_VFS, \"dir: %p dentry: (%pd) %p flags: %x\\n\",\n\t\t dir, dentry, dentry, flags);\n\n\tif (dentry->d_name.len > NAME_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\t/* We can walk d_parent because we hold the dir->i_mutex */\n\tdfid = v9fs_fid_lookup(dentry->d_parent);\n\tif (IS_ERR(dfid))\n\t\treturn ERR_CAST(dfid);\n\n\tname = (char *) dentry->d_name.name;\n\tfid = p9_client_walk(dfid, 1, &name, 1);\n\tif (IS_ERR(fid)) {\n\t\tif (fid == ERR_PTR(-ENOENT)) {\n\t\t\td_add(dentry, NULL);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn ERR_CAST(fid);\n\t}\n\t/*\n\t * Make sure we don't use a wrong inode due to parallel\n\t * unlink. For cached mode create calls request for new\n\t * inode. But with cache disabled, lookup should do this.\n\t */\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n\t\tinode = v9fs_get_inode_from_fid(v9ses, fid, dir->i_sb);\n\telse\n\t\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\tif (IS_ERR(inode)) {\n\t\tp9_client_clunk(fid);\n\t\treturn ERR_CAST(inode);\n\t}\n\t/*\n\t * If we had a rename on the server and a parallel lookup\n\t * for the new name, then make sure we instantiate with\n\t * the new name. ie look up for a/b, while on server somebody\n\t * moved b under k and client parallely did a lookup for\n\t * k/b.\n\t */\n\tres = d_splice_alias(inode, dentry);\n\tif (!res)\n\t\tv9fs_fid_add(dentry, fid);\n\telse if (!IS_ERR(res))\n\t\tv9fs_fid_add(res, fid);\n\telse\n\t\tp9_client_clunk(fid);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int\nv9fs_vfs_atomic_open(struct inode *dir, struct dentry *dentry,\n\t\t     struct file *file, unsigned flags, umode_t mode,\n\t\t     int *opened)\n{\n\tint err;\n\tu32 perm;\n\tstruct v9fs_inode *v9inode;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid, *inode_fid;\n\tstruct dentry *res = NULL;\n\n\tif (d_unhashed(dentry)) {\n\t\tres = v9fs_vfs_lookup(dir, dentry, 0);\n\t\tif (IS_ERR(res))\n\t\t\treturn PTR_ERR(res);\n\n\t\tif (res)\n\t\t\tdentry = res;\n\t}\n\n\t/* Only creates */\n\tif (!(flags & O_CREAT) || dentry->d_inode)\n\t\treturn finish_no_open(file, res);\n\n\terr = 0;\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\tperm = unixmode2p9mode(v9ses, mode);\n\tfid = v9fs_create(v9ses, dir, dentry, NULL, perm,\n\t\t\t\tv9fs_uflags2omode(flags,\n\t\t\t\t\t\tv9fs_proto_dotu(v9ses)));\n\tif (IS_ERR(fid)) {\n\t\terr = PTR_ERR(fid);\n\t\tfid = NULL;\n\t\tgoto error;\n\t}\n\n\tv9fs_invalidate_inode_attr(dir);\n\tv9inode = V9FS_I(dentry->d_inode);\n\tmutex_lock(&v9inode->v_mutex);\n\tif ((v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) &&\n\t    !v9inode->writeback_fid &&\n\t    ((flags & O_ACCMODE) != O_RDONLY)) {\n\t\t/*\n\t\t * clone a fid and add it to writeback_fid\n\t\t * we do it during open time instead of\n\t\t * page dirty time via write_begin/page_mkwrite\n\t\t * because we want write after unlink usecase\n\t\t * to work.\n\t\t */\n\t\tinode_fid = v9fs_writeback_fid(dentry);\n\t\tif (IS_ERR(inode_fid)) {\n\t\t\terr = PTR_ERR(inode_fid);\n\t\t\tmutex_unlock(&v9inode->v_mutex);\n\t\t\tgoto error;\n\t\t}\n\t\tv9inode->writeback_fid = (void *) inode_fid;\n\t}\n\tmutex_unlock(&v9inode->v_mutex);\n\terr = finish_open(file, dentry, generic_file_open, opened);\n\tif (err)\n\t\tgoto error;\n\n\tfile->private_data = fid;\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n\t\tv9fs_cache_inode_set_cookie(dentry->d_inode, file);\n\n\t*opened |= FILE_CREATED;\nout:\n\tdput(res);\n\treturn err;\n\nerror:\n\tif (fid)\n\t\tp9_client_clunk(fid);\n\tgoto out;\n}"
  },
  {
    "function_name": "v9fs_vfs_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "785-843",
    "snippet": "struct dentry *v9fs_vfs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t      unsigned int flags)\n{\n\tstruct dentry *res;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *dfid, *fid;\n\tstruct inode *inode;\n\tchar *name;\n\n\tp9_debug(P9_DEBUG_VFS, \"dir: %p dentry: (%pd) %p flags: %x\\n\",\n\t\t dir, dentry, dentry, flags);\n\n\tif (dentry->d_name.len > NAME_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\t/* We can walk d_parent because we hold the dir->i_mutex */\n\tdfid = v9fs_fid_lookup(dentry->d_parent);\n\tif (IS_ERR(dfid))\n\t\treturn ERR_CAST(dfid);\n\n\tname = (char *) dentry->d_name.name;\n\tfid = p9_client_walk(dfid, 1, &name, 1);\n\tif (IS_ERR(fid)) {\n\t\tif (fid == ERR_PTR(-ENOENT)) {\n\t\t\td_add(dentry, NULL);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn ERR_CAST(fid);\n\t}\n\t/*\n\t * Make sure we don't use a wrong inode due to parallel\n\t * unlink. For cached mode create calls request for new\n\t * inode. But with cache disabled, lookup should do this.\n\t */\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n\t\tinode = v9fs_get_inode_from_fid(v9ses, fid, dir->i_sb);\n\telse\n\t\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\tif (IS_ERR(inode)) {\n\t\tp9_client_clunk(fid);\n\t\treturn ERR_CAST(inode);\n\t}\n\t/*\n\t * If we had a rename on the server and a parallel lookup\n\t * for the new name, then make sure we instantiate with\n\t * the new name. ie look up for a/b, while on server somebody\n\t * moved b under k and client parallely did a lookup for\n\t * k/b.\n\t */\n\tres = d_splice_alias(inode, dentry);\n\tif (!res)\n\t\tv9fs_fid_add(dentry, fid);\n\telse if (!IS_ERR(res))\n\t\tv9fs_fid_add(res, fid);\n\telse\n\t\tp9_client_clunk(fid);\n\treturn res;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p9_client_clunk",
          "args": [
            "fid"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fid_add",
          "args": [
            "res",
            "fid"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "res"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_splice_alias",
          "args": [
            "inode",
            "dentry"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "d_splice_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2741-2792",
          "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_clunk",
          "args": [
            "fid"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_get_new_inode_from_fid",
          "args": [
            "v9ses",
            "fid",
            "dir->i_sb"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_get_new_inode_from_fid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "218-226",
          "snippet": "static inline struct inode *\nv9fs_get_new_inode_from_fid(struct v9fs_session_info *v9ses, struct p9_fid *fid,\n\t\t\t    struct super_block *sb)\n{\n\tif (v9fs_proto_dotl(v9ses))\n\t\treturn v9fs_inode_from_fid_dotl(v9ses, fid, sb, 1);\n\telse\n\t\treturn v9fs_inode_from_fid(v9ses, fid, sb, 1);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct inode *\nv9fs_get_new_inode_from_fid(struct v9fs_session_info *v9ses, struct p9_fid *fid,\n\t\t\t    struct super_block *sb)\n{\n\tif (v9fs_proto_dotl(v9ses))\n\t\treturn v9fs_inode_from_fid_dotl(v9ses, fid, sb, 1);\n\telse\n\t\treturn v9fs_inode_from_fid(v9ses, fid, sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_get_inode_from_fid",
          "args": [
            "v9ses",
            "fid",
            "dir->i_sb"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_get_inode_from_fid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "200-208",
          "snippet": "static inline struct inode *\nv9fs_get_inode_from_fid(struct v9fs_session_info *v9ses, struct p9_fid *fid,\n\t\t\tstruct super_block *sb)\n{\n\tif (v9fs_proto_dotl(v9ses))\n\t\treturn v9fs_inode_from_fid_dotl(v9ses, fid, sb, 0);\n\telse\n\t\treturn v9fs_inode_from_fid(v9ses, fid, sb, 0);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct inode *\nv9fs_get_inode_from_fid(struct v9fs_session_info *v9ses, struct p9_fid *fid,\n\t\t\tstruct super_block *sb)\n{\n\tif (v9fs_proto_dotl(v9ses))\n\t\treturn v9fs_inode_from_fid_dotl(v9ses, fid, sb, 0);\n\telse\n\t\treturn v9fs_inode_from_fid(v9ses, fid, sb, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "fid"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fid"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_walk",
          "args": [
            "dfid",
            "1",
            "&name",
            "1"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "dfid"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dfid"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fid_lookup",
          "args": [
            "dentry->d_parent"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "231-258",
          "snippet": "struct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_inode2v9ses",
          "args": [
            "dir"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_inode2v9ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "172-175",
          "snippet": "static inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"dir: %p dentry: (%pd) %p flags: %x\\n\"",
            "dir",
            "dentry",
            "dentry",
            "flags"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct dentry *v9fs_vfs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t      unsigned int flags)\n{\n\tstruct dentry *res;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *dfid, *fid;\n\tstruct inode *inode;\n\tchar *name;\n\n\tp9_debug(P9_DEBUG_VFS, \"dir: %p dentry: (%pd) %p flags: %x\\n\",\n\t\t dir, dentry, dentry, flags);\n\n\tif (dentry->d_name.len > NAME_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\t/* We can walk d_parent because we hold the dir->i_mutex */\n\tdfid = v9fs_fid_lookup(dentry->d_parent);\n\tif (IS_ERR(dfid))\n\t\treturn ERR_CAST(dfid);\n\n\tname = (char *) dentry->d_name.name;\n\tfid = p9_client_walk(dfid, 1, &name, 1);\n\tif (IS_ERR(fid)) {\n\t\tif (fid == ERR_PTR(-ENOENT)) {\n\t\t\td_add(dentry, NULL);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn ERR_CAST(fid);\n\t}\n\t/*\n\t * Make sure we don't use a wrong inode due to parallel\n\t * unlink. For cached mode create calls request for new\n\t * inode. But with cache disabled, lookup should do this.\n\t */\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n\t\tinode = v9fs_get_inode_from_fid(v9ses, fid, dir->i_sb);\n\telse\n\t\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\tif (IS_ERR(inode)) {\n\t\tp9_client_clunk(fid);\n\t\treturn ERR_CAST(inode);\n\t}\n\t/*\n\t * If we had a rename on the server and a parallel lookup\n\t * for the new name, then make sure we instantiate with\n\t * the new name. ie look up for a/b, while on server somebody\n\t * moved b under k and client parallely did a lookup for\n\t * k/b.\n\t */\n\tres = d_splice_alias(inode, dentry);\n\tif (!res)\n\t\tv9fs_fid_add(dentry, fid);\n\telse if (!IS_ERR(res))\n\t\tv9fs_fid_add(res, fid);\n\telse\n\t\tp9_client_clunk(fid);\n\treturn res;\n}"
  },
  {
    "function_name": "v9fs_vfs_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "751-775",
    "snippet": "static int v9fs_vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint err;\n\tu32 perm;\n\tstruct p9_fid *fid;\n\tstruct v9fs_session_info *v9ses;\n\n\tp9_debug(P9_DEBUG_VFS, \"name %pd\\n\", dentry);\n\terr = 0;\n\tv9ses = v9fs_inode2v9ses(dir);\n\tperm = unixmode2p9mode(v9ses, mode | S_IFDIR);\n\tfid = v9fs_create(v9ses, dir, dentry, NULL, perm, P9_OREAD);\n\tif (IS_ERR(fid)) {\n\t\terr = PTR_ERR(fid);\n\t\tfid = NULL;\n\t} else {\n\t\tinc_nlink(dir);\n\t\tv9fs_invalidate_inode_attr(dir);\n\t}\n\n\tif (fid)\n\t\tp9_client_clunk(fid);\n\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p9_client_clunk",
          "args": [
            "fid"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_invalidate_inode_attr",
          "args": [
            "dir"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_invalidate_inode_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs_vfs.h",
          "lines": "81-87",
          "snippet": "static inline void v9fs_invalidate_inode_attr(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = V9FS_I(inode);\n\tv9inode->cache_validity |= V9FS_INO_INVALID_ATTR;\n\treturn;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void v9fs_invalidate_inode_attr(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = V9FS_I(inode);\n\tv9inode->cache_validity |= V9FS_INO_INVALID_ATTR;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "dir"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fid"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fid"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_create",
          "args": [
            "v9ses",
            "dir",
            "dentry",
            "NULL",
            "perm",
            "P9_OREAD"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "642-710",
          "snippet": "static struct p9_fid *\nv9fs_create(struct v9fs_session_info *v9ses, struct inode *dir,\n\t\tstruct dentry *dentry, char *extension, u32 perm, u8 mode)\n{\n\tint err;\n\tchar *name;\n\tstruct p9_fid *dfid, *ofid, *fid;\n\tstruct inode *inode;\n\n\tp9_debug(P9_DEBUG_VFS, \"name %pd\\n\", dentry);\n\n\terr = 0;\n\tofid = NULL;\n\tfid = NULL;\n\tname = (char *) dentry->d_name.name;\n\tdfid = v9fs_fid_lookup(dentry->d_parent);\n\tif (IS_ERR(dfid)) {\n\t\terr = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\n\t/* clone a fid to use for creation */\n\tofid = p9_client_walk(dfid, 0, NULL, 1);\n\tif (IS_ERR(ofid)) {\n\t\terr = PTR_ERR(ofid);\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_walk failed %d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = p9_client_fcreate(ofid, name, perm, mode, extension);\n\tif (err < 0) {\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_fcreate failed %d\\n\", err);\n\t\tgoto error;\n\t}\n\n\tif (!(perm & P9_DMLINK)) {\n\t\t/* now walk from the parent so we can get unopened fid */\n\t\tfid = p9_client_walk(dfid, 1, &name, 1);\n\t\tif (IS_ERR(fid)) {\n\t\t\terr = PTR_ERR(fid);\n\t\t\tp9_debug(P9_DEBUG_VFS,\n\t\t\t\t   \"p9_client_walk failed %d\\n\", err);\n\t\t\tfid = NULL;\n\t\t\tgoto error;\n\t\t}\n\t\t/*\n\t\t * instantiate inode and assign the unopened fid to the dentry\n\t\t */\n\t\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tp9_debug(P9_DEBUG_VFS,\n\t\t\t\t   \"inode creation failed %d\\n\", err);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_fid_add(dentry, fid);\n\t\td_instantiate(dentry, inode);\n\t}\n\treturn ofid;\nerror:\n\tif (ofid)\n\t\tp9_client_clunk(ofid);\n\n\tif (fid)\n\t\tp9_client_clunk(fid);\n\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic struct p9_fid *\nv9fs_create(struct v9fs_session_info *v9ses, struct inode *dir,\n\t\tstruct dentry *dentry, char *extension, u32 perm, u8 mode)\n{\n\tint err;\n\tchar *name;\n\tstruct p9_fid *dfid, *ofid, *fid;\n\tstruct inode *inode;\n\n\tp9_debug(P9_DEBUG_VFS, \"name %pd\\n\", dentry);\n\n\terr = 0;\n\tofid = NULL;\n\tfid = NULL;\n\tname = (char *) dentry->d_name.name;\n\tdfid = v9fs_fid_lookup(dentry->d_parent);\n\tif (IS_ERR(dfid)) {\n\t\terr = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\n\t/* clone a fid to use for creation */\n\tofid = p9_client_walk(dfid, 0, NULL, 1);\n\tif (IS_ERR(ofid)) {\n\t\terr = PTR_ERR(ofid);\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_walk failed %d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = p9_client_fcreate(ofid, name, perm, mode, extension);\n\tif (err < 0) {\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_fcreate failed %d\\n\", err);\n\t\tgoto error;\n\t}\n\n\tif (!(perm & P9_DMLINK)) {\n\t\t/* now walk from the parent so we can get unopened fid */\n\t\tfid = p9_client_walk(dfid, 1, &name, 1);\n\t\tif (IS_ERR(fid)) {\n\t\t\terr = PTR_ERR(fid);\n\t\t\tp9_debug(P9_DEBUG_VFS,\n\t\t\t\t   \"p9_client_walk failed %d\\n\", err);\n\t\t\tfid = NULL;\n\t\t\tgoto error;\n\t\t}\n\t\t/*\n\t\t * instantiate inode and assign the unopened fid to the dentry\n\t\t */\n\t\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tp9_debug(P9_DEBUG_VFS,\n\t\t\t\t   \"inode creation failed %d\\n\", err);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_fid_add(dentry, fid);\n\t\td_instantiate(dentry, inode);\n\t}\n\treturn ofid;\nerror:\n\tif (ofid)\n\t\tp9_client_clunk(ofid);\n\n\tif (fid)\n\t\tp9_client_clunk(fid);\n\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unixmode2p9mode",
          "args": [
            "v9ses",
            "mode | S_IFDIR"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "unixmode2p9mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "64-90",
          "snippet": "static u32 unixmode2p9mode(struct v9fs_session_info *v9ses, umode_t mode)\n{\n\tint res;\n\tres = mode & 0777;\n\tif (S_ISDIR(mode))\n\t\tres |= P9_DMDIR;\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tif (v9ses->nodev == 0) {\n\t\t\tif (S_ISSOCK(mode))\n\t\t\t\tres |= P9_DMSOCKET;\n\t\t\tif (S_ISFIFO(mode))\n\t\t\t\tres |= P9_DMNAMEDPIPE;\n\t\t\tif (S_ISBLK(mode))\n\t\t\t\tres |= P9_DMDEVICE;\n\t\t\tif (S_ISCHR(mode))\n\t\t\t\tres |= P9_DMDEVICE;\n\t\t}\n\n\t\tif ((mode & S_ISUID) == S_ISUID)\n\t\t\tres |= P9_DMSETUID;\n\t\tif ((mode & S_ISGID) == S_ISGID)\n\t\t\tres |= P9_DMSETGID;\n\t\tif ((mode & S_ISVTX) == S_ISVTX)\n\t\t\tres |= P9_DMSETVTX;\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic u32 unixmode2p9mode(struct v9fs_session_info *v9ses, umode_t mode)\n{\n\tint res;\n\tres = mode & 0777;\n\tif (S_ISDIR(mode))\n\t\tres |= P9_DMDIR;\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tif (v9ses->nodev == 0) {\n\t\t\tif (S_ISSOCK(mode))\n\t\t\t\tres |= P9_DMSOCKET;\n\t\t\tif (S_ISFIFO(mode))\n\t\t\t\tres |= P9_DMNAMEDPIPE;\n\t\t\tif (S_ISBLK(mode))\n\t\t\t\tres |= P9_DMDEVICE;\n\t\t\tif (S_ISCHR(mode))\n\t\t\t\tres |= P9_DMDEVICE;\n\t\t}\n\n\t\tif ((mode & S_ISUID) == S_ISUID)\n\t\t\tres |= P9_DMSETUID;\n\t\tif ((mode & S_ISGID) == S_ISGID)\n\t\t\tres |= P9_DMSETGID;\n\t\tif ((mode & S_ISVTX) == S_ISVTX)\n\t\t\tres |= P9_DMSETVTX;\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_inode2v9ses",
          "args": [
            "dir"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_inode2v9ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "172-175",
          "snippet": "static inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"name %pd\\n\"",
            "dentry"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint err;\n\tu32 perm;\n\tstruct p9_fid *fid;\n\tstruct v9fs_session_info *v9ses;\n\n\tp9_debug(P9_DEBUG_VFS, \"name %pd\\n\", dentry);\n\terr = 0;\n\tv9ses = v9fs_inode2v9ses(dir);\n\tperm = unixmode2p9mode(v9ses, mode | S_IFDIR);\n\tfid = v9fs_create(v9ses, dir, dentry, NULL, perm, P9_OREAD);\n\tif (IS_ERR(fid)) {\n\t\terr = PTR_ERR(fid);\n\t\tfid = NULL;\n\t} else {\n\t\tinc_nlink(dir);\n\t\tv9fs_invalidate_inode_attr(dir);\n\t}\n\n\tif (fid)\n\t\tp9_client_clunk(fid);\n\n\treturn err;\n}"
  },
  {
    "function_name": "v9fs_vfs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "724-741",
    "snippet": "static int\nv9fs_vfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\tbool excl)\n{\n\tstruct v9fs_session_info *v9ses = v9fs_inode2v9ses(dir);\n\tu32 perm = unixmode2p9mode(v9ses, mode);\n\tstruct p9_fid *fid;\n\n\t/* P9_OEXCL? */\n\tfid = v9fs_create(v9ses, dir, dentry, NULL, perm, P9_ORDWR);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\tv9fs_invalidate_inode_attr(dir);\n\tp9_client_clunk(fid);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p9_client_clunk",
          "args": [
            "fid"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_invalidate_inode_attr",
          "args": [
            "dir"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_invalidate_inode_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs_vfs.h",
          "lines": "81-87",
          "snippet": "static inline void v9fs_invalidate_inode_attr(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = V9FS_I(inode);\n\tv9inode->cache_validity |= V9FS_INO_INVALID_ATTR;\n\treturn;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void v9fs_invalidate_inode_attr(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = V9FS_I(inode);\n\tv9inode->cache_validity |= V9FS_INO_INVALID_ATTR;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fid"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fid"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_create",
          "args": [
            "v9ses",
            "dir",
            "dentry",
            "NULL",
            "perm",
            "P9_ORDWR"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "642-710",
          "snippet": "static struct p9_fid *\nv9fs_create(struct v9fs_session_info *v9ses, struct inode *dir,\n\t\tstruct dentry *dentry, char *extension, u32 perm, u8 mode)\n{\n\tint err;\n\tchar *name;\n\tstruct p9_fid *dfid, *ofid, *fid;\n\tstruct inode *inode;\n\n\tp9_debug(P9_DEBUG_VFS, \"name %pd\\n\", dentry);\n\n\terr = 0;\n\tofid = NULL;\n\tfid = NULL;\n\tname = (char *) dentry->d_name.name;\n\tdfid = v9fs_fid_lookup(dentry->d_parent);\n\tif (IS_ERR(dfid)) {\n\t\terr = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\n\t/* clone a fid to use for creation */\n\tofid = p9_client_walk(dfid, 0, NULL, 1);\n\tif (IS_ERR(ofid)) {\n\t\terr = PTR_ERR(ofid);\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_walk failed %d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = p9_client_fcreate(ofid, name, perm, mode, extension);\n\tif (err < 0) {\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_fcreate failed %d\\n\", err);\n\t\tgoto error;\n\t}\n\n\tif (!(perm & P9_DMLINK)) {\n\t\t/* now walk from the parent so we can get unopened fid */\n\t\tfid = p9_client_walk(dfid, 1, &name, 1);\n\t\tif (IS_ERR(fid)) {\n\t\t\terr = PTR_ERR(fid);\n\t\t\tp9_debug(P9_DEBUG_VFS,\n\t\t\t\t   \"p9_client_walk failed %d\\n\", err);\n\t\t\tfid = NULL;\n\t\t\tgoto error;\n\t\t}\n\t\t/*\n\t\t * instantiate inode and assign the unopened fid to the dentry\n\t\t */\n\t\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tp9_debug(P9_DEBUG_VFS,\n\t\t\t\t   \"inode creation failed %d\\n\", err);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_fid_add(dentry, fid);\n\t\td_instantiate(dentry, inode);\n\t}\n\treturn ofid;\nerror:\n\tif (ofid)\n\t\tp9_client_clunk(ofid);\n\n\tif (fid)\n\t\tp9_client_clunk(fid);\n\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic struct p9_fid *\nv9fs_create(struct v9fs_session_info *v9ses, struct inode *dir,\n\t\tstruct dentry *dentry, char *extension, u32 perm, u8 mode)\n{\n\tint err;\n\tchar *name;\n\tstruct p9_fid *dfid, *ofid, *fid;\n\tstruct inode *inode;\n\n\tp9_debug(P9_DEBUG_VFS, \"name %pd\\n\", dentry);\n\n\terr = 0;\n\tofid = NULL;\n\tfid = NULL;\n\tname = (char *) dentry->d_name.name;\n\tdfid = v9fs_fid_lookup(dentry->d_parent);\n\tif (IS_ERR(dfid)) {\n\t\terr = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\n\t/* clone a fid to use for creation */\n\tofid = p9_client_walk(dfid, 0, NULL, 1);\n\tif (IS_ERR(ofid)) {\n\t\terr = PTR_ERR(ofid);\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_walk failed %d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = p9_client_fcreate(ofid, name, perm, mode, extension);\n\tif (err < 0) {\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_fcreate failed %d\\n\", err);\n\t\tgoto error;\n\t}\n\n\tif (!(perm & P9_DMLINK)) {\n\t\t/* now walk from the parent so we can get unopened fid */\n\t\tfid = p9_client_walk(dfid, 1, &name, 1);\n\t\tif (IS_ERR(fid)) {\n\t\t\terr = PTR_ERR(fid);\n\t\t\tp9_debug(P9_DEBUG_VFS,\n\t\t\t\t   \"p9_client_walk failed %d\\n\", err);\n\t\t\tfid = NULL;\n\t\t\tgoto error;\n\t\t}\n\t\t/*\n\t\t * instantiate inode and assign the unopened fid to the dentry\n\t\t */\n\t\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tp9_debug(P9_DEBUG_VFS,\n\t\t\t\t   \"inode creation failed %d\\n\", err);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_fid_add(dentry, fid);\n\t\td_instantiate(dentry, inode);\n\t}\n\treturn ofid;\nerror:\n\tif (ofid)\n\t\tp9_client_clunk(ofid);\n\n\tif (fid)\n\t\tp9_client_clunk(fid);\n\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unixmode2p9mode",
          "args": [
            "v9ses",
            "mode"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "unixmode2p9mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "64-90",
          "snippet": "static u32 unixmode2p9mode(struct v9fs_session_info *v9ses, umode_t mode)\n{\n\tint res;\n\tres = mode & 0777;\n\tif (S_ISDIR(mode))\n\t\tres |= P9_DMDIR;\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tif (v9ses->nodev == 0) {\n\t\t\tif (S_ISSOCK(mode))\n\t\t\t\tres |= P9_DMSOCKET;\n\t\t\tif (S_ISFIFO(mode))\n\t\t\t\tres |= P9_DMNAMEDPIPE;\n\t\t\tif (S_ISBLK(mode))\n\t\t\t\tres |= P9_DMDEVICE;\n\t\t\tif (S_ISCHR(mode))\n\t\t\t\tres |= P9_DMDEVICE;\n\t\t}\n\n\t\tif ((mode & S_ISUID) == S_ISUID)\n\t\t\tres |= P9_DMSETUID;\n\t\tif ((mode & S_ISGID) == S_ISGID)\n\t\t\tres |= P9_DMSETGID;\n\t\tif ((mode & S_ISVTX) == S_ISVTX)\n\t\t\tres |= P9_DMSETVTX;\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic u32 unixmode2p9mode(struct v9fs_session_info *v9ses, umode_t mode)\n{\n\tint res;\n\tres = mode & 0777;\n\tif (S_ISDIR(mode))\n\t\tres |= P9_DMDIR;\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tif (v9ses->nodev == 0) {\n\t\t\tif (S_ISSOCK(mode))\n\t\t\t\tres |= P9_DMSOCKET;\n\t\t\tif (S_ISFIFO(mode))\n\t\t\t\tres |= P9_DMNAMEDPIPE;\n\t\t\tif (S_ISBLK(mode))\n\t\t\t\tres |= P9_DMDEVICE;\n\t\t\tif (S_ISCHR(mode))\n\t\t\t\tres |= P9_DMDEVICE;\n\t\t}\n\n\t\tif ((mode & S_ISUID) == S_ISUID)\n\t\t\tres |= P9_DMSETUID;\n\t\tif ((mode & S_ISGID) == S_ISGID)\n\t\t\tres |= P9_DMSETGID;\n\t\tif ((mode & S_ISVTX) == S_ISVTX)\n\t\t\tres |= P9_DMSETVTX;\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_inode2v9ses",
          "args": [
            "dir"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_inode2v9ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "172-175",
          "snippet": "static inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int\nv9fs_vfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\tbool excl)\n{\n\tstruct v9fs_session_info *v9ses = v9fs_inode2v9ses(dir);\n\tu32 perm = unixmode2p9mode(v9ses, mode);\n\tstruct p9_fid *fid;\n\n\t/* P9_OEXCL? */\n\tfid = v9fs_create(v9ses, dir, dentry, NULL, perm, P9_ORDWR);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\tv9fs_invalidate_inode_attr(dir);\n\tp9_client_clunk(fid);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "v9fs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "642-710",
    "snippet": "static struct p9_fid *\nv9fs_create(struct v9fs_session_info *v9ses, struct inode *dir,\n\t\tstruct dentry *dentry, char *extension, u32 perm, u8 mode)\n{\n\tint err;\n\tchar *name;\n\tstruct p9_fid *dfid, *ofid, *fid;\n\tstruct inode *inode;\n\n\tp9_debug(P9_DEBUG_VFS, \"name %pd\\n\", dentry);\n\n\terr = 0;\n\tofid = NULL;\n\tfid = NULL;\n\tname = (char *) dentry->d_name.name;\n\tdfid = v9fs_fid_lookup(dentry->d_parent);\n\tif (IS_ERR(dfid)) {\n\t\terr = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\n\t/* clone a fid to use for creation */\n\tofid = p9_client_walk(dfid, 0, NULL, 1);\n\tif (IS_ERR(ofid)) {\n\t\terr = PTR_ERR(ofid);\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_walk failed %d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = p9_client_fcreate(ofid, name, perm, mode, extension);\n\tif (err < 0) {\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_fcreate failed %d\\n\", err);\n\t\tgoto error;\n\t}\n\n\tif (!(perm & P9_DMLINK)) {\n\t\t/* now walk from the parent so we can get unopened fid */\n\t\tfid = p9_client_walk(dfid, 1, &name, 1);\n\t\tif (IS_ERR(fid)) {\n\t\t\terr = PTR_ERR(fid);\n\t\t\tp9_debug(P9_DEBUG_VFS,\n\t\t\t\t   \"p9_client_walk failed %d\\n\", err);\n\t\t\tfid = NULL;\n\t\t\tgoto error;\n\t\t}\n\t\t/*\n\t\t * instantiate inode and assign the unopened fid to the dentry\n\t\t */\n\t\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tp9_debug(P9_DEBUG_VFS,\n\t\t\t\t   \"inode creation failed %d\\n\", err);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_fid_add(dentry, fid);\n\t\td_instantiate(dentry, inode);\n\t}\n\treturn ofid;\nerror:\n\tif (ofid)\n\t\tp9_client_clunk(ofid);\n\n\tif (fid)\n\t\tp9_client_clunk(fid);\n\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_clunk",
          "args": [
            "fid"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_clunk",
          "args": [
            "ofid"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_fid_add",
          "args": [
            "dentry",
            "fid"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"inode creation failed %d\\n\"",
            "err"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_get_new_inode_from_fid",
          "args": [
            "v9ses",
            "fid",
            "dir->i_sb"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_get_new_inode_from_fid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "218-226",
          "snippet": "static inline struct inode *\nv9fs_get_new_inode_from_fid(struct v9fs_session_info *v9ses, struct p9_fid *fid,\n\t\t\t    struct super_block *sb)\n{\n\tif (v9fs_proto_dotl(v9ses))\n\t\treturn v9fs_inode_from_fid_dotl(v9ses, fid, sb, 1);\n\telse\n\t\treturn v9fs_inode_from_fid(v9ses, fid, sb, 1);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct inode *\nv9fs_get_new_inode_from_fid(struct v9fs_session_info *v9ses, struct p9_fid *fid,\n\t\t\t    struct super_block *sb)\n{\n\tif (v9fs_proto_dotl(v9ses))\n\t\treturn v9fs_inode_from_fid_dotl(v9ses, fid, sb, 1);\n\telse\n\t\treturn v9fs_inode_from_fid(v9ses, fid, sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"p9_client_walk failed %d\\n\"",
            "err"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fid"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fid"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_walk",
          "args": [
            "dfid",
            "1",
            "&name",
            "1"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"p9_client_fcreate failed %d\\n\"",
            "err"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_fcreate",
          "args": [
            "ofid",
            "name",
            "perm",
            "mode",
            "extension"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"p9_client_walk failed %d\\n\"",
            "err"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ofid"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ofid"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_walk",
          "args": [
            "dfid",
            "0",
            "NULL",
            "1"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"fid lookup failed %d\\n\"",
            "err"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dfid"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dfid"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fid_lookup",
          "args": [
            "dentry->d_parent"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "231-258",
          "snippet": "struct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"name %pd\\n\"",
            "dentry"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic struct p9_fid *\nv9fs_create(struct v9fs_session_info *v9ses, struct inode *dir,\n\t\tstruct dentry *dentry, char *extension, u32 perm, u8 mode)\n{\n\tint err;\n\tchar *name;\n\tstruct p9_fid *dfid, *ofid, *fid;\n\tstruct inode *inode;\n\n\tp9_debug(P9_DEBUG_VFS, \"name %pd\\n\", dentry);\n\n\terr = 0;\n\tofid = NULL;\n\tfid = NULL;\n\tname = (char *) dentry->d_name.name;\n\tdfid = v9fs_fid_lookup(dentry->d_parent);\n\tif (IS_ERR(dfid)) {\n\t\terr = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\n\t/* clone a fid to use for creation */\n\tofid = p9_client_walk(dfid, 0, NULL, 1);\n\tif (IS_ERR(ofid)) {\n\t\terr = PTR_ERR(ofid);\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_walk failed %d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = p9_client_fcreate(ofid, name, perm, mode, extension);\n\tif (err < 0) {\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_fcreate failed %d\\n\", err);\n\t\tgoto error;\n\t}\n\n\tif (!(perm & P9_DMLINK)) {\n\t\t/* now walk from the parent so we can get unopened fid */\n\t\tfid = p9_client_walk(dfid, 1, &name, 1);\n\t\tif (IS_ERR(fid)) {\n\t\t\terr = PTR_ERR(fid);\n\t\t\tp9_debug(P9_DEBUG_VFS,\n\t\t\t\t   \"p9_client_walk failed %d\\n\", err);\n\t\t\tfid = NULL;\n\t\t\tgoto error;\n\t\t}\n\t\t/*\n\t\t * instantiate inode and assign the unopened fid to the dentry\n\t\t */\n\t\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tp9_debug(P9_DEBUG_VFS,\n\t\t\t\t   \"inode creation failed %d\\n\", err);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_fid_add(dentry, fid);\n\t\td_instantiate(dentry, inode);\n\t}\n\treturn ofid;\nerror:\n\tif (ofid)\n\t\tp9_client_clunk(ofid);\n\n\tif (fid)\n\t\tp9_client_clunk(fid);\n\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "v9fs_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "587-630",
    "snippet": "static int v9fs_remove(struct inode *dir, struct dentry *dentry, int flags)\n{\n\tstruct inode *inode;\n\tint retval = -EOPNOTSUPP;\n\tstruct p9_fid *v9fid, *dfid;\n\tstruct v9fs_session_info *v9ses;\n\n\tp9_debug(P9_DEBUG_VFS, \"inode: %p dentry: %p rmdir: %x\\n\",\n\t\t dir, dentry, flags);\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\tinode = dentry->d_inode;\n\tdfid = v9fs_fid_lookup(dentry->d_parent);\n\tif (IS_ERR(dfid)) {\n\t\tretval = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", retval);\n\t\treturn retval;\n\t}\n\tif (v9fs_proto_dotl(v9ses))\n\t\tretval = p9_client_unlinkat(dfid, dentry->d_name.name,\n\t\t\t\t\t    v9fs_at_to_dotl_flags(flags));\n\tif (retval == -EOPNOTSUPP) {\n\t\t/* Try the one based on path */\n\t\tv9fid = v9fs_fid_clone(dentry);\n\t\tif (IS_ERR(v9fid))\n\t\t\treturn PTR_ERR(v9fid);\n\t\tretval = p9_client_remove(v9fid);\n\t}\n\tif (!retval) {\n\t\t/*\n\t\t * directories on unlink should have zero\n\t\t * link count\n\t\t */\n\t\tif (flags & AT_REMOVEDIR) {\n\t\t\tclear_nlink(inode);\n\t\t\tdrop_nlink(dir);\n\t\t} else\n\t\t\tdrop_nlink(inode);\n\n\t\tv9fs_invalidate_inode_attr(inode);\n\t\tv9fs_invalidate_inode_attr(dir);\n\t}\n\treturn retval;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v9fs_invalidate_inode_attr",
          "args": [
            "dir"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_invalidate_inode_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs_vfs.h",
          "lines": "81-87",
          "snippet": "static inline void v9fs_invalidate_inode_attr(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = V9FS_I(inode);\n\tv9inode->cache_validity |= V9FS_INO_INVALID_ATTR;\n\treturn;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void v9fs_invalidate_inode_attr(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = V9FS_I(inode);\n\tv9inode->cache_validity |= V9FS_INO_INVALID_ATTR;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "inode"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_client_remove",
          "args": [
            "v9fid"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "v9fid"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "v9fid"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fid_clone",
          "args": [
            "dentry"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "260-270",
          "snippet": "struct p9_fid *v9fs_fid_clone(struct dentry *dentry)\n{\n\tstruct p9_fid *fid, *ret;\n\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn fid;\n\n\tret = p9_client_walk(fid, 0, NULL, 1);\n\treturn ret;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct p9_fid *v9fs_fid_clone(struct dentry *dentry)\n{\n\tstruct p9_fid *fid, *ret;\n\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn fid;\n\n\tret = p9_client_walk(fid, 0, NULL, 1);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_client_unlinkat",
          "args": [
            "dfid",
            "dentry->d_name.name",
            "v9fs_at_to_dotl_flags(flags)"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_at_to_dotl_flags",
          "args": [
            "flags"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_at_to_dotl_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "571-577",
          "snippet": "static int v9fs_at_to_dotl_flags(int flags)\n{\n\tint rflags = 0;\n\tif (flags & AT_REMOVEDIR)\n\t\trflags |= P9_DOTL_AT_REMOVEDIR;\n\treturn rflags;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_at_to_dotl_flags(int flags)\n{\n\tint rflags = 0;\n\tif (flags & AT_REMOVEDIR)\n\t\trflags |= P9_DOTL_AT_REMOVEDIR;\n\treturn rflags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_proto_dotl",
          "args": [
            "v9ses"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_proto_dotl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "187-190",
          "snippet": "static inline int v9fs_proto_dotl(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000L;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline int v9fs_proto_dotl(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000L;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"fid lookup failed %d\\n\"",
            "retval"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dfid"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dfid"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fid_lookup",
          "args": [
            "dentry->d_parent"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "231-258",
          "snippet": "struct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_inode2v9ses",
          "args": [
            "dir"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_inode2v9ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "172-175",
          "snippet": "static inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"inode: %p dentry: %p rmdir: %x\\n\"",
            "dir",
            "dentry",
            "flags"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_remove(struct inode *dir, struct dentry *dentry, int flags)\n{\n\tstruct inode *inode;\n\tint retval = -EOPNOTSUPP;\n\tstruct p9_fid *v9fid, *dfid;\n\tstruct v9fs_session_info *v9ses;\n\n\tp9_debug(P9_DEBUG_VFS, \"inode: %p dentry: %p rmdir: %x\\n\",\n\t\t dir, dentry, flags);\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\tinode = dentry->d_inode;\n\tdfid = v9fs_fid_lookup(dentry->d_parent);\n\tif (IS_ERR(dfid)) {\n\t\tretval = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", retval);\n\t\treturn retval;\n\t}\n\tif (v9fs_proto_dotl(v9ses))\n\t\tretval = p9_client_unlinkat(dfid, dentry->d_name.name,\n\t\t\t\t\t    v9fs_at_to_dotl_flags(flags));\n\tif (retval == -EOPNOTSUPP) {\n\t\t/* Try the one based on path */\n\t\tv9fid = v9fs_fid_clone(dentry);\n\t\tif (IS_ERR(v9fid))\n\t\t\treturn PTR_ERR(v9fid);\n\t\tretval = p9_client_remove(v9fid);\n\t}\n\tif (!retval) {\n\t\t/*\n\t\t * directories on unlink should have zero\n\t\t * link count\n\t\t */\n\t\tif (flags & AT_REMOVEDIR) {\n\t\t\tclear_nlink(inode);\n\t\t\tdrop_nlink(dir);\n\t\t} else\n\t\t\tdrop_nlink(inode);\n\n\t\tv9fs_invalidate_inode_attr(inode);\n\t\tv9fs_invalidate_inode_attr(dir);\n\t}\n\treturn retval;\n}"
  },
  {
    "function_name": "v9fs_at_to_dotl_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "571-577",
    "snippet": "static int v9fs_at_to_dotl_flags(int flags)\n{\n\tint rflags = 0;\n\tif (flags & AT_REMOVEDIR)\n\t\trflags |= P9_DOTL_AT_REMOVEDIR;\n\treturn rflags;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_at_to_dotl_flags(int flags)\n{\n\tint rflags = 0;\n\tif (flags & AT_REMOVEDIR)\n\t\trflags |= P9_DOTL_AT_REMOVEDIR;\n\treturn rflags;\n}"
  },
  {
    "function_name": "v9fs_inode_from_fid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "549-564",
    "snippet": "struct inode *\nv9fs_inode_from_fid(struct v9fs_session_info *v9ses, struct p9_fid *fid,\n\t\t    struct super_block *sb, int new)\n{\n\tstruct p9_wstat *st;\n\tstruct inode *inode = NULL;\n\n\tst = p9_client_stat(fid);\n\tif (IS_ERR(st))\n\t\treturn ERR_CAST(st);\n\n\tinode = v9fs_qid_iget(sb, &st->qid, st, new);\n\tp9stat_free(st);\n\tkfree(st);\n\treturn inode;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "st"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9stat_free",
          "args": [
            "st"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_qid_iget",
          "args": [
            "sb",
            "&st->qid",
            "st",
            "new"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_qid_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "503-547",
          "snippet": "static struct inode *v9fs_qid_iget(struct super_block *sb,\n\t\t\t\t   struct p9_qid *qid,\n\t\t\t\t   struct p9_wstat *st,\n\t\t\t\t   int new)\n{\n\tdev_t rdev;\n\tint retval;\n\tumode_t umode;\n\tunsigned long i_ino;\n\tstruct inode *inode;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\tint (*test)(struct inode *, void *);\n\n\tif (new)\n\t\ttest = v9fs_test_new_inode;\n\telse\n\t\ttest = v9fs_test_inode;\n\n\ti_ino = v9fs_qid2ino(qid);\n\tinode = iget5_locked(sb, i_ino, test, v9fs_set_inode, st);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\t/*\n\t * initialize the inode with the stat info\n\t * FIXME!! we may need support for stale inodes\n\t * later.\n\t */\n\tinode->i_ino = i_ino;\n\tumode = p9mode2unixmode(v9ses, st, &rdev);\n\tretval = v9fs_init_inode(v9ses, inode, umode, rdev);\n\tif (retval)\n\t\tgoto error;\n\n\tv9fs_stat2inode(st, inode, sb);\n\tv9fs_cache_inode_get_cookie(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\nerror:\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(retval);\n\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic struct inode *v9fs_qid_iget(struct super_block *sb,\n\t\t\t\t   struct p9_qid *qid,\n\t\t\t\t   struct p9_wstat *st,\n\t\t\t\t   int new)\n{\n\tdev_t rdev;\n\tint retval;\n\tumode_t umode;\n\tunsigned long i_ino;\n\tstruct inode *inode;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\tint (*test)(struct inode *, void *);\n\n\tif (new)\n\t\ttest = v9fs_test_new_inode;\n\telse\n\t\ttest = v9fs_test_inode;\n\n\ti_ino = v9fs_qid2ino(qid);\n\tinode = iget5_locked(sb, i_ino, test, v9fs_set_inode, st);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\t/*\n\t * initialize the inode with the stat info\n\t * FIXME!! we may need support for stale inodes\n\t * later.\n\t */\n\tinode->i_ino = i_ino;\n\tumode = p9mode2unixmode(v9ses, st, &rdev);\n\tretval = v9fs_init_inode(v9ses, inode, umode, rdev);\n\tif (retval)\n\t\tgoto error;\n\n\tv9fs_stat2inode(st, inode, sb);\n\tv9fs_cache_inode_get_cookie(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\nerror:\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(retval);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "st"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "st"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_stat",
          "args": [
            "fid"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct inode *\nv9fs_inode_from_fid(struct v9fs_session_info *v9ses, struct p9_fid *fid,\n\t\t    struct super_block *sb, int new)\n{\n\tstruct p9_wstat *st;\n\tstruct inode *inode = NULL;\n\n\tst = p9_client_stat(fid);\n\tif (IS_ERR(st))\n\t\treturn ERR_CAST(st);\n\n\tinode = v9fs_qid_iget(sb, &st->qid, st, new);\n\tp9stat_free(st);\n\tkfree(st);\n\treturn inode;\n}"
  },
  {
    "function_name": "v9fs_qid_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "503-547",
    "snippet": "static struct inode *v9fs_qid_iget(struct super_block *sb,\n\t\t\t\t   struct p9_qid *qid,\n\t\t\t\t   struct p9_wstat *st,\n\t\t\t\t   int new)\n{\n\tdev_t rdev;\n\tint retval;\n\tumode_t umode;\n\tunsigned long i_ino;\n\tstruct inode *inode;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\tint (*test)(struct inode *, void *);\n\n\tif (new)\n\t\ttest = v9fs_test_new_inode;\n\telse\n\t\ttest = v9fs_test_inode;\n\n\ti_ino = v9fs_qid2ino(qid);\n\tinode = iget5_locked(sb, i_ino, test, v9fs_set_inode, st);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\t/*\n\t * initialize the inode with the stat info\n\t * FIXME!! we may need support for stale inodes\n\t * later.\n\t */\n\tinode->i_ino = i_ino;\n\tumode = p9mode2unixmode(v9ses, st, &rdev);\n\tretval = v9fs_init_inode(v9ses, inode, umode, rdev);\n\tif (retval)\n\t\tgoto error;\n\n\tv9fs_stat2inode(st, inode, sb);\n\tv9fs_cache_inode_get_cookie(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\nerror:\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(retval);\n\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "retval"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_cache_inode_get_cookie",
          "args": [
            "inode"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_cache_inode_get_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/cache.c",
          "lines": "192-211",
          "snippet": "void v9fs_cache_inode_get_cookie(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tstruct v9fs_session_info *v9ses;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tv9inode = V9FS_I(inode);\n\tif (v9inode->fscache)\n\t\treturn;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tv9inode->fscache = fscache_acquire_cookie(v9ses->fscache,\n\t\t\t\t\t\t  &v9fs_cache_inode_index_def,\n\t\t\t\t\t\t  v9inode, true);\n\n\tp9_debug(P9_DEBUG_FSC, \"inode %p get cookie %p\\n\",\n\t\t inode, v9inode->fscache);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/jiffies.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct fscache_cookie_def v9fs_cache_inode_index_def = {\n\t.name\t\t= \"9p.inode\",\n\t.type\t\t= FSCACHE_COOKIE_TYPE_DATAFILE,\n\t.get_key\t= v9fs_cache_inode_get_key,\n\t.get_attr\t= v9fs_cache_inode_get_attr,\n\t.get_aux\t= v9fs_cache_inode_get_aux,\n\t.check_aux\t= v9fs_cache_inode_check_aux,\n\t.now_uncached\t= v9fs_cache_inode_now_uncached,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs.h\"\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/jiffies.h>\n\nconst struct fscache_cookie_def v9fs_cache_inode_index_def = {\n\t.name\t\t= \"9p.inode\",\n\t.type\t\t= FSCACHE_COOKIE_TYPE_DATAFILE,\n\t.get_key\t= v9fs_cache_inode_get_key,\n\t.get_attr\t= v9fs_cache_inode_get_attr,\n\t.get_aux\t= v9fs_cache_inode_get_aux,\n\t.check_aux\t= v9fs_cache_inode_check_aux,\n\t.now_uncached\t= v9fs_cache_inode_now_uncached,\n};\n\nvoid v9fs_cache_inode_get_cookie(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tstruct v9fs_session_info *v9ses;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tv9inode = V9FS_I(inode);\n\tif (v9inode->fscache)\n\t\treturn;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tv9inode->fscache = fscache_acquire_cookie(v9ses->fscache,\n\t\t\t\t\t\t  &v9fs_cache_inode_index_def,\n\t\t\t\t\t\t  v9inode, true);\n\n\tp9_debug(P9_DEBUG_FSC, \"inode %p get cookie %p\\n\",\n\t\t inode, v9inode->fscache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_stat2inode",
          "args": [
            "st",
            "inode",
            "sb"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_stat2inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "1156-1204",
          "snippet": "void\nv9fs_stat2inode(struct p9_wstat *stat, struct inode *inode,\n\tstruct super_block *sb)\n{\n\tumode_t mode;\n\tchar ext[32];\n\tchar tag_name[14];\n\tunsigned int i_nlink;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tset_nlink(inode, 1);\n\n\tinode->i_atime.tv_sec = stat->atime;\n\tinode->i_mtime.tv_sec = stat->mtime;\n\tinode->i_ctime.tv_sec = stat->mtime;\n\n\tinode->i_uid = v9ses->dfltuid;\n\tinode->i_gid = v9ses->dfltgid;\n\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tinode->i_uid = stat->n_uid;\n\t\tinode->i_gid = stat->n_gid;\n\t}\n\tif ((S_ISREG(inode->i_mode)) || (S_ISDIR(inode->i_mode))) {\n\t\tif (v9fs_proto_dotu(v9ses) && (stat->extension[0] != '\\0')) {\n\t\t\t/*\n\t\t\t * Hadlink support got added later to\n\t\t\t * to the .u extension. So there can be\n\t\t\t * server out there that doesn't support\n\t\t\t * this even with .u extension. So check\n\t\t\t * for non NULL stat->extension\n\t\t\t */\n\t\t\tstrlcpy(ext, stat->extension, sizeof(ext));\n\t\t\t/* HARDLINKCOUNT %u */\n\t\t\tsscanf(ext, \"%13s %u\", tag_name, &i_nlink);\n\t\t\tif (!strncmp(tag_name, \"HARDLINKCOUNT\", 13))\n\t\t\t\tset_nlink(inode, i_nlink);\n\t\t}\n\t}\n\tmode = p9mode2perm(v9ses, stat);\n\tmode |= inode->i_mode & ~S_IALLUGO;\n\tinode->i_mode = mode;\n\ti_size_write(inode, stat->length);\n\n\t/* not real number of blocks, but 512 byte ones ... */\n\tinode->i_blocks = (i_size_read(inode) + 512 - 1) >> 9;\n\tv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid\nv9fs_stat2inode(struct p9_wstat *stat, struct inode *inode,\n\tstruct super_block *sb)\n{\n\tumode_t mode;\n\tchar ext[32];\n\tchar tag_name[14];\n\tunsigned int i_nlink;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tset_nlink(inode, 1);\n\n\tinode->i_atime.tv_sec = stat->atime;\n\tinode->i_mtime.tv_sec = stat->mtime;\n\tinode->i_ctime.tv_sec = stat->mtime;\n\n\tinode->i_uid = v9ses->dfltuid;\n\tinode->i_gid = v9ses->dfltgid;\n\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tinode->i_uid = stat->n_uid;\n\t\tinode->i_gid = stat->n_gid;\n\t}\n\tif ((S_ISREG(inode->i_mode)) || (S_ISDIR(inode->i_mode))) {\n\t\tif (v9fs_proto_dotu(v9ses) && (stat->extension[0] != '\\0')) {\n\t\t\t/*\n\t\t\t * Hadlink support got added later to\n\t\t\t * to the .u extension. So there can be\n\t\t\t * server out there that doesn't support\n\t\t\t * this even with .u extension. So check\n\t\t\t * for non NULL stat->extension\n\t\t\t */\n\t\t\tstrlcpy(ext, stat->extension, sizeof(ext));\n\t\t\t/* HARDLINKCOUNT %u */\n\t\t\tsscanf(ext, \"%13s %u\", tag_name, &i_nlink);\n\t\t\tif (!strncmp(tag_name, \"HARDLINKCOUNT\", 13))\n\t\t\t\tset_nlink(inode, i_nlink);\n\t\t}\n\t}\n\tmode = p9mode2perm(v9ses, stat);\n\tmode |= inode->i_mode & ~S_IALLUGO;\n\tinode->i_mode = mode;\n\ti_size_write(inode, stat->length);\n\n\t/* not real number of blocks, but 512 byte ones ... */\n\tinode->i_blocks = (i_size_read(inode) + 512 - 1) >> 9;\n\tv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_init_inode",
          "args": [
            "v9ses",
            "inode",
            "umode",
            "rdev"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_init_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "271-361",
          "snippet": "int v9fs_init_inode(struct v9fs_session_info *v9ses,\n\t\t    struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tint err = 0;\n\n\tinode_init_owner(inode, NULL, mode);\n\tinode->i_blocks = 0;\n\tinode->i_rdev = rdev;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_mapping->a_ops = &v9fs_addr_operations;\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFSOCK:\n\t\tif (v9fs_proto_dotl(v9ses)) {\n\t\t\tinode->i_op = &v9fs_file_inode_operations_dotl;\n\t\t} else if (v9fs_proto_dotu(v9ses)) {\n\t\t\tinode->i_op = &v9fs_file_inode_operations;\n\t\t} else {\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t \"special files without extended mode\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tcase S_IFREG:\n\t\tif (v9fs_proto_dotl(v9ses)) {\n\t\t\tinode->i_op = &v9fs_file_inode_operations_dotl;\n\t\t\tif (v9ses->cache == CACHE_LOOSE ||\n\t\t\t    v9ses->cache == CACHE_FSCACHE)\n\t\t\t\tinode->i_fop =\n\t\t\t\t\t&v9fs_cached_file_operations_dotl;\n\t\t\telse if (v9ses->cache == CACHE_MMAP)\n\t\t\t\tinode->i_fop = &v9fs_mmap_file_operations_dotl;\n\t\t\telse\n\t\t\t\tinode->i_fop = &v9fs_file_operations_dotl;\n\t\t} else {\n\t\t\tinode->i_op = &v9fs_file_inode_operations;\n\t\t\tif (v9ses->cache == CACHE_LOOSE ||\n\t\t\t    v9ses->cache == CACHE_FSCACHE)\n\t\t\t\tinode->i_fop =\n\t\t\t\t\t&v9fs_cached_file_operations;\n\t\t\telse if (v9ses->cache == CACHE_MMAP)\n\t\t\t\tinode->i_fop = &v9fs_mmap_file_operations;\n\t\t\telse\n\t\t\t\tinode->i_fop = &v9fs_file_operations;\n\t\t}\n\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tif (!v9fs_proto_dotu(v9ses) && !v9fs_proto_dotl(v9ses)) {\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t \"extended modes used with legacy protocol\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (v9fs_proto_dotl(v9ses))\n\t\t\tinode->i_op = &v9fs_symlink_inode_operations_dotl;\n\t\telse\n\t\t\tinode->i_op = &v9fs_symlink_inode_operations;\n\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinc_nlink(inode);\n\t\tif (v9fs_proto_dotl(v9ses))\n\t\t\tinode->i_op = &v9fs_dir_inode_operations_dotl;\n\t\telse if (v9fs_proto_dotu(v9ses))\n\t\t\tinode->i_op = &v9fs_dir_inode_operations_dotu;\n\t\telse\n\t\t\tinode->i_op = &v9fs_dir_inode_operations;\n\n\t\tif (v9fs_proto_dotl(v9ses))\n\t\t\tinode->i_fop = &v9fs_dir_operations_dotl;\n\t\telse\n\t\t\tinode->i_fop = &v9fs_dir_operations;\n\n\t\tbreak;\n\tdefault:\n\t\tp9_debug(P9_DEBUG_ERROR, \"BAD mode 0x%hx S_IFMT 0x%x\\n\",\n\t\t\t mode, mode & S_IFMT);\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\nerror:\n\treturn err;\n\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations v9fs_dir_inode_operations;",
            "static const struct inode_operations v9fs_dir_inode_operations_dotu;",
            "static const struct inode_operations v9fs_file_inode_operations;",
            "static const struct inode_operations v9fs_symlink_inode_operations;",
            "static const struct inode_operations v9fs_dir_inode_operations_dotu = {\n\t.create = v9fs_vfs_create,\n\t.lookup = v9fs_vfs_lookup,\n\t.atomic_open = v9fs_vfs_atomic_open,\n\t.symlink = v9fs_vfs_symlink,\n\t.link = v9fs_vfs_link,\n\t.unlink = v9fs_vfs_unlink,\n\t.mkdir = v9fs_vfs_mkdir,\n\t.rmdir = v9fs_vfs_rmdir,\n\t.mknod = v9fs_vfs_mknod,\n\t.rename = v9fs_vfs_rename,\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};",
            "static const struct inode_operations v9fs_dir_inode_operations = {\n\t.create = v9fs_vfs_create,\n\t.lookup = v9fs_vfs_lookup,\n\t.atomic_open = v9fs_vfs_atomic_open,\n\t.unlink = v9fs_vfs_unlink,\n\t.mkdir = v9fs_vfs_mkdir,\n\t.rmdir = v9fs_vfs_rmdir,\n\t.mknod = v9fs_vfs_mknod,\n\t.rename = v9fs_vfs_rename,\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};",
            "static const struct inode_operations v9fs_file_inode_operations = {\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};",
            "static const struct inode_operations v9fs_symlink_inode_operations = {\n\t.readlink = generic_readlink,\n\t.follow_link = v9fs_vfs_follow_link,\n\t.put_link = v9fs_vfs_put_link,\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic const struct inode_operations v9fs_dir_inode_operations;\nstatic const struct inode_operations v9fs_dir_inode_operations_dotu;\nstatic const struct inode_operations v9fs_file_inode_operations;\nstatic const struct inode_operations v9fs_symlink_inode_operations;\nstatic const struct inode_operations v9fs_dir_inode_operations_dotu = {\n\t.create = v9fs_vfs_create,\n\t.lookup = v9fs_vfs_lookup,\n\t.atomic_open = v9fs_vfs_atomic_open,\n\t.symlink = v9fs_vfs_symlink,\n\t.link = v9fs_vfs_link,\n\t.unlink = v9fs_vfs_unlink,\n\t.mkdir = v9fs_vfs_mkdir,\n\t.rmdir = v9fs_vfs_rmdir,\n\t.mknod = v9fs_vfs_mknod,\n\t.rename = v9fs_vfs_rename,\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};\nstatic const struct inode_operations v9fs_dir_inode_operations = {\n\t.create = v9fs_vfs_create,\n\t.lookup = v9fs_vfs_lookup,\n\t.atomic_open = v9fs_vfs_atomic_open,\n\t.unlink = v9fs_vfs_unlink,\n\t.mkdir = v9fs_vfs_mkdir,\n\t.rmdir = v9fs_vfs_rmdir,\n\t.mknod = v9fs_vfs_mknod,\n\t.rename = v9fs_vfs_rename,\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};\nstatic const struct inode_operations v9fs_file_inode_operations = {\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};\nstatic const struct inode_operations v9fs_symlink_inode_operations = {\n\t.readlink = generic_readlink,\n\t.follow_link = v9fs_vfs_follow_link,\n\t.put_link = v9fs_vfs_put_link,\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};\n\nint v9fs_init_inode(struct v9fs_session_info *v9ses,\n\t\t    struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tint err = 0;\n\n\tinode_init_owner(inode, NULL, mode);\n\tinode->i_blocks = 0;\n\tinode->i_rdev = rdev;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_mapping->a_ops = &v9fs_addr_operations;\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFSOCK:\n\t\tif (v9fs_proto_dotl(v9ses)) {\n\t\t\tinode->i_op = &v9fs_file_inode_operations_dotl;\n\t\t} else if (v9fs_proto_dotu(v9ses)) {\n\t\t\tinode->i_op = &v9fs_file_inode_operations;\n\t\t} else {\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t \"special files without extended mode\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tcase S_IFREG:\n\t\tif (v9fs_proto_dotl(v9ses)) {\n\t\t\tinode->i_op = &v9fs_file_inode_operations_dotl;\n\t\t\tif (v9ses->cache == CACHE_LOOSE ||\n\t\t\t    v9ses->cache == CACHE_FSCACHE)\n\t\t\t\tinode->i_fop =\n\t\t\t\t\t&v9fs_cached_file_operations_dotl;\n\t\t\telse if (v9ses->cache == CACHE_MMAP)\n\t\t\t\tinode->i_fop = &v9fs_mmap_file_operations_dotl;\n\t\t\telse\n\t\t\t\tinode->i_fop = &v9fs_file_operations_dotl;\n\t\t} else {\n\t\t\tinode->i_op = &v9fs_file_inode_operations;\n\t\t\tif (v9ses->cache == CACHE_LOOSE ||\n\t\t\t    v9ses->cache == CACHE_FSCACHE)\n\t\t\t\tinode->i_fop =\n\t\t\t\t\t&v9fs_cached_file_operations;\n\t\t\telse if (v9ses->cache == CACHE_MMAP)\n\t\t\t\tinode->i_fop = &v9fs_mmap_file_operations;\n\t\t\telse\n\t\t\t\tinode->i_fop = &v9fs_file_operations;\n\t\t}\n\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tif (!v9fs_proto_dotu(v9ses) && !v9fs_proto_dotl(v9ses)) {\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t \"extended modes used with legacy protocol\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (v9fs_proto_dotl(v9ses))\n\t\t\tinode->i_op = &v9fs_symlink_inode_operations_dotl;\n\t\telse\n\t\t\tinode->i_op = &v9fs_symlink_inode_operations;\n\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinc_nlink(inode);\n\t\tif (v9fs_proto_dotl(v9ses))\n\t\t\tinode->i_op = &v9fs_dir_inode_operations_dotl;\n\t\telse if (v9fs_proto_dotu(v9ses))\n\t\t\tinode->i_op = &v9fs_dir_inode_operations_dotu;\n\t\telse\n\t\t\tinode->i_op = &v9fs_dir_inode_operations;\n\n\t\tif (v9fs_proto_dotl(v9ses))\n\t\t\tinode->i_fop = &v9fs_dir_operations_dotl;\n\t\telse\n\t\t\tinode->i_fop = &v9fs_dir_operations;\n\n\t\tbreak;\n\tdefault:\n\t\tp9_debug(P9_DEBUG_ERROR, \"BAD mode 0x%hx S_IFMT 0x%x\\n\",\n\t\t\t mode, mode & S_IFMT);\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\nerror:\n\treturn err;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9mode2unixmode",
          "args": [
            "v9ses",
            "st",
            "&rdev"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "p9mode2unixmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "125-167",
          "snippet": "static umode_t p9mode2unixmode(struct v9fs_session_info *v9ses,\n\t\t\t       struct p9_wstat *stat, dev_t *rdev)\n{\n\tint res;\n\tu32 mode = stat->mode;\n\n\t*rdev = 0;\n\tres = p9mode2perm(v9ses, stat);\n\n\tif ((mode & P9_DMDIR) == P9_DMDIR)\n\t\tres |= S_IFDIR;\n\telse if ((mode & P9_DMSYMLINK) && (v9fs_proto_dotu(v9ses)))\n\t\tres |= S_IFLNK;\n\telse if ((mode & P9_DMSOCKET) && (v9fs_proto_dotu(v9ses))\n\t\t && (v9ses->nodev == 0))\n\t\tres |= S_IFSOCK;\n\telse if ((mode & P9_DMNAMEDPIPE) && (v9fs_proto_dotu(v9ses))\n\t\t && (v9ses->nodev == 0))\n\t\tres |= S_IFIFO;\n\telse if ((mode & P9_DMDEVICE) && (v9fs_proto_dotu(v9ses))\n\t\t && (v9ses->nodev == 0)) {\n\t\tchar type = 0, ext[32];\n\t\tint major = -1, minor = -1;\n\n\t\tstrlcpy(ext, stat->extension, sizeof(ext));\n\t\tsscanf(ext, \"%c %i %i\", &type, &major, &minor);\n\t\tswitch (type) {\n\t\tcase 'c':\n\t\t\tres |= S_IFCHR;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tres |= S_IFBLK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp9_debug(P9_DEBUG_ERROR, \"Unknown special type %c %s\\n\",\n\t\t\t\t type, stat->extension);\n\t\t};\n\t\t*rdev = MKDEV(major, minor);\n\t} else\n\t\tres |= S_IFREG;\n\n\treturn res;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic umode_t p9mode2unixmode(struct v9fs_session_info *v9ses,\n\t\t\t       struct p9_wstat *stat, dev_t *rdev)\n{\n\tint res;\n\tu32 mode = stat->mode;\n\n\t*rdev = 0;\n\tres = p9mode2perm(v9ses, stat);\n\n\tif ((mode & P9_DMDIR) == P9_DMDIR)\n\t\tres |= S_IFDIR;\n\telse if ((mode & P9_DMSYMLINK) && (v9fs_proto_dotu(v9ses)))\n\t\tres |= S_IFLNK;\n\telse if ((mode & P9_DMSOCKET) && (v9fs_proto_dotu(v9ses))\n\t\t && (v9ses->nodev == 0))\n\t\tres |= S_IFSOCK;\n\telse if ((mode & P9_DMNAMEDPIPE) && (v9fs_proto_dotu(v9ses))\n\t\t && (v9ses->nodev == 0))\n\t\tres |= S_IFIFO;\n\telse if ((mode & P9_DMDEVICE) && (v9fs_proto_dotu(v9ses))\n\t\t && (v9ses->nodev == 0)) {\n\t\tchar type = 0, ext[32];\n\t\tint major = -1, minor = -1;\n\n\t\tstrlcpy(ext, stat->extension, sizeof(ext));\n\t\tsscanf(ext, \"%c %i %i\", &type, &major, &minor);\n\t\tswitch (type) {\n\t\tcase 'c':\n\t\t\tres |= S_IFCHR;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tres |= S_IFBLK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp9_debug(P9_DEBUG_ERROR, \"Unknown special type %c %s\\n\",\n\t\t\t\t type, stat->extension);\n\t\t};\n\t\t*rdev = MKDEV(major, minor);\n\t} else\n\t\tres |= S_IFREG;\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget5_locked",
          "args": [
            "sb",
            "i_ino",
            "test",
            "v9fs_set_inode",
            "st"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "iget5_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "991-1047",
          "snippet": "struct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_qid2ino",
          "args": [
            "qid"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_qid2ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "1213-1224",
          "snippet": "ino_t v9fs_qid2ino(struct p9_qid *qid)\n{\n\tu64 path = qid->path + 2;\n\tino_t i = 0;\n\n\tif (sizeof(ino_t) == sizeof(path))\n\t\tmemcpy(&i, &path, sizeof(ino_t));\n\telse\n\t\ti = (ino_t) (path ^ (path >> 32));\n\n\treturn i;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nino_t v9fs_qid2ino(struct p9_qid *qid)\n{\n\tu64 path = qid->path + 2;\n\tino_t i = 0;\n\n\tif (sizeof(ino_t) == sizeof(path))\n\t\tmemcpy(&i, &path, sizeof(ino_t));\n\telse\n\t\ti = (ino_t) (path ^ (path >> 32));\n\n\treturn i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic struct inode *v9fs_qid_iget(struct super_block *sb,\n\t\t\t\t   struct p9_qid *qid,\n\t\t\t\t   struct p9_wstat *st,\n\t\t\t\t   int new)\n{\n\tdev_t rdev;\n\tint retval;\n\tumode_t umode;\n\tunsigned long i_ino;\n\tstruct inode *inode;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\tint (*test)(struct inode *, void *);\n\n\tif (new)\n\t\ttest = v9fs_test_new_inode;\n\telse\n\t\ttest = v9fs_test_inode;\n\n\ti_ino = v9fs_qid2ino(qid);\n\tinode = iget5_locked(sb, i_ino, test, v9fs_set_inode, st);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\t/*\n\t * initialize the inode with the stat info\n\t * FIXME!! we may need support for stale inodes\n\t * later.\n\t */\n\tinode->i_ino = i_ino;\n\tumode = p9mode2unixmode(v9ses, st, &rdev);\n\tretval = v9fs_init_inode(v9ses, inode, umode, rdev);\n\tif (retval)\n\t\tgoto error;\n\n\tv9fs_stat2inode(st, inode, sb);\n\tv9fs_cache_inode_get_cookie(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\nerror:\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(retval);\n\n}"
  },
  {
    "function_name": "v9fs_set_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "494-501",
    "snippet": "static int v9fs_set_inode(struct inode *inode,  void *data)\n{\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\tstruct p9_wstat *st = (struct p9_wstat *)data;\n\n\tmemcpy(&v9inode->qid, &st->qid, sizeof(st->qid));\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&v9inode->qid",
            "&st->qid",
            "sizeof(st->qid)"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "V9FS_I",
          "args": [
            "inode"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "V9FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "137-140",
          "snippet": "static inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_set_inode(struct inode *inode,  void *data)\n{\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\tstruct p9_wstat *st = (struct p9_wstat *)data;\n\n\tmemcpy(&v9inode->qid, &st->qid, sizeof(st->qid));\n\treturn 0;\n}"
  },
  {
    "function_name": "v9fs_test_new_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "489-492",
    "snippet": "static int v9fs_test_new_inode(struct inode *inode, void *data)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_test_new_inode(struct inode *inode, void *data)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "v9fs_test_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "466-487",
    "snippet": "static int v9fs_test_inode(struct inode *inode, void *data)\n{\n\tint umode;\n\tdev_t rdev;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\tstruct p9_wstat *st = (struct p9_wstat *)data;\n\tstruct v9fs_session_info *v9ses = v9fs_inode2v9ses(inode);\n\n\tumode = p9mode2unixmode(v9ses, st, &rdev);\n\t/* don't match inode of different type */\n\tif ((inode->i_mode & S_IFMT) != (umode & S_IFMT))\n\t\treturn 0;\n\n\t/* compare qid details */\n\tif (memcmp(&v9inode->qid.version,\n\t\t   &st->qid.version, sizeof(v9inode->qid.version)))\n\t\treturn 0;\n\n\tif (v9inode->qid.type != st->qid.type)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&v9inode->qid.version",
            "&st->qid.version",
            "sizeof(v9inode->qid.version)"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9mode2unixmode",
          "args": [
            "v9ses",
            "st",
            "&rdev"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "p9mode2unixmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "125-167",
          "snippet": "static umode_t p9mode2unixmode(struct v9fs_session_info *v9ses,\n\t\t\t       struct p9_wstat *stat, dev_t *rdev)\n{\n\tint res;\n\tu32 mode = stat->mode;\n\n\t*rdev = 0;\n\tres = p9mode2perm(v9ses, stat);\n\n\tif ((mode & P9_DMDIR) == P9_DMDIR)\n\t\tres |= S_IFDIR;\n\telse if ((mode & P9_DMSYMLINK) && (v9fs_proto_dotu(v9ses)))\n\t\tres |= S_IFLNK;\n\telse if ((mode & P9_DMSOCKET) && (v9fs_proto_dotu(v9ses))\n\t\t && (v9ses->nodev == 0))\n\t\tres |= S_IFSOCK;\n\telse if ((mode & P9_DMNAMEDPIPE) && (v9fs_proto_dotu(v9ses))\n\t\t && (v9ses->nodev == 0))\n\t\tres |= S_IFIFO;\n\telse if ((mode & P9_DMDEVICE) && (v9fs_proto_dotu(v9ses))\n\t\t && (v9ses->nodev == 0)) {\n\t\tchar type = 0, ext[32];\n\t\tint major = -1, minor = -1;\n\n\t\tstrlcpy(ext, stat->extension, sizeof(ext));\n\t\tsscanf(ext, \"%c %i %i\", &type, &major, &minor);\n\t\tswitch (type) {\n\t\tcase 'c':\n\t\t\tres |= S_IFCHR;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tres |= S_IFBLK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp9_debug(P9_DEBUG_ERROR, \"Unknown special type %c %s\\n\",\n\t\t\t\t type, stat->extension);\n\t\t};\n\t\t*rdev = MKDEV(major, minor);\n\t} else\n\t\tres |= S_IFREG;\n\n\treturn res;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic umode_t p9mode2unixmode(struct v9fs_session_info *v9ses,\n\t\t\t       struct p9_wstat *stat, dev_t *rdev)\n{\n\tint res;\n\tu32 mode = stat->mode;\n\n\t*rdev = 0;\n\tres = p9mode2perm(v9ses, stat);\n\n\tif ((mode & P9_DMDIR) == P9_DMDIR)\n\t\tres |= S_IFDIR;\n\telse if ((mode & P9_DMSYMLINK) && (v9fs_proto_dotu(v9ses)))\n\t\tres |= S_IFLNK;\n\telse if ((mode & P9_DMSOCKET) && (v9fs_proto_dotu(v9ses))\n\t\t && (v9ses->nodev == 0))\n\t\tres |= S_IFSOCK;\n\telse if ((mode & P9_DMNAMEDPIPE) && (v9fs_proto_dotu(v9ses))\n\t\t && (v9ses->nodev == 0))\n\t\tres |= S_IFIFO;\n\telse if ((mode & P9_DMDEVICE) && (v9fs_proto_dotu(v9ses))\n\t\t && (v9ses->nodev == 0)) {\n\t\tchar type = 0, ext[32];\n\t\tint major = -1, minor = -1;\n\n\t\tstrlcpy(ext, stat->extension, sizeof(ext));\n\t\tsscanf(ext, \"%c %i %i\", &type, &major, &minor);\n\t\tswitch (type) {\n\t\tcase 'c':\n\t\t\tres |= S_IFCHR;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tres |= S_IFBLK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp9_debug(P9_DEBUG_ERROR, \"Unknown special type %c %s\\n\",\n\t\t\t\t type, stat->extension);\n\t\t};\n\t\t*rdev = MKDEV(major, minor);\n\t} else\n\t\tres |= S_IFREG;\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_inode2v9ses",
          "args": [
            "inode"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_inode2v9ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "172-175",
          "snippet": "static inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "V9FS_I",
          "args": [
            "inode"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "V9FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "137-140",
          "snippet": "static inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_test_inode(struct inode *inode, void *data)\n{\n\tint umode;\n\tdev_t rdev;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\tstruct p9_wstat *st = (struct p9_wstat *)data;\n\tstruct v9fs_session_info *v9ses = v9fs_inode2v9ses(inode);\n\n\tumode = p9mode2unixmode(v9ses, st, &rdev);\n\t/* don't match inode of different type */\n\tif ((inode->i_mode & S_IFMT) != (umode & S_IFMT))\n\t\treturn 0;\n\n\t/* compare qid details */\n\tif (memcmp(&v9inode->qid.version,\n\t\t   &st->qid.version, sizeof(v9inode->qid.version)))\n\t\treturn 0;\n\n\tif (v9inode->qid.type != st->qid.type)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "v9fs_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "450-464",
    "snippet": "void v9fs_evict_inode(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\ttruncate_inode_pages_final(inode->i_mapping);\n\tclear_inode(inode);\n\tfilemap_fdatawrite(inode->i_mapping);\n\n\tv9fs_cache_inode_put_cookie(inode);\n\t/* clunk the fid stashed in writeback_fid */\n\tif (v9inode->writeback_fid) {\n\t\tp9_client_clunk(v9inode->writeback_fid);\n\t\tv9inode->writeback_fid = NULL;\n\t}\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p9_client_clunk",
          "args": [
            "v9inode->writeback_fid"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_cache_inode_put_cookie",
          "args": [
            "inode"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_cache_inode_put_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/cache.c",
          "lines": "213-224",
          "snippet": "void v9fs_cache_inode_put_cookie(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tif (!v9inode->fscache)\n\t\treturn;\n\tp9_debug(P9_DEBUG_FSC, \"inode %p put cookie %p\\n\",\n\t\t inode, v9inode->fscache);\n\n\tfscache_relinquish_cookie(v9inode->fscache, 0);\n\tv9inode->fscache = NULL;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/jiffies.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs.h\"\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/jiffies.h>\n\nvoid v9fs_cache_inode_put_cookie(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tif (!v9inode->fscache)\n\t\treturn;\n\tp9_debug(P9_DEBUG_FSC, \"inode %p put cookie %p\\n\",\n\t\t inode, v9inode->fscache);\n\n\tfscache_relinquish_cookie(v9inode->fscache, 0);\n\tv9inode->fscache = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_fdatawrite",
          "args": [
            "inode->i_mapping"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "inode->i_mapping"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "V9FS_I",
          "args": [
            "inode"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "V9FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "137-140",
          "snippet": "static inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_evict_inode(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\ttruncate_inode_pages_final(inode->i_mapping);\n\tclear_inode(inode);\n\tfilemap_fdatawrite(inode->i_mapping);\n\n\tv9fs_cache_inode_put_cookie(inode);\n\t/* clunk the fid stashed in writeback_fid */\n\tif (v9inode->writeback_fid) {\n\t\tp9_client_clunk(v9inode->writeback_fid);\n\t\tv9inode->writeback_fid = NULL;\n\t}\n}"
  },
  {
    "function_name": "v9fs_get_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "370-390",
    "snippet": "struct inode *v9fs_get_inode(struct super_block *sb, umode_t mode, dev_t rdev)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\n\tp9_debug(P9_DEBUG_VFS, \"super block: %p mode: %ho\\n\", sb, mode);\n\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tpr_warn(\"%s (%d): Problem allocating inode\\n\",\n\t\t\t__func__, task_pid_nr(current));\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\terr = v9fs_init_inode(v9ses, inode, mode, rdev);\n\tif (err) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn inode;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_init_inode",
          "args": [
            "v9ses",
            "inode",
            "mode",
            "rdev"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_init_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "271-361",
          "snippet": "int v9fs_init_inode(struct v9fs_session_info *v9ses,\n\t\t    struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tint err = 0;\n\n\tinode_init_owner(inode, NULL, mode);\n\tinode->i_blocks = 0;\n\tinode->i_rdev = rdev;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_mapping->a_ops = &v9fs_addr_operations;\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFSOCK:\n\t\tif (v9fs_proto_dotl(v9ses)) {\n\t\t\tinode->i_op = &v9fs_file_inode_operations_dotl;\n\t\t} else if (v9fs_proto_dotu(v9ses)) {\n\t\t\tinode->i_op = &v9fs_file_inode_operations;\n\t\t} else {\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t \"special files without extended mode\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tcase S_IFREG:\n\t\tif (v9fs_proto_dotl(v9ses)) {\n\t\t\tinode->i_op = &v9fs_file_inode_operations_dotl;\n\t\t\tif (v9ses->cache == CACHE_LOOSE ||\n\t\t\t    v9ses->cache == CACHE_FSCACHE)\n\t\t\t\tinode->i_fop =\n\t\t\t\t\t&v9fs_cached_file_operations_dotl;\n\t\t\telse if (v9ses->cache == CACHE_MMAP)\n\t\t\t\tinode->i_fop = &v9fs_mmap_file_operations_dotl;\n\t\t\telse\n\t\t\t\tinode->i_fop = &v9fs_file_operations_dotl;\n\t\t} else {\n\t\t\tinode->i_op = &v9fs_file_inode_operations;\n\t\t\tif (v9ses->cache == CACHE_LOOSE ||\n\t\t\t    v9ses->cache == CACHE_FSCACHE)\n\t\t\t\tinode->i_fop =\n\t\t\t\t\t&v9fs_cached_file_operations;\n\t\t\telse if (v9ses->cache == CACHE_MMAP)\n\t\t\t\tinode->i_fop = &v9fs_mmap_file_operations;\n\t\t\telse\n\t\t\t\tinode->i_fop = &v9fs_file_operations;\n\t\t}\n\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tif (!v9fs_proto_dotu(v9ses) && !v9fs_proto_dotl(v9ses)) {\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t \"extended modes used with legacy protocol\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (v9fs_proto_dotl(v9ses))\n\t\t\tinode->i_op = &v9fs_symlink_inode_operations_dotl;\n\t\telse\n\t\t\tinode->i_op = &v9fs_symlink_inode_operations;\n\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinc_nlink(inode);\n\t\tif (v9fs_proto_dotl(v9ses))\n\t\t\tinode->i_op = &v9fs_dir_inode_operations_dotl;\n\t\telse if (v9fs_proto_dotu(v9ses))\n\t\t\tinode->i_op = &v9fs_dir_inode_operations_dotu;\n\t\telse\n\t\t\tinode->i_op = &v9fs_dir_inode_operations;\n\n\t\tif (v9fs_proto_dotl(v9ses))\n\t\t\tinode->i_fop = &v9fs_dir_operations_dotl;\n\t\telse\n\t\t\tinode->i_fop = &v9fs_dir_operations;\n\n\t\tbreak;\n\tdefault:\n\t\tp9_debug(P9_DEBUG_ERROR, \"BAD mode 0x%hx S_IFMT 0x%x\\n\",\n\t\t\t mode, mode & S_IFMT);\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\nerror:\n\treturn err;\n\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations v9fs_dir_inode_operations;",
            "static const struct inode_operations v9fs_dir_inode_operations_dotu;",
            "static const struct inode_operations v9fs_file_inode_operations;",
            "static const struct inode_operations v9fs_symlink_inode_operations;",
            "static const struct inode_operations v9fs_dir_inode_operations_dotu = {\n\t.create = v9fs_vfs_create,\n\t.lookup = v9fs_vfs_lookup,\n\t.atomic_open = v9fs_vfs_atomic_open,\n\t.symlink = v9fs_vfs_symlink,\n\t.link = v9fs_vfs_link,\n\t.unlink = v9fs_vfs_unlink,\n\t.mkdir = v9fs_vfs_mkdir,\n\t.rmdir = v9fs_vfs_rmdir,\n\t.mknod = v9fs_vfs_mknod,\n\t.rename = v9fs_vfs_rename,\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};",
            "static const struct inode_operations v9fs_dir_inode_operations = {\n\t.create = v9fs_vfs_create,\n\t.lookup = v9fs_vfs_lookup,\n\t.atomic_open = v9fs_vfs_atomic_open,\n\t.unlink = v9fs_vfs_unlink,\n\t.mkdir = v9fs_vfs_mkdir,\n\t.rmdir = v9fs_vfs_rmdir,\n\t.mknod = v9fs_vfs_mknod,\n\t.rename = v9fs_vfs_rename,\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};",
            "static const struct inode_operations v9fs_file_inode_operations = {\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};",
            "static const struct inode_operations v9fs_symlink_inode_operations = {\n\t.readlink = generic_readlink,\n\t.follow_link = v9fs_vfs_follow_link,\n\t.put_link = v9fs_vfs_put_link,\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic const struct inode_operations v9fs_dir_inode_operations;\nstatic const struct inode_operations v9fs_dir_inode_operations_dotu;\nstatic const struct inode_operations v9fs_file_inode_operations;\nstatic const struct inode_operations v9fs_symlink_inode_operations;\nstatic const struct inode_operations v9fs_dir_inode_operations_dotu = {\n\t.create = v9fs_vfs_create,\n\t.lookup = v9fs_vfs_lookup,\n\t.atomic_open = v9fs_vfs_atomic_open,\n\t.symlink = v9fs_vfs_symlink,\n\t.link = v9fs_vfs_link,\n\t.unlink = v9fs_vfs_unlink,\n\t.mkdir = v9fs_vfs_mkdir,\n\t.rmdir = v9fs_vfs_rmdir,\n\t.mknod = v9fs_vfs_mknod,\n\t.rename = v9fs_vfs_rename,\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};\nstatic const struct inode_operations v9fs_dir_inode_operations = {\n\t.create = v9fs_vfs_create,\n\t.lookup = v9fs_vfs_lookup,\n\t.atomic_open = v9fs_vfs_atomic_open,\n\t.unlink = v9fs_vfs_unlink,\n\t.mkdir = v9fs_vfs_mkdir,\n\t.rmdir = v9fs_vfs_rmdir,\n\t.mknod = v9fs_vfs_mknod,\n\t.rename = v9fs_vfs_rename,\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};\nstatic const struct inode_operations v9fs_file_inode_operations = {\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};\nstatic const struct inode_operations v9fs_symlink_inode_operations = {\n\t.readlink = generic_readlink,\n\t.follow_link = v9fs_vfs_follow_link,\n\t.put_link = v9fs_vfs_put_link,\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};\n\nint v9fs_init_inode(struct v9fs_session_info *v9ses,\n\t\t    struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tint err = 0;\n\n\tinode_init_owner(inode, NULL, mode);\n\tinode->i_blocks = 0;\n\tinode->i_rdev = rdev;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_mapping->a_ops = &v9fs_addr_operations;\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFSOCK:\n\t\tif (v9fs_proto_dotl(v9ses)) {\n\t\t\tinode->i_op = &v9fs_file_inode_operations_dotl;\n\t\t} else if (v9fs_proto_dotu(v9ses)) {\n\t\t\tinode->i_op = &v9fs_file_inode_operations;\n\t\t} else {\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t \"special files without extended mode\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tcase S_IFREG:\n\t\tif (v9fs_proto_dotl(v9ses)) {\n\t\t\tinode->i_op = &v9fs_file_inode_operations_dotl;\n\t\t\tif (v9ses->cache == CACHE_LOOSE ||\n\t\t\t    v9ses->cache == CACHE_FSCACHE)\n\t\t\t\tinode->i_fop =\n\t\t\t\t\t&v9fs_cached_file_operations_dotl;\n\t\t\telse if (v9ses->cache == CACHE_MMAP)\n\t\t\t\tinode->i_fop = &v9fs_mmap_file_operations_dotl;\n\t\t\telse\n\t\t\t\tinode->i_fop = &v9fs_file_operations_dotl;\n\t\t} else {\n\t\t\tinode->i_op = &v9fs_file_inode_operations;\n\t\t\tif (v9ses->cache == CACHE_LOOSE ||\n\t\t\t    v9ses->cache == CACHE_FSCACHE)\n\t\t\t\tinode->i_fop =\n\t\t\t\t\t&v9fs_cached_file_operations;\n\t\t\telse if (v9ses->cache == CACHE_MMAP)\n\t\t\t\tinode->i_fop = &v9fs_mmap_file_operations;\n\t\t\telse\n\t\t\t\tinode->i_fop = &v9fs_file_operations;\n\t\t}\n\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tif (!v9fs_proto_dotu(v9ses) && !v9fs_proto_dotl(v9ses)) {\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t \"extended modes used with legacy protocol\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (v9fs_proto_dotl(v9ses))\n\t\t\tinode->i_op = &v9fs_symlink_inode_operations_dotl;\n\t\telse\n\t\t\tinode->i_op = &v9fs_symlink_inode_operations;\n\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinc_nlink(inode);\n\t\tif (v9fs_proto_dotl(v9ses))\n\t\t\tinode->i_op = &v9fs_dir_inode_operations_dotl;\n\t\telse if (v9fs_proto_dotu(v9ses))\n\t\t\tinode->i_op = &v9fs_dir_inode_operations_dotu;\n\t\telse\n\t\t\tinode->i_op = &v9fs_dir_inode_operations;\n\n\t\tif (v9fs_proto_dotl(v9ses))\n\t\t\tinode->i_fop = &v9fs_dir_operations_dotl;\n\t\telse\n\t\t\tinode->i_fop = &v9fs_dir_operations;\n\n\t\tbreak;\n\tdefault:\n\t\tp9_debug(P9_DEBUG_ERROR, \"BAD mode 0x%hx S_IFMT 0x%x\\n\",\n\t\t\t mode, mode & S_IFMT);\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\nerror:\n\treturn err;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s (%d): Problem allocating inode\\n\"",
            "__func__",
            "task_pid_nr(current)"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"super block: %p mode: %ho\\n\"",
            "sb",
            "mode"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct inode *v9fs_get_inode(struct super_block *sb, umode_t mode, dev_t rdev)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\n\tp9_debug(P9_DEBUG_VFS, \"super block: %p mode: %ho\\n\", sb, mode);\n\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tpr_warn(\"%s (%d): Problem allocating inode\\n\",\n\t\t\t__func__, task_pid_nr(current));\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\terr = v9fs_init_inode(v9ses, inode, mode, rdev);\n\tif (err) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn inode;\n}"
  },
  {
    "function_name": "v9fs_init_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "271-361",
    "snippet": "int v9fs_init_inode(struct v9fs_session_info *v9ses,\n\t\t    struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tint err = 0;\n\n\tinode_init_owner(inode, NULL, mode);\n\tinode->i_blocks = 0;\n\tinode->i_rdev = rdev;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_mapping->a_ops = &v9fs_addr_operations;\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFSOCK:\n\t\tif (v9fs_proto_dotl(v9ses)) {\n\t\t\tinode->i_op = &v9fs_file_inode_operations_dotl;\n\t\t} else if (v9fs_proto_dotu(v9ses)) {\n\t\t\tinode->i_op = &v9fs_file_inode_operations;\n\t\t} else {\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t \"special files without extended mode\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tcase S_IFREG:\n\t\tif (v9fs_proto_dotl(v9ses)) {\n\t\t\tinode->i_op = &v9fs_file_inode_operations_dotl;\n\t\t\tif (v9ses->cache == CACHE_LOOSE ||\n\t\t\t    v9ses->cache == CACHE_FSCACHE)\n\t\t\t\tinode->i_fop =\n\t\t\t\t\t&v9fs_cached_file_operations_dotl;\n\t\t\telse if (v9ses->cache == CACHE_MMAP)\n\t\t\t\tinode->i_fop = &v9fs_mmap_file_operations_dotl;\n\t\t\telse\n\t\t\t\tinode->i_fop = &v9fs_file_operations_dotl;\n\t\t} else {\n\t\t\tinode->i_op = &v9fs_file_inode_operations;\n\t\t\tif (v9ses->cache == CACHE_LOOSE ||\n\t\t\t    v9ses->cache == CACHE_FSCACHE)\n\t\t\t\tinode->i_fop =\n\t\t\t\t\t&v9fs_cached_file_operations;\n\t\t\telse if (v9ses->cache == CACHE_MMAP)\n\t\t\t\tinode->i_fop = &v9fs_mmap_file_operations;\n\t\t\telse\n\t\t\t\tinode->i_fop = &v9fs_file_operations;\n\t\t}\n\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tif (!v9fs_proto_dotu(v9ses) && !v9fs_proto_dotl(v9ses)) {\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t \"extended modes used with legacy protocol\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (v9fs_proto_dotl(v9ses))\n\t\t\tinode->i_op = &v9fs_symlink_inode_operations_dotl;\n\t\telse\n\t\t\tinode->i_op = &v9fs_symlink_inode_operations;\n\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinc_nlink(inode);\n\t\tif (v9fs_proto_dotl(v9ses))\n\t\t\tinode->i_op = &v9fs_dir_inode_operations_dotl;\n\t\telse if (v9fs_proto_dotu(v9ses))\n\t\t\tinode->i_op = &v9fs_dir_inode_operations_dotu;\n\t\telse\n\t\t\tinode->i_op = &v9fs_dir_inode_operations;\n\n\t\tif (v9fs_proto_dotl(v9ses))\n\t\t\tinode->i_fop = &v9fs_dir_operations_dotl;\n\t\telse\n\t\t\tinode->i_fop = &v9fs_dir_operations;\n\n\t\tbreak;\n\tdefault:\n\t\tp9_debug(P9_DEBUG_ERROR, \"BAD mode 0x%hx S_IFMT 0x%x\\n\",\n\t\t\t mode, mode & S_IFMT);\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\nerror:\n\treturn err;\n\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct inode_operations v9fs_dir_inode_operations;",
      "static const struct inode_operations v9fs_dir_inode_operations_dotu;",
      "static const struct inode_operations v9fs_file_inode_operations;",
      "static const struct inode_operations v9fs_symlink_inode_operations;",
      "static const struct inode_operations v9fs_dir_inode_operations_dotu = {\n\t.create = v9fs_vfs_create,\n\t.lookup = v9fs_vfs_lookup,\n\t.atomic_open = v9fs_vfs_atomic_open,\n\t.symlink = v9fs_vfs_symlink,\n\t.link = v9fs_vfs_link,\n\t.unlink = v9fs_vfs_unlink,\n\t.mkdir = v9fs_vfs_mkdir,\n\t.rmdir = v9fs_vfs_rmdir,\n\t.mknod = v9fs_vfs_mknod,\n\t.rename = v9fs_vfs_rename,\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};",
      "static const struct inode_operations v9fs_dir_inode_operations = {\n\t.create = v9fs_vfs_create,\n\t.lookup = v9fs_vfs_lookup,\n\t.atomic_open = v9fs_vfs_atomic_open,\n\t.unlink = v9fs_vfs_unlink,\n\t.mkdir = v9fs_vfs_mkdir,\n\t.rmdir = v9fs_vfs_rmdir,\n\t.mknod = v9fs_vfs_mknod,\n\t.rename = v9fs_vfs_rename,\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};",
      "static const struct inode_operations v9fs_file_inode_operations = {\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};",
      "static const struct inode_operations v9fs_symlink_inode_operations = {\n\t.readlink = generic_readlink,\n\t.follow_link = v9fs_vfs_follow_link,\n\t.put_link = v9fs_vfs_put_link,\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_ERROR",
            "\"BAD mode 0x%hx S_IFMT 0x%x\\n\"",
            "mode",
            "mode & S_IFMT"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_proto_dotl",
          "args": [
            "v9ses"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_proto_dotl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "187-190",
          "snippet": "static inline int v9fs_proto_dotl(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000L;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline int v9fs_proto_dotl(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000L;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_proto_dotu",
          "args": [
            "v9ses"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_proto_dotu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "182-185",
          "snippet": "static inline int v9fs_proto_dotu(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000U;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline int v9fs_proto_dotu(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000U;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_ERROR",
            "\"extended modes used with legacy protocol\\n\""
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "inode->i_rdev"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_ERROR",
            "\"special files without extended mode\\n\""
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_init_owner",
          "args": [
            "inode",
            "NULL",
            "mode"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1880-1891",
          "snippet": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic const struct inode_operations v9fs_dir_inode_operations;\nstatic const struct inode_operations v9fs_dir_inode_operations_dotu;\nstatic const struct inode_operations v9fs_file_inode_operations;\nstatic const struct inode_operations v9fs_symlink_inode_operations;\nstatic const struct inode_operations v9fs_dir_inode_operations_dotu = {\n\t.create = v9fs_vfs_create,\n\t.lookup = v9fs_vfs_lookup,\n\t.atomic_open = v9fs_vfs_atomic_open,\n\t.symlink = v9fs_vfs_symlink,\n\t.link = v9fs_vfs_link,\n\t.unlink = v9fs_vfs_unlink,\n\t.mkdir = v9fs_vfs_mkdir,\n\t.rmdir = v9fs_vfs_rmdir,\n\t.mknod = v9fs_vfs_mknod,\n\t.rename = v9fs_vfs_rename,\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};\nstatic const struct inode_operations v9fs_dir_inode_operations = {\n\t.create = v9fs_vfs_create,\n\t.lookup = v9fs_vfs_lookup,\n\t.atomic_open = v9fs_vfs_atomic_open,\n\t.unlink = v9fs_vfs_unlink,\n\t.mkdir = v9fs_vfs_mkdir,\n\t.rmdir = v9fs_vfs_rmdir,\n\t.mknod = v9fs_vfs_mknod,\n\t.rename = v9fs_vfs_rename,\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};\nstatic const struct inode_operations v9fs_file_inode_operations = {\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};\nstatic const struct inode_operations v9fs_symlink_inode_operations = {\n\t.readlink = generic_readlink,\n\t.follow_link = v9fs_vfs_follow_link,\n\t.put_link = v9fs_vfs_put_link,\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};\n\nint v9fs_init_inode(struct v9fs_session_info *v9ses,\n\t\t    struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tint err = 0;\n\n\tinode_init_owner(inode, NULL, mode);\n\tinode->i_blocks = 0;\n\tinode->i_rdev = rdev;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_mapping->a_ops = &v9fs_addr_operations;\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFSOCK:\n\t\tif (v9fs_proto_dotl(v9ses)) {\n\t\t\tinode->i_op = &v9fs_file_inode_operations_dotl;\n\t\t} else if (v9fs_proto_dotu(v9ses)) {\n\t\t\tinode->i_op = &v9fs_file_inode_operations;\n\t\t} else {\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t \"special files without extended mode\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tcase S_IFREG:\n\t\tif (v9fs_proto_dotl(v9ses)) {\n\t\t\tinode->i_op = &v9fs_file_inode_operations_dotl;\n\t\t\tif (v9ses->cache == CACHE_LOOSE ||\n\t\t\t    v9ses->cache == CACHE_FSCACHE)\n\t\t\t\tinode->i_fop =\n\t\t\t\t\t&v9fs_cached_file_operations_dotl;\n\t\t\telse if (v9ses->cache == CACHE_MMAP)\n\t\t\t\tinode->i_fop = &v9fs_mmap_file_operations_dotl;\n\t\t\telse\n\t\t\t\tinode->i_fop = &v9fs_file_operations_dotl;\n\t\t} else {\n\t\t\tinode->i_op = &v9fs_file_inode_operations;\n\t\t\tif (v9ses->cache == CACHE_LOOSE ||\n\t\t\t    v9ses->cache == CACHE_FSCACHE)\n\t\t\t\tinode->i_fop =\n\t\t\t\t\t&v9fs_cached_file_operations;\n\t\t\telse if (v9ses->cache == CACHE_MMAP)\n\t\t\t\tinode->i_fop = &v9fs_mmap_file_operations;\n\t\t\telse\n\t\t\t\tinode->i_fop = &v9fs_file_operations;\n\t\t}\n\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tif (!v9fs_proto_dotu(v9ses) && !v9fs_proto_dotl(v9ses)) {\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t \"extended modes used with legacy protocol\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (v9fs_proto_dotl(v9ses))\n\t\t\tinode->i_op = &v9fs_symlink_inode_operations_dotl;\n\t\telse\n\t\t\tinode->i_op = &v9fs_symlink_inode_operations;\n\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinc_nlink(inode);\n\t\tif (v9fs_proto_dotl(v9ses))\n\t\t\tinode->i_op = &v9fs_dir_inode_operations_dotl;\n\t\telse if (v9fs_proto_dotu(v9ses))\n\t\t\tinode->i_op = &v9fs_dir_inode_operations_dotu;\n\t\telse\n\t\t\tinode->i_op = &v9fs_dir_inode_operations;\n\n\t\tif (v9fs_proto_dotl(v9ses))\n\t\t\tinode->i_fop = &v9fs_dir_operations_dotl;\n\t\telse\n\t\t\tinode->i_fop = &v9fs_dir_operations;\n\n\t\tbreak;\n\tdefault:\n\t\tp9_debug(P9_DEBUG_ERROR, \"BAD mode 0x%hx S_IFMT 0x%x\\n\",\n\t\t\t mode, mode & S_IFMT);\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\nerror:\n\treturn err;\n\n}"
  },
  {
    "function_name": "v9fs_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "266-269",
    "snippet": "void v9fs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, v9fs_i_callback);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "v9fs_i_callback"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, v9fs_i_callback);\n}"
  },
  {
    "function_name": "v9fs_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "260-264",
    "snippet": "static void v9fs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(v9fs_inode_cache, V9FS_I(inode));\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "v9fs_inode_cache",
            "V9FS_I(inode)"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "V9FS_I",
          "args": [
            "inode"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "V9FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "137-140",
          "snippet": "static inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic void v9fs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(v9fs_inode_cache, V9FS_I(inode));\n}"
  },
  {
    "function_name": "v9fs_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "238-253",
    "snippet": "struct inode *v9fs_alloc_inode(struct super_block *sb)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = (struct v9fs_inode *)kmem_cache_alloc(v9fs_inode_cache,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (!v9inode)\n\t\treturn NULL;\n#ifdef CONFIG_9P_FSCACHE\n\tv9inode->fscache = NULL;\n\tspin_lock_init(&v9inode->fscache_lock);\n#endif\n\tv9inode->writeback_fid = NULL;\n\tv9inode->cache_validity = 0;\n\tmutex_init(&v9inode->v_mutex);\n\treturn &v9inode->vfs_inode;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&v9inode->v_mutex"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&v9inode->fscache_lock"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "v9fs_inode_cache",
            "GFP_KERNEL"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct inode *v9fs_alloc_inode(struct super_block *sb)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = (struct v9fs_inode *)kmem_cache_alloc(v9fs_inode_cache,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (!v9inode)\n\t\treturn NULL;\n#ifdef CONFIG_9P_FSCACHE\n\tv9inode->fscache = NULL;\n\tspin_lock_init(&v9inode->fscache_lock);\n#endif\n\tv9inode->writeback_fid = NULL;\n\tv9inode->cache_validity = 0;\n\tmutex_init(&v9inode->v_mutex);\n\treturn &v9inode->vfs_inode;\n}"
  },
  {
    "function_name": "v9fs_blank_wstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "212-232",
    "snippet": "void\nv9fs_blank_wstat(struct p9_wstat *wstat)\n{\n\twstat->type = ~0;\n\twstat->dev = ~0;\n\twstat->qid.type = ~0;\n\twstat->qid.version = ~0;\n\t*((long long *)&wstat->qid.path) = ~0;\n\twstat->mode = ~0;\n\twstat->atime = ~0;\n\twstat->mtime = ~0;\n\twstat->length = ~0;\n\twstat->name = NULL;\n\twstat->uid = NULL;\n\twstat->gid = NULL;\n\twstat->muid = NULL;\n\twstat->n_uid = INVALID_UID;\n\twstat->n_gid = INVALID_GID;\n\twstat->n_muid = INVALID_UID;\n\twstat->extension = NULL;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid\nv9fs_blank_wstat(struct p9_wstat *wstat)\n{\n\twstat->type = ~0;\n\twstat->dev = ~0;\n\twstat->qid.type = ~0;\n\twstat->qid.version = ~0;\n\t*((long long *)&wstat->qid.path) = ~0;\n\twstat->mode = ~0;\n\twstat->atime = ~0;\n\twstat->mtime = ~0;\n\twstat->length = ~0;\n\twstat->name = NULL;\n\twstat->uid = NULL;\n\twstat->gid = NULL;\n\twstat->muid = NULL;\n\twstat->n_uid = INVALID_UID;\n\twstat->n_gid = INVALID_GID;\n\twstat->n_muid = INVALID_UID;\n\twstat->extension = NULL;\n}"
  },
  {
    "function_name": "v9fs_uflags2omode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "175-204",
    "snippet": "int v9fs_uflags2omode(int uflags, int extended)\n{\n\tint ret;\n\n\tret = 0;\n\tswitch (uflags&3) {\n\tdefault:\n\tcase O_RDONLY:\n\t\tret = P9_OREAD;\n\t\tbreak;\n\n\tcase O_WRONLY:\n\t\tret = P9_OWRITE;\n\t\tbreak;\n\n\tcase O_RDWR:\n\t\tret = P9_ORDWR;\n\t\tbreak;\n\t}\n\n\tif (extended) {\n\t\tif (uflags & O_EXCL)\n\t\t\tret |= P9_OEXCL;\n\n\t\tif (uflags & O_APPEND)\n\t\t\tret |= P9_OAPPEND;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nint v9fs_uflags2omode(int uflags, int extended)\n{\n\tint ret;\n\n\tret = 0;\n\tswitch (uflags&3) {\n\tdefault:\n\tcase O_RDONLY:\n\t\tret = P9_OREAD;\n\t\tbreak;\n\n\tcase O_WRONLY:\n\t\tret = P9_OWRITE;\n\t\tbreak;\n\n\tcase O_RDWR:\n\t\tret = P9_ORDWR;\n\t\tbreak;\n\t}\n\n\tif (extended) {\n\t\tif (uflags & O_EXCL)\n\t\t\tret |= P9_OEXCL;\n\n\t\tif (uflags & O_APPEND)\n\t\t\tret |= P9_OAPPEND;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "p9mode2unixmode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "125-167",
    "snippet": "static umode_t p9mode2unixmode(struct v9fs_session_info *v9ses,\n\t\t\t       struct p9_wstat *stat, dev_t *rdev)\n{\n\tint res;\n\tu32 mode = stat->mode;\n\n\t*rdev = 0;\n\tres = p9mode2perm(v9ses, stat);\n\n\tif ((mode & P9_DMDIR) == P9_DMDIR)\n\t\tres |= S_IFDIR;\n\telse if ((mode & P9_DMSYMLINK) && (v9fs_proto_dotu(v9ses)))\n\t\tres |= S_IFLNK;\n\telse if ((mode & P9_DMSOCKET) && (v9fs_proto_dotu(v9ses))\n\t\t && (v9ses->nodev == 0))\n\t\tres |= S_IFSOCK;\n\telse if ((mode & P9_DMNAMEDPIPE) && (v9fs_proto_dotu(v9ses))\n\t\t && (v9ses->nodev == 0))\n\t\tres |= S_IFIFO;\n\telse if ((mode & P9_DMDEVICE) && (v9fs_proto_dotu(v9ses))\n\t\t && (v9ses->nodev == 0)) {\n\t\tchar type = 0, ext[32];\n\t\tint major = -1, minor = -1;\n\n\t\tstrlcpy(ext, stat->extension, sizeof(ext));\n\t\tsscanf(ext, \"%c %i %i\", &type, &major, &minor);\n\t\tswitch (type) {\n\t\tcase 'c':\n\t\t\tres |= S_IFCHR;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tres |= S_IFBLK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp9_debug(P9_DEBUG_ERROR, \"Unknown special type %c %s\\n\",\n\t\t\t\t type, stat->extension);\n\t\t};\n\t\t*rdev = MKDEV(major, minor);\n\t} else\n\t\tres |= S_IFREG;\n\n\treturn res;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "major",
            "minor"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_ERROR",
            "\"Unknown special type %c %s\\n\"",
            "type",
            "stat->extension"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ext",
            "\"%c %i %i\"",
            "&type",
            "&major",
            "&minor"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "ext",
            "stat->extension",
            "sizeof(ext)"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_proto_dotu",
          "args": [
            "v9ses"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_proto_dotu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "182-185",
          "snippet": "static inline int v9fs_proto_dotu(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000U;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline int v9fs_proto_dotu(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000U;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9mode2perm",
          "args": [
            "v9ses",
            "stat"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "p9mode2perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "98-116",
          "snippet": "static int p9mode2perm(struct v9fs_session_info *v9ses,\n\t\t       struct p9_wstat *stat)\n{\n\tint res;\n\tint mode = stat->mode;\n\n\tres = mode & S_IALLUGO;\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tif ((mode & P9_DMSETUID) == P9_DMSETUID)\n\t\t\tres |= S_ISUID;\n\n\t\tif ((mode & P9_DMSETGID) == P9_DMSETGID)\n\t\t\tres |= S_ISGID;\n\n\t\tif ((mode & P9_DMSETVTX) == P9_DMSETVTX)\n\t\t\tres |= S_ISVTX;\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int p9mode2perm(struct v9fs_session_info *v9ses,\n\t\t       struct p9_wstat *stat)\n{\n\tint res;\n\tint mode = stat->mode;\n\n\tres = mode & S_IALLUGO;\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tif ((mode & P9_DMSETUID) == P9_DMSETUID)\n\t\t\tres |= S_ISUID;\n\n\t\tif ((mode & P9_DMSETGID) == P9_DMSETGID)\n\t\t\tres |= S_ISGID;\n\n\t\tif ((mode & P9_DMSETVTX) == P9_DMSETVTX)\n\t\t\tres |= S_ISVTX;\n\t}\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic umode_t p9mode2unixmode(struct v9fs_session_info *v9ses,\n\t\t\t       struct p9_wstat *stat, dev_t *rdev)\n{\n\tint res;\n\tu32 mode = stat->mode;\n\n\t*rdev = 0;\n\tres = p9mode2perm(v9ses, stat);\n\n\tif ((mode & P9_DMDIR) == P9_DMDIR)\n\t\tres |= S_IFDIR;\n\telse if ((mode & P9_DMSYMLINK) && (v9fs_proto_dotu(v9ses)))\n\t\tres |= S_IFLNK;\n\telse if ((mode & P9_DMSOCKET) && (v9fs_proto_dotu(v9ses))\n\t\t && (v9ses->nodev == 0))\n\t\tres |= S_IFSOCK;\n\telse if ((mode & P9_DMNAMEDPIPE) && (v9fs_proto_dotu(v9ses))\n\t\t && (v9ses->nodev == 0))\n\t\tres |= S_IFIFO;\n\telse if ((mode & P9_DMDEVICE) && (v9fs_proto_dotu(v9ses))\n\t\t && (v9ses->nodev == 0)) {\n\t\tchar type = 0, ext[32];\n\t\tint major = -1, minor = -1;\n\n\t\tstrlcpy(ext, stat->extension, sizeof(ext));\n\t\tsscanf(ext, \"%c %i %i\", &type, &major, &minor);\n\t\tswitch (type) {\n\t\tcase 'c':\n\t\t\tres |= S_IFCHR;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tres |= S_IFBLK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp9_debug(P9_DEBUG_ERROR, \"Unknown special type %c %s\\n\",\n\t\t\t\t type, stat->extension);\n\t\t};\n\t\t*rdev = MKDEV(major, minor);\n\t} else\n\t\tres |= S_IFREG;\n\n\treturn res;\n}"
  },
  {
    "function_name": "p9mode2perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "98-116",
    "snippet": "static int p9mode2perm(struct v9fs_session_info *v9ses,\n\t\t       struct p9_wstat *stat)\n{\n\tint res;\n\tint mode = stat->mode;\n\n\tres = mode & S_IALLUGO;\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tif ((mode & P9_DMSETUID) == P9_DMSETUID)\n\t\t\tres |= S_ISUID;\n\n\t\tif ((mode & P9_DMSETGID) == P9_DMSETGID)\n\t\t\tres |= S_ISGID;\n\n\t\tif ((mode & P9_DMSETVTX) == P9_DMSETVTX)\n\t\t\tres |= S_ISVTX;\n\t}\n\treturn res;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v9fs_proto_dotu",
          "args": [
            "v9ses"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_proto_dotu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "182-185",
          "snippet": "static inline int v9fs_proto_dotu(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000U;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline int v9fs_proto_dotu(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000U;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int p9mode2perm(struct v9fs_session_info *v9ses,\n\t\t       struct p9_wstat *stat)\n{\n\tint res;\n\tint mode = stat->mode;\n\n\tres = mode & S_IALLUGO;\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tif ((mode & P9_DMSETUID) == P9_DMSETUID)\n\t\t\tres |= S_ISUID;\n\n\t\tif ((mode & P9_DMSETGID) == P9_DMSETGID)\n\t\t\tres |= S_ISGID;\n\n\t\tif ((mode & P9_DMSETVTX) == P9_DMSETVTX)\n\t\t\tres |= S_ISVTX;\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "unixmode2p9mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
    "lines": "64-90",
    "snippet": "static u32 unixmode2p9mode(struct v9fs_session_info *v9ses, umode_t mode)\n{\n\tint res;\n\tres = mode & 0777;\n\tif (S_ISDIR(mode))\n\t\tres |= P9_DMDIR;\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tif (v9ses->nodev == 0) {\n\t\t\tif (S_ISSOCK(mode))\n\t\t\t\tres |= P9_DMSOCKET;\n\t\t\tif (S_ISFIFO(mode))\n\t\t\t\tres |= P9_DMNAMEDPIPE;\n\t\t\tif (S_ISBLK(mode))\n\t\t\t\tres |= P9_DMDEVICE;\n\t\t\tif (S_ISCHR(mode))\n\t\t\t\tres |= P9_DMDEVICE;\n\t\t}\n\n\t\tif ((mode & S_ISUID) == S_ISUID)\n\t\t\tres |= P9_DMSETUID;\n\t\tif ((mode & S_ISGID) == S_ISGID)\n\t\t\tres |= P9_DMSETGID;\n\t\tif ((mode & S_ISVTX) == S_ISVTX)\n\t\t\tres |= P9_DMSETVTX;\n\t}\n\treturn res;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "mode"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "mode"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISFIFO",
          "args": [
            "mode"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISSOCK",
          "args": [
            "mode"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_proto_dotu",
          "args": [
            "v9ses"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_proto_dotu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "182-185",
          "snippet": "static inline int v9fs_proto_dotu(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000U;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline int v9fs_proto_dotu(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000U;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic u32 unixmode2p9mode(struct v9fs_session_info *v9ses, umode_t mode)\n{\n\tint res;\n\tres = mode & 0777;\n\tif (S_ISDIR(mode))\n\t\tres |= P9_DMDIR;\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tif (v9ses->nodev == 0) {\n\t\t\tif (S_ISSOCK(mode))\n\t\t\t\tres |= P9_DMSOCKET;\n\t\t\tif (S_ISFIFO(mode))\n\t\t\t\tres |= P9_DMNAMEDPIPE;\n\t\t\tif (S_ISBLK(mode))\n\t\t\t\tres |= P9_DMDEVICE;\n\t\t\tif (S_ISCHR(mode))\n\t\t\t\tres |= P9_DMDEVICE;\n\t\t}\n\n\t\tif ((mode & S_ISUID) == S_ISUID)\n\t\t\tres |= P9_DMSETUID;\n\t\tif ((mode & S_ISGID) == S_ISGID)\n\t\t\tres |= P9_DMSETGID;\n\t\tif ((mode & S_ISVTX) == S_ISVTX)\n\t\t\tres |= P9_DMSETVTX;\n\t}\n\treturn res;\n}"
  }
]