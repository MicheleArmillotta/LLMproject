[
  {
    "function_name": "proc_page_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/page.c",
    "lines": "228-233",
    "snippet": "static int __init proc_page_init(void)\n{\n\tproc_create(\"kpagecount\", S_IRUSR, NULL, &proc_kpagecount_operations);\n\tproc_create(\"kpageflags\", S_IRUSR, NULL, &proc_kpageflags_operations);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/bootmem.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations proc_kpagecount_operations = {\n\t.llseek = mem_lseek,\n\t.read = kpagecount_read,\n};",
      "static const struct file_operations proc_kpageflags_operations = {\n\t.llseek = mem_lseek,\n\t.read = kpageflags_read,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"kpageflags\"",
            "S_IRUSR",
            "NULL",
            "&proc_kpageflags_operations"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "__proc_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "355-391",
          "snippet": "static struct proc_dir_entry *__proc_create(struct proc_dir_entry **parent,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  umode_t mode,\n\t\t\t\t\t  nlink_t nlink)\n{\n\tstruct proc_dir_entry *ent = NULL;\n\tconst char *fn;\n\tstruct qstr qstr;\n\n\tif (xlate_proc_name(name, parent, &fn) != 0)\n\t\tgoto out;\n\tqstr.name = fn;\n\tqstr.len = strlen(fn);\n\tif (qstr.len == 0 || qstr.len >= 256) {\n\t\tWARN(1, \"name len %u\\n\", qstr.len);\n\t\treturn NULL;\n\t}\n\tif (*parent == &proc_root && name_to_int(&qstr) != ~0U) {\n\t\tWARN(1, \"create '/proc/%s' by hand\\n\", qstr.name);\n\t\treturn NULL;\n\t}\n\n\tent = kzalloc(sizeof(struct proc_dir_entry) + qstr.len + 1, GFP_KERNEL);\n\tif (!ent)\n\t\tgoto out;\n\n\tmemcpy(ent->name, fn, qstr.len + 1);\n\tent->namelen = qstr.len;\n\tent->mode = mode;\n\tent->nlink = nlink;\n\tent->subdir = RB_ROOT;\n\tatomic_set(&ent->count, 1);\n\tspin_lock_init(&ent->pde_unload_lock);\n\tINIT_LIST_HEAD(&ent->pde_openers);\nout:\n\treturn ent;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic struct proc_dir_entry *__proc_create(struct proc_dir_entry **parent,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  umode_t mode,\n\t\t\t\t\t  nlink_t nlink)\n{\n\tstruct proc_dir_entry *ent = NULL;\n\tconst char *fn;\n\tstruct qstr qstr;\n\n\tif (xlate_proc_name(name, parent, &fn) != 0)\n\t\tgoto out;\n\tqstr.name = fn;\n\tqstr.len = strlen(fn);\n\tif (qstr.len == 0 || qstr.len >= 256) {\n\t\tWARN(1, \"name len %u\\n\", qstr.len);\n\t\treturn NULL;\n\t}\n\tif (*parent == &proc_root && name_to_int(&qstr) != ~0U) {\n\t\tWARN(1, \"create '/proc/%s' by hand\\n\", qstr.name);\n\t\treturn NULL;\n\t}\n\n\tent = kzalloc(sizeof(struct proc_dir_entry) + qstr.len + 1, GFP_KERNEL);\n\tif (!ent)\n\t\tgoto out;\n\n\tmemcpy(ent->name, fn, qstr.len + 1);\n\tent->namelen = qstr.len;\n\tent->mode = mode;\n\tent->nlink = nlink;\n\tent->subdir = RB_ROOT;\n\tatomic_set(&ent->count, 1);\n\tspin_lock_init(&ent->pde_unload_lock);\n\tINIT_LIST_HEAD(&ent->pde_openers);\nout:\n\treturn ent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/hugetlb.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/huge_mm.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/bootmem.h>\n\nstatic const struct file_operations proc_kpagecount_operations = {\n\t.llseek = mem_lseek,\n\t.read = kpagecount_read,\n};\nstatic const struct file_operations proc_kpageflags_operations = {\n\t.llseek = mem_lseek,\n\t.read = kpageflags_read,\n};\n\nstatic int __init proc_page_init(void)\n{\n\tproc_create(\"kpagecount\", S_IRUSR, NULL, &proc_kpagecount_operations);\n\tproc_create(\"kpageflags\", S_IRUSR, NULL, &proc_kpageflags_operations);\n\treturn 0;\n}"
  },
  {
    "function_name": "kpageflags_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/page.c",
    "lines": "187-221",
    "snippet": "static ssize_t kpageflags_read(struct file *file, char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tu64 __user *out = (u64 __user *)buf;\n\tstruct page *ppage;\n\tunsigned long src = *ppos;\n\tunsigned long pfn;\n\tssize_t ret = 0;\n\n\tpfn = src / KPMSIZE;\n\tcount = min_t(unsigned long, count, (max_pfn * KPMSIZE) - src);\n\tif (src & KPMMASK || count & KPMMASK)\n\t\treturn -EINVAL;\n\n\twhile (count > 0) {\n\t\tif (pfn_valid(pfn))\n\t\t\tppage = pfn_to_page(pfn);\n\t\telse\n\t\t\tppage = NULL;\n\n\t\tif (put_user(stable_page_flags(ppage), out)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tpfn++;\n\t\tout++;\n\t\tcount -= KPMSIZE;\n\t}\n\n\t*ppos += (char __user *)out - buf;\n\tif (!ret)\n\t\tret = (char __user *)out - buf;\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/bootmem.h>"
    ],
    "macros_used": [
      "#define KPMMASK (KPMSIZE - 1)",
      "#define KPMSIZE sizeof(u64)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "stable_page_flags(ppage)",
            "out"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stable_page_flags",
          "args": [
            "ppage"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "stable_page_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/page.c",
          "lines": "81-185",
          "snippet": "u64 stable_page_flags(struct page *page)\n{\n\tu64 k;\n\tu64 u;\n\n\t/*\n\t * pseudo flag: KPF_NOPAGE\n\t * it differentiates a memory hole from a page with no flags\n\t */\n\tif (!page)\n\t\treturn 1 << KPF_NOPAGE;\n\n\tk = page->flags;\n\tu = 0;\n\n\t/*\n\t * pseudo flags for the well known (anonymous) memory mapped pages\n\t *\n\t * Note that page->_mapcount is overloaded in SLOB/SLUB/SLQB, so the\n\t * simple test in page_mapped() is not enough.\n\t */\n\tif (!PageSlab(page) && page_mapped(page))\n\t\tu |= 1 << KPF_MMAP;\n\tif (PageAnon(page))\n\t\tu |= 1 << KPF_ANON;\n\tif (PageKsm(page))\n\t\tu |= 1 << KPF_KSM;\n\n\t/*\n\t * compound pages: export both head/tail info\n\t * they together define a compound page's start/end pos and order\n\t */\n\tif (PageHead(page))\n\t\tu |= 1 << KPF_COMPOUND_HEAD;\n\tif (PageTail(page))\n\t\tu |= 1 << KPF_COMPOUND_TAIL;\n\tif (PageHuge(page))\n\t\tu |= 1 << KPF_HUGE;\n\t/*\n\t * PageTransCompound can be true for non-huge compound pages (slab\n\t * pages or pages allocated by drivers with __GFP_COMP) because it\n\t * just checks PG_head/PG_tail, so we need to check PageLRU/PageAnon\n\t * to make sure a given page is a thp, not a non-huge compound page.\n\t */\n\telse if (PageTransCompound(page)) {\n\t\tstruct page *head = compound_head(page);\n\n\t\tif (PageLRU(head) || PageAnon(head))\n\t\t\tu |= 1 << KPF_THP;\n\t\telse if (is_huge_zero_page(head)) {\n\t\t\tu |= 1 << KPF_ZERO_PAGE;\n\t\t\tu |= 1 << KPF_THP;\n\t\t}\n\t} else if (is_zero_pfn(page_to_pfn(page)))\n\t\tu |= 1 << KPF_ZERO_PAGE;\n\n\n\t/*\n\t * Caveats on high order pages: page->_count will only be set\n\t * -1 on the head page; SLUB/SLQB do the same for PG_slab;\n\t * SLOB won't set PG_slab at all on compound pages.\n\t */\n\tif (PageBuddy(page))\n\t\tu |= 1 << KPF_BUDDY;\n\n\tif (PageBalloon(page))\n\t\tu |= 1 << KPF_BALLOON;\n\n\tu |= kpf_copy_bit(k, KPF_LOCKED,\tPG_locked);\n\n\tu |= kpf_copy_bit(k, KPF_SLAB,\t\tPG_slab);\n\n\tu |= kpf_copy_bit(k, KPF_ERROR,\t\tPG_error);\n\tu |= kpf_copy_bit(k, KPF_DIRTY,\t\tPG_dirty);\n\tu |= kpf_copy_bit(k, KPF_UPTODATE,\tPG_uptodate);\n\tu |= kpf_copy_bit(k, KPF_WRITEBACK,\tPG_writeback);\n\n\tu |= kpf_copy_bit(k, KPF_LRU,\t\tPG_lru);\n\tu |= kpf_copy_bit(k, KPF_REFERENCED,\tPG_referenced);\n\tu |= kpf_copy_bit(k, KPF_ACTIVE,\tPG_active);\n\tu |= kpf_copy_bit(k, KPF_RECLAIM,\tPG_reclaim);\n\n\tu |= kpf_copy_bit(k, KPF_SWAPCACHE,\tPG_swapcache);\n\tu |= kpf_copy_bit(k, KPF_SWAPBACKED,\tPG_swapbacked);\n\n\tu |= kpf_copy_bit(k, KPF_UNEVICTABLE,\tPG_unevictable);\n\tu |= kpf_copy_bit(k, KPF_MLOCKED,\tPG_mlocked);\n\n#ifdef CONFIG_MEMORY_FAILURE\n\tu |= kpf_copy_bit(k, KPF_HWPOISON,\tPG_hwpoison);\n#endif\n\n#ifdef CONFIG_ARCH_USES_PG_UNCACHED\n\tu |= kpf_copy_bit(k, KPF_UNCACHED,\tPG_uncached);\n#endif\n\n\tu |= kpf_copy_bit(k, KPF_RESERVED,\tPG_reserved);\n\tu |= kpf_copy_bit(k, KPF_MAPPEDTODISK,\tPG_mappedtodisk);\n\tu |= kpf_copy_bit(k, KPF_PRIVATE,\tPG_private);\n\tu |= kpf_copy_bit(k, KPF_PRIVATE_2,\tPG_private_2);\n\tu |= kpf_copy_bit(k, KPF_OWNER_PRIVATE,\tPG_owner_priv_1);\n\tu |= kpf_copy_bit(k, KPF_ARCH,\t\tPG_arch_1);\n\n\treturn u;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/bootmem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/hugetlb.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/huge_mm.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/bootmem.h>\n\nu64 stable_page_flags(struct page *page)\n{\n\tu64 k;\n\tu64 u;\n\n\t/*\n\t * pseudo flag: KPF_NOPAGE\n\t * it differentiates a memory hole from a page with no flags\n\t */\n\tif (!page)\n\t\treturn 1 << KPF_NOPAGE;\n\n\tk = page->flags;\n\tu = 0;\n\n\t/*\n\t * pseudo flags for the well known (anonymous) memory mapped pages\n\t *\n\t * Note that page->_mapcount is overloaded in SLOB/SLUB/SLQB, so the\n\t * simple test in page_mapped() is not enough.\n\t */\n\tif (!PageSlab(page) && page_mapped(page))\n\t\tu |= 1 << KPF_MMAP;\n\tif (PageAnon(page))\n\t\tu |= 1 << KPF_ANON;\n\tif (PageKsm(page))\n\t\tu |= 1 << KPF_KSM;\n\n\t/*\n\t * compound pages: export both head/tail info\n\t * they together define a compound page's start/end pos and order\n\t */\n\tif (PageHead(page))\n\t\tu |= 1 << KPF_COMPOUND_HEAD;\n\tif (PageTail(page))\n\t\tu |= 1 << KPF_COMPOUND_TAIL;\n\tif (PageHuge(page))\n\t\tu |= 1 << KPF_HUGE;\n\t/*\n\t * PageTransCompound can be true for non-huge compound pages (slab\n\t * pages or pages allocated by drivers with __GFP_COMP) because it\n\t * just checks PG_head/PG_tail, so we need to check PageLRU/PageAnon\n\t * to make sure a given page is a thp, not a non-huge compound page.\n\t */\n\telse if (PageTransCompound(page)) {\n\t\tstruct page *head = compound_head(page);\n\n\t\tif (PageLRU(head) || PageAnon(head))\n\t\t\tu |= 1 << KPF_THP;\n\t\telse if (is_huge_zero_page(head)) {\n\t\t\tu |= 1 << KPF_ZERO_PAGE;\n\t\t\tu |= 1 << KPF_THP;\n\t\t}\n\t} else if (is_zero_pfn(page_to_pfn(page)))\n\t\tu |= 1 << KPF_ZERO_PAGE;\n\n\n\t/*\n\t * Caveats on high order pages: page->_count will only be set\n\t * -1 on the head page; SLUB/SLQB do the same for PG_slab;\n\t * SLOB won't set PG_slab at all on compound pages.\n\t */\n\tif (PageBuddy(page))\n\t\tu |= 1 << KPF_BUDDY;\n\n\tif (PageBalloon(page))\n\t\tu |= 1 << KPF_BALLOON;\n\n\tu |= kpf_copy_bit(k, KPF_LOCKED,\tPG_locked);\n\n\tu |= kpf_copy_bit(k, KPF_SLAB,\t\tPG_slab);\n\n\tu |= kpf_copy_bit(k, KPF_ERROR,\t\tPG_error);\n\tu |= kpf_copy_bit(k, KPF_DIRTY,\t\tPG_dirty);\n\tu |= kpf_copy_bit(k, KPF_UPTODATE,\tPG_uptodate);\n\tu |= kpf_copy_bit(k, KPF_WRITEBACK,\tPG_writeback);\n\n\tu |= kpf_copy_bit(k, KPF_LRU,\t\tPG_lru);\n\tu |= kpf_copy_bit(k, KPF_REFERENCED,\tPG_referenced);\n\tu |= kpf_copy_bit(k, KPF_ACTIVE,\tPG_active);\n\tu |= kpf_copy_bit(k, KPF_RECLAIM,\tPG_reclaim);\n\n\tu |= kpf_copy_bit(k, KPF_SWAPCACHE,\tPG_swapcache);\n\tu |= kpf_copy_bit(k, KPF_SWAPBACKED,\tPG_swapbacked);\n\n\tu |= kpf_copy_bit(k, KPF_UNEVICTABLE,\tPG_unevictable);\n\tu |= kpf_copy_bit(k, KPF_MLOCKED,\tPG_mlocked);\n\n#ifdef CONFIG_MEMORY_FAILURE\n\tu |= kpf_copy_bit(k, KPF_HWPOISON,\tPG_hwpoison);\n#endif\n\n#ifdef CONFIG_ARCH_USES_PG_UNCACHED\n\tu |= kpf_copy_bit(k, KPF_UNCACHED,\tPG_uncached);\n#endif\n\n\tu |= kpf_copy_bit(k, KPF_RESERVED,\tPG_reserved);\n\tu |= kpf_copy_bit(k, KPF_MAPPEDTODISK,\tPG_mappedtodisk);\n\tu |= kpf_copy_bit(k, KPF_PRIVATE,\tPG_private);\n\tu |= kpf_copy_bit(k, KPF_PRIVATE_2,\tPG_private_2);\n\tu |= kpf_copy_bit(k, KPF_OWNER_PRIVATE,\tPG_owner_priv_1);\n\tu |= kpf_copy_bit(k, KPF_ARCH,\t\tPG_arch_1);\n\n\treturn u;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "count",
            "(max_pfn * KPMSIZE) - src"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/hugetlb.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/huge_mm.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/bootmem.h>\n\n#define KPMMASK (KPMSIZE - 1)\n#define KPMSIZE sizeof(u64)\n\nstatic ssize_t kpageflags_read(struct file *file, char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tu64 __user *out = (u64 __user *)buf;\n\tstruct page *ppage;\n\tunsigned long src = *ppos;\n\tunsigned long pfn;\n\tssize_t ret = 0;\n\n\tpfn = src / KPMSIZE;\n\tcount = min_t(unsigned long, count, (max_pfn * KPMSIZE) - src);\n\tif (src & KPMMASK || count & KPMMASK)\n\t\treturn -EINVAL;\n\n\twhile (count > 0) {\n\t\tif (pfn_valid(pfn))\n\t\t\tppage = pfn_to_page(pfn);\n\t\telse\n\t\t\tppage = NULL;\n\n\t\tif (put_user(stable_page_flags(ppage), out)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tpfn++;\n\t\tout++;\n\t\tcount -= KPMSIZE;\n\t}\n\n\t*ppos += (char __user *)out - buf;\n\tif (!ret)\n\t\tret = (char __user *)out - buf;\n\treturn ret;\n}"
  },
  {
    "function_name": "stable_page_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/page.c",
    "lines": "81-185",
    "snippet": "u64 stable_page_flags(struct page *page)\n{\n\tu64 k;\n\tu64 u;\n\n\t/*\n\t * pseudo flag: KPF_NOPAGE\n\t * it differentiates a memory hole from a page with no flags\n\t */\n\tif (!page)\n\t\treturn 1 << KPF_NOPAGE;\n\n\tk = page->flags;\n\tu = 0;\n\n\t/*\n\t * pseudo flags for the well known (anonymous) memory mapped pages\n\t *\n\t * Note that page->_mapcount is overloaded in SLOB/SLUB/SLQB, so the\n\t * simple test in page_mapped() is not enough.\n\t */\n\tif (!PageSlab(page) && page_mapped(page))\n\t\tu |= 1 << KPF_MMAP;\n\tif (PageAnon(page))\n\t\tu |= 1 << KPF_ANON;\n\tif (PageKsm(page))\n\t\tu |= 1 << KPF_KSM;\n\n\t/*\n\t * compound pages: export both head/tail info\n\t * they together define a compound page's start/end pos and order\n\t */\n\tif (PageHead(page))\n\t\tu |= 1 << KPF_COMPOUND_HEAD;\n\tif (PageTail(page))\n\t\tu |= 1 << KPF_COMPOUND_TAIL;\n\tif (PageHuge(page))\n\t\tu |= 1 << KPF_HUGE;\n\t/*\n\t * PageTransCompound can be true for non-huge compound pages (slab\n\t * pages or pages allocated by drivers with __GFP_COMP) because it\n\t * just checks PG_head/PG_tail, so we need to check PageLRU/PageAnon\n\t * to make sure a given page is a thp, not a non-huge compound page.\n\t */\n\telse if (PageTransCompound(page)) {\n\t\tstruct page *head = compound_head(page);\n\n\t\tif (PageLRU(head) || PageAnon(head))\n\t\t\tu |= 1 << KPF_THP;\n\t\telse if (is_huge_zero_page(head)) {\n\t\t\tu |= 1 << KPF_ZERO_PAGE;\n\t\t\tu |= 1 << KPF_THP;\n\t\t}\n\t} else if (is_zero_pfn(page_to_pfn(page)))\n\t\tu |= 1 << KPF_ZERO_PAGE;\n\n\n\t/*\n\t * Caveats on high order pages: page->_count will only be set\n\t * -1 on the head page; SLUB/SLQB do the same for PG_slab;\n\t * SLOB won't set PG_slab at all on compound pages.\n\t */\n\tif (PageBuddy(page))\n\t\tu |= 1 << KPF_BUDDY;\n\n\tif (PageBalloon(page))\n\t\tu |= 1 << KPF_BALLOON;\n\n\tu |= kpf_copy_bit(k, KPF_LOCKED,\tPG_locked);\n\n\tu |= kpf_copy_bit(k, KPF_SLAB,\t\tPG_slab);\n\n\tu |= kpf_copy_bit(k, KPF_ERROR,\t\tPG_error);\n\tu |= kpf_copy_bit(k, KPF_DIRTY,\t\tPG_dirty);\n\tu |= kpf_copy_bit(k, KPF_UPTODATE,\tPG_uptodate);\n\tu |= kpf_copy_bit(k, KPF_WRITEBACK,\tPG_writeback);\n\n\tu |= kpf_copy_bit(k, KPF_LRU,\t\tPG_lru);\n\tu |= kpf_copy_bit(k, KPF_REFERENCED,\tPG_referenced);\n\tu |= kpf_copy_bit(k, KPF_ACTIVE,\tPG_active);\n\tu |= kpf_copy_bit(k, KPF_RECLAIM,\tPG_reclaim);\n\n\tu |= kpf_copy_bit(k, KPF_SWAPCACHE,\tPG_swapcache);\n\tu |= kpf_copy_bit(k, KPF_SWAPBACKED,\tPG_swapbacked);\n\n\tu |= kpf_copy_bit(k, KPF_UNEVICTABLE,\tPG_unevictable);\n\tu |= kpf_copy_bit(k, KPF_MLOCKED,\tPG_mlocked);\n\n#ifdef CONFIG_MEMORY_FAILURE\n\tu |= kpf_copy_bit(k, KPF_HWPOISON,\tPG_hwpoison);\n#endif\n\n#ifdef CONFIG_ARCH_USES_PG_UNCACHED\n\tu |= kpf_copy_bit(k, KPF_UNCACHED,\tPG_uncached);\n#endif\n\n\tu |= kpf_copy_bit(k, KPF_RESERVED,\tPG_reserved);\n\tu |= kpf_copy_bit(k, KPF_MAPPEDTODISK,\tPG_mappedtodisk);\n\tu |= kpf_copy_bit(k, KPF_PRIVATE,\tPG_private);\n\tu |= kpf_copy_bit(k, KPF_PRIVATE_2,\tPG_private_2);\n\tu |= kpf_copy_bit(k, KPF_OWNER_PRIVATE,\tPG_owner_priv_1);\n\tu |= kpf_copy_bit(k, KPF_ARCH,\t\tPG_arch_1);\n\n\treturn u;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/bootmem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kpf_copy_bit",
          "args": [
            "k",
            "KPF_ARCH",
            "PG_arch_1"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "kpf_copy_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/page.c",
          "lines": "76-79",
          "snippet": "static inline u64 kpf_copy_bit(u64 kflags, int ubit, int kbit)\n{\n\treturn ((kflags >> kbit) & 1) << ubit;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/bootmem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/hugetlb.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/huge_mm.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/bootmem.h>\n\nstatic inline u64 kpf_copy_bit(u64 kflags, int ubit, int kbit)\n{\n\treturn ((kflags >> kbit) & 1) << ubit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageBalloon",
          "args": [
            "page"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageBuddy",
          "args": [
            "page"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_zero_pfn",
          "args": [
            "page_to_pfn(page)"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_huge_zero_page",
          "args": [
            "head"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "head"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "head"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransCompound",
          "args": [
            "page"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTail",
          "args": [
            "page"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHead",
          "args": [
            "page"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageKsm",
          "args": [
            "page"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapped",
          "args": [
            "page"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSlab",
          "args": [
            "page"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/hugetlb.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/huge_mm.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/bootmem.h>\n\nu64 stable_page_flags(struct page *page)\n{\n\tu64 k;\n\tu64 u;\n\n\t/*\n\t * pseudo flag: KPF_NOPAGE\n\t * it differentiates a memory hole from a page with no flags\n\t */\n\tif (!page)\n\t\treturn 1 << KPF_NOPAGE;\n\n\tk = page->flags;\n\tu = 0;\n\n\t/*\n\t * pseudo flags for the well known (anonymous) memory mapped pages\n\t *\n\t * Note that page->_mapcount is overloaded in SLOB/SLUB/SLQB, so the\n\t * simple test in page_mapped() is not enough.\n\t */\n\tif (!PageSlab(page) && page_mapped(page))\n\t\tu |= 1 << KPF_MMAP;\n\tif (PageAnon(page))\n\t\tu |= 1 << KPF_ANON;\n\tif (PageKsm(page))\n\t\tu |= 1 << KPF_KSM;\n\n\t/*\n\t * compound pages: export both head/tail info\n\t * they together define a compound page's start/end pos and order\n\t */\n\tif (PageHead(page))\n\t\tu |= 1 << KPF_COMPOUND_HEAD;\n\tif (PageTail(page))\n\t\tu |= 1 << KPF_COMPOUND_TAIL;\n\tif (PageHuge(page))\n\t\tu |= 1 << KPF_HUGE;\n\t/*\n\t * PageTransCompound can be true for non-huge compound pages (slab\n\t * pages or pages allocated by drivers with __GFP_COMP) because it\n\t * just checks PG_head/PG_tail, so we need to check PageLRU/PageAnon\n\t * to make sure a given page is a thp, not a non-huge compound page.\n\t */\n\telse if (PageTransCompound(page)) {\n\t\tstruct page *head = compound_head(page);\n\n\t\tif (PageLRU(head) || PageAnon(head))\n\t\t\tu |= 1 << KPF_THP;\n\t\telse if (is_huge_zero_page(head)) {\n\t\t\tu |= 1 << KPF_ZERO_PAGE;\n\t\t\tu |= 1 << KPF_THP;\n\t\t}\n\t} else if (is_zero_pfn(page_to_pfn(page)))\n\t\tu |= 1 << KPF_ZERO_PAGE;\n\n\n\t/*\n\t * Caveats on high order pages: page->_count will only be set\n\t * -1 on the head page; SLUB/SLQB do the same for PG_slab;\n\t * SLOB won't set PG_slab at all on compound pages.\n\t */\n\tif (PageBuddy(page))\n\t\tu |= 1 << KPF_BUDDY;\n\n\tif (PageBalloon(page))\n\t\tu |= 1 << KPF_BALLOON;\n\n\tu |= kpf_copy_bit(k, KPF_LOCKED,\tPG_locked);\n\n\tu |= kpf_copy_bit(k, KPF_SLAB,\t\tPG_slab);\n\n\tu |= kpf_copy_bit(k, KPF_ERROR,\t\tPG_error);\n\tu |= kpf_copy_bit(k, KPF_DIRTY,\t\tPG_dirty);\n\tu |= kpf_copy_bit(k, KPF_UPTODATE,\tPG_uptodate);\n\tu |= kpf_copy_bit(k, KPF_WRITEBACK,\tPG_writeback);\n\n\tu |= kpf_copy_bit(k, KPF_LRU,\t\tPG_lru);\n\tu |= kpf_copy_bit(k, KPF_REFERENCED,\tPG_referenced);\n\tu |= kpf_copy_bit(k, KPF_ACTIVE,\tPG_active);\n\tu |= kpf_copy_bit(k, KPF_RECLAIM,\tPG_reclaim);\n\n\tu |= kpf_copy_bit(k, KPF_SWAPCACHE,\tPG_swapcache);\n\tu |= kpf_copy_bit(k, KPF_SWAPBACKED,\tPG_swapbacked);\n\n\tu |= kpf_copy_bit(k, KPF_UNEVICTABLE,\tPG_unevictable);\n\tu |= kpf_copy_bit(k, KPF_MLOCKED,\tPG_mlocked);\n\n#ifdef CONFIG_MEMORY_FAILURE\n\tu |= kpf_copy_bit(k, KPF_HWPOISON,\tPG_hwpoison);\n#endif\n\n#ifdef CONFIG_ARCH_USES_PG_UNCACHED\n\tu |= kpf_copy_bit(k, KPF_UNCACHED,\tPG_uncached);\n#endif\n\n\tu |= kpf_copy_bit(k, KPF_RESERVED,\tPG_reserved);\n\tu |= kpf_copy_bit(k, KPF_MAPPEDTODISK,\tPG_mappedtodisk);\n\tu |= kpf_copy_bit(k, KPF_PRIVATE,\tPG_private);\n\tu |= kpf_copy_bit(k, KPF_PRIVATE_2,\tPG_private_2);\n\tu |= kpf_copy_bit(k, KPF_OWNER_PRIVATE,\tPG_owner_priv_1);\n\tu |= kpf_copy_bit(k, KPF_ARCH,\t\tPG_arch_1);\n\n\treturn u;\n}"
  },
  {
    "function_name": "kpf_copy_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/page.c",
    "lines": "76-79",
    "snippet": "static inline u64 kpf_copy_bit(u64 kflags, int ubit, int kbit)\n{\n\treturn ((kflags >> kbit) & 1) << ubit;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/bootmem.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/hugetlb.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/huge_mm.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/bootmem.h>\n\nstatic inline u64 kpf_copy_bit(u64 kflags, int ubit, int kbit)\n{\n\treturn ((kflags >> kbit) & 1) << ubit;\n}"
  },
  {
    "function_name": "kpagecount_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/page.c",
    "lines": "24-63",
    "snippet": "static ssize_t kpagecount_read(struct file *file, char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tu64 __user *out = (u64 __user *)buf;\n\tstruct page *ppage;\n\tunsigned long src = *ppos;\n\tunsigned long pfn;\n\tssize_t ret = 0;\n\tu64 pcount;\n\n\tpfn = src / KPMSIZE;\n\tcount = min_t(size_t, count, (max_pfn * KPMSIZE) - src);\n\tif (src & KPMMASK || count & KPMMASK)\n\t\treturn -EINVAL;\n\n\twhile (count > 0) {\n\t\tif (pfn_valid(pfn))\n\t\t\tppage = pfn_to_page(pfn);\n\t\telse\n\t\t\tppage = NULL;\n\t\tif (!ppage || PageSlab(ppage))\n\t\t\tpcount = 0;\n\t\telse\n\t\t\tpcount = page_mapcount(ppage);\n\n\t\tif (put_user(pcount, out)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tpfn++;\n\t\tout++;\n\t\tcount -= KPMSIZE;\n\t}\n\n\t*ppos += (char __user *)out - buf;\n\tif (!ret)\n\t\tret = (char __user *)out - buf;\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/bootmem.h>"
    ],
    "macros_used": [
      "#define KPMMASK (KPMSIZE - 1)",
      "#define KPMSIZE sizeof(u64)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "pcount",
            "out"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "ppage"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSlab",
          "args": [
            "ppage"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "count",
            "(max_pfn * KPMSIZE) - src"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/hugetlb.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/huge_mm.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/bootmem.h>\n\n#define KPMMASK (KPMSIZE - 1)\n#define KPMSIZE sizeof(u64)\n\nstatic ssize_t kpagecount_read(struct file *file, char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tu64 __user *out = (u64 __user *)buf;\n\tstruct page *ppage;\n\tunsigned long src = *ppos;\n\tunsigned long pfn;\n\tssize_t ret = 0;\n\tu64 pcount;\n\n\tpfn = src / KPMSIZE;\n\tcount = min_t(size_t, count, (max_pfn * KPMSIZE) - src);\n\tif (src & KPMMASK || count & KPMMASK)\n\t\treturn -EINVAL;\n\n\twhile (count > 0) {\n\t\tif (pfn_valid(pfn))\n\t\t\tppage = pfn_to_page(pfn);\n\t\telse\n\t\t\tppage = NULL;\n\t\tif (!ppage || PageSlab(ppage))\n\t\t\tpcount = 0;\n\t\telse\n\t\t\tpcount = page_mapcount(ppage);\n\n\t\tif (put_user(pcount, out)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tpfn++;\n\t\tout++;\n\t\tcount -= KPMSIZE;\n\t}\n\n\t*ppos += (char __user *)out - buf;\n\tif (!ret)\n\t\tret = (char __user *)out - buf;\n\treturn ret;\n}"
  }
]