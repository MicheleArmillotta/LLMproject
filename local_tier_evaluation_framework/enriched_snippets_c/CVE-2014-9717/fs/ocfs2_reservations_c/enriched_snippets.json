[
  {
    "function_name": "ocfs2_resmap_claimed_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
    "lines": "796-839",
    "snippet": "void ocfs2_resmap_claimed_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t       struct ocfs2_alloc_reservation *resv,\n\t\t\t       u32 cstart, u32 clen)\n{\n\tunsigned int cend = cstart + clen - 1;\n\n\tif (resmap == NULL || ocfs2_resmap_disabled(resmap))\n\t\treturn;\n\n\tif (resv == NULL)\n\t\treturn;\n\n\tBUG_ON(cstart != resv->r_start);\n\n\tspin_lock(&resv_lock);\n\n\ttrace_ocfs2_resmap_claimed_bits_begin(cstart, cend, clen, resv->r_start,\n\t\t\t\t\t      ocfs2_resv_end(resv), resv->r_len,\n\t\t\t\t\t      resv->r_last_start,\n\t\t\t\t\t      resv->r_last_len);\n\n\tBUG_ON(cstart < resv->r_start);\n\tBUG_ON(cstart > ocfs2_resv_end(resv));\n\tBUG_ON(cend > ocfs2_resv_end(resv));\n\n\tocfs2_adjust_resv_from_alloc(resmap, resv, cstart, cend);\n\tresv->r_last_start = cstart;\n\tresv->r_last_len = clen;\n\n\t/*\n\t * May have been discarded above from\n\t * ocfs2_adjust_resv_from_alloc().\n\t */\n\tif (!ocfs2_resv_empty(resv))\n\t\tocfs2_resv_mark_lru(resmap, resv);\n\n\ttrace_ocfs2_resmap_claimed_bits_end(resv->r_start, ocfs2_resv_end(resv),\n\t\t\t\t\t    resv->r_len, resv->r_last_start,\n\t\t\t\t\t    resv->r_last_len);\n\n\tocfs2_check_resmap(resmap);\n\n\tspin_unlock(&resv_lock);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(resv_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&resv_lock"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_check_resmap",
          "args": [
            "resmap"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_resmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "194-197",
          "snippet": "static inline void ocfs2_check_resmap(struct ocfs2_reservation_map *resmap)\n{\n\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_check_resmap(struct ocfs2_reservation_map *resmap)\n{\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_resmap_claimed_bits_end",
          "args": [
            "resv->r_start",
            "ocfs2_resv_end(resv)",
            "resv->r_len",
            "resv->r_last_start",
            "resv->r_last_len"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_resv_end",
          "args": [
            "resv"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "67-72",
          "snippet": "static inline unsigned int ocfs2_resv_end(struct ocfs2_alloc_reservation *resv)\n{\n\tif (resv->r_len)\n\t\treturn resv->r_start + resv->r_len - 1;\n\treturn resv->r_start;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ocfs2_resv_end(struct ocfs2_alloc_reservation *resv)\n{\n\tif (resv->r_len)\n\t\treturn resv->r_start + resv->r_len - 1;\n\treturn resv->r_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_resv_mark_lru",
          "args": [
            "resmap",
            "resv"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_mark_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "227-236",
          "snippet": "static void ocfs2_resv_mark_lru(struct ocfs2_reservation_map *resmap,\n\t\t\t\tstruct ocfs2_alloc_reservation *resv)\n{\n\tassert_spin_locked(&resv_lock);\n\n\tif (!list_empty(&resv->r_lru))\n\t\tlist_del_init(&resv->r_lru);\n\n\tlist_add_tail(&resv->r_lru, &resmap->m_lru);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(resv_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(resv_lock);\n\nstatic void ocfs2_resv_mark_lru(struct ocfs2_reservation_map *resmap,\n\t\t\t\tstruct ocfs2_alloc_reservation *resv)\n{\n\tassert_spin_locked(&resv_lock);\n\n\tif (!list_empty(&resv->r_lru))\n\t\tlist_del_init(&resv->r_lru);\n\n\tlist_add_tail(&resv->r_lru, &resmap->m_lru);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_resv_empty",
          "args": [
            "resv"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "74-77",
          "snippet": "static inline int ocfs2_resv_empty(struct ocfs2_alloc_reservation *resv)\n{\n\treturn !!(resv->r_len == 0);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int ocfs2_resv_empty(struct ocfs2_alloc_reservation *resv)\n{\n\treturn !!(resv->r_len == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_adjust_resv_from_alloc",
          "args": [
            "resmap",
            "resv",
            "cstart",
            "cend"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_adjust_resv_from_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "767-794",
          "snippet": "static void\n\tocfs2_adjust_resv_from_alloc(struct ocfs2_reservation_map *resmap,\n\t\t\t\t     struct ocfs2_alloc_reservation *resv,\n\t\t\t\t     unsigned int start, unsigned int end)\n{\n\tunsigned int rhs = 0;\n\tunsigned int old_end = ocfs2_resv_end(resv);\n\n\tBUG_ON(start != resv->r_start || old_end < end);\n\n\t/*\n\t * Completely used? We can remove it then.\n\t */\n\tif (old_end == end) {\n\t\t__ocfs2_resv_discard(resmap, resv);\n\t\treturn;\n\t}\n\n\trhs = old_end - end;\n\n\t/*\n\t * This should have been trapped above.\n\t */\n\tBUG_ON(rhs == 0);\n\n\tresv->r_start = end + 1;\n\tresv->r_len = old_end - resv->r_start + 1;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void\n\tocfs2_adjust_resv_from_alloc(struct ocfs2_reservation_map *resmap,\n\t\t\t\t     struct ocfs2_alloc_reservation *resv,\n\t\t\t\t     unsigned int start, unsigned int end)\n{\n\tunsigned int rhs = 0;\n\tunsigned int old_end = ocfs2_resv_end(resv);\n\n\tBUG_ON(start != resv->r_start || old_end < end);\n\n\t/*\n\t * Completely used? We can remove it then.\n\t */\n\tif (old_end == end) {\n\t\t__ocfs2_resv_discard(resmap, resv);\n\t\treturn;\n\t}\n\n\trhs = old_end - end;\n\n\t/*\n\t * This should have been trapped above.\n\t */\n\tBUG_ON(rhs == 0);\n\n\tresv->r_start = end + 1;\n\tresv->r_len = old_end - resv->r_start + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cend > ocfs2_resv_end(resv)"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cstart > ocfs2_resv_end(resv)"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cstart < resv->r_start"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_resmap_claimed_bits_begin",
          "args": [
            "cstart",
            "cend",
            "clen",
            "resv->r_start",
            "ocfs2_resv_end(resv)",
            "resv->r_len",
            "resv->r_last_start",
            "resv->r_last_len"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&resv_lock"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cstart != resv->r_start"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_resmap_disabled",
          "args": [
            "resmap"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resmap_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "79-84",
          "snippet": "static inline int ocfs2_resmap_disabled(struct ocfs2_reservation_map *resmap)\n{\n\tif (resmap->m_osb->osb_resv_level == 0)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int ocfs2_resmap_disabled(struct ocfs2_reservation_map *resmap)\n{\n\tif (resmap->m_osb->osb_resv_level == 0)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(resv_lock);\n\nvoid ocfs2_resmap_claimed_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t       struct ocfs2_alloc_reservation *resv,\n\t\t\t       u32 cstart, u32 clen)\n{\n\tunsigned int cend = cstart + clen - 1;\n\n\tif (resmap == NULL || ocfs2_resmap_disabled(resmap))\n\t\treturn;\n\n\tif (resv == NULL)\n\t\treturn;\n\n\tBUG_ON(cstart != resv->r_start);\n\n\tspin_lock(&resv_lock);\n\n\ttrace_ocfs2_resmap_claimed_bits_begin(cstart, cend, clen, resv->r_start,\n\t\t\t\t\t      ocfs2_resv_end(resv), resv->r_len,\n\t\t\t\t\t      resv->r_last_start,\n\t\t\t\t\t      resv->r_last_len);\n\n\tBUG_ON(cstart < resv->r_start);\n\tBUG_ON(cstart > ocfs2_resv_end(resv));\n\tBUG_ON(cend > ocfs2_resv_end(resv));\n\n\tocfs2_adjust_resv_from_alloc(resmap, resv, cstart, cend);\n\tresv->r_last_start = cstart;\n\tresv->r_last_len = clen;\n\n\t/*\n\t * May have been discarded above from\n\t * ocfs2_adjust_resv_from_alloc().\n\t */\n\tif (!ocfs2_resv_empty(resv))\n\t\tocfs2_resv_mark_lru(resmap, resv);\n\n\ttrace_ocfs2_resmap_claimed_bits_end(resv->r_start, ocfs2_resv_end(resv),\n\t\t\t\t\t    resv->r_len, resv->r_last_start,\n\t\t\t\t\t    resv->r_last_len);\n\n\tocfs2_check_resmap(resmap);\n\n\tspin_unlock(&resv_lock);\n}"
  },
  {
    "function_name": "ocfs2_adjust_resv_from_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
    "lines": "767-794",
    "snippet": "static void\n\tocfs2_adjust_resv_from_alloc(struct ocfs2_reservation_map *resmap,\n\t\t\t\t     struct ocfs2_alloc_reservation *resv,\n\t\t\t\t     unsigned int start, unsigned int end)\n{\n\tunsigned int rhs = 0;\n\tunsigned int old_end = ocfs2_resv_end(resv);\n\n\tBUG_ON(start != resv->r_start || old_end < end);\n\n\t/*\n\t * Completely used? We can remove it then.\n\t */\n\tif (old_end == end) {\n\t\t__ocfs2_resv_discard(resmap, resv);\n\t\treturn;\n\t}\n\n\trhs = old_end - end;\n\n\t/*\n\t * This should have been trapped above.\n\t */\n\tBUG_ON(rhs == 0);\n\n\tresv->r_start = end + 1;\n\tresv->r_len = old_end - resv->r_start + 1;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "rhs == 0"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_resv_discard",
          "args": [
            "resmap",
            "resv"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_resv_discard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "254-267",
          "snippet": "static void __ocfs2_resv_discard(struct ocfs2_reservation_map *resmap,\n\t\t\t\t struct ocfs2_alloc_reservation *resv)\n{\n\tassert_spin_locked(&resv_lock);\n\n\t__ocfs2_resv_trunc(resv);\n\t/*\n\t * last_len and last_start no longer make sense if\n\t * we're changing the range of our allocations.\n\t */\n\tresv->r_last_len = resv->r_last_start = 0;\n\n\tocfs2_resv_remove(resmap, resv);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(resv_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(resv_lock);\n\nstatic void __ocfs2_resv_discard(struct ocfs2_reservation_map *resmap,\n\t\t\t\t struct ocfs2_alloc_reservation *resv)\n{\n\tassert_spin_locked(&resv_lock);\n\n\t__ocfs2_resv_trunc(resv);\n\t/*\n\t * last_len and last_start no longer make sense if\n\t * we're changing the range of our allocations.\n\t */\n\tresv->r_last_len = resv->r_last_start = 0;\n\n\tocfs2_resv_remove(resmap, resv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "start != resv->r_start || old_end < end"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_resv_end",
          "args": [
            "resv"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "67-72",
          "snippet": "static inline unsigned int ocfs2_resv_end(struct ocfs2_alloc_reservation *resv)\n{\n\tif (resv->r_len)\n\t\treturn resv->r_start + resv->r_len - 1;\n\treturn resv->r_start;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ocfs2_resv_end(struct ocfs2_alloc_reservation *resv)\n{\n\tif (resv->r_len)\n\t\treturn resv->r_start + resv->r_len - 1;\n\treturn resv->r_start;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void\n\tocfs2_adjust_resv_from_alloc(struct ocfs2_reservation_map *resmap,\n\t\t\t\t     struct ocfs2_alloc_reservation *resv,\n\t\t\t\t     unsigned int start, unsigned int end)\n{\n\tunsigned int rhs = 0;\n\tunsigned int old_end = ocfs2_resv_end(resv);\n\n\tBUG_ON(start != resv->r_start || old_end < end);\n\n\t/*\n\t * Completely used? We can remove it then.\n\t */\n\tif (old_end == end) {\n\t\t__ocfs2_resv_discard(resmap, resv);\n\t\treturn;\n\t}\n\n\trhs = old_end - end;\n\n\t/*\n\t * This should have been trapped above.\n\t */\n\tBUG_ON(rhs == 0);\n\n\tresv->r_start = end + 1;\n\tresv->r_len = old_end - resv->r_start + 1;\n}"
  },
  {
    "function_name": "ocfs2_resmap_resv_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
    "lines": "727-765",
    "snippet": "int ocfs2_resmap_resv_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t   struct ocfs2_alloc_reservation *resv,\n\t\t\t   int *cstart, int *clen)\n{\n\tif (resv == NULL || ocfs2_resmap_disabled(resmap))\n\t\treturn -ENOSPC;\n\n\tspin_lock(&resv_lock);\n\n\tif (ocfs2_resv_empty(resv)) {\n\t\t/*\n\t\t * We don't want to over-allocate for temporary\n\t\t * windows. Otherwise, we run the risk of fragmenting the\n\t\t * allocation space.\n\t\t */\n\t\tunsigned int wanted = ocfs2_resv_window_bits(resmap, resv);\n\n\t\tif ((resv->r_flags & OCFS2_RESV_FLAG_TMP) || wanted < *clen)\n\t\t\twanted = *clen;\n\n\t\t/*\n\t\t * Try to get a window here. If it works, we must fall\n\t\t * through and test the bitmap . This avoids some\n\t\t * ping-ponging of windows due to non-reserved space\n\t\t * being allocation before we initialize a window for\n\t\t * that inode.\n\t\t */\n\t\tocfs2_resv_find_window(resmap, resv, wanted);\n\t\ttrace_ocfs2_resmap_resv_bits(resv->r_start, resv->r_len);\n\t}\n\n\tBUG_ON(ocfs2_resv_empty(resv));\n\n\t*cstart = resv->r_start;\n\t*clen = resv->r_len;\n\n\tspin_unlock(&resv_lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(resv_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&resv_lock"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ocfs2_resv_empty(resv)"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_resv_empty",
          "args": [
            "resv"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "74-77",
          "snippet": "static inline int ocfs2_resv_empty(struct ocfs2_alloc_reservation *resv)\n{\n\treturn !!(resv->r_len == 0);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int ocfs2_resv_empty(struct ocfs2_alloc_reservation *resv)\n{\n\treturn !!(resv->r_len == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_resmap_resv_bits",
          "args": [
            "resv->r_start",
            "resv->r_len"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_resv_find_window",
          "args": [
            "resmap",
            "resv",
            "wanted"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_find_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "691-725",
          "snippet": "static void ocfs2_resv_find_window(struct ocfs2_reservation_map *resmap,\n\t\t\t\t   struct ocfs2_alloc_reservation *resv,\n\t\t\t\t   unsigned int wanted)\n{\n\tunsigned int goal = 0;\n\n\tBUG_ON(!ocfs2_resv_empty(resv));\n\n\t/*\n\t * Begin by trying to get a window as close to the previous\n\t * one as possible. Using the most recent allocation as a\n\t * start goal makes sense.\n\t */\n\tif (resv->r_last_len) {\n\t\tgoal = resv->r_last_start + resv->r_last_len;\n\t\tif (goal >= resmap->m_bitmap_len)\n\t\t\tgoal = 0;\n\t}\n\n\t__ocfs2_resv_find_window(resmap, resv, goal, wanted);\n\n\t/* Search from last alloc didn't work, try once more from beginning. */\n\tif (ocfs2_resv_empty(resv) && goal != 0)\n\t\t__ocfs2_resv_find_window(resmap, resv, 0, wanted);\n\n\tif (ocfs2_resv_empty(resv)) {\n\t\t/*\n\t\t * Still empty? Pull oldest one off the LRU, remove it from\n\t\t * tree, put this one in it's place.\n\t\t */\n\t\tocfs2_cannibalize_resv(resmap, resv, wanted);\n\t}\n\n\tBUG_ON(ocfs2_resv_empty(resv));\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_resv_find_window(struct ocfs2_reservation_map *resmap,\n\t\t\t\t   struct ocfs2_alloc_reservation *resv,\n\t\t\t\t   unsigned int wanted)\n{\n\tunsigned int goal = 0;\n\n\tBUG_ON(!ocfs2_resv_empty(resv));\n\n\t/*\n\t * Begin by trying to get a window as close to the previous\n\t * one as possible. Using the most recent allocation as a\n\t * start goal makes sense.\n\t */\n\tif (resv->r_last_len) {\n\t\tgoal = resv->r_last_start + resv->r_last_len;\n\t\tif (goal >= resmap->m_bitmap_len)\n\t\t\tgoal = 0;\n\t}\n\n\t__ocfs2_resv_find_window(resmap, resv, goal, wanted);\n\n\t/* Search from last alloc didn't work, try once more from beginning. */\n\tif (ocfs2_resv_empty(resv) && goal != 0)\n\t\t__ocfs2_resv_find_window(resmap, resv, 0, wanted);\n\n\tif (ocfs2_resv_empty(resv)) {\n\t\t/*\n\t\t * Still empty? Pull oldest one off the LRU, remove it from\n\t\t * tree, put this one in it's place.\n\t\t */\n\t\tocfs2_cannibalize_resv(resmap, resv, wanted);\n\t}\n\n\tBUG_ON(ocfs2_resv_empty(resv));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_resv_window_bits",
          "args": [
            "resmap",
            "resv"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_window_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "52-65",
          "snippet": "static unsigned int ocfs2_resv_window_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t\t\t   struct ocfs2_alloc_reservation *resv)\n{\n\tstruct ocfs2_super *osb = resmap->m_osb;\n\tunsigned int bits;\n\n\tif (!(resv->r_flags & OCFS2_RESV_FLAG_DIR)) {\n\t\t/* 8, 16, 32, 64, 128, 256, 512, 1024 */\n\t\tbits = 4 << osb->osb_resv_level;\n\t} else {\n\t\tbits = 4 << osb->osb_dir_resv_level;\n\t}\n\treturn bits;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic unsigned int ocfs2_resv_window_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t\t\t   struct ocfs2_alloc_reservation *resv)\n{\n\tstruct ocfs2_super *osb = resmap->m_osb;\n\tunsigned int bits;\n\n\tif (!(resv->r_flags & OCFS2_RESV_FLAG_DIR)) {\n\t\t/* 8, 16, 32, 64, 128, 256, 512, 1024 */\n\t\tbits = 4 << osb->osb_resv_level;\n\t} else {\n\t\tbits = 4 << osb->osb_dir_resv_level;\n\t}\n\treturn bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&resv_lock"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_resmap_disabled",
          "args": [
            "resmap"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resmap_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "79-84",
          "snippet": "static inline int ocfs2_resmap_disabled(struct ocfs2_reservation_map *resmap)\n{\n\tif (resmap->m_osb->osb_resv_level == 0)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int ocfs2_resmap_disabled(struct ocfs2_reservation_map *resmap)\n{\n\tif (resmap->m_osb->osb_resv_level == 0)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(resv_lock);\n\nint ocfs2_resmap_resv_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t   struct ocfs2_alloc_reservation *resv,\n\t\t\t   int *cstart, int *clen)\n{\n\tif (resv == NULL || ocfs2_resmap_disabled(resmap))\n\t\treturn -ENOSPC;\n\n\tspin_lock(&resv_lock);\n\n\tif (ocfs2_resv_empty(resv)) {\n\t\t/*\n\t\t * We don't want to over-allocate for temporary\n\t\t * windows. Otherwise, we run the risk of fragmenting the\n\t\t * allocation space.\n\t\t */\n\t\tunsigned int wanted = ocfs2_resv_window_bits(resmap, resv);\n\n\t\tif ((resv->r_flags & OCFS2_RESV_FLAG_TMP) || wanted < *clen)\n\t\t\twanted = *clen;\n\n\t\t/*\n\t\t * Try to get a window here. If it works, we must fall\n\t\t * through and test the bitmap . This avoids some\n\t\t * ping-ponging of windows due to non-reserved space\n\t\t * being allocation before we initialize a window for\n\t\t * that inode.\n\t\t */\n\t\tocfs2_resv_find_window(resmap, resv, wanted);\n\t\ttrace_ocfs2_resmap_resv_bits(resv->r_start, resv->r_len);\n\t}\n\n\tBUG_ON(ocfs2_resv_empty(resv));\n\n\t*cstart = resv->r_start;\n\t*clen = resv->r_len;\n\n\tspin_unlock(&resv_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_resv_find_window",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
    "lines": "691-725",
    "snippet": "static void ocfs2_resv_find_window(struct ocfs2_reservation_map *resmap,\n\t\t\t\t   struct ocfs2_alloc_reservation *resv,\n\t\t\t\t   unsigned int wanted)\n{\n\tunsigned int goal = 0;\n\n\tBUG_ON(!ocfs2_resv_empty(resv));\n\n\t/*\n\t * Begin by trying to get a window as close to the previous\n\t * one as possible. Using the most recent allocation as a\n\t * start goal makes sense.\n\t */\n\tif (resv->r_last_len) {\n\t\tgoal = resv->r_last_start + resv->r_last_len;\n\t\tif (goal >= resmap->m_bitmap_len)\n\t\t\tgoal = 0;\n\t}\n\n\t__ocfs2_resv_find_window(resmap, resv, goal, wanted);\n\n\t/* Search from last alloc didn't work, try once more from beginning. */\n\tif (ocfs2_resv_empty(resv) && goal != 0)\n\t\t__ocfs2_resv_find_window(resmap, resv, 0, wanted);\n\n\tif (ocfs2_resv_empty(resv)) {\n\t\t/*\n\t\t * Still empty? Pull oldest one off the LRU, remove it from\n\t\t * tree, put this one in it's place.\n\t\t */\n\t\tocfs2_cannibalize_resv(resmap, resv, wanted);\n\t}\n\n\tBUG_ON(ocfs2_resv_empty(resv));\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ocfs2_resv_empty(resv)"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_resv_empty",
          "args": [
            "resv"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "74-77",
          "snippet": "static inline int ocfs2_resv_empty(struct ocfs2_alloc_reservation *resv)\n{\n\treturn !!(resv->r_len == 0);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int ocfs2_resv_empty(struct ocfs2_alloc_reservation *resv)\n{\n\treturn !!(resv->r_len == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_cannibalize_resv",
          "args": [
            "resmap",
            "resv",
            "wanted"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cannibalize_resv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "630-689",
          "snippet": "static void ocfs2_cannibalize_resv(struct ocfs2_reservation_map *resmap,\n\t\t\t\t   struct ocfs2_alloc_reservation *resv,\n\t\t\t\t   unsigned int wanted)\n{\n\tstruct ocfs2_alloc_reservation *lru_resv;\n\tint tmpwindow = !!(resv->r_flags & OCFS2_RESV_FLAG_TMP);\n\tunsigned int min_bits;\n\n\tif (!tmpwindow)\n\t\tmin_bits = ocfs2_resv_window_bits(resmap, resv) >> 1;\n\telse\n\t\tmin_bits = wanted; /* We at know the temp window will use all\n\t\t\t\t    * of these bits */\n\n\t/*\n\t * Take the first reservation off the LRU as our 'target'. We\n\t * don't try to be smart about it. There might be a case for\n\t * searching based on size but I don't have enough data to be\n\t * sure. --Mark (3/16/2010)\n\t */\n\tlru_resv = list_first_entry(&resmap->m_lru,\n\t\t\t\t    struct ocfs2_alloc_reservation, r_lru);\n\n\ttrace_ocfs2_cannibalize_resv_begin(lru_resv->r_start,\n\t\t\t\t\t   lru_resv->r_len,\n\t\t\t\t\t   ocfs2_resv_end(lru_resv));\n\n\t/*\n\t * Cannibalize (some or all) of the target reservation and\n\t * feed it to the current window.\n\t */\n\tif (lru_resv->r_len <= min_bits) {\n\t\t/*\n\t\t * Discard completely if size is less than or equal to a\n\t\t * reasonable threshold - 50% of window bits for non temporary\n\t\t * windows.\n\t\t */\n\t\tresv->r_start = lru_resv->r_start;\n\t\tresv->r_len = lru_resv->r_len;\n\n\t\t__ocfs2_resv_discard(resmap, lru_resv);\n\t} else {\n\t\tunsigned int shrink;\n\t\tif (tmpwindow)\n\t\t\tshrink = min_bits;\n\t\telse\n\t\t\tshrink = lru_resv->r_len / 2;\n\n\t\tlru_resv->r_len -= shrink;\n\n\t\tresv->r_start = ocfs2_resv_end(lru_resv) + 1;\n\t\tresv->r_len = shrink;\n\t}\n\n\ttrace_ocfs2_cannibalize_resv_end(resv->r_start, ocfs2_resv_end(resv),\n\t\t\t\t\t resv->r_len, resv->r_last_start,\n\t\t\t\t\t resv->r_last_len);\n\n\tocfs2_resv_insert(resmap, resv);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_cannibalize_resv(struct ocfs2_reservation_map *resmap,\n\t\t\t\t   struct ocfs2_alloc_reservation *resv,\n\t\t\t\t   unsigned int wanted)\n{\n\tstruct ocfs2_alloc_reservation *lru_resv;\n\tint tmpwindow = !!(resv->r_flags & OCFS2_RESV_FLAG_TMP);\n\tunsigned int min_bits;\n\n\tif (!tmpwindow)\n\t\tmin_bits = ocfs2_resv_window_bits(resmap, resv) >> 1;\n\telse\n\t\tmin_bits = wanted; /* We at know the temp window will use all\n\t\t\t\t    * of these bits */\n\n\t/*\n\t * Take the first reservation off the LRU as our 'target'. We\n\t * don't try to be smart about it. There might be a case for\n\t * searching based on size but I don't have enough data to be\n\t * sure. --Mark (3/16/2010)\n\t */\n\tlru_resv = list_first_entry(&resmap->m_lru,\n\t\t\t\t    struct ocfs2_alloc_reservation, r_lru);\n\n\ttrace_ocfs2_cannibalize_resv_begin(lru_resv->r_start,\n\t\t\t\t\t   lru_resv->r_len,\n\t\t\t\t\t   ocfs2_resv_end(lru_resv));\n\n\t/*\n\t * Cannibalize (some or all) of the target reservation and\n\t * feed it to the current window.\n\t */\n\tif (lru_resv->r_len <= min_bits) {\n\t\t/*\n\t\t * Discard completely if size is less than or equal to a\n\t\t * reasonable threshold - 50% of window bits for non temporary\n\t\t * windows.\n\t\t */\n\t\tresv->r_start = lru_resv->r_start;\n\t\tresv->r_len = lru_resv->r_len;\n\n\t\t__ocfs2_resv_discard(resmap, lru_resv);\n\t} else {\n\t\tunsigned int shrink;\n\t\tif (tmpwindow)\n\t\t\tshrink = min_bits;\n\t\telse\n\t\t\tshrink = lru_resv->r_len / 2;\n\n\t\tlru_resv->r_len -= shrink;\n\n\t\tresv->r_start = ocfs2_resv_end(lru_resv) + 1;\n\t\tresv->r_len = shrink;\n\t}\n\n\ttrace_ocfs2_cannibalize_resv_end(resv->r_start, ocfs2_resv_end(resv),\n\t\t\t\t\t resv->r_len, resv->r_last_start,\n\t\t\t\t\t resv->r_last_len);\n\n\tocfs2_resv_insert(resmap, resv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ocfs2_resv_find_window",
          "args": [
            "resmap",
            "resv",
            "0",
            "wanted"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_resv_find_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "470-628",
          "snippet": "static void __ocfs2_resv_find_window(struct ocfs2_reservation_map *resmap,\n\t\t\t\t     struct ocfs2_alloc_reservation *resv,\n\t\t\t\t     unsigned int goal, unsigned int wanted)\n{\n\tstruct rb_root *root = &resmap->m_reservations;\n\tunsigned int gap_start, gap_end, gap_len;\n\tstruct ocfs2_alloc_reservation *prev_resv, *next_resv;\n\tstruct rb_node *prev, *next;\n\tunsigned int cstart, clen;\n\tunsigned int best_start = 0, best_len = 0;\n\n\t/*\n\t * Nasty cases to consider:\n\t *\n\t * - rbtree is empty\n\t * - our window should be first in all reservations\n\t * - our window should be last in all reservations\n\t * - need to make sure we don't go past end of bitmap\n\t */\n\ttrace_ocfs2_resv_find_window_begin(resv->r_start, ocfs2_resv_end(resv),\n\t\t\t\t\t   goal, wanted, RB_EMPTY_ROOT(root));\n\n\tassert_spin_locked(&resv_lock);\n\n\tif (RB_EMPTY_ROOT(root)) {\n\t\t/*\n\t\t * Easiest case - empty tree. We can just take\n\t\t * whatever window of free bits we want.\n\t\t */\n\t\tclen = ocfs2_resmap_find_free_bits(resmap, wanted, goal,\n\t\t\t\t\t\t   resmap->m_bitmap_len - goal,\n\t\t\t\t\t\t   &cstart, &clen);\n\n\t\t/*\n\t\t * This should never happen - the local alloc window\n\t\t * will always have free bits when we're called.\n\t\t */\n\t\tBUG_ON(goal == 0 && clen == 0);\n\n\t\tif (clen == 0)\n\t\t\treturn;\n\n\t\tresv->r_start = cstart;\n\t\tresv->r_len = clen;\n\n\t\tocfs2_resv_insert(resmap, resv);\n\t\treturn;\n\t}\n\n\tprev_resv = ocfs2_find_resv_lhs(resmap, goal);\n\n\tif (prev_resv == NULL) {\n\t\t/*\n\t\t * A NULL here means that the search code couldn't\n\t\t * find a window that starts before goal.\n\t\t *\n\t\t * However, we can take the first window after goal,\n\t\t * which is also by definition, the leftmost window in\n\t\t * the entire tree. If we can find free bits in the\n\t\t * gap between goal and the LHS window, then the\n\t\t * reservation can safely be placed there.\n\t\t *\n\t\t * Otherwise we fall back to a linear search, checking\n\t\t * the gaps in between windows for a place to\n\t\t * allocate.\n\t\t */\n\n\t\tnext = rb_first(root);\n\t\tnext_resv = rb_entry(next, struct ocfs2_alloc_reservation,\n\t\t\t\t     r_node);\n\n\t\t/*\n\t\t * The search should never return such a window. (see\n\t\t * comment above\n\t\t */\n\t\tif (next_resv->r_start <= goal) {\n\t\t\tmlog(ML_ERROR, \"goal: %u next_resv: start %u len %u\\n\",\n\t\t\t     goal, next_resv->r_start, next_resv->r_len);\n\t\t\tocfs2_dump_resv(resmap);\n\t\t\tBUG();\n\t\t}\n\n\t\tclen = ocfs2_resmap_find_free_bits(resmap, wanted, goal,\n\t\t\t\t\t\t   next_resv->r_start - goal,\n\t\t\t\t\t\t   &cstart, &clen);\n\t\tif (clen) {\n\t\t\tbest_len = clen;\n\t\t\tbest_start = cstart;\n\t\t\tif (best_len == wanted)\n\t\t\t\tgoto out_insert;\n\t\t}\n\n\t\tprev_resv = next_resv;\n\t\tnext_resv = NULL;\n\t}\n\n\ttrace_ocfs2_resv_find_window_prev(prev_resv->r_start,\n\t\t\t\t\t  ocfs2_resv_end(prev_resv));\n\n\tprev = &prev_resv->r_node;\n\n\t/* Now we do a linear search for a window, starting at 'prev_rsv' */\n\twhile (1) {\n\t\tnext = rb_next(prev);\n\t\tif (next) {\n\t\t\tnext_resv = rb_entry(next,\n\t\t\t\t\t     struct ocfs2_alloc_reservation,\n\t\t\t\t\t     r_node);\n\n\t\t\tgap_start = ocfs2_resv_end(prev_resv) + 1;\n\t\t\tgap_end = next_resv->r_start - 1;\n\t\t\tgap_len = gap_end - gap_start + 1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We're at the rightmost edge of the\n\t\t\t * tree. See if a reservation between this\n\t\t\t * window and the end of the bitmap will work.\n\t\t\t */\n\t\t\tgap_start = ocfs2_resv_end(prev_resv) + 1;\n\t\t\tgap_len = resmap->m_bitmap_len - gap_start;\n\t\t\tgap_end = resmap->m_bitmap_len - 1;\n\t\t}\n\n\t\ttrace_ocfs2_resv_find_window_next(next ? next_resv->r_start: -1,\n\t\t\t\t\tnext ? ocfs2_resv_end(next_resv) : -1);\n\t\t/*\n\t\t * No need to check this gap if we have already found\n\t\t * a larger region of free bits.\n\t\t */\n\t\tif (gap_len <= best_len)\n\t\t\tgoto next_resv;\n\n\t\tclen = ocfs2_resmap_find_free_bits(resmap, wanted, gap_start,\n\t\t\t\t\t\t   gap_len, &cstart, &clen);\n\t\tif (clen == wanted) {\n\t\t\tbest_len = clen;\n\t\t\tbest_start = cstart;\n\t\t\tgoto out_insert;\n\t\t} else if (clen > best_len) {\n\t\t\tbest_len = clen;\n\t\t\tbest_start = cstart;\n\t\t}\n\nnext_resv:\n\t\tif (!next)\n\t\t\tbreak;\n\n\t\tprev = next;\n\t\tprev_resv = rb_entry(prev, struct ocfs2_alloc_reservation,\n\t\t\t\t     r_node);\n\t}\n\nout_insert:\n\tif (best_len) {\n\t\tresv->r_start = best_start;\n\t\tresv->r_len = best_len;\n\t\tocfs2_resv_insert(resmap, resv);\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(resv_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(resv_lock);\n\nstatic void __ocfs2_resv_find_window(struct ocfs2_reservation_map *resmap,\n\t\t\t\t     struct ocfs2_alloc_reservation *resv,\n\t\t\t\t     unsigned int goal, unsigned int wanted)\n{\n\tstruct rb_root *root = &resmap->m_reservations;\n\tunsigned int gap_start, gap_end, gap_len;\n\tstruct ocfs2_alloc_reservation *prev_resv, *next_resv;\n\tstruct rb_node *prev, *next;\n\tunsigned int cstart, clen;\n\tunsigned int best_start = 0, best_len = 0;\n\n\t/*\n\t * Nasty cases to consider:\n\t *\n\t * - rbtree is empty\n\t * - our window should be first in all reservations\n\t * - our window should be last in all reservations\n\t * - need to make sure we don't go past end of bitmap\n\t */\n\ttrace_ocfs2_resv_find_window_begin(resv->r_start, ocfs2_resv_end(resv),\n\t\t\t\t\t   goal, wanted, RB_EMPTY_ROOT(root));\n\n\tassert_spin_locked(&resv_lock);\n\n\tif (RB_EMPTY_ROOT(root)) {\n\t\t/*\n\t\t * Easiest case - empty tree. We can just take\n\t\t * whatever window of free bits we want.\n\t\t */\n\t\tclen = ocfs2_resmap_find_free_bits(resmap, wanted, goal,\n\t\t\t\t\t\t   resmap->m_bitmap_len - goal,\n\t\t\t\t\t\t   &cstart, &clen);\n\n\t\t/*\n\t\t * This should never happen - the local alloc window\n\t\t * will always have free bits when we're called.\n\t\t */\n\t\tBUG_ON(goal == 0 && clen == 0);\n\n\t\tif (clen == 0)\n\t\t\treturn;\n\n\t\tresv->r_start = cstart;\n\t\tresv->r_len = clen;\n\n\t\tocfs2_resv_insert(resmap, resv);\n\t\treturn;\n\t}\n\n\tprev_resv = ocfs2_find_resv_lhs(resmap, goal);\n\n\tif (prev_resv == NULL) {\n\t\t/*\n\t\t * A NULL here means that the search code couldn't\n\t\t * find a window that starts before goal.\n\t\t *\n\t\t * However, we can take the first window after goal,\n\t\t * which is also by definition, the leftmost window in\n\t\t * the entire tree. If we can find free bits in the\n\t\t * gap between goal and the LHS window, then the\n\t\t * reservation can safely be placed there.\n\t\t *\n\t\t * Otherwise we fall back to a linear search, checking\n\t\t * the gaps in between windows for a place to\n\t\t * allocate.\n\t\t */\n\n\t\tnext = rb_first(root);\n\t\tnext_resv = rb_entry(next, struct ocfs2_alloc_reservation,\n\t\t\t\t     r_node);\n\n\t\t/*\n\t\t * The search should never return such a window. (see\n\t\t * comment above\n\t\t */\n\t\tif (next_resv->r_start <= goal) {\n\t\t\tmlog(ML_ERROR, \"goal: %u next_resv: start %u len %u\\n\",\n\t\t\t     goal, next_resv->r_start, next_resv->r_len);\n\t\t\tocfs2_dump_resv(resmap);\n\t\t\tBUG();\n\t\t}\n\n\t\tclen = ocfs2_resmap_find_free_bits(resmap, wanted, goal,\n\t\t\t\t\t\t   next_resv->r_start - goal,\n\t\t\t\t\t\t   &cstart, &clen);\n\t\tif (clen) {\n\t\t\tbest_len = clen;\n\t\t\tbest_start = cstart;\n\t\t\tif (best_len == wanted)\n\t\t\t\tgoto out_insert;\n\t\t}\n\n\t\tprev_resv = next_resv;\n\t\tnext_resv = NULL;\n\t}\n\n\ttrace_ocfs2_resv_find_window_prev(prev_resv->r_start,\n\t\t\t\t\t  ocfs2_resv_end(prev_resv));\n\n\tprev = &prev_resv->r_node;\n\n\t/* Now we do a linear search for a window, starting at 'prev_rsv' */\n\twhile (1) {\n\t\tnext = rb_next(prev);\n\t\tif (next) {\n\t\t\tnext_resv = rb_entry(next,\n\t\t\t\t\t     struct ocfs2_alloc_reservation,\n\t\t\t\t\t     r_node);\n\n\t\t\tgap_start = ocfs2_resv_end(prev_resv) + 1;\n\t\t\tgap_end = next_resv->r_start - 1;\n\t\t\tgap_len = gap_end - gap_start + 1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We're at the rightmost edge of the\n\t\t\t * tree. See if a reservation between this\n\t\t\t * window and the end of the bitmap will work.\n\t\t\t */\n\t\t\tgap_start = ocfs2_resv_end(prev_resv) + 1;\n\t\t\tgap_len = resmap->m_bitmap_len - gap_start;\n\t\t\tgap_end = resmap->m_bitmap_len - 1;\n\t\t}\n\n\t\ttrace_ocfs2_resv_find_window_next(next ? next_resv->r_start: -1,\n\t\t\t\t\tnext ? ocfs2_resv_end(next_resv) : -1);\n\t\t/*\n\t\t * No need to check this gap if we have already found\n\t\t * a larger region of free bits.\n\t\t */\n\t\tif (gap_len <= best_len)\n\t\t\tgoto next_resv;\n\n\t\tclen = ocfs2_resmap_find_free_bits(resmap, wanted, gap_start,\n\t\t\t\t\t\t   gap_len, &cstart, &clen);\n\t\tif (clen == wanted) {\n\t\t\tbest_len = clen;\n\t\t\tbest_start = cstart;\n\t\t\tgoto out_insert;\n\t\t} else if (clen > best_len) {\n\t\t\tbest_len = clen;\n\t\t\tbest_start = cstart;\n\t\t}\n\nnext_resv:\n\t\tif (!next)\n\t\t\tbreak;\n\n\t\tprev = next;\n\t\tprev_resv = rb_entry(prev, struct ocfs2_alloc_reservation,\n\t\t\t\t     r_node);\n\t}\n\nout_insert:\n\tif (best_len) {\n\t\tresv->r_start = best_start;\n\t\tresv->r_len = best_len;\n\t\tocfs2_resv_insert(resmap, resv);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ocfs2_resv_empty(resv)"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_resv_find_window(struct ocfs2_reservation_map *resmap,\n\t\t\t\t   struct ocfs2_alloc_reservation *resv,\n\t\t\t\t   unsigned int wanted)\n{\n\tunsigned int goal = 0;\n\n\tBUG_ON(!ocfs2_resv_empty(resv));\n\n\t/*\n\t * Begin by trying to get a window as close to the previous\n\t * one as possible. Using the most recent allocation as a\n\t * start goal makes sense.\n\t */\n\tif (resv->r_last_len) {\n\t\tgoal = resv->r_last_start + resv->r_last_len;\n\t\tif (goal >= resmap->m_bitmap_len)\n\t\t\tgoal = 0;\n\t}\n\n\t__ocfs2_resv_find_window(resmap, resv, goal, wanted);\n\n\t/* Search from last alloc didn't work, try once more from beginning. */\n\tif (ocfs2_resv_empty(resv) && goal != 0)\n\t\t__ocfs2_resv_find_window(resmap, resv, 0, wanted);\n\n\tif (ocfs2_resv_empty(resv)) {\n\t\t/*\n\t\t * Still empty? Pull oldest one off the LRU, remove it from\n\t\t * tree, put this one in it's place.\n\t\t */\n\t\tocfs2_cannibalize_resv(resmap, resv, wanted);\n\t}\n\n\tBUG_ON(ocfs2_resv_empty(resv));\n}"
  },
  {
    "function_name": "ocfs2_cannibalize_resv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
    "lines": "630-689",
    "snippet": "static void ocfs2_cannibalize_resv(struct ocfs2_reservation_map *resmap,\n\t\t\t\t   struct ocfs2_alloc_reservation *resv,\n\t\t\t\t   unsigned int wanted)\n{\n\tstruct ocfs2_alloc_reservation *lru_resv;\n\tint tmpwindow = !!(resv->r_flags & OCFS2_RESV_FLAG_TMP);\n\tunsigned int min_bits;\n\n\tif (!tmpwindow)\n\t\tmin_bits = ocfs2_resv_window_bits(resmap, resv) >> 1;\n\telse\n\t\tmin_bits = wanted; /* We at know the temp window will use all\n\t\t\t\t    * of these bits */\n\n\t/*\n\t * Take the first reservation off the LRU as our 'target'. We\n\t * don't try to be smart about it. There might be a case for\n\t * searching based on size but I don't have enough data to be\n\t * sure. --Mark (3/16/2010)\n\t */\n\tlru_resv = list_first_entry(&resmap->m_lru,\n\t\t\t\t    struct ocfs2_alloc_reservation, r_lru);\n\n\ttrace_ocfs2_cannibalize_resv_begin(lru_resv->r_start,\n\t\t\t\t\t   lru_resv->r_len,\n\t\t\t\t\t   ocfs2_resv_end(lru_resv));\n\n\t/*\n\t * Cannibalize (some or all) of the target reservation and\n\t * feed it to the current window.\n\t */\n\tif (lru_resv->r_len <= min_bits) {\n\t\t/*\n\t\t * Discard completely if size is less than or equal to a\n\t\t * reasonable threshold - 50% of window bits for non temporary\n\t\t * windows.\n\t\t */\n\t\tresv->r_start = lru_resv->r_start;\n\t\tresv->r_len = lru_resv->r_len;\n\n\t\t__ocfs2_resv_discard(resmap, lru_resv);\n\t} else {\n\t\tunsigned int shrink;\n\t\tif (tmpwindow)\n\t\t\tshrink = min_bits;\n\t\telse\n\t\t\tshrink = lru_resv->r_len / 2;\n\n\t\tlru_resv->r_len -= shrink;\n\n\t\tresv->r_start = ocfs2_resv_end(lru_resv) + 1;\n\t\tresv->r_len = shrink;\n\t}\n\n\ttrace_ocfs2_cannibalize_resv_end(resv->r_start, ocfs2_resv_end(resv),\n\t\t\t\t\t resv->r_len, resv->r_last_start,\n\t\t\t\t\t resv->r_last_len);\n\n\tocfs2_resv_insert(resmap, resv);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_resv_insert",
          "args": [
            "resmap",
            "resv"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "314-355",
          "snippet": "static void ocfs2_resv_insert(struct ocfs2_reservation_map *resmap,\n\t\t\t      struct ocfs2_alloc_reservation *new)\n{\n\tstruct rb_root *root = &resmap->m_reservations;\n\tstruct rb_node *parent = NULL;\n\tstruct rb_node **p = &root->rb_node;\n\tstruct ocfs2_alloc_reservation *tmp;\n\n\tassert_spin_locked(&resv_lock);\n\n\ttrace_ocfs2_resv_insert(new->r_start, new->r_len);\n\n\twhile (*p) {\n\t\tparent = *p;\n\n\t\ttmp = rb_entry(parent, struct ocfs2_alloc_reservation, r_node);\n\n\t\tif (new->r_start < tmp->r_start) {\n\t\t\tp = &(*p)->rb_left;\n\n\t\t\t/*\n\t\t\t * This is a good place to check for\n\t\t\t * overlapping reservations.\n\t\t\t */\n\t\t\tBUG_ON(ocfs2_resv_end(new) >= tmp->r_start);\n\t\t} else if (new->r_start > ocfs2_resv_end(tmp)) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\t/* This should never happen! */\n\t\t\tmlog(ML_ERROR, \"Duplicate reservation window!\\n\");\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(&new->r_node, parent, p);\n\trb_insert_color(&new->r_node, root);\n\tnew->r_flags |= OCFS2_RESV_FLAG_INUSE;\n\n\tocfs2_resv_mark_lru(resmap, new);\n\n\tocfs2_check_resmap(resmap);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(resv_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(resv_lock);\n\nstatic void ocfs2_resv_insert(struct ocfs2_reservation_map *resmap,\n\t\t\t      struct ocfs2_alloc_reservation *new)\n{\n\tstruct rb_root *root = &resmap->m_reservations;\n\tstruct rb_node *parent = NULL;\n\tstruct rb_node **p = &root->rb_node;\n\tstruct ocfs2_alloc_reservation *tmp;\n\n\tassert_spin_locked(&resv_lock);\n\n\ttrace_ocfs2_resv_insert(new->r_start, new->r_len);\n\n\twhile (*p) {\n\t\tparent = *p;\n\n\t\ttmp = rb_entry(parent, struct ocfs2_alloc_reservation, r_node);\n\n\t\tif (new->r_start < tmp->r_start) {\n\t\t\tp = &(*p)->rb_left;\n\n\t\t\t/*\n\t\t\t * This is a good place to check for\n\t\t\t * overlapping reservations.\n\t\t\t */\n\t\t\tBUG_ON(ocfs2_resv_end(new) >= tmp->r_start);\n\t\t} else if (new->r_start > ocfs2_resv_end(tmp)) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\t/* This should never happen! */\n\t\t\tmlog(ML_ERROR, \"Duplicate reservation window!\\n\");\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(&new->r_node, parent, p);\n\trb_insert_color(&new->r_node, root);\n\tnew->r_flags |= OCFS2_RESV_FLAG_INUSE;\n\n\tocfs2_resv_mark_lru(resmap, new);\n\n\tocfs2_check_resmap(resmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_cannibalize_resv_end",
          "args": [
            "resv->r_start",
            "ocfs2_resv_end(resv)",
            "resv->r_len",
            "resv->r_last_start",
            "resv->r_last_len"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_resv_end",
          "args": [
            "resv"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "67-72",
          "snippet": "static inline unsigned int ocfs2_resv_end(struct ocfs2_alloc_reservation *resv)\n{\n\tif (resv->r_len)\n\t\treturn resv->r_start + resv->r_len - 1;\n\treturn resv->r_start;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ocfs2_resv_end(struct ocfs2_alloc_reservation *resv)\n{\n\tif (resv->r_len)\n\t\treturn resv->r_start + resv->r_len - 1;\n\treturn resv->r_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ocfs2_resv_discard",
          "args": [
            "resmap",
            "lru_resv"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_resv_discard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "254-267",
          "snippet": "static void __ocfs2_resv_discard(struct ocfs2_reservation_map *resmap,\n\t\t\t\t struct ocfs2_alloc_reservation *resv)\n{\n\tassert_spin_locked(&resv_lock);\n\n\t__ocfs2_resv_trunc(resv);\n\t/*\n\t * last_len and last_start no longer make sense if\n\t * we're changing the range of our allocations.\n\t */\n\tresv->r_last_len = resv->r_last_start = 0;\n\n\tocfs2_resv_remove(resmap, resv);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(resv_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(resv_lock);\n\nstatic void __ocfs2_resv_discard(struct ocfs2_reservation_map *resmap,\n\t\t\t\t struct ocfs2_alloc_reservation *resv)\n{\n\tassert_spin_locked(&resv_lock);\n\n\t__ocfs2_resv_trunc(resv);\n\t/*\n\t * last_len and last_start no longer make sense if\n\t * we're changing the range of our allocations.\n\t */\n\tresv->r_last_len = resv->r_last_start = 0;\n\n\tocfs2_resv_remove(resmap, resv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_cannibalize_resv_begin",
          "args": [
            "lru_resv->r_start",
            "lru_resv->r_len",
            "ocfs2_resv_end(lru_resv)"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&resmap->m_lru",
            "structocfs2_alloc_reservation",
            "r_lru"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_resv_window_bits",
          "args": [
            "resmap",
            "resv"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_window_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "52-65",
          "snippet": "static unsigned int ocfs2_resv_window_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t\t\t   struct ocfs2_alloc_reservation *resv)\n{\n\tstruct ocfs2_super *osb = resmap->m_osb;\n\tunsigned int bits;\n\n\tif (!(resv->r_flags & OCFS2_RESV_FLAG_DIR)) {\n\t\t/* 8, 16, 32, 64, 128, 256, 512, 1024 */\n\t\tbits = 4 << osb->osb_resv_level;\n\t} else {\n\t\tbits = 4 << osb->osb_dir_resv_level;\n\t}\n\treturn bits;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic unsigned int ocfs2_resv_window_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t\t\t   struct ocfs2_alloc_reservation *resv)\n{\n\tstruct ocfs2_super *osb = resmap->m_osb;\n\tunsigned int bits;\n\n\tif (!(resv->r_flags & OCFS2_RESV_FLAG_DIR)) {\n\t\t/* 8, 16, 32, 64, 128, 256, 512, 1024 */\n\t\tbits = 4 << osb->osb_resv_level;\n\t} else {\n\t\tbits = 4 << osb->osb_dir_resv_level;\n\t}\n\treturn bits;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_cannibalize_resv(struct ocfs2_reservation_map *resmap,\n\t\t\t\t   struct ocfs2_alloc_reservation *resv,\n\t\t\t\t   unsigned int wanted)\n{\n\tstruct ocfs2_alloc_reservation *lru_resv;\n\tint tmpwindow = !!(resv->r_flags & OCFS2_RESV_FLAG_TMP);\n\tunsigned int min_bits;\n\n\tif (!tmpwindow)\n\t\tmin_bits = ocfs2_resv_window_bits(resmap, resv) >> 1;\n\telse\n\t\tmin_bits = wanted; /* We at know the temp window will use all\n\t\t\t\t    * of these bits */\n\n\t/*\n\t * Take the first reservation off the LRU as our 'target'. We\n\t * don't try to be smart about it. There might be a case for\n\t * searching based on size but I don't have enough data to be\n\t * sure. --Mark (3/16/2010)\n\t */\n\tlru_resv = list_first_entry(&resmap->m_lru,\n\t\t\t\t    struct ocfs2_alloc_reservation, r_lru);\n\n\ttrace_ocfs2_cannibalize_resv_begin(lru_resv->r_start,\n\t\t\t\t\t   lru_resv->r_len,\n\t\t\t\t\t   ocfs2_resv_end(lru_resv));\n\n\t/*\n\t * Cannibalize (some or all) of the target reservation and\n\t * feed it to the current window.\n\t */\n\tif (lru_resv->r_len <= min_bits) {\n\t\t/*\n\t\t * Discard completely if size is less than or equal to a\n\t\t * reasonable threshold - 50% of window bits for non temporary\n\t\t * windows.\n\t\t */\n\t\tresv->r_start = lru_resv->r_start;\n\t\tresv->r_len = lru_resv->r_len;\n\n\t\t__ocfs2_resv_discard(resmap, lru_resv);\n\t} else {\n\t\tunsigned int shrink;\n\t\tif (tmpwindow)\n\t\t\tshrink = min_bits;\n\t\telse\n\t\t\tshrink = lru_resv->r_len / 2;\n\n\t\tlru_resv->r_len -= shrink;\n\n\t\tresv->r_start = ocfs2_resv_end(lru_resv) + 1;\n\t\tresv->r_len = shrink;\n\t}\n\n\ttrace_ocfs2_cannibalize_resv_end(resv->r_start, ocfs2_resv_end(resv),\n\t\t\t\t\t resv->r_len, resv->r_last_start,\n\t\t\t\t\t resv->r_last_len);\n\n\tocfs2_resv_insert(resmap, resv);\n}"
  },
  {
    "function_name": "__ocfs2_resv_find_window",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
    "lines": "470-628",
    "snippet": "static void __ocfs2_resv_find_window(struct ocfs2_reservation_map *resmap,\n\t\t\t\t     struct ocfs2_alloc_reservation *resv,\n\t\t\t\t     unsigned int goal, unsigned int wanted)\n{\n\tstruct rb_root *root = &resmap->m_reservations;\n\tunsigned int gap_start, gap_end, gap_len;\n\tstruct ocfs2_alloc_reservation *prev_resv, *next_resv;\n\tstruct rb_node *prev, *next;\n\tunsigned int cstart, clen;\n\tunsigned int best_start = 0, best_len = 0;\n\n\t/*\n\t * Nasty cases to consider:\n\t *\n\t * - rbtree is empty\n\t * - our window should be first in all reservations\n\t * - our window should be last in all reservations\n\t * - need to make sure we don't go past end of bitmap\n\t */\n\ttrace_ocfs2_resv_find_window_begin(resv->r_start, ocfs2_resv_end(resv),\n\t\t\t\t\t   goal, wanted, RB_EMPTY_ROOT(root));\n\n\tassert_spin_locked(&resv_lock);\n\n\tif (RB_EMPTY_ROOT(root)) {\n\t\t/*\n\t\t * Easiest case - empty tree. We can just take\n\t\t * whatever window of free bits we want.\n\t\t */\n\t\tclen = ocfs2_resmap_find_free_bits(resmap, wanted, goal,\n\t\t\t\t\t\t   resmap->m_bitmap_len - goal,\n\t\t\t\t\t\t   &cstart, &clen);\n\n\t\t/*\n\t\t * This should never happen - the local alloc window\n\t\t * will always have free bits when we're called.\n\t\t */\n\t\tBUG_ON(goal == 0 && clen == 0);\n\n\t\tif (clen == 0)\n\t\t\treturn;\n\n\t\tresv->r_start = cstart;\n\t\tresv->r_len = clen;\n\n\t\tocfs2_resv_insert(resmap, resv);\n\t\treturn;\n\t}\n\n\tprev_resv = ocfs2_find_resv_lhs(resmap, goal);\n\n\tif (prev_resv == NULL) {\n\t\t/*\n\t\t * A NULL here means that the search code couldn't\n\t\t * find a window that starts before goal.\n\t\t *\n\t\t * However, we can take the first window after goal,\n\t\t * which is also by definition, the leftmost window in\n\t\t * the entire tree. If we can find free bits in the\n\t\t * gap between goal and the LHS window, then the\n\t\t * reservation can safely be placed there.\n\t\t *\n\t\t * Otherwise we fall back to a linear search, checking\n\t\t * the gaps in between windows for a place to\n\t\t * allocate.\n\t\t */\n\n\t\tnext = rb_first(root);\n\t\tnext_resv = rb_entry(next, struct ocfs2_alloc_reservation,\n\t\t\t\t     r_node);\n\n\t\t/*\n\t\t * The search should never return such a window. (see\n\t\t * comment above\n\t\t */\n\t\tif (next_resv->r_start <= goal) {\n\t\t\tmlog(ML_ERROR, \"goal: %u next_resv: start %u len %u\\n\",\n\t\t\t     goal, next_resv->r_start, next_resv->r_len);\n\t\t\tocfs2_dump_resv(resmap);\n\t\t\tBUG();\n\t\t}\n\n\t\tclen = ocfs2_resmap_find_free_bits(resmap, wanted, goal,\n\t\t\t\t\t\t   next_resv->r_start - goal,\n\t\t\t\t\t\t   &cstart, &clen);\n\t\tif (clen) {\n\t\t\tbest_len = clen;\n\t\t\tbest_start = cstart;\n\t\t\tif (best_len == wanted)\n\t\t\t\tgoto out_insert;\n\t\t}\n\n\t\tprev_resv = next_resv;\n\t\tnext_resv = NULL;\n\t}\n\n\ttrace_ocfs2_resv_find_window_prev(prev_resv->r_start,\n\t\t\t\t\t  ocfs2_resv_end(prev_resv));\n\n\tprev = &prev_resv->r_node;\n\n\t/* Now we do a linear search for a window, starting at 'prev_rsv' */\n\twhile (1) {\n\t\tnext = rb_next(prev);\n\t\tif (next) {\n\t\t\tnext_resv = rb_entry(next,\n\t\t\t\t\t     struct ocfs2_alloc_reservation,\n\t\t\t\t\t     r_node);\n\n\t\t\tgap_start = ocfs2_resv_end(prev_resv) + 1;\n\t\t\tgap_end = next_resv->r_start - 1;\n\t\t\tgap_len = gap_end - gap_start + 1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We're at the rightmost edge of the\n\t\t\t * tree. See if a reservation between this\n\t\t\t * window and the end of the bitmap will work.\n\t\t\t */\n\t\t\tgap_start = ocfs2_resv_end(prev_resv) + 1;\n\t\t\tgap_len = resmap->m_bitmap_len - gap_start;\n\t\t\tgap_end = resmap->m_bitmap_len - 1;\n\t\t}\n\n\t\ttrace_ocfs2_resv_find_window_next(next ? next_resv->r_start: -1,\n\t\t\t\t\tnext ? ocfs2_resv_end(next_resv) : -1);\n\t\t/*\n\t\t * No need to check this gap if we have already found\n\t\t * a larger region of free bits.\n\t\t */\n\t\tif (gap_len <= best_len)\n\t\t\tgoto next_resv;\n\n\t\tclen = ocfs2_resmap_find_free_bits(resmap, wanted, gap_start,\n\t\t\t\t\t\t   gap_len, &cstart, &clen);\n\t\tif (clen == wanted) {\n\t\t\tbest_len = clen;\n\t\t\tbest_start = cstart;\n\t\t\tgoto out_insert;\n\t\t} else if (clen > best_len) {\n\t\t\tbest_len = clen;\n\t\t\tbest_start = cstart;\n\t\t}\n\nnext_resv:\n\t\tif (!next)\n\t\t\tbreak;\n\n\t\tprev = next;\n\t\tprev_resv = rb_entry(prev, struct ocfs2_alloc_reservation,\n\t\t\t\t     r_node);\n\t}\n\nout_insert:\n\tif (best_len) {\n\t\tresv->r_start = best_start;\n\t\tresv->r_len = best_len;\n\t\tocfs2_resv_insert(resmap, resv);\n\t}\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(resv_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_resv_insert",
          "args": [
            "resmap",
            "resv"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "314-355",
          "snippet": "static void ocfs2_resv_insert(struct ocfs2_reservation_map *resmap,\n\t\t\t      struct ocfs2_alloc_reservation *new)\n{\n\tstruct rb_root *root = &resmap->m_reservations;\n\tstruct rb_node *parent = NULL;\n\tstruct rb_node **p = &root->rb_node;\n\tstruct ocfs2_alloc_reservation *tmp;\n\n\tassert_spin_locked(&resv_lock);\n\n\ttrace_ocfs2_resv_insert(new->r_start, new->r_len);\n\n\twhile (*p) {\n\t\tparent = *p;\n\n\t\ttmp = rb_entry(parent, struct ocfs2_alloc_reservation, r_node);\n\n\t\tif (new->r_start < tmp->r_start) {\n\t\t\tp = &(*p)->rb_left;\n\n\t\t\t/*\n\t\t\t * This is a good place to check for\n\t\t\t * overlapping reservations.\n\t\t\t */\n\t\t\tBUG_ON(ocfs2_resv_end(new) >= tmp->r_start);\n\t\t} else if (new->r_start > ocfs2_resv_end(tmp)) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\t/* This should never happen! */\n\t\t\tmlog(ML_ERROR, \"Duplicate reservation window!\\n\");\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(&new->r_node, parent, p);\n\trb_insert_color(&new->r_node, root);\n\tnew->r_flags |= OCFS2_RESV_FLAG_INUSE;\n\n\tocfs2_resv_mark_lru(resmap, new);\n\n\tocfs2_check_resmap(resmap);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(resv_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(resv_lock);\n\nstatic void ocfs2_resv_insert(struct ocfs2_reservation_map *resmap,\n\t\t\t      struct ocfs2_alloc_reservation *new)\n{\n\tstruct rb_root *root = &resmap->m_reservations;\n\tstruct rb_node *parent = NULL;\n\tstruct rb_node **p = &root->rb_node;\n\tstruct ocfs2_alloc_reservation *tmp;\n\n\tassert_spin_locked(&resv_lock);\n\n\ttrace_ocfs2_resv_insert(new->r_start, new->r_len);\n\n\twhile (*p) {\n\t\tparent = *p;\n\n\t\ttmp = rb_entry(parent, struct ocfs2_alloc_reservation, r_node);\n\n\t\tif (new->r_start < tmp->r_start) {\n\t\t\tp = &(*p)->rb_left;\n\n\t\t\t/*\n\t\t\t * This is a good place to check for\n\t\t\t * overlapping reservations.\n\t\t\t */\n\t\t\tBUG_ON(ocfs2_resv_end(new) >= tmp->r_start);\n\t\t} else if (new->r_start > ocfs2_resv_end(tmp)) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\t/* This should never happen! */\n\t\t\tmlog(ML_ERROR, \"Duplicate reservation window!\\n\");\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(&new->r_node, parent, p);\n\trb_insert_color(&new->r_node, root);\n\tnew->r_flags |= OCFS2_RESV_FLAG_INUSE;\n\n\tocfs2_resv_mark_lru(resmap, new);\n\n\tocfs2_check_resmap(resmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "prev",
            "structocfs2_alloc_reservation",
            "r_node"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_resmap_find_free_bits",
          "args": [
            "resmap",
            "wanted",
            "gap_start",
            "gap_len",
            "&cstart",
            "&clen"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resmap_find_free_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "414-468",
          "snippet": "static int ocfs2_resmap_find_free_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t\t       unsigned int wanted,\n\t\t\t\t       unsigned int search_start,\n\t\t\t\t       unsigned int search_len,\n\t\t\t\t       unsigned int *rstart,\n\t\t\t\t       unsigned int *rlen)\n{\n\tvoid *bitmap = resmap->m_disk_bitmap;\n\tunsigned int best_start, best_len = 0;\n\tint offset, start, found;\n\n\ttrace_ocfs2_resmap_find_free_bits_begin(search_start, search_len,\n\t\t\t\t\t\twanted, resmap->m_bitmap_len);\n\n\tfound = best_start = best_len = 0;\n\n\tstart = search_start;\n\twhile ((offset = ocfs2_find_next_zero_bit(bitmap, resmap->m_bitmap_len,\n\t\t\t\t\t\t start)) != -1) {\n\t\t/* Search reached end of the region */\n\t\tif (offset >= (search_start + search_len))\n\t\t\tbreak;\n\n\t\tif (offset == start) {\n\t\t\t/* we found a zero */\n\t\t\tfound++;\n\t\t\t/* move start to the next bit to test */\n\t\t\tstart++;\n\t\t} else {\n\t\t\t/* got a zero after some ones */\n\t\t\tfound = 1;\n\t\t\tstart = offset + 1;\n\t\t}\n\t\tif (found > best_len) {\n\t\t\tbest_len = found;\n\t\t\tbest_start = start - found;\n\t\t}\n\n\t\tif (found >= wanted)\n\t\t\tbreak;\n\t}\n\n\tif (best_len == 0)\n\t\treturn 0;\n\n\tif (best_len >= wanted)\n\t\tbest_len = wanted;\n\n\t*rlen = best_len;\n\t*rstart = best_start;\n\n\ttrace_ocfs2_resmap_find_free_bits_end(best_start, best_len);\n\n\treturn *rlen;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_resmap_find_free_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t\t       unsigned int wanted,\n\t\t\t\t       unsigned int search_start,\n\t\t\t\t       unsigned int search_len,\n\t\t\t\t       unsigned int *rstart,\n\t\t\t\t       unsigned int *rlen)\n{\n\tvoid *bitmap = resmap->m_disk_bitmap;\n\tunsigned int best_start, best_len = 0;\n\tint offset, start, found;\n\n\ttrace_ocfs2_resmap_find_free_bits_begin(search_start, search_len,\n\t\t\t\t\t\twanted, resmap->m_bitmap_len);\n\n\tfound = best_start = best_len = 0;\n\n\tstart = search_start;\n\twhile ((offset = ocfs2_find_next_zero_bit(bitmap, resmap->m_bitmap_len,\n\t\t\t\t\t\t start)) != -1) {\n\t\t/* Search reached end of the region */\n\t\tif (offset >= (search_start + search_len))\n\t\t\tbreak;\n\n\t\tif (offset == start) {\n\t\t\t/* we found a zero */\n\t\t\tfound++;\n\t\t\t/* move start to the next bit to test */\n\t\t\tstart++;\n\t\t} else {\n\t\t\t/* got a zero after some ones */\n\t\t\tfound = 1;\n\t\t\tstart = offset + 1;\n\t\t}\n\t\tif (found > best_len) {\n\t\t\tbest_len = found;\n\t\t\tbest_start = start - found;\n\t\t}\n\n\t\tif (found >= wanted)\n\t\t\tbreak;\n\t}\n\n\tif (best_len == 0)\n\t\treturn 0;\n\n\tif (best_len >= wanted)\n\t\tbest_len = wanted;\n\n\t*rlen = best_len;\n\t*rstart = best_start;\n\n\ttrace_ocfs2_resmap_find_free_bits_end(best_start, best_len);\n\n\treturn *rlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_resv_find_window_next",
          "args": [
            "next ? next_resv->r_start: -1",
            "next ? ocfs2_resv_end(next_resv) : -1"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_resv_end",
          "args": [
            "next_resv"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "67-72",
          "snippet": "static inline unsigned int ocfs2_resv_end(struct ocfs2_alloc_reservation *resv)\n{\n\tif (resv->r_len)\n\t\treturn resv->r_start + resv->r_len - 1;\n\treturn resv->r_start;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ocfs2_resv_end(struct ocfs2_alloc_reservation *resv)\n{\n\tif (resv->r_len)\n\t\treturn resv->r_start + resv->r_len - 1;\n\treturn resv->r_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "next",
            "structocfs2_alloc_reservation",
            "r_node"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "prev"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_resv_find_window_prev",
          "args": [
            "prev_resv->r_start",
            "ocfs2_resv_end(prev_resv)"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dump_resv",
          "args": [
            "resmap"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dump_resv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "86-120",
          "snippet": "static void ocfs2_dump_resv(struct ocfs2_reservation_map *resmap)\n{\n\tstruct ocfs2_super *osb = resmap->m_osb;\n\tstruct rb_node *node;\n\tstruct ocfs2_alloc_reservation *resv;\n\tint i = 0;\n\n\tmlog(ML_NOTICE, \"Dumping resmap for device %s. Bitmap length: %u\\n\",\n\t     osb->dev_str, resmap->m_bitmap_len);\n\n\tnode = rb_first(&resmap->m_reservations);\n\twhile (node) {\n\t\tresv = rb_entry(node, struct ocfs2_alloc_reservation, r_node);\n\n\t\tmlog(ML_NOTICE, \"start: %u\\tend: %u\\tlen: %u\\tlast_start: %u\"\n\t\t     \"\\tlast_len: %u\\n\", resv->r_start,\n\t\t     ocfs2_resv_end(resv), resv->r_len, resv->r_last_start,\n\t\t     resv->r_last_len);\n\n\t\tnode = rb_next(node);\n\t\ti++;\n\t}\n\n\tmlog(ML_NOTICE, \"%d reservations found. LRU follows\\n\", i);\n\n\ti = 0;\n\tlist_for_each_entry(resv, &resmap->m_lru, r_lru) {\n\t\tmlog(ML_NOTICE, \"LRU(%d) start: %u\\tend: %u\\tlen: %u\\t\"\n\t\t     \"last_start: %u\\tlast_len: %u\\n\", i, resv->r_start,\n\t\t     ocfs2_resv_end(resv), resv->r_len, resv->r_last_start,\n\t\t     resv->r_last_len);\n\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dump_resv(struct ocfs2_reservation_map *resmap)\n{\n\tstruct ocfs2_super *osb = resmap->m_osb;\n\tstruct rb_node *node;\n\tstruct ocfs2_alloc_reservation *resv;\n\tint i = 0;\n\n\tmlog(ML_NOTICE, \"Dumping resmap for device %s. Bitmap length: %u\\n\",\n\t     osb->dev_str, resmap->m_bitmap_len);\n\n\tnode = rb_first(&resmap->m_reservations);\n\twhile (node) {\n\t\tresv = rb_entry(node, struct ocfs2_alloc_reservation, r_node);\n\n\t\tmlog(ML_NOTICE, \"start: %u\\tend: %u\\tlen: %u\\tlast_start: %u\"\n\t\t     \"\\tlast_len: %u\\n\", resv->r_start,\n\t\t     ocfs2_resv_end(resv), resv->r_len, resv->r_last_start,\n\t\t     resv->r_last_len);\n\n\t\tnode = rb_next(node);\n\t\ti++;\n\t}\n\n\tmlog(ML_NOTICE, \"%d reservations found. LRU follows\\n\", i);\n\n\ti = 0;\n\tlist_for_each_entry(resv, &resmap->m_lru, r_lru) {\n\t\tmlog(ML_NOTICE, \"LRU(%d) start: %u\\tend: %u\\tlen: %u\\t\"\n\t\t     \"last_start: %u\\tlast_len: %u\\n\", i, resv->r_start,\n\t\t     ocfs2_resv_end(resv), resv->r_len, resv->r_last_start,\n\t\t     resv->r_last_len);\n\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"goal: %u next_resv: start %u len %u\\n\"",
            "goal",
            "next_resv->r_start",
            "next_resv->r_len"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "next",
            "structocfs2_alloc_reservation",
            "r_node"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "root"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_resv_lhs",
          "args": [
            "resmap",
            "goal"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_resv_lhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "366-396",
          "snippet": "static struct ocfs2_alloc_reservation *\nocfs2_find_resv_lhs(struct ocfs2_reservation_map *resmap, unsigned int goal)\n{\n\tstruct ocfs2_alloc_reservation *resv = NULL;\n\tstruct ocfs2_alloc_reservation *prev_resv = NULL;\n\tstruct rb_node *node = resmap->m_reservations.rb_node;\n\n\tassert_spin_locked(&resv_lock);\n\n\tif (!node)\n\t\treturn NULL;\n\n\tnode = rb_first(&resmap->m_reservations);\n\twhile (node) {\n\t\tresv = rb_entry(node, struct ocfs2_alloc_reservation, r_node);\n\n\t\tif (resv->r_start <= goal && ocfs2_resv_end(resv) >= goal)\n\t\t\tbreak;\n\n\t\t/* Check if we overshot the reservation just before goal? */\n\t\tif (resv->r_start > goal) {\n\t\t\tresv = prev_resv;\n\t\t\tbreak;\n\t\t}\n\n\t\tprev_resv = resv;\n\t\tnode = rb_next(node);\n\t}\n\n\treturn resv;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(resv_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(resv_lock);\n\nstatic struct ocfs2_alloc_reservation *\nocfs2_find_resv_lhs(struct ocfs2_reservation_map *resmap, unsigned int goal)\n{\n\tstruct ocfs2_alloc_reservation *resv = NULL;\n\tstruct ocfs2_alloc_reservation *prev_resv = NULL;\n\tstruct rb_node *node = resmap->m_reservations.rb_node;\n\n\tassert_spin_locked(&resv_lock);\n\n\tif (!node)\n\t\treturn NULL;\n\n\tnode = rb_first(&resmap->m_reservations);\n\twhile (node) {\n\t\tresv = rb_entry(node, struct ocfs2_alloc_reservation, r_node);\n\n\t\tif (resv->r_start <= goal && ocfs2_resv_end(resv) >= goal)\n\t\t\tbreak;\n\n\t\t/* Check if we overshot the reservation just before goal? */\n\t\tif (resv->r_start > goal) {\n\t\t\tresv = prev_resv;\n\t\t\tbreak;\n\t\t}\n\n\t\tprev_resv = resv;\n\t\tnode = rb_next(node);\n\t}\n\n\treturn resv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "goal == 0 && clen == 0"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "root"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&resv_lock"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_resv_find_window_begin",
          "args": [
            "resv->r_start",
            "ocfs2_resv_end(resv)",
            "goal",
            "wanted",
            "RB_EMPTY_ROOT(root)"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "root"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(resv_lock);\n\nstatic void __ocfs2_resv_find_window(struct ocfs2_reservation_map *resmap,\n\t\t\t\t     struct ocfs2_alloc_reservation *resv,\n\t\t\t\t     unsigned int goal, unsigned int wanted)\n{\n\tstruct rb_root *root = &resmap->m_reservations;\n\tunsigned int gap_start, gap_end, gap_len;\n\tstruct ocfs2_alloc_reservation *prev_resv, *next_resv;\n\tstruct rb_node *prev, *next;\n\tunsigned int cstart, clen;\n\tunsigned int best_start = 0, best_len = 0;\n\n\t/*\n\t * Nasty cases to consider:\n\t *\n\t * - rbtree is empty\n\t * - our window should be first in all reservations\n\t * - our window should be last in all reservations\n\t * - need to make sure we don't go past end of bitmap\n\t */\n\ttrace_ocfs2_resv_find_window_begin(resv->r_start, ocfs2_resv_end(resv),\n\t\t\t\t\t   goal, wanted, RB_EMPTY_ROOT(root));\n\n\tassert_spin_locked(&resv_lock);\n\n\tif (RB_EMPTY_ROOT(root)) {\n\t\t/*\n\t\t * Easiest case - empty tree. We can just take\n\t\t * whatever window of free bits we want.\n\t\t */\n\t\tclen = ocfs2_resmap_find_free_bits(resmap, wanted, goal,\n\t\t\t\t\t\t   resmap->m_bitmap_len - goal,\n\t\t\t\t\t\t   &cstart, &clen);\n\n\t\t/*\n\t\t * This should never happen - the local alloc window\n\t\t * will always have free bits when we're called.\n\t\t */\n\t\tBUG_ON(goal == 0 && clen == 0);\n\n\t\tif (clen == 0)\n\t\t\treturn;\n\n\t\tresv->r_start = cstart;\n\t\tresv->r_len = clen;\n\n\t\tocfs2_resv_insert(resmap, resv);\n\t\treturn;\n\t}\n\n\tprev_resv = ocfs2_find_resv_lhs(resmap, goal);\n\n\tif (prev_resv == NULL) {\n\t\t/*\n\t\t * A NULL here means that the search code couldn't\n\t\t * find a window that starts before goal.\n\t\t *\n\t\t * However, we can take the first window after goal,\n\t\t * which is also by definition, the leftmost window in\n\t\t * the entire tree. If we can find free bits in the\n\t\t * gap between goal and the LHS window, then the\n\t\t * reservation can safely be placed there.\n\t\t *\n\t\t * Otherwise we fall back to a linear search, checking\n\t\t * the gaps in between windows for a place to\n\t\t * allocate.\n\t\t */\n\n\t\tnext = rb_first(root);\n\t\tnext_resv = rb_entry(next, struct ocfs2_alloc_reservation,\n\t\t\t\t     r_node);\n\n\t\t/*\n\t\t * The search should never return such a window. (see\n\t\t * comment above\n\t\t */\n\t\tif (next_resv->r_start <= goal) {\n\t\t\tmlog(ML_ERROR, \"goal: %u next_resv: start %u len %u\\n\",\n\t\t\t     goal, next_resv->r_start, next_resv->r_len);\n\t\t\tocfs2_dump_resv(resmap);\n\t\t\tBUG();\n\t\t}\n\n\t\tclen = ocfs2_resmap_find_free_bits(resmap, wanted, goal,\n\t\t\t\t\t\t   next_resv->r_start - goal,\n\t\t\t\t\t\t   &cstart, &clen);\n\t\tif (clen) {\n\t\t\tbest_len = clen;\n\t\t\tbest_start = cstart;\n\t\t\tif (best_len == wanted)\n\t\t\t\tgoto out_insert;\n\t\t}\n\n\t\tprev_resv = next_resv;\n\t\tnext_resv = NULL;\n\t}\n\n\ttrace_ocfs2_resv_find_window_prev(prev_resv->r_start,\n\t\t\t\t\t  ocfs2_resv_end(prev_resv));\n\n\tprev = &prev_resv->r_node;\n\n\t/* Now we do a linear search for a window, starting at 'prev_rsv' */\n\twhile (1) {\n\t\tnext = rb_next(prev);\n\t\tif (next) {\n\t\t\tnext_resv = rb_entry(next,\n\t\t\t\t\t     struct ocfs2_alloc_reservation,\n\t\t\t\t\t     r_node);\n\n\t\t\tgap_start = ocfs2_resv_end(prev_resv) + 1;\n\t\t\tgap_end = next_resv->r_start - 1;\n\t\t\tgap_len = gap_end - gap_start + 1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We're at the rightmost edge of the\n\t\t\t * tree. See if a reservation between this\n\t\t\t * window and the end of the bitmap will work.\n\t\t\t */\n\t\t\tgap_start = ocfs2_resv_end(prev_resv) + 1;\n\t\t\tgap_len = resmap->m_bitmap_len - gap_start;\n\t\t\tgap_end = resmap->m_bitmap_len - 1;\n\t\t}\n\n\t\ttrace_ocfs2_resv_find_window_next(next ? next_resv->r_start: -1,\n\t\t\t\t\tnext ? ocfs2_resv_end(next_resv) : -1);\n\t\t/*\n\t\t * No need to check this gap if we have already found\n\t\t * a larger region of free bits.\n\t\t */\n\t\tif (gap_len <= best_len)\n\t\t\tgoto next_resv;\n\n\t\tclen = ocfs2_resmap_find_free_bits(resmap, wanted, gap_start,\n\t\t\t\t\t\t   gap_len, &cstart, &clen);\n\t\tif (clen == wanted) {\n\t\t\tbest_len = clen;\n\t\t\tbest_start = cstart;\n\t\t\tgoto out_insert;\n\t\t} else if (clen > best_len) {\n\t\t\tbest_len = clen;\n\t\t\tbest_start = cstart;\n\t\t}\n\nnext_resv:\n\t\tif (!next)\n\t\t\tbreak;\n\n\t\tprev = next;\n\t\tprev_resv = rb_entry(prev, struct ocfs2_alloc_reservation,\n\t\t\t\t     r_node);\n\t}\n\nout_insert:\n\tif (best_len) {\n\t\tresv->r_start = best_start;\n\t\tresv->r_len = best_len;\n\t\tocfs2_resv_insert(resmap, resv);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_resmap_find_free_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
    "lines": "414-468",
    "snippet": "static int ocfs2_resmap_find_free_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t\t       unsigned int wanted,\n\t\t\t\t       unsigned int search_start,\n\t\t\t\t       unsigned int search_len,\n\t\t\t\t       unsigned int *rstart,\n\t\t\t\t       unsigned int *rlen)\n{\n\tvoid *bitmap = resmap->m_disk_bitmap;\n\tunsigned int best_start, best_len = 0;\n\tint offset, start, found;\n\n\ttrace_ocfs2_resmap_find_free_bits_begin(search_start, search_len,\n\t\t\t\t\t\twanted, resmap->m_bitmap_len);\n\n\tfound = best_start = best_len = 0;\n\n\tstart = search_start;\n\twhile ((offset = ocfs2_find_next_zero_bit(bitmap, resmap->m_bitmap_len,\n\t\t\t\t\t\t start)) != -1) {\n\t\t/* Search reached end of the region */\n\t\tif (offset >= (search_start + search_len))\n\t\t\tbreak;\n\n\t\tif (offset == start) {\n\t\t\t/* we found a zero */\n\t\t\tfound++;\n\t\t\t/* move start to the next bit to test */\n\t\t\tstart++;\n\t\t} else {\n\t\t\t/* got a zero after some ones */\n\t\t\tfound = 1;\n\t\t\tstart = offset + 1;\n\t\t}\n\t\tif (found > best_len) {\n\t\t\tbest_len = found;\n\t\t\tbest_start = start - found;\n\t\t}\n\n\t\tif (found >= wanted)\n\t\t\tbreak;\n\t}\n\n\tif (best_len == 0)\n\t\treturn 0;\n\n\tif (best_len >= wanted)\n\t\tbest_len = wanted;\n\n\t*rlen = best_len;\n\t*rstart = best_start;\n\n\ttrace_ocfs2_resmap_find_free_bits_end(best_start, best_len);\n\n\treturn *rlen;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ocfs2_resmap_find_free_bits_end",
          "args": [
            "best_start",
            "best_len"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_next_zero_bit",
          "args": [
            "bitmap",
            "resmap->m_bitmap_len",
            "start"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_next_zero_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "904-916",
          "snippet": "static inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_find_next_zero_bit find_next_zero_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_find_next_zero_bit find_next_zero_bit_le\n\nstatic inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_resmap_find_free_bits_begin",
          "args": [
            "search_start",
            "search_len",
            "wanted",
            "resmap->m_bitmap_len"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_resmap_find_free_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t\t       unsigned int wanted,\n\t\t\t\t       unsigned int search_start,\n\t\t\t\t       unsigned int search_len,\n\t\t\t\t       unsigned int *rstart,\n\t\t\t\t       unsigned int *rlen)\n{\n\tvoid *bitmap = resmap->m_disk_bitmap;\n\tunsigned int best_start, best_len = 0;\n\tint offset, start, found;\n\n\ttrace_ocfs2_resmap_find_free_bits_begin(search_start, search_len,\n\t\t\t\t\t\twanted, resmap->m_bitmap_len);\n\n\tfound = best_start = best_len = 0;\n\n\tstart = search_start;\n\twhile ((offset = ocfs2_find_next_zero_bit(bitmap, resmap->m_bitmap_len,\n\t\t\t\t\t\t start)) != -1) {\n\t\t/* Search reached end of the region */\n\t\tif (offset >= (search_start + search_len))\n\t\t\tbreak;\n\n\t\tif (offset == start) {\n\t\t\t/* we found a zero */\n\t\t\tfound++;\n\t\t\t/* move start to the next bit to test */\n\t\t\tstart++;\n\t\t} else {\n\t\t\t/* got a zero after some ones */\n\t\t\tfound = 1;\n\t\t\tstart = offset + 1;\n\t\t}\n\t\tif (found > best_len) {\n\t\t\tbest_len = found;\n\t\t\tbest_start = start - found;\n\t\t}\n\n\t\tif (found >= wanted)\n\t\t\tbreak;\n\t}\n\n\tif (best_len == 0)\n\t\treturn 0;\n\n\tif (best_len >= wanted)\n\t\tbest_len = wanted;\n\n\t*rlen = best_len;\n\t*rstart = best_start;\n\n\ttrace_ocfs2_resmap_find_free_bits_end(best_start, best_len);\n\n\treturn *rlen;\n}"
  },
  {
    "function_name": "ocfs2_find_resv_lhs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
    "lines": "366-396",
    "snippet": "static struct ocfs2_alloc_reservation *\nocfs2_find_resv_lhs(struct ocfs2_reservation_map *resmap, unsigned int goal)\n{\n\tstruct ocfs2_alloc_reservation *resv = NULL;\n\tstruct ocfs2_alloc_reservation *prev_resv = NULL;\n\tstruct rb_node *node = resmap->m_reservations.rb_node;\n\n\tassert_spin_locked(&resv_lock);\n\n\tif (!node)\n\t\treturn NULL;\n\n\tnode = rb_first(&resmap->m_reservations);\n\twhile (node) {\n\t\tresv = rb_entry(node, struct ocfs2_alloc_reservation, r_node);\n\n\t\tif (resv->r_start <= goal && ocfs2_resv_end(resv) >= goal)\n\t\t\tbreak;\n\n\t\t/* Check if we overshot the reservation just before goal? */\n\t\tif (resv->r_start > goal) {\n\t\t\tresv = prev_resv;\n\t\t\tbreak;\n\t\t}\n\n\t\tprev_resv = resv;\n\t\tnode = rb_next(node);\n\t}\n\n\treturn resv;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(resv_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "node"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_resv_end",
          "args": [
            "resv"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "67-72",
          "snippet": "static inline unsigned int ocfs2_resv_end(struct ocfs2_alloc_reservation *resv)\n{\n\tif (resv->r_len)\n\t\treturn resv->r_start + resv->r_len - 1;\n\treturn resv->r_start;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ocfs2_resv_end(struct ocfs2_alloc_reservation *resv)\n{\n\tif (resv->r_len)\n\t\treturn resv->r_start + resv->r_len - 1;\n\treturn resv->r_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structocfs2_alloc_reservation",
            "r_node"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&resmap->m_reservations"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&resv_lock"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(resv_lock);\n\nstatic struct ocfs2_alloc_reservation *\nocfs2_find_resv_lhs(struct ocfs2_reservation_map *resmap, unsigned int goal)\n{\n\tstruct ocfs2_alloc_reservation *resv = NULL;\n\tstruct ocfs2_alloc_reservation *prev_resv = NULL;\n\tstruct rb_node *node = resmap->m_reservations.rb_node;\n\n\tassert_spin_locked(&resv_lock);\n\n\tif (!node)\n\t\treturn NULL;\n\n\tnode = rb_first(&resmap->m_reservations);\n\twhile (node) {\n\t\tresv = rb_entry(node, struct ocfs2_alloc_reservation, r_node);\n\n\t\tif (resv->r_start <= goal && ocfs2_resv_end(resv) >= goal)\n\t\t\tbreak;\n\n\t\t/* Check if we overshot the reservation just before goal? */\n\t\tif (resv->r_start > goal) {\n\t\t\tresv = prev_resv;\n\t\t\tbreak;\n\t\t}\n\n\t\tprev_resv = resv;\n\t\tnode = rb_next(node);\n\t}\n\n\treturn resv;\n}"
  },
  {
    "function_name": "ocfs2_resv_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
    "lines": "314-355",
    "snippet": "static void ocfs2_resv_insert(struct ocfs2_reservation_map *resmap,\n\t\t\t      struct ocfs2_alloc_reservation *new)\n{\n\tstruct rb_root *root = &resmap->m_reservations;\n\tstruct rb_node *parent = NULL;\n\tstruct rb_node **p = &root->rb_node;\n\tstruct ocfs2_alloc_reservation *tmp;\n\n\tassert_spin_locked(&resv_lock);\n\n\ttrace_ocfs2_resv_insert(new->r_start, new->r_len);\n\n\twhile (*p) {\n\t\tparent = *p;\n\n\t\ttmp = rb_entry(parent, struct ocfs2_alloc_reservation, r_node);\n\n\t\tif (new->r_start < tmp->r_start) {\n\t\t\tp = &(*p)->rb_left;\n\n\t\t\t/*\n\t\t\t * This is a good place to check for\n\t\t\t * overlapping reservations.\n\t\t\t */\n\t\t\tBUG_ON(ocfs2_resv_end(new) >= tmp->r_start);\n\t\t} else if (new->r_start > ocfs2_resv_end(tmp)) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\t/* This should never happen! */\n\t\t\tmlog(ML_ERROR, \"Duplicate reservation window!\\n\");\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(&new->r_node, parent, p);\n\trb_insert_color(&new->r_node, root);\n\tnew->r_flags |= OCFS2_RESV_FLAG_INUSE;\n\n\tocfs2_resv_mark_lru(resmap, new);\n\n\tocfs2_check_resmap(resmap);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(resv_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_check_resmap",
          "args": [
            "resmap"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_resmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "194-197",
          "snippet": "static inline void ocfs2_check_resmap(struct ocfs2_reservation_map *resmap)\n{\n\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_check_resmap(struct ocfs2_reservation_map *resmap)\n{\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_resv_mark_lru",
          "args": [
            "resmap",
            "new"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_mark_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "227-236",
          "snippet": "static void ocfs2_resv_mark_lru(struct ocfs2_reservation_map *resmap,\n\t\t\t\tstruct ocfs2_alloc_reservation *resv)\n{\n\tassert_spin_locked(&resv_lock);\n\n\tif (!list_empty(&resv->r_lru))\n\t\tlist_del_init(&resv->r_lru);\n\n\tlist_add_tail(&resv->r_lru, &resmap->m_lru);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(resv_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(resv_lock);\n\nstatic void ocfs2_resv_mark_lru(struct ocfs2_reservation_map *resmap,\n\t\t\t\tstruct ocfs2_alloc_reservation *resv)\n{\n\tassert_spin_locked(&resv_lock);\n\n\tif (!list_empty(&resv->r_lru))\n\t\tlist_del_init(&resv->r_lru);\n\n\tlist_add_tail(&resv->r_lru, &resmap->m_lru);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&new->r_node",
            "root"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&new->r_node",
            "parent",
            "p"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Duplicate reservation window!\\n\""
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_resv_end",
          "args": [
            "tmp"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "67-72",
          "snippet": "static inline unsigned int ocfs2_resv_end(struct ocfs2_alloc_reservation *resv)\n{\n\tif (resv->r_len)\n\t\treturn resv->r_start + resv->r_len - 1;\n\treturn resv->r_start;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ocfs2_resv_end(struct ocfs2_alloc_reservation *resv)\n{\n\tif (resv->r_len)\n\t\treturn resv->r_start + resv->r_len - 1;\n\treturn resv->r_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ocfs2_resv_end(new) >= tmp->r_start"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structocfs2_alloc_reservation",
            "r_node"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_resv_insert",
          "args": [
            "new->r_start",
            "new->r_len"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&resv_lock"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(resv_lock);\n\nstatic void ocfs2_resv_insert(struct ocfs2_reservation_map *resmap,\n\t\t\t      struct ocfs2_alloc_reservation *new)\n{\n\tstruct rb_root *root = &resmap->m_reservations;\n\tstruct rb_node *parent = NULL;\n\tstruct rb_node **p = &root->rb_node;\n\tstruct ocfs2_alloc_reservation *tmp;\n\n\tassert_spin_locked(&resv_lock);\n\n\ttrace_ocfs2_resv_insert(new->r_start, new->r_len);\n\n\twhile (*p) {\n\t\tparent = *p;\n\n\t\ttmp = rb_entry(parent, struct ocfs2_alloc_reservation, r_node);\n\n\t\tif (new->r_start < tmp->r_start) {\n\t\t\tp = &(*p)->rb_left;\n\n\t\t\t/*\n\t\t\t * This is a good place to check for\n\t\t\t * overlapping reservations.\n\t\t\t */\n\t\t\tBUG_ON(ocfs2_resv_end(new) >= tmp->r_start);\n\t\t} else if (new->r_start > ocfs2_resv_end(tmp)) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\t/* This should never happen! */\n\t\t\tmlog(ML_ERROR, \"Duplicate reservation window!\\n\");\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(&new->r_node, parent, p);\n\trb_insert_color(&new->r_node, root);\n\tnew->r_flags |= OCFS2_RESV_FLAG_INUSE;\n\n\tocfs2_resv_mark_lru(resmap, new);\n\n\tocfs2_check_resmap(resmap);\n}"
  },
  {
    "function_name": "ocfs2_resmap_uninit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
    "lines": "309-312",
    "snippet": "void ocfs2_resmap_uninit(struct ocfs2_reservation_map *resmap)\n{\n\t/* Does nothing for now. Keep this around for API symmetry */\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_resmap_uninit(struct ocfs2_reservation_map *resmap)\n{\n\t/* Does nothing for now. Keep this around for API symmetry */\n}"
  },
  {
    "function_name": "ocfs2_resmap_restart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
    "lines": "294-307",
    "snippet": "void ocfs2_resmap_restart(struct ocfs2_reservation_map *resmap,\n\t\t\t  unsigned int clen, char *disk_bitmap)\n{\n\tif (ocfs2_resmap_disabled(resmap))\n\t\treturn;\n\n\tspin_lock(&resv_lock);\n\n\tocfs2_resmap_clear_all_resv(resmap);\n\tresmap->m_bitmap_len = clen;\n\tresmap->m_disk_bitmap = disk_bitmap;\n\n\tspin_unlock(&resv_lock);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(resv_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&resv_lock"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_resmap_clear_all_resv",
          "args": [
            "resmap"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resmap_clear_all_resv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "280-292",
          "snippet": "static void ocfs2_resmap_clear_all_resv(struct ocfs2_reservation_map *resmap)\n{\n\tstruct rb_node *node;\n\tstruct ocfs2_alloc_reservation *resv;\n\n\tassert_spin_locked(&resv_lock);\n\n\twhile ((node = rb_last(&resmap->m_reservations)) != NULL) {\n\t\tresv = rb_entry(node, struct ocfs2_alloc_reservation, r_node);\n\n\t\t__ocfs2_resv_discard(resmap, resv);\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(resv_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(resv_lock);\n\nstatic void ocfs2_resmap_clear_all_resv(struct ocfs2_reservation_map *resmap)\n{\n\tstruct rb_node *node;\n\tstruct ocfs2_alloc_reservation *resv;\n\n\tassert_spin_locked(&resv_lock);\n\n\twhile ((node = rb_last(&resmap->m_reservations)) != NULL) {\n\t\tresv = rb_entry(node, struct ocfs2_alloc_reservation, r_node);\n\n\t\t__ocfs2_resv_discard(resmap, resv);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&resv_lock"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_resmap_disabled",
          "args": [
            "resmap"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resmap_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "79-84",
          "snippet": "static inline int ocfs2_resmap_disabled(struct ocfs2_reservation_map *resmap)\n{\n\tif (resmap->m_osb->osb_resv_level == 0)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int ocfs2_resmap_disabled(struct ocfs2_reservation_map *resmap)\n{\n\tif (resmap->m_osb->osb_resv_level == 0)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(resv_lock);\n\nvoid ocfs2_resmap_restart(struct ocfs2_reservation_map *resmap,\n\t\t\t  unsigned int clen, char *disk_bitmap)\n{\n\tif (ocfs2_resmap_disabled(resmap))\n\t\treturn;\n\n\tspin_lock(&resv_lock);\n\n\tocfs2_resmap_clear_all_resv(resmap);\n\tresmap->m_bitmap_len = clen;\n\tresmap->m_disk_bitmap = disk_bitmap;\n\n\tspin_unlock(&resv_lock);\n}"
  },
  {
    "function_name": "ocfs2_resmap_clear_all_resv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
    "lines": "280-292",
    "snippet": "static void ocfs2_resmap_clear_all_resv(struct ocfs2_reservation_map *resmap)\n{\n\tstruct rb_node *node;\n\tstruct ocfs2_alloc_reservation *resv;\n\n\tassert_spin_locked(&resv_lock);\n\n\twhile ((node = rb_last(&resmap->m_reservations)) != NULL) {\n\t\tresv = rb_entry(node, struct ocfs2_alloc_reservation, r_node);\n\n\t\t__ocfs2_resv_discard(resmap, resv);\n\t}\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(resv_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_resv_discard",
          "args": [
            "resmap",
            "resv"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_resv_discard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "254-267",
          "snippet": "static void __ocfs2_resv_discard(struct ocfs2_reservation_map *resmap,\n\t\t\t\t struct ocfs2_alloc_reservation *resv)\n{\n\tassert_spin_locked(&resv_lock);\n\n\t__ocfs2_resv_trunc(resv);\n\t/*\n\t * last_len and last_start no longer make sense if\n\t * we're changing the range of our allocations.\n\t */\n\tresv->r_last_len = resv->r_last_start = 0;\n\n\tocfs2_resv_remove(resmap, resv);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(resv_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(resv_lock);\n\nstatic void __ocfs2_resv_discard(struct ocfs2_reservation_map *resmap,\n\t\t\t\t struct ocfs2_alloc_reservation *resv)\n{\n\tassert_spin_locked(&resv_lock);\n\n\t__ocfs2_resv_trunc(resv);\n\t/*\n\t * last_len and last_start no longer make sense if\n\t * we're changing the range of our allocations.\n\t */\n\tresv->r_last_len = resv->r_last_start = 0;\n\n\tocfs2_resv_remove(resmap, resv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structocfs2_alloc_reservation",
            "r_node"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_last",
          "args": [
            "&resmap->m_reservations"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&resv_lock"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(resv_lock);\n\nstatic void ocfs2_resmap_clear_all_resv(struct ocfs2_reservation_map *resmap)\n{\n\tstruct rb_node *node;\n\tstruct ocfs2_alloc_reservation *resv;\n\n\tassert_spin_locked(&resv_lock);\n\n\twhile ((node = rb_last(&resmap->m_reservations)) != NULL) {\n\t\tresv = rb_entry(node, struct ocfs2_alloc_reservation, r_node);\n\n\t\t__ocfs2_resv_discard(resmap, resv);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_resv_discard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
    "lines": "270-278",
    "snippet": "void ocfs2_resv_discard(struct ocfs2_reservation_map *resmap,\n\t\t\tstruct ocfs2_alloc_reservation *resv)\n{\n\tif (resv) {\n\t\tspin_lock(&resv_lock);\n\t\t__ocfs2_resv_discard(resmap, resv);\n\t\tspin_unlock(&resv_lock);\n\t}\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(resv_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&resv_lock"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ocfs2_resv_discard",
          "args": [
            "resmap",
            "resv"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_resv_discard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "254-267",
          "snippet": "static void __ocfs2_resv_discard(struct ocfs2_reservation_map *resmap,\n\t\t\t\t struct ocfs2_alloc_reservation *resv)\n{\n\tassert_spin_locked(&resv_lock);\n\n\t__ocfs2_resv_trunc(resv);\n\t/*\n\t * last_len and last_start no longer make sense if\n\t * we're changing the range of our allocations.\n\t */\n\tresv->r_last_len = resv->r_last_start = 0;\n\n\tocfs2_resv_remove(resmap, resv);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(resv_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(resv_lock);\n\nstatic void __ocfs2_resv_discard(struct ocfs2_reservation_map *resmap,\n\t\t\t\t struct ocfs2_alloc_reservation *resv)\n{\n\tassert_spin_locked(&resv_lock);\n\n\t__ocfs2_resv_trunc(resv);\n\t/*\n\t * last_len and last_start no longer make sense if\n\t * we're changing the range of our allocations.\n\t */\n\tresv->r_last_len = resv->r_last_start = 0;\n\n\tocfs2_resv_remove(resmap, resv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&resv_lock"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(resv_lock);\n\nvoid ocfs2_resv_discard(struct ocfs2_reservation_map *resmap,\n\t\t\tstruct ocfs2_alloc_reservation *resv)\n{\n\tif (resv) {\n\t\tspin_lock(&resv_lock);\n\t\t__ocfs2_resv_discard(resmap, resv);\n\t\tspin_unlock(&resv_lock);\n\t}\n}"
  },
  {
    "function_name": "__ocfs2_resv_discard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
    "lines": "254-267",
    "snippet": "static void __ocfs2_resv_discard(struct ocfs2_reservation_map *resmap,\n\t\t\t\t struct ocfs2_alloc_reservation *resv)\n{\n\tassert_spin_locked(&resv_lock);\n\n\t__ocfs2_resv_trunc(resv);\n\t/*\n\t * last_len and last_start no longer make sense if\n\t * we're changing the range of our allocations.\n\t */\n\tresv->r_last_len = resv->r_last_start = 0;\n\n\tocfs2_resv_remove(resmap, resv);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(resv_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_resv_remove",
          "args": [
            "resmap",
            "resv"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "244-252",
          "snippet": "static void ocfs2_resv_remove(struct ocfs2_reservation_map *resmap,\n\t\t\t      struct ocfs2_alloc_reservation *resv)\n{\n\tif (resv->r_flags & OCFS2_RESV_FLAG_INUSE) {\n\t\tlist_del_init(&resv->r_lru);\n\t\trb_erase(&resv->r_node, &resmap->m_reservations);\n\t\tresv->r_flags &= ~OCFS2_RESV_FLAG_INUSE;\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_resv_remove(struct ocfs2_reservation_map *resmap,\n\t\t\t      struct ocfs2_alloc_reservation *resv)\n{\n\tif (resv->r_flags & OCFS2_RESV_FLAG_INUSE) {\n\t\tlist_del_init(&resv->r_lru);\n\t\trb_erase(&resv->r_node, &resmap->m_reservations);\n\t\tresv->r_flags &= ~OCFS2_RESV_FLAG_INUSE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ocfs2_resv_trunc",
          "args": [
            "resv"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_resv_trunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "238-242",
          "snippet": "static void __ocfs2_resv_trunc(struct ocfs2_alloc_reservation *resv)\n{\n\tresv->r_len = 0;\n\tresv->r_start = 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void __ocfs2_resv_trunc(struct ocfs2_alloc_reservation *resv)\n{\n\tresv->r_len = 0;\n\tresv->r_start = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&resv_lock"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(resv_lock);\n\nstatic void __ocfs2_resv_discard(struct ocfs2_reservation_map *resmap,\n\t\t\t\t struct ocfs2_alloc_reservation *resv)\n{\n\tassert_spin_locked(&resv_lock);\n\n\t__ocfs2_resv_trunc(resv);\n\t/*\n\t * last_len and last_start no longer make sense if\n\t * we're changing the range of our allocations.\n\t */\n\tresv->r_last_len = resv->r_last_start = 0;\n\n\tocfs2_resv_remove(resmap, resv);\n}"
  },
  {
    "function_name": "ocfs2_resv_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
    "lines": "244-252",
    "snippet": "static void ocfs2_resv_remove(struct ocfs2_reservation_map *resmap,\n\t\t\t      struct ocfs2_alloc_reservation *resv)\n{\n\tif (resv->r_flags & OCFS2_RESV_FLAG_INUSE) {\n\t\tlist_del_init(&resv->r_lru);\n\t\trb_erase(&resv->r_node, &resmap->m_reservations);\n\t\tresv->r_flags &= ~OCFS2_RESV_FLAG_INUSE;\n\t}\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&resv->r_node",
            "&resmap->m_reservations"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&resv->r_lru"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_resv_remove(struct ocfs2_reservation_map *resmap,\n\t\t\t      struct ocfs2_alloc_reservation *resv)\n{\n\tif (resv->r_flags & OCFS2_RESV_FLAG_INUSE) {\n\t\tlist_del_init(&resv->r_lru);\n\t\trb_erase(&resv->r_node, &resmap->m_reservations);\n\t\tresv->r_flags &= ~OCFS2_RESV_FLAG_INUSE;\n\t}\n}"
  },
  {
    "function_name": "__ocfs2_resv_trunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
    "lines": "238-242",
    "snippet": "static void __ocfs2_resv_trunc(struct ocfs2_alloc_reservation *resv)\n{\n\tresv->r_len = 0;\n\tresv->r_start = 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void __ocfs2_resv_trunc(struct ocfs2_alloc_reservation *resv)\n{\n\tresv->r_len = 0;\n\tresv->r_start = 0;\n}"
  },
  {
    "function_name": "ocfs2_resv_mark_lru",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
    "lines": "227-236",
    "snippet": "static void ocfs2_resv_mark_lru(struct ocfs2_reservation_map *resmap,\n\t\t\t\tstruct ocfs2_alloc_reservation *resv)\n{\n\tassert_spin_locked(&resv_lock);\n\n\tif (!list_empty(&resv->r_lru))\n\t\tlist_del_init(&resv->r_lru);\n\n\tlist_add_tail(&resv->r_lru, &resmap->m_lru);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(resv_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&resv->r_lru",
            "&resmap->m_lru"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&resv->r_lru"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&resv->r_lru"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&resv_lock"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(resv_lock);\n\nstatic void ocfs2_resv_mark_lru(struct ocfs2_reservation_map *resmap,\n\t\t\t\tstruct ocfs2_alloc_reservation *resv)\n{\n\tassert_spin_locked(&resv_lock);\n\n\tif (!list_empty(&resv->r_lru))\n\t\tlist_del_init(&resv->r_lru);\n\n\tlist_add_tail(&resv->r_lru, &resmap->m_lru);\n}"
  },
  {
    "function_name": "ocfs2_resmap_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
    "lines": "214-225",
    "snippet": "int ocfs2_resmap_init(struct ocfs2_super *osb,\n\t\t      struct ocfs2_reservation_map *resmap)\n{\n\tmemset(resmap, 0, sizeof(*resmap));\n\n\tresmap->m_osb = osb;\n\tresmap->m_reservations = RB_ROOT;\n\t/* m_bitmap_len is initialized to zero by the above memset. */\n\tINIT_LIST_HEAD(&resmap->m_lru);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&resmap->m_lru"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "resmap",
            "0",
            "sizeof(*resmap)"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_resmap_init(struct ocfs2_super *osb,\n\t\t      struct ocfs2_reservation_map *resmap)\n{\n\tmemset(resmap, 0, sizeof(*resmap));\n\n\tresmap->m_osb = osb;\n\tresmap->m_reservations = RB_ROOT;\n\t/* m_bitmap_len is initialized to zero by the above memset. */\n\tINIT_LIST_HEAD(&resmap->m_lru);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_resv_set_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
    "lines": "206-212",
    "snippet": "void ocfs2_resv_set_type(struct ocfs2_alloc_reservation *resv,\n\t\t\t unsigned int flags)\n{\n\tBUG_ON(flags & ~OCFS2_RESV_TYPES);\n\n\tresv->r_flags |= flags;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "flags & ~OCFS2_RESV_TYPES"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_resv_set_type(struct ocfs2_alloc_reservation *resv,\n\t\t\t unsigned int flags)\n{\n\tBUG_ON(flags & ~OCFS2_RESV_TYPES);\n\n\tresv->r_flags |= flags;\n}"
  },
  {
    "function_name": "ocfs2_resv_init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
    "lines": "200-204",
    "snippet": "void ocfs2_resv_init_once(struct ocfs2_alloc_reservation *resv)\n{\n\tmemset(resv, 0, sizeof(*resv));\n\tINIT_LIST_HEAD(&resv->r_lru);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&resv->r_lru"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "resv",
            "0",
            "sizeof(*resv)"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_resv_init_once(struct ocfs2_alloc_reservation *resv)\n{\n\tmemset(resv, 0, sizeof(*resv));\n\tINIT_LIST_HEAD(&resv->r_lru);\n}"
  },
  {
    "function_name": "ocfs2_check_resmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
    "lines": "194-197",
    "snippet": "static inline void ocfs2_check_resmap(struct ocfs2_reservation_map *resmap)\n{\n\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_check_resmap(struct ocfs2_reservation_map *resmap)\n{\n\n}"
  },
  {
    "function_name": "ocfs2_check_resmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
    "lines": "144-192",
    "snippet": "static void ocfs2_check_resmap(struct ocfs2_reservation_map *resmap)\n{\n\tunsigned int off = 0;\n\tint i = 0;\n\tstruct rb_node *node;\n\tstruct ocfs2_alloc_reservation *resv;\n\n\tnode = rb_first(&resmap->m_reservations);\n\twhile (node) {\n\t\tresv = rb_entry(node, struct ocfs2_alloc_reservation, r_node);\n\n\t\tif (i > 0 && resv->r_start <= off) {\n\t\t\tmlog(ML_ERROR, \"reservation %d has bad start off!\\n\",\n\t\t\t     i);\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (resv->r_len == 0) {\n\t\t\tmlog(ML_ERROR, \"reservation %d has no length!\\n\",\n\t\t\t     i);\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (resv->r_start > ocfs2_resv_end(resv)) {\n\t\t\tmlog(ML_ERROR, \"reservation %d has invalid range!\\n\",\n\t\t\t     i);\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (ocfs2_resv_end(resv) >= resmap->m_bitmap_len) {\n\t\t\tmlog(ML_ERROR, \"reservation %d extends past bitmap!\\n\",\n\t\t\t     i);\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (ocfs2_validate_resmap_bits(resmap, i, resv))\n\t\t\tgoto bad;\n\n\t\toff = ocfs2_resv_end(resv);\n\t\tnode = rb_next(node);\n\n\t\ti++;\n\t}\n\treturn;\n\nbad:\n\tocfs2_dump_resv(resmap);\n\tBUG();\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dump_resv",
          "args": [
            "resmap"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dump_resv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "86-120",
          "snippet": "static void ocfs2_dump_resv(struct ocfs2_reservation_map *resmap)\n{\n\tstruct ocfs2_super *osb = resmap->m_osb;\n\tstruct rb_node *node;\n\tstruct ocfs2_alloc_reservation *resv;\n\tint i = 0;\n\n\tmlog(ML_NOTICE, \"Dumping resmap for device %s. Bitmap length: %u\\n\",\n\t     osb->dev_str, resmap->m_bitmap_len);\n\n\tnode = rb_first(&resmap->m_reservations);\n\twhile (node) {\n\t\tresv = rb_entry(node, struct ocfs2_alloc_reservation, r_node);\n\n\t\tmlog(ML_NOTICE, \"start: %u\\tend: %u\\tlen: %u\\tlast_start: %u\"\n\t\t     \"\\tlast_len: %u\\n\", resv->r_start,\n\t\t     ocfs2_resv_end(resv), resv->r_len, resv->r_last_start,\n\t\t     resv->r_last_len);\n\n\t\tnode = rb_next(node);\n\t\ti++;\n\t}\n\n\tmlog(ML_NOTICE, \"%d reservations found. LRU follows\\n\", i);\n\n\ti = 0;\n\tlist_for_each_entry(resv, &resmap->m_lru, r_lru) {\n\t\tmlog(ML_NOTICE, \"LRU(%d) start: %u\\tend: %u\\tlen: %u\\t\"\n\t\t     \"last_start: %u\\tlast_len: %u\\n\", i, resv->r_start,\n\t\t     ocfs2_resv_end(resv), resv->r_len, resv->r_last_start,\n\t\t     resv->r_last_len);\n\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dump_resv(struct ocfs2_reservation_map *resmap)\n{\n\tstruct ocfs2_super *osb = resmap->m_osb;\n\tstruct rb_node *node;\n\tstruct ocfs2_alloc_reservation *resv;\n\tint i = 0;\n\n\tmlog(ML_NOTICE, \"Dumping resmap for device %s. Bitmap length: %u\\n\",\n\t     osb->dev_str, resmap->m_bitmap_len);\n\n\tnode = rb_first(&resmap->m_reservations);\n\twhile (node) {\n\t\tresv = rb_entry(node, struct ocfs2_alloc_reservation, r_node);\n\n\t\tmlog(ML_NOTICE, \"start: %u\\tend: %u\\tlen: %u\\tlast_start: %u\"\n\t\t     \"\\tlast_len: %u\\n\", resv->r_start,\n\t\t     ocfs2_resv_end(resv), resv->r_len, resv->r_last_start,\n\t\t     resv->r_last_len);\n\n\t\tnode = rb_next(node);\n\t\ti++;\n\t}\n\n\tmlog(ML_NOTICE, \"%d reservations found. LRU follows\\n\", i);\n\n\ti = 0;\n\tlist_for_each_entry(resv, &resmap->m_lru, r_lru) {\n\t\tmlog(ML_NOTICE, \"LRU(%d) start: %u\\tend: %u\\tlen: %u\\t\"\n\t\t     \"last_start: %u\\tlast_len: %u\\n\", i, resv->r_start,\n\t\t     ocfs2_resv_end(resv), resv->r_len, resv->r_last_start,\n\t\t     resv->r_last_len);\n\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "node"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_resv_end",
          "args": [
            "resv"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "67-72",
          "snippet": "static inline unsigned int ocfs2_resv_end(struct ocfs2_alloc_reservation *resv)\n{\n\tif (resv->r_len)\n\t\treturn resv->r_start + resv->r_len - 1;\n\treturn resv->r_start;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ocfs2_resv_end(struct ocfs2_alloc_reservation *resv)\n{\n\tif (resv->r_len)\n\t\treturn resv->r_start + resv->r_len - 1;\n\treturn resv->r_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_validate_resmap_bits",
          "args": [
            "resmap",
            "i",
            "resv"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_validate_resmap_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "123-142",
          "snippet": "static int ocfs2_validate_resmap_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t\t      int i,\n\t\t\t\t      struct ocfs2_alloc_reservation *resv)\n{\n\tchar *disk_bitmap = resmap->m_disk_bitmap;\n\tunsigned int start = resv->r_start;\n\tunsigned int end = ocfs2_resv_end(resv);\n\n\twhile (start <= end) {\n\t\tif (ocfs2_test_bit(start, disk_bitmap)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"reservation %d covers an allocated area \"\n\t\t\t     \"starting at bit %u!\\n\", i, start);\n\t\t\treturn 1;\n\t\t}\n\n\t\tstart++;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_validate_resmap_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t\t      int i,\n\t\t\t\t      struct ocfs2_alloc_reservation *resv)\n{\n\tchar *disk_bitmap = resmap->m_disk_bitmap;\n\tunsigned int start = resv->r_start;\n\tunsigned int end = ocfs2_resv_end(resv);\n\n\twhile (start <= end) {\n\t\tif (ocfs2_test_bit(start, disk_bitmap)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"reservation %d covers an allocated area \"\n\t\t\t     \"starting at bit %u!\\n\", i, start);\n\t\t\treturn 1;\n\t\t}\n\n\t\tstart++;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"reservation %d extends past bitmap!\\n\"",
            "i"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structocfs2_alloc_reservation",
            "r_node"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&resmap->m_reservations"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_check_resmap(struct ocfs2_reservation_map *resmap)\n{\n\tunsigned int off = 0;\n\tint i = 0;\n\tstruct rb_node *node;\n\tstruct ocfs2_alloc_reservation *resv;\n\n\tnode = rb_first(&resmap->m_reservations);\n\twhile (node) {\n\t\tresv = rb_entry(node, struct ocfs2_alloc_reservation, r_node);\n\n\t\tif (i > 0 && resv->r_start <= off) {\n\t\t\tmlog(ML_ERROR, \"reservation %d has bad start off!\\n\",\n\t\t\t     i);\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (resv->r_len == 0) {\n\t\t\tmlog(ML_ERROR, \"reservation %d has no length!\\n\",\n\t\t\t     i);\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (resv->r_start > ocfs2_resv_end(resv)) {\n\t\t\tmlog(ML_ERROR, \"reservation %d has invalid range!\\n\",\n\t\t\t     i);\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (ocfs2_resv_end(resv) >= resmap->m_bitmap_len) {\n\t\t\tmlog(ML_ERROR, \"reservation %d extends past bitmap!\\n\",\n\t\t\t     i);\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (ocfs2_validate_resmap_bits(resmap, i, resv))\n\t\t\tgoto bad;\n\n\t\toff = ocfs2_resv_end(resv);\n\t\tnode = rb_next(node);\n\n\t\ti++;\n\t}\n\treturn;\n\nbad:\n\tocfs2_dump_resv(resmap);\n\tBUG();\n}"
  },
  {
    "function_name": "ocfs2_validate_resmap_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
    "lines": "123-142",
    "snippet": "static int ocfs2_validate_resmap_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t\t      int i,\n\t\t\t\t      struct ocfs2_alloc_reservation *resv)\n{\n\tchar *disk_bitmap = resmap->m_disk_bitmap;\n\tunsigned int start = resv->r_start;\n\tunsigned int end = ocfs2_resv_end(resv);\n\n\twhile (start <= end) {\n\t\tif (ocfs2_test_bit(start, disk_bitmap)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"reservation %d covers an allocated area \"\n\t\t\t     \"starting at bit %u!\\n\", i, start);\n\t\t\treturn 1;\n\t\t}\n\n\t\tstart++;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"reservation %d covers an allocated area \"\n\t\t\t     \"starting at bit %u!\\n\"",
            "i",
            "start"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_test_bit",
          "args": [
            "start",
            "disk_bitmap"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_resv_end",
          "args": [
            "resv"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "67-72",
          "snippet": "static inline unsigned int ocfs2_resv_end(struct ocfs2_alloc_reservation *resv)\n{\n\tif (resv->r_len)\n\t\treturn resv->r_start + resv->r_len - 1;\n\treturn resv->r_start;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ocfs2_resv_end(struct ocfs2_alloc_reservation *resv)\n{\n\tif (resv->r_len)\n\t\treturn resv->r_start + resv->r_len - 1;\n\treturn resv->r_start;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_validate_resmap_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t\t      int i,\n\t\t\t\t      struct ocfs2_alloc_reservation *resv)\n{\n\tchar *disk_bitmap = resmap->m_disk_bitmap;\n\tunsigned int start = resv->r_start;\n\tunsigned int end = ocfs2_resv_end(resv);\n\n\twhile (start <= end) {\n\t\tif (ocfs2_test_bit(start, disk_bitmap)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"reservation %d covers an allocated area \"\n\t\t\t     \"starting at bit %u!\\n\", i, start);\n\t\t\treturn 1;\n\t\t}\n\n\t\tstart++;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_dump_resv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
    "lines": "86-120",
    "snippet": "static void ocfs2_dump_resv(struct ocfs2_reservation_map *resmap)\n{\n\tstruct ocfs2_super *osb = resmap->m_osb;\n\tstruct rb_node *node;\n\tstruct ocfs2_alloc_reservation *resv;\n\tint i = 0;\n\n\tmlog(ML_NOTICE, \"Dumping resmap for device %s. Bitmap length: %u\\n\",\n\t     osb->dev_str, resmap->m_bitmap_len);\n\n\tnode = rb_first(&resmap->m_reservations);\n\twhile (node) {\n\t\tresv = rb_entry(node, struct ocfs2_alloc_reservation, r_node);\n\n\t\tmlog(ML_NOTICE, \"start: %u\\tend: %u\\tlen: %u\\tlast_start: %u\"\n\t\t     \"\\tlast_len: %u\\n\", resv->r_start,\n\t\t     ocfs2_resv_end(resv), resv->r_len, resv->r_last_start,\n\t\t     resv->r_last_len);\n\n\t\tnode = rb_next(node);\n\t\ti++;\n\t}\n\n\tmlog(ML_NOTICE, \"%d reservations found. LRU follows\\n\", i);\n\n\ti = 0;\n\tlist_for_each_entry(resv, &resmap->m_lru, r_lru) {\n\t\tmlog(ML_NOTICE, \"LRU(%d) start: %u\\tend: %u\\tlen: %u\\t\"\n\t\t     \"last_start: %u\\tlast_len: %u\\n\", i, resv->r_start,\n\t\t     ocfs2_resv_end(resv), resv->r_len, resv->r_last_start,\n\t\t     resv->r_last_len);\n\n\t\ti++;\n\t}\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_NOTICE",
            "\"LRU(%d) start: %u\\tend: %u\\tlen: %u\\t\"\n\t\t     \"last_start: %u\\tlast_len: %u\\n\"",
            "i",
            "resv->r_start",
            "ocfs2_resv_end(resv)",
            "resv->r_len",
            "resv->r_last_start",
            "resv->r_last_len"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_resv_end",
          "args": [
            "resv"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "67-72",
          "snippet": "static inline unsigned int ocfs2_resv_end(struct ocfs2_alloc_reservation *resv)\n{\n\tif (resv->r_len)\n\t\treturn resv->r_start + resv->r_len - 1;\n\treturn resv->r_start;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ocfs2_resv_end(struct ocfs2_alloc_reservation *resv)\n{\n\tif (resv->r_len)\n\t\treturn resv->r_start + resv->r_len - 1;\n\treturn resv->r_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "resv",
            "&resmap->m_lru",
            "r_lru"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_NOTICE",
            "\"%d reservations found. LRU follows\\n\"",
            "i"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "node"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_NOTICE",
            "\"start: %u\\tend: %u\\tlen: %u\\tlast_start: %u\"\n\t\t     \"\\tlast_len: %u\\n\"",
            "resv->r_start",
            "ocfs2_resv_end(resv)",
            "resv->r_len",
            "resv->r_last_start",
            "resv->r_last_len"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structocfs2_alloc_reservation",
            "r_node"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&resmap->m_reservations"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_NOTICE",
            "\"Dumping resmap for device %s. Bitmap length: %u\\n\"",
            "osb->dev_str",
            "resmap->m_bitmap_len"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dump_resv(struct ocfs2_reservation_map *resmap)\n{\n\tstruct ocfs2_super *osb = resmap->m_osb;\n\tstruct rb_node *node;\n\tstruct ocfs2_alloc_reservation *resv;\n\tint i = 0;\n\n\tmlog(ML_NOTICE, \"Dumping resmap for device %s. Bitmap length: %u\\n\",\n\t     osb->dev_str, resmap->m_bitmap_len);\n\n\tnode = rb_first(&resmap->m_reservations);\n\twhile (node) {\n\t\tresv = rb_entry(node, struct ocfs2_alloc_reservation, r_node);\n\n\t\tmlog(ML_NOTICE, \"start: %u\\tend: %u\\tlen: %u\\tlast_start: %u\"\n\t\t     \"\\tlast_len: %u\\n\", resv->r_start,\n\t\t     ocfs2_resv_end(resv), resv->r_len, resv->r_last_start,\n\t\t     resv->r_last_len);\n\n\t\tnode = rb_next(node);\n\t\ti++;\n\t}\n\n\tmlog(ML_NOTICE, \"%d reservations found. LRU follows\\n\", i);\n\n\ti = 0;\n\tlist_for_each_entry(resv, &resmap->m_lru, r_lru) {\n\t\tmlog(ML_NOTICE, \"LRU(%d) start: %u\\tend: %u\\tlen: %u\\t\"\n\t\t     \"last_start: %u\\tlast_len: %u\\n\", i, resv->r_start,\n\t\t     ocfs2_resv_end(resv), resv->r_len, resv->r_last_start,\n\t\t     resv->r_last_len);\n\n\t\ti++;\n\t}\n}"
  },
  {
    "function_name": "ocfs2_resmap_disabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
    "lines": "79-84",
    "snippet": "static inline int ocfs2_resmap_disabled(struct ocfs2_reservation_map *resmap)\n{\n\tif (resmap->m_osb->osb_resv_level == 0)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int ocfs2_resmap_disabled(struct ocfs2_reservation_map *resmap)\n{\n\tif (resmap->m_osb->osb_resv_level == 0)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_resv_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
    "lines": "74-77",
    "snippet": "static inline int ocfs2_resv_empty(struct ocfs2_alloc_reservation *resv)\n{\n\treturn !!(resv->r_len == 0);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int ocfs2_resv_empty(struct ocfs2_alloc_reservation *resv)\n{\n\treturn !!(resv->r_len == 0);\n}"
  },
  {
    "function_name": "ocfs2_resv_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
    "lines": "67-72",
    "snippet": "static inline unsigned int ocfs2_resv_end(struct ocfs2_alloc_reservation *resv)\n{\n\tif (resv->r_len)\n\t\treturn resv->r_start + resv->r_len - 1;\n\treturn resv->r_start;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ocfs2_resv_end(struct ocfs2_alloc_reservation *resv)\n{\n\tif (resv->r_len)\n\t\treturn resv->r_start + resv->r_len - 1;\n\treturn resv->r_start;\n}"
  },
  {
    "function_name": "ocfs2_resv_window_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
    "lines": "52-65",
    "snippet": "static unsigned int ocfs2_resv_window_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t\t\t   struct ocfs2_alloc_reservation *resv)\n{\n\tstruct ocfs2_super *osb = resmap->m_osb;\n\tunsigned int bits;\n\n\tif (!(resv->r_flags & OCFS2_RESV_FLAG_DIR)) {\n\t\t/* 8, 16, 32, 64, 128, 256, 512, 1024 */\n\t\tbits = 4 << osb->osb_resv_level;\n\t} else {\n\t\tbits = 4 << osb->osb_dir_resv_level;\n\t}\n\treturn bits;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic unsigned int ocfs2_resv_window_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t\t\t   struct ocfs2_alloc_reservation *resv)\n{\n\tstruct ocfs2_super *osb = resmap->m_osb;\n\tunsigned int bits;\n\n\tif (!(resv->r_flags & OCFS2_RESV_FLAG_DIR)) {\n\t\t/* 8, 16, 32, 64, 128, 256, 512, 1024 */\n\t\tbits = 4 << osb->osb_resv_level;\n\t} else {\n\t\tbits = 4 << osb->osb_dir_resv_level;\n\t}\n\treturn bits;\n}"
  },
  {
    "function_name": "ocfs2_dir_resv_allowed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
    "lines": "47-50",
    "snippet": "int ocfs2_dir_resv_allowed(struct ocfs2_super *osb)\n{\n\treturn (osb->osb_resv_level && osb->osb_dir_resv_level);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_dir_resv_allowed(struct ocfs2_super *osb)\n{\n\treturn (osb->osb_resv_level && osb->osb_dir_resv_level);\n}"
  }
]