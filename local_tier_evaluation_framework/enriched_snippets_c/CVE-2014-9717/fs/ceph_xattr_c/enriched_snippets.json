[
  {
    "function_name": "ceph_removexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "1099-1108",
    "snippet": "int ceph_removexattr(struct dentry *dentry, const char *name)\n{\n\tif (ceph_snap(dentry->d_inode) != CEPH_NOSNAP)\n\t\treturn -EROFS;\n\n\tif (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn generic_removexattr(dentry, name);\n\n\treturn __ceph_removexattr(dentry, name);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ceph_removexattr",
          "args": [
            "dentry",
            "name"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_removexattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "1033-1097",
          "snippet": "int __ceph_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ceph_vxattr *vxattr;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint issued;\n\tint err;\n\tint required_blob_size;\n\tint dirty;\n\n\tif (!ceph_is_valid_xattr(name))\n\t\treturn -EOPNOTSUPP;\n\n\tvxattr = ceph_match_vxattr(inode, name);\n\tif (vxattr && vxattr->readonly)\n\t\treturn -EOPNOTSUPP;\n\n\t/* pass any unhandled ceph.* xattrs through to the MDS */\n\tif (!strncmp(name, XATTR_CEPH_PREFIX, XATTR_CEPH_PREFIX_LEN))\n\t\tgoto do_sync_unlocked;\n\n\terr = -ENOMEM;\n\tspin_lock(&ci->i_ceph_lock);\nretry:\n\tissued = __ceph_caps_issued(ci, NULL);\n\tdout(\"removexattr %p issued %s\\n\", inode, ceph_cap_string(issued));\n\n\tif (ci->i_xattrs.version == 0 || !(issued & CEPH_CAP_XATTR_EXCL))\n\t\tgoto do_sync;\n\t__build_xattrs(inode);\n\n\trequired_blob_size = __get_required_blob_size(ci, 0, 0);\n\n\tif (!ci->i_xattrs.prealloc_blob ||\n\t    required_blob_size > ci->i_xattrs.prealloc_blob->alloc_len) {\n\t\tstruct ceph_buffer *blob;\n\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tdout(\" preaallocating new blob size=%d\\n\", required_blob_size);\n\t\tblob = ceph_buffer_new(required_blob_size, GFP_NOFS);\n\t\tif (!blob)\n\t\t\tgoto out;\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tif (ci->i_xattrs.prealloc_blob)\n\t\t\tceph_buffer_put(ci->i_xattrs.prealloc_blob);\n\t\tci->i_xattrs.prealloc_blob = blob;\n\t\tgoto retry;\n\t}\n\n\terr = __remove_xattr_by_name(ceph_inode(inode), name);\n\n\tdirty = __ceph_mark_dirty_caps(ci, CEPH_CAP_XATTR_EXCL);\n\tci->i_xattrs.dirty = true;\n\tinode->i_ctime = CURRENT_TIME;\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (dirty)\n\t\t__mark_inode_dirty(inode, dirty);\n\treturn err;\ndo_sync:\n\tspin_unlock(&ci->i_ceph_lock);\ndo_sync_unlocked:\n\terr = ceph_send_removexattr(dentry, name);\nout:\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define XATTR_CEPH_PREFIX_LEN (sizeof (XATTR_CEPH_PREFIX) - 1)",
            "#define XATTR_CEPH_PREFIX \"ceph.\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define XATTR_CEPH_PREFIX_LEN (sizeof (XATTR_CEPH_PREFIX) - 1)\n#define XATTR_CEPH_PREFIX \"ceph.\"\n\nint __ceph_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ceph_vxattr *vxattr;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint issued;\n\tint err;\n\tint required_blob_size;\n\tint dirty;\n\n\tif (!ceph_is_valid_xattr(name))\n\t\treturn -EOPNOTSUPP;\n\n\tvxattr = ceph_match_vxattr(inode, name);\n\tif (vxattr && vxattr->readonly)\n\t\treturn -EOPNOTSUPP;\n\n\t/* pass any unhandled ceph.* xattrs through to the MDS */\n\tif (!strncmp(name, XATTR_CEPH_PREFIX, XATTR_CEPH_PREFIX_LEN))\n\t\tgoto do_sync_unlocked;\n\n\terr = -ENOMEM;\n\tspin_lock(&ci->i_ceph_lock);\nretry:\n\tissued = __ceph_caps_issued(ci, NULL);\n\tdout(\"removexattr %p issued %s\\n\", inode, ceph_cap_string(issued));\n\n\tif (ci->i_xattrs.version == 0 || !(issued & CEPH_CAP_XATTR_EXCL))\n\t\tgoto do_sync;\n\t__build_xattrs(inode);\n\n\trequired_blob_size = __get_required_blob_size(ci, 0, 0);\n\n\tif (!ci->i_xattrs.prealloc_blob ||\n\t    required_blob_size > ci->i_xattrs.prealloc_blob->alloc_len) {\n\t\tstruct ceph_buffer *blob;\n\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tdout(\" preaallocating new blob size=%d\\n\", required_blob_size);\n\t\tblob = ceph_buffer_new(required_blob_size, GFP_NOFS);\n\t\tif (!blob)\n\t\t\tgoto out;\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tif (ci->i_xattrs.prealloc_blob)\n\t\t\tceph_buffer_put(ci->i_xattrs.prealloc_blob);\n\t\tci->i_xattrs.prealloc_blob = blob;\n\t\tgoto retry;\n\t}\n\n\terr = __remove_xattr_by_name(ceph_inode(inode), name);\n\n\tdirty = __ceph_mark_dirty_caps(ci, CEPH_CAP_XATTR_EXCL);\n\tci->i_xattrs.dirty = true;\n\tinode->i_ctime = CURRENT_TIME;\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (dirty)\n\t\t__mark_inode_dirty(inode, dirty);\n\treturn err;\ndo_sync:\n\tspin_unlock(&ci->i_ceph_lock);\ndo_sync_unlocked:\n\terr = ceph_send_removexattr(dentry, name);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_removexattr",
          "args": [
            "dentry",
            "name"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "generic_removexattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "777-787",
          "snippet": "int\ngeneric_removexattr(struct dentry *dentry, const char *name)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->set(dentry, name, NULL, 0,\n\t\t\t    XATTR_REPLACE, handler->flags);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ngeneric_removexattr(struct dentry *dentry, const char *name)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->set(dentry, name, NULL, 0,\n\t\t\t    XATTR_REPLACE, handler->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_SYSTEM_PREFIX",
            "XATTR_SYSTEM_PREFIX_LEN"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_snap",
          "args": [
            "dentry->d_inode"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_snap_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "115-124",
          "snippet": "const char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_removexattr(struct dentry *dentry, const char *name)\n{\n\tif (ceph_snap(dentry->d_inode) != CEPH_NOSNAP)\n\t\treturn -EROFS;\n\n\tif (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn generic_removexattr(dentry, name);\n\n\treturn __ceph_removexattr(dentry, name);\n}"
  },
  {
    "function_name": "__ceph_removexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "1033-1097",
    "snippet": "int __ceph_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ceph_vxattr *vxattr;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint issued;\n\tint err;\n\tint required_blob_size;\n\tint dirty;\n\n\tif (!ceph_is_valid_xattr(name))\n\t\treturn -EOPNOTSUPP;\n\n\tvxattr = ceph_match_vxattr(inode, name);\n\tif (vxattr && vxattr->readonly)\n\t\treturn -EOPNOTSUPP;\n\n\t/* pass any unhandled ceph.* xattrs through to the MDS */\n\tif (!strncmp(name, XATTR_CEPH_PREFIX, XATTR_CEPH_PREFIX_LEN))\n\t\tgoto do_sync_unlocked;\n\n\terr = -ENOMEM;\n\tspin_lock(&ci->i_ceph_lock);\nretry:\n\tissued = __ceph_caps_issued(ci, NULL);\n\tdout(\"removexattr %p issued %s\\n\", inode, ceph_cap_string(issued));\n\n\tif (ci->i_xattrs.version == 0 || !(issued & CEPH_CAP_XATTR_EXCL))\n\t\tgoto do_sync;\n\t__build_xattrs(inode);\n\n\trequired_blob_size = __get_required_blob_size(ci, 0, 0);\n\n\tif (!ci->i_xattrs.prealloc_blob ||\n\t    required_blob_size > ci->i_xattrs.prealloc_blob->alloc_len) {\n\t\tstruct ceph_buffer *blob;\n\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tdout(\" preaallocating new blob size=%d\\n\", required_blob_size);\n\t\tblob = ceph_buffer_new(required_blob_size, GFP_NOFS);\n\t\tif (!blob)\n\t\t\tgoto out;\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tif (ci->i_xattrs.prealloc_blob)\n\t\t\tceph_buffer_put(ci->i_xattrs.prealloc_blob);\n\t\tci->i_xattrs.prealloc_blob = blob;\n\t\tgoto retry;\n\t}\n\n\terr = __remove_xattr_by_name(ceph_inode(inode), name);\n\n\tdirty = __ceph_mark_dirty_caps(ci, CEPH_CAP_XATTR_EXCL);\n\tci->i_xattrs.dirty = true;\n\tinode->i_ctime = CURRENT_TIME;\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (dirty)\n\t\t__mark_inode_dirty(inode, dirty);\n\treturn err;\ndo_sync:\n\tspin_unlock(&ci->i_ceph_lock);\ndo_sync_unlocked:\n\terr = ceph_send_removexattr(dentry, name);\nout:\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [
      "#define XATTR_CEPH_PREFIX_LEN (sizeof (XATTR_CEPH_PREFIX) - 1)",
      "#define XATTR_CEPH_PREFIX \"ceph.\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_send_removexattr",
          "args": [
            "dentry",
            "name"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_send_removexattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "1010-1031",
          "snippet": "static int ceph_send_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(dentry->d_sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ceph_mds_request *req;\n\tint err;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_RMXATTR,\n\t\t\t\t       USE_AUTH_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_inode_drop = CEPH_CAP_XATTR_SHARED;\n\treq->r_num_caps = 1;\n\treq->r_path2 = kstrdup(name, GFP_NOFS);\n\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tceph_mdsc_put_request(req);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_send_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(dentry->d_sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ceph_mds_request *req;\n\tint err;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_RMXATTR,\n\t\t\t\t       USE_AUTH_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_inode_drop = CEPH_CAP_XATTR_SHARED;\n\treq->r_num_caps = 1;\n\treq->r_path2 = kstrdup(name, GFP_NOFS);\n\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tceph_mdsc_put_request(req);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mark_inode_dirty",
          "args": [
            "inode",
            "dirty"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1181-1285",
          "snippet": "void __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)\n\nvoid __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_mark_dirty_caps",
          "args": [
            "ci",
            "CEPH_CAP_XATTR_EXCL"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_mark_dirty_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1389-1423",
          "snippet": "int __ceph_mark_dirty_caps(struct ceph_inode_info *ci, int mask)\n{\n\tstruct ceph_mds_client *mdsc =\n\t\tceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tint was = ci->i_dirty_caps;\n\tint dirty = 0;\n\n\tdout(\"__mark_dirty_caps %p %s dirty %s -> %s\\n\", &ci->vfs_inode,\n\t     ceph_cap_string(mask), ceph_cap_string(was),\n\t     ceph_cap_string(was | mask));\n\tci->i_dirty_caps |= mask;\n\tif (was == 0) {\n\t\tif (!ci->i_head_snapc)\n\t\t\tci->i_head_snapc = ceph_get_snap_context(\n\t\t\t\tci->i_snap_realm->cached_context);\n\t\tdout(\" inode %p now dirty snapc %p auth cap %p\\n\",\n\t\t     &ci->vfs_inode, ci->i_head_snapc, ci->i_auth_cap);\n\t\tWARN_ON(!ci->i_auth_cap);\n\t\tBUG_ON(!list_empty(&ci->i_dirty_item));\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t\tlist_add(&ci->i_dirty_item, &mdsc->cap_dirty);\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\tif (ci->i_flushing_caps == 0) {\n\t\t\tihold(inode);\n\t\t\tdirty |= I_DIRTY_SYNC;\n\t\t}\n\t}\n\tBUG_ON(list_empty(&ci->i_dirty_item));\n\tif (((was | ci->i_flushing_caps) & CEPH_CAP_FILE_BUFFER) &&\n\t    (mask & CEPH_CAP_FILE_BUFFER))\n\t\tdirty |= I_DIRTY_DATASYNC;\n\t__cap_delay_requeue(mdsc, ci);\n\treturn dirty;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_mark_dirty_caps(struct ceph_inode_info *ci, int mask)\n{\n\tstruct ceph_mds_client *mdsc =\n\t\tceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tint was = ci->i_dirty_caps;\n\tint dirty = 0;\n\n\tdout(\"__mark_dirty_caps %p %s dirty %s -> %s\\n\", &ci->vfs_inode,\n\t     ceph_cap_string(mask), ceph_cap_string(was),\n\t     ceph_cap_string(was | mask));\n\tci->i_dirty_caps |= mask;\n\tif (was == 0) {\n\t\tif (!ci->i_head_snapc)\n\t\t\tci->i_head_snapc = ceph_get_snap_context(\n\t\t\t\tci->i_snap_realm->cached_context);\n\t\tdout(\" inode %p now dirty snapc %p auth cap %p\\n\",\n\t\t     &ci->vfs_inode, ci->i_head_snapc, ci->i_auth_cap);\n\t\tWARN_ON(!ci->i_auth_cap);\n\t\tBUG_ON(!list_empty(&ci->i_dirty_item));\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t\tlist_add(&ci->i_dirty_item, &mdsc->cap_dirty);\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\tif (ci->i_flushing_caps == 0) {\n\t\t\tihold(inode);\n\t\t\tdirty |= I_DIRTY_SYNC;\n\t\t}\n\t}\n\tBUG_ON(list_empty(&ci->i_dirty_item));\n\tif (((was | ci->i_flushing_caps) & CEPH_CAP_FILE_BUFFER) &&\n\t    (mask & CEPH_CAP_FILE_BUFFER))\n\t\tdirty |= I_DIRTY_DATASYNC;\n\t__cap_delay_requeue(mdsc, ci);\n\treturn dirty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__remove_xattr_by_name",
          "args": [
            "ceph_inode(inode)",
            "name"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_xattr_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "499-510",
          "snippet": "static int __remove_xattr_by_name(struct ceph_inode_info *ci,\n\t\t\t   const char *name)\n{\n\tstruct rb_node **p;\n\tstruct ceph_inode_xattr *xattr;\n\tint err;\n\n\tp = &ci->i_xattrs.index.rb_node;\n\txattr = __get_xattr(ci, name);\n\terr = __remove_xattr(ci, xattr);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nstatic int __remove_xattr_by_name(struct ceph_inode_info *ci,\n\t\t\t   const char *name)\n{\n\tstruct rb_node **p;\n\tstruct ceph_inode_xattr *xattr;\n\tint err;\n\n\tp = &ci->i_xattrs.index.rb_node;\n\txattr = __get_xattr(ci, name);\n\terr = __remove_xattr(ci, xattr);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_vxattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "273-280",
          "snippet": "static struct ceph_vxattr *ceph_inode_vxattrs(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn ceph_dir_vxattrs;\n\telse if (S_ISREG(inode->i_mode))\n\t\treturn ceph_file_vxattrs;\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ceph_vxattr ceph_dir_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.dir.layout\",\n\t\t.name_size = sizeof(\"ceph.dir.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(dir, layout, object_size),\n\tXATTR_LAYOUT_FIELD(dir, layout, pool),\n\tXATTR_NAME_CEPH(dir, entries),\n\tXATTR_NAME_CEPH(dir, files),\n\tXATTR_NAME_CEPH(dir, subdirs),\n\tXATTR_NAME_CEPH(dir, rentries),\n\tXATTR_NAME_CEPH(dir, rfiles),\n\tXATTR_NAME_CEPH(dir, rsubdirs),\n\tXATTR_NAME_CEPH(dir, rbytes),\n\tXATTR_NAME_CEPH(dir, rctime),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};",
            "static struct ceph_vxattr ceph_file_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.file.layout\",\n\t\t.name_size = sizeof(\"ceph.file.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(file, layout, object_size),\n\tXATTR_LAYOUT_FIELD(file, layout, pool),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_vxattr ceph_dir_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.dir.layout\",\n\t\t.name_size = sizeof(\"ceph.dir.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(dir, layout, object_size),\n\tXATTR_LAYOUT_FIELD(dir, layout, pool),\n\tXATTR_NAME_CEPH(dir, entries),\n\tXATTR_NAME_CEPH(dir, files),\n\tXATTR_NAME_CEPH(dir, subdirs),\n\tXATTR_NAME_CEPH(dir, rentries),\n\tXATTR_NAME_CEPH(dir, rfiles),\n\tXATTR_NAME_CEPH(dir, rsubdirs),\n\tXATTR_NAME_CEPH(dir, rbytes),\n\tXATTR_NAME_CEPH(dir, rctime),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};\nstatic struct ceph_vxattr ceph_file_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.file.layout\",\n\t\t.name_size = sizeof(\"ceph.file.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(file, layout, object_size),\n\tXATTR_LAYOUT_FIELD(file, layout, pool),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};\n\nstatic struct ceph_vxattr *ceph_inode_vxattrs(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn ceph_dir_vxattrs;\n\telse if (S_ISREG(inode->i_mode))\n\t\treturn ceph_file_vxattrs;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_buffer_put",
          "args": [
            "ci->i_xattrs.prealloc_blob"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_buffer_new",
          "args": [
            "required_blob_size",
            "GFP_NOFS"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" preaallocating new blob size=%d\\n\"",
            "required_blob_size"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_required_blob_size",
          "args": [
            "ci",
            "0",
            "0"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "__get_required_blob_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "651-669",
          "snippet": "static int __get_required_blob_size(struct ceph_inode_info *ci, int name_size,\n\t\t\t\t    int val_size)\n{\n\t/*\n\t * 4 bytes for the length, and additional 4 bytes per each xattr name,\n\t * 4 bytes per each value\n\t */\n\tint size = 4 + ci->i_xattrs.count*(4 + 4) +\n\t\t\t     ci->i_xattrs.names_size +\n\t\t\t     ci->i_xattrs.vals_size;\n\tdout(\"__get_required_blob_size c=%d names.size=%d vals.size=%d\\n\",\n\t     ci->i_xattrs.count, ci->i_xattrs.names_size,\n\t     ci->i_xattrs.vals_size);\n\n\tif (name_size)\n\t\tsize += 4 + 4 + name_size + val_size;\n\n\treturn size;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nstatic int __get_required_blob_size(struct ceph_inode_info *ci, int name_size,\n\t\t\t\t    int val_size)\n{\n\t/*\n\t * 4 bytes for the length, and additional 4 bytes per each xattr name,\n\t * 4 bytes per each value\n\t */\n\tint size = 4 + ci->i_xattrs.count*(4 + 4) +\n\t\t\t     ci->i_xattrs.names_size +\n\t\t\t     ci->i_xattrs.vals_size;\n\tdout(\"__get_required_blob_size c=%d names.size=%d vals.size=%d\\n\",\n\t     ci->i_xattrs.count, ci->i_xattrs.names_size,\n\t     ci->i_xattrs.vals_size);\n\n\tif (name_size)\n\t\tsize += 4 + 4 + name_size + val_size;\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__build_xattrs",
          "args": [
            "inode"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "__build_xattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "563-649",
          "snippet": "static int __build_xattrs(struct inode *inode)\n\t__releases(ci->i_ceph_lock)\n\t__acquires(ci->i_ceph_lock)\n{\n\tu32 namelen;\n\tu32 numattr = 0;\n\tvoid *p, *end;\n\tu32 len;\n\tconst char *name, *val;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint xattr_version;\n\tstruct ceph_inode_xattr **xattrs = NULL;\n\tint err = 0;\n\tint i;\n\n\tdout(\"__build_xattrs() len=%d\\n\",\n\t     ci->i_xattrs.blob ? (int)ci->i_xattrs.blob->vec.iov_len : 0);\n\n\tif (ci->i_xattrs.index_version >= ci->i_xattrs.version)\n\t\treturn 0; /* already built */\n\n\t__ceph_destroy_xattrs(ci);\n\nstart:\n\t/* updated internal xattr rb tree */\n\tif (ci->i_xattrs.blob && ci->i_xattrs.blob->vec.iov_len > 4) {\n\t\tp = ci->i_xattrs.blob->vec.iov_base;\n\t\tend = p + ci->i_xattrs.blob->vec.iov_len;\n\t\tceph_decode_32_safe(&p, end, numattr, bad);\n\t\txattr_version = ci->i_xattrs.version;\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\txattrs = kcalloc(numattr, sizeof(struct ceph_inode_xattr *),\n\t\t\t\t GFP_NOFS);\n\t\terr = -ENOMEM;\n\t\tif (!xattrs)\n\t\t\tgoto bad_lock;\n\n\t\tfor (i = 0; i < numattr; i++) {\n\t\t\txattrs[i] = kmalloc(sizeof(struct ceph_inode_xattr),\n\t\t\t\t\t    GFP_NOFS);\n\t\t\tif (!xattrs[i])\n\t\t\t\tgoto bad_lock;\n\t\t}\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tif (ci->i_xattrs.version != xattr_version) {\n\t\t\t/* lost a race, retry */\n\t\t\tfor (i = 0; i < numattr; i++)\n\t\t\t\tkfree(xattrs[i]);\n\t\t\tkfree(xattrs);\n\t\t\txattrs = NULL;\n\t\t\tgoto start;\n\t\t}\n\t\terr = -EIO;\n\t\twhile (numattr--) {\n\t\t\tceph_decode_32_safe(&p, end, len, bad);\n\t\t\tnamelen = len;\n\t\t\tname = p;\n\t\t\tp += len;\n\t\t\tceph_decode_32_safe(&p, end, len, bad);\n\t\t\tval = p;\n\t\t\tp += len;\n\n\t\t\terr = __set_xattr(ci, name, namelen, val, len,\n\t\t\t\t\t  0, 0, &xattrs[numattr]);\n\n\t\t\tif (err < 0)\n\t\t\t\tgoto bad;\n\t\t}\n\t\tkfree(xattrs);\n\t}\n\tci->i_xattrs.index_version = ci->i_xattrs.version;\n\tci->i_xattrs.dirty = false;\n\n\treturn err;\nbad_lock:\n\tspin_lock(&ci->i_ceph_lock);\nbad:\n\tif (xattrs) {\n\t\tfor (i = 0; i < numattr; i++)\n\t\t\tkfree(xattrs[i]);\n\t\tkfree(xattrs);\n\t}\n\tci->i_xattrs.names_size = 0;\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nstatic int __build_xattrs(struct inode *inode)\n\t__releases(ci->i_ceph_lock)\n\t__acquires(ci->i_ceph_lock)\n{\n\tu32 namelen;\n\tu32 numattr = 0;\n\tvoid *p, *end;\n\tu32 len;\n\tconst char *name, *val;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint xattr_version;\n\tstruct ceph_inode_xattr **xattrs = NULL;\n\tint err = 0;\n\tint i;\n\n\tdout(\"__build_xattrs() len=%d\\n\",\n\t     ci->i_xattrs.blob ? (int)ci->i_xattrs.blob->vec.iov_len : 0);\n\n\tif (ci->i_xattrs.index_version >= ci->i_xattrs.version)\n\t\treturn 0; /* already built */\n\n\t__ceph_destroy_xattrs(ci);\n\nstart:\n\t/* updated internal xattr rb tree */\n\tif (ci->i_xattrs.blob && ci->i_xattrs.blob->vec.iov_len > 4) {\n\t\tp = ci->i_xattrs.blob->vec.iov_base;\n\t\tend = p + ci->i_xattrs.blob->vec.iov_len;\n\t\tceph_decode_32_safe(&p, end, numattr, bad);\n\t\txattr_version = ci->i_xattrs.version;\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\txattrs = kcalloc(numattr, sizeof(struct ceph_inode_xattr *),\n\t\t\t\t GFP_NOFS);\n\t\terr = -ENOMEM;\n\t\tif (!xattrs)\n\t\t\tgoto bad_lock;\n\n\t\tfor (i = 0; i < numattr; i++) {\n\t\t\txattrs[i] = kmalloc(sizeof(struct ceph_inode_xattr),\n\t\t\t\t\t    GFP_NOFS);\n\t\t\tif (!xattrs[i])\n\t\t\t\tgoto bad_lock;\n\t\t}\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tif (ci->i_xattrs.version != xattr_version) {\n\t\t\t/* lost a race, retry */\n\t\t\tfor (i = 0; i < numattr; i++)\n\t\t\t\tkfree(xattrs[i]);\n\t\t\tkfree(xattrs);\n\t\t\txattrs = NULL;\n\t\t\tgoto start;\n\t\t}\n\t\terr = -EIO;\n\t\twhile (numattr--) {\n\t\t\tceph_decode_32_safe(&p, end, len, bad);\n\t\t\tnamelen = len;\n\t\t\tname = p;\n\t\t\tp += len;\n\t\t\tceph_decode_32_safe(&p, end, len, bad);\n\t\t\tval = p;\n\t\t\tp += len;\n\n\t\t\terr = __set_xattr(ci, name, namelen, val, len,\n\t\t\t\t\t  0, 0, &xattrs[numattr]);\n\n\t\t\tif (err < 0)\n\t\t\t\tgoto bad;\n\t\t}\n\t\tkfree(xattrs);\n\t}\n\tci->i_xattrs.index_version = ci->i_xattrs.version;\n\tci->i_xattrs.dirty = false;\n\n\treturn err;\nbad_lock:\n\tspin_lock(&ci->i_ceph_lock);\nbad:\n\tif (xattrs) {\n\t\tfor (i = 0; i < numattr; i++)\n\t\t\tkfree(xattrs[i]);\n\t\tkfree(xattrs);\n\t}\n\tci->i_xattrs.names_size = 0;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"removexattr %p issued %s\\n\"",
            "inode",
            "ceph_cap_string(issued)"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "issued"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_issued",
          "args": [
            "ci",
            "NULL"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_issued_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "700-715",
          "snippet": "int __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_CEPH_PREFIX",
            "XATTR_CEPH_PREFIX_LEN"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_match_vxattr",
          "args": [
            "inode",
            "name"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_match_vxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "322-336",
          "snippet": "static struct ceph_vxattr *ceph_match_vxattr(struct inode *inode,\n\t\t\t\t\t\tconst char *name)\n{\n\tstruct ceph_vxattr *vxattr = ceph_inode_vxattrs(inode);\n\n\tif (vxattr) {\n\t\twhile (vxattr->name) {\n\t\t\tif (!strcmp(vxattr->name, name))\n\t\t\t\treturn vxattr;\n\t\t\tvxattr++;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_vxattr *ceph_match_vxattr(struct inode *inode,\n\t\t\t\t\t\tconst char *name)\n{\n\tstruct ceph_vxattr *vxattr = ceph_inode_vxattrs(inode);\n\n\tif (vxattr) {\n\t\twhile (vxattr->name) {\n\t\t\tif (!strcmp(vxattr->name, name))\n\t\t\t\treturn vxattr;\n\t\t\tvxattr++;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_is_valid_xattr",
          "args": [
            "name"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_is_valid_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "31-39",
          "snippet": "static bool ceph_is_valid_xattr(const char *name)\n{\n\treturn !strncmp(name, XATTR_CEPH_PREFIX, XATTR_CEPH_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\tXATTR_SECURITY_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define XATTR_CEPH_PREFIX_LEN (sizeof (XATTR_CEPH_PREFIX) - 1)",
            "#define XATTR_CEPH_PREFIX \"ceph.\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define XATTR_CEPH_PREFIX_LEN (sizeof (XATTR_CEPH_PREFIX) - 1)\n#define XATTR_CEPH_PREFIX \"ceph.\"\n\nstatic bool ceph_is_valid_xattr(const char *name)\n{\n\treturn !strncmp(name, XATTR_CEPH_PREFIX, XATTR_CEPH_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\tXATTR_SECURITY_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define XATTR_CEPH_PREFIX_LEN (sizeof (XATTR_CEPH_PREFIX) - 1)\n#define XATTR_CEPH_PREFIX \"ceph.\"\n\nint __ceph_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ceph_vxattr *vxattr;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint issued;\n\tint err;\n\tint required_blob_size;\n\tint dirty;\n\n\tif (!ceph_is_valid_xattr(name))\n\t\treturn -EOPNOTSUPP;\n\n\tvxattr = ceph_match_vxattr(inode, name);\n\tif (vxattr && vxattr->readonly)\n\t\treturn -EOPNOTSUPP;\n\n\t/* pass any unhandled ceph.* xattrs through to the MDS */\n\tif (!strncmp(name, XATTR_CEPH_PREFIX, XATTR_CEPH_PREFIX_LEN))\n\t\tgoto do_sync_unlocked;\n\n\terr = -ENOMEM;\n\tspin_lock(&ci->i_ceph_lock);\nretry:\n\tissued = __ceph_caps_issued(ci, NULL);\n\tdout(\"removexattr %p issued %s\\n\", inode, ceph_cap_string(issued));\n\n\tif (ci->i_xattrs.version == 0 || !(issued & CEPH_CAP_XATTR_EXCL))\n\t\tgoto do_sync;\n\t__build_xattrs(inode);\n\n\trequired_blob_size = __get_required_blob_size(ci, 0, 0);\n\n\tif (!ci->i_xattrs.prealloc_blob ||\n\t    required_blob_size > ci->i_xattrs.prealloc_blob->alloc_len) {\n\t\tstruct ceph_buffer *blob;\n\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tdout(\" preaallocating new blob size=%d\\n\", required_blob_size);\n\t\tblob = ceph_buffer_new(required_blob_size, GFP_NOFS);\n\t\tif (!blob)\n\t\t\tgoto out;\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tif (ci->i_xattrs.prealloc_blob)\n\t\t\tceph_buffer_put(ci->i_xattrs.prealloc_blob);\n\t\tci->i_xattrs.prealloc_blob = blob;\n\t\tgoto retry;\n\t}\n\n\terr = __remove_xattr_by_name(ceph_inode(inode), name);\n\n\tdirty = __ceph_mark_dirty_caps(ci, CEPH_CAP_XATTR_EXCL);\n\tci->i_xattrs.dirty = true;\n\tinode->i_ctime = CURRENT_TIME;\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (dirty)\n\t\t__mark_inode_dirty(inode, dirty);\n\treturn err;\ndo_sync:\n\tspin_unlock(&ci->i_ceph_lock);\ndo_sync_unlocked:\n\terr = ceph_send_removexattr(dentry, name);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "ceph_send_removexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "1010-1031",
    "snippet": "static int ceph_send_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(dentry->d_sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ceph_mds_request *req;\n\tint err;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_RMXATTR,\n\t\t\t\t       USE_AUTH_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_inode_drop = CEPH_CAP_XATTR_SHARED;\n\treq->r_num_caps = 1;\n\treq->r_path2 = kstrdup(name, GFP_NOFS);\n\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tceph_mdsc_put_request(req);\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_mdsc_put_request",
          "args": [
            "req"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.h",
          "lines": "377-380",
          "snippet": "static inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}",
          "includes": [
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mdsmap.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kref.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/auth.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/types.h>\n#include <linux/spinlock.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kref.h>\n#include <linux/completion.h>\n\nstatic inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_do_request",
          "args": [
            "mdsc",
            "NULL",
            "req"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_do_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2212-2284",
          "snippet": "int ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nint ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "name",
            "GFP_NOFS"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_create_request",
          "args": [
            "mdsc",
            "CEPH_MDS_OP_RMXATTR",
            "USE_AUTH_MDS"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_create_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1640-1665",
          "snippet": "struct ceph_mds_request *\nceph_mdsc_create_request(struct ceph_mds_client *mdsc, int op, int mode)\n{\n\tstruct ceph_mds_request *req = kzalloc(sizeof(*req), GFP_NOFS);\n\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&req->r_fill_mutex);\n\treq->r_mdsc = mdsc;\n\treq->r_started = jiffies;\n\treq->r_resend_mds = -1;\n\tINIT_LIST_HEAD(&req->r_unsafe_dir_item);\n\treq->r_fmode = -1;\n\tkref_init(&req->r_kref);\n\tINIT_LIST_HEAD(&req->r_wait);\n\tinit_completion(&req->r_completion);\n\tinit_completion(&req->r_safe_completion);\n\tINIT_LIST_HEAD(&req->r_unsafe_item);\n\n\treq->r_stamp = CURRENT_TIME;\n\n\treq->r_op = op;\n\treq->r_direct_mode = mode;\n\treturn req;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_mds_request *\nceph_mdsc_create_request(struct ceph_mds_client *mdsc, int op, int mode)\n{\n\tstruct ceph_mds_request *req = kzalloc(sizeof(*req), GFP_NOFS);\n\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&req->r_fill_mutex);\n\treq->r_mdsc = mdsc;\n\treq->r_started = jiffies;\n\treq->r_resend_mds = -1;\n\tINIT_LIST_HEAD(&req->r_unsafe_dir_item);\n\treq->r_fmode = -1;\n\tkref_init(&req->r_kref);\n\tINIT_LIST_HEAD(&req->r_wait);\n\tinit_completion(&req->r_completion);\n\tinit_completion(&req->r_safe_completion);\n\tINIT_LIST_HEAD(&req->r_unsafe_item);\n\n\treq->r_stamp = CURRENT_TIME;\n\n\treq->r_op = op;\n\treq->r_direct_mode = mode;\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "dentry->d_sb"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_send_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(dentry->d_sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ceph_mds_request *req;\n\tint err;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_RMXATTR,\n\t\t\t\t       USE_AUTH_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_inode_drop = CEPH_CAP_XATTR_SHARED;\n\treq->r_num_caps = 1;\n\treq->r_path2 = kstrdup(name, GFP_NOFS);\n\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tceph_mdsc_put_request(req);\n\treturn err;\n}"
  },
  {
    "function_name": "ceph_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "995-1008",
    "snippet": "int ceph_setxattr(struct dentry *dentry, const char *name,\n\t\t  const void *value, size_t size, int flags)\n{\n\tif (ceph_snap(dentry->d_inode) != CEPH_NOSNAP)\n\t\treturn -EROFS;\n\n\tif (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn generic_setxattr(dentry, name, value, size, flags);\n\n\tif (size == 0)\n\t\tvalue = \"\";  /* empty EA, do not remove */\n\n\treturn __ceph_setxattr(dentry, name, value, size, flags);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ceph_setxattr",
          "args": [
            "dentry",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "901-993",
          "snippet": "int __ceph_setxattr(struct dentry *dentry, const char *name,\n\t\t\tconst void *value, size_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ceph_vxattr *vxattr;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint issued;\n\tint err;\n\tint dirty = 0;\n\tint name_len = strlen(name);\n\tint val_len = size;\n\tchar *newname = NULL;\n\tchar *newval = NULL;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\tint required_blob_size;\n\n\tif (!ceph_is_valid_xattr(name))\n\t\treturn -EOPNOTSUPP;\n\n\tvxattr = ceph_match_vxattr(inode, name);\n\tif (vxattr && vxattr->readonly)\n\t\treturn -EOPNOTSUPP;\n\n\t/* pass any unhandled ceph.* xattrs through to the MDS */\n\tif (!strncmp(name, XATTR_CEPH_PREFIX, XATTR_CEPH_PREFIX_LEN))\n\t\tgoto do_sync_unlocked;\n\n\t/* preallocate memory for xattr name, value, index node */\n\terr = -ENOMEM;\n\tnewname = kmemdup(name, name_len + 1, GFP_NOFS);\n\tif (!newname)\n\t\tgoto out;\n\n\tif (val_len) {\n\t\tnewval = kmemdup(value, val_len, GFP_NOFS);\n\t\tif (!newval)\n\t\t\tgoto out;\n\t}\n\n\txattr = kmalloc(sizeof(struct ceph_inode_xattr), GFP_NOFS);\n\tif (!xattr)\n\t\tgoto out;\n\n\tspin_lock(&ci->i_ceph_lock);\nretry:\n\tissued = __ceph_caps_issued(ci, NULL);\n\tdout(\"setxattr %p issued %s\\n\", inode, ceph_cap_string(issued));\n\tif (ci->i_xattrs.version == 0 || !(issued & CEPH_CAP_XATTR_EXCL))\n\t\tgoto do_sync;\n\t__build_xattrs(inode);\n\n\trequired_blob_size = __get_required_blob_size(ci, name_len, val_len);\n\n\tif (!ci->i_xattrs.prealloc_blob ||\n\t    required_blob_size > ci->i_xattrs.prealloc_blob->alloc_len) {\n\t\tstruct ceph_buffer *blob;\n\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tdout(\" preaallocating new blob size=%d\\n\", required_blob_size);\n\t\tblob = ceph_buffer_new(required_blob_size, GFP_NOFS);\n\t\tif (!blob)\n\t\t\tgoto out;\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tif (ci->i_xattrs.prealloc_blob)\n\t\t\tceph_buffer_put(ci->i_xattrs.prealloc_blob);\n\t\tci->i_xattrs.prealloc_blob = blob;\n\t\tgoto retry;\n\t}\n\n\terr = __set_xattr(ci, newname, name_len, newval, val_len,\n\t\t\t  flags, value ? 1 : -1, &xattr);\n\n\tif (!err) {\n\t\tdirty = __ceph_mark_dirty_caps(ci, CEPH_CAP_XATTR_EXCL);\n\t\tci->i_xattrs.dirty = true;\n\t\tinode->i_ctime = CURRENT_TIME;\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (dirty)\n\t\t__mark_inode_dirty(inode, dirty);\n\treturn err;\n\ndo_sync:\n\tspin_unlock(&ci->i_ceph_lock);\ndo_sync_unlocked:\n\terr = ceph_sync_setxattr(dentry, name, value, size, flags);\nout:\n\tkfree(newname);\n\tkfree(newval);\n\tkfree(xattr);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define XATTR_CEPH_PREFIX_LEN (sizeof (XATTR_CEPH_PREFIX) - 1)",
            "#define XATTR_CEPH_PREFIX \"ceph.\""
          ],
          "globals_used": [
            "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define XATTR_CEPH_PREFIX_LEN (sizeof (XATTR_CEPH_PREFIX) - 1)\n#define XATTR_CEPH_PREFIX \"ceph.\"\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nint __ceph_setxattr(struct dentry *dentry, const char *name,\n\t\t\tconst void *value, size_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ceph_vxattr *vxattr;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint issued;\n\tint err;\n\tint dirty = 0;\n\tint name_len = strlen(name);\n\tint val_len = size;\n\tchar *newname = NULL;\n\tchar *newval = NULL;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\tint required_blob_size;\n\n\tif (!ceph_is_valid_xattr(name))\n\t\treturn -EOPNOTSUPP;\n\n\tvxattr = ceph_match_vxattr(inode, name);\n\tif (vxattr && vxattr->readonly)\n\t\treturn -EOPNOTSUPP;\n\n\t/* pass any unhandled ceph.* xattrs through to the MDS */\n\tif (!strncmp(name, XATTR_CEPH_PREFIX, XATTR_CEPH_PREFIX_LEN))\n\t\tgoto do_sync_unlocked;\n\n\t/* preallocate memory for xattr name, value, index node */\n\terr = -ENOMEM;\n\tnewname = kmemdup(name, name_len + 1, GFP_NOFS);\n\tif (!newname)\n\t\tgoto out;\n\n\tif (val_len) {\n\t\tnewval = kmemdup(value, val_len, GFP_NOFS);\n\t\tif (!newval)\n\t\t\tgoto out;\n\t}\n\n\txattr = kmalloc(sizeof(struct ceph_inode_xattr), GFP_NOFS);\n\tif (!xattr)\n\t\tgoto out;\n\n\tspin_lock(&ci->i_ceph_lock);\nretry:\n\tissued = __ceph_caps_issued(ci, NULL);\n\tdout(\"setxattr %p issued %s\\n\", inode, ceph_cap_string(issued));\n\tif (ci->i_xattrs.version == 0 || !(issued & CEPH_CAP_XATTR_EXCL))\n\t\tgoto do_sync;\n\t__build_xattrs(inode);\n\n\trequired_blob_size = __get_required_blob_size(ci, name_len, val_len);\n\n\tif (!ci->i_xattrs.prealloc_blob ||\n\t    required_blob_size > ci->i_xattrs.prealloc_blob->alloc_len) {\n\t\tstruct ceph_buffer *blob;\n\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tdout(\" preaallocating new blob size=%d\\n\", required_blob_size);\n\t\tblob = ceph_buffer_new(required_blob_size, GFP_NOFS);\n\t\tif (!blob)\n\t\t\tgoto out;\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tif (ci->i_xattrs.prealloc_blob)\n\t\t\tceph_buffer_put(ci->i_xattrs.prealloc_blob);\n\t\tci->i_xattrs.prealloc_blob = blob;\n\t\tgoto retry;\n\t}\n\n\terr = __set_xattr(ci, newname, name_len, newval, val_len,\n\t\t\t  flags, value ? 1 : -1, &xattr);\n\n\tif (!err) {\n\t\tdirty = __ceph_mark_dirty_caps(ci, CEPH_CAP_XATTR_EXCL);\n\t\tci->i_xattrs.dirty = true;\n\t\tinode->i_ctime = CURRENT_TIME;\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (dirty)\n\t\t__mark_inode_dirty(inode, dirty);\n\treturn err;\n\ndo_sync:\n\tspin_unlock(&ci->i_ceph_lock);\ndo_sync_unlocked:\n\terr = ceph_sync_setxattr(dentry, name, value, size, flags);\nout:\n\tkfree(newname);\n\tkfree(newval);\n\tkfree(xattr);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_setxattr",
          "args": [
            "dentry",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "generic_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "760-771",
          "snippet": "int\ngeneric_setxattr(struct dentry *dentry, const char *name, const void *value, size_t size, int flags)\n{\n\tconst struct xattr_handler *handler;\n\n\tif (size == 0)\n\t\tvalue = \"\";  /* empty EA, do not remove */\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->set(dentry, name, value, size, flags, handler->flags);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ngeneric_setxattr(struct dentry *dentry, const char *name, const void *value, size_t size, int flags)\n{\n\tconst struct xattr_handler *handler;\n\n\tif (size == 0)\n\t\tvalue = \"\";  /* empty EA, do not remove */\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->set(dentry, name, value, size, flags, handler->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_SYSTEM_PREFIX",
            "XATTR_SYSTEM_PREFIX_LEN"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_snap",
          "args": [
            "dentry->d_inode"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_snap_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "115-124",
          "snippet": "const char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_setxattr(struct dentry *dentry, const char *name,\n\t\t  const void *value, size_t size, int flags)\n{\n\tif (ceph_snap(dentry->d_inode) != CEPH_NOSNAP)\n\t\treturn -EROFS;\n\n\tif (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn generic_setxattr(dentry, name, value, size, flags);\n\n\tif (size == 0)\n\t\tvalue = \"\";  /* empty EA, do not remove */\n\n\treturn __ceph_setxattr(dentry, name, value, size, flags);\n}"
  },
  {
    "function_name": "__ceph_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "901-993",
    "snippet": "int __ceph_setxattr(struct dentry *dentry, const char *name,\n\t\t\tconst void *value, size_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ceph_vxattr *vxattr;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint issued;\n\tint err;\n\tint dirty = 0;\n\tint name_len = strlen(name);\n\tint val_len = size;\n\tchar *newname = NULL;\n\tchar *newval = NULL;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\tint required_blob_size;\n\n\tif (!ceph_is_valid_xattr(name))\n\t\treturn -EOPNOTSUPP;\n\n\tvxattr = ceph_match_vxattr(inode, name);\n\tif (vxattr && vxattr->readonly)\n\t\treturn -EOPNOTSUPP;\n\n\t/* pass any unhandled ceph.* xattrs through to the MDS */\n\tif (!strncmp(name, XATTR_CEPH_PREFIX, XATTR_CEPH_PREFIX_LEN))\n\t\tgoto do_sync_unlocked;\n\n\t/* preallocate memory for xattr name, value, index node */\n\terr = -ENOMEM;\n\tnewname = kmemdup(name, name_len + 1, GFP_NOFS);\n\tif (!newname)\n\t\tgoto out;\n\n\tif (val_len) {\n\t\tnewval = kmemdup(value, val_len, GFP_NOFS);\n\t\tif (!newval)\n\t\t\tgoto out;\n\t}\n\n\txattr = kmalloc(sizeof(struct ceph_inode_xattr), GFP_NOFS);\n\tif (!xattr)\n\t\tgoto out;\n\n\tspin_lock(&ci->i_ceph_lock);\nretry:\n\tissued = __ceph_caps_issued(ci, NULL);\n\tdout(\"setxattr %p issued %s\\n\", inode, ceph_cap_string(issued));\n\tif (ci->i_xattrs.version == 0 || !(issued & CEPH_CAP_XATTR_EXCL))\n\t\tgoto do_sync;\n\t__build_xattrs(inode);\n\n\trequired_blob_size = __get_required_blob_size(ci, name_len, val_len);\n\n\tif (!ci->i_xattrs.prealloc_blob ||\n\t    required_blob_size > ci->i_xattrs.prealloc_blob->alloc_len) {\n\t\tstruct ceph_buffer *blob;\n\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tdout(\" preaallocating new blob size=%d\\n\", required_blob_size);\n\t\tblob = ceph_buffer_new(required_blob_size, GFP_NOFS);\n\t\tif (!blob)\n\t\t\tgoto out;\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tif (ci->i_xattrs.prealloc_blob)\n\t\t\tceph_buffer_put(ci->i_xattrs.prealloc_blob);\n\t\tci->i_xattrs.prealloc_blob = blob;\n\t\tgoto retry;\n\t}\n\n\terr = __set_xattr(ci, newname, name_len, newval, val_len,\n\t\t\t  flags, value ? 1 : -1, &xattr);\n\n\tif (!err) {\n\t\tdirty = __ceph_mark_dirty_caps(ci, CEPH_CAP_XATTR_EXCL);\n\t\tci->i_xattrs.dirty = true;\n\t\tinode->i_ctime = CURRENT_TIME;\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (dirty)\n\t\t__mark_inode_dirty(inode, dirty);\n\treturn err;\n\ndo_sync:\n\tspin_unlock(&ci->i_ceph_lock);\ndo_sync_unlocked:\n\terr = ceph_sync_setxattr(dentry, name, value, size, flags);\nout:\n\tkfree(newname);\n\tkfree(newval);\n\tkfree(xattr);\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [
      "#define XATTR_CEPH_PREFIX_LEN (sizeof (XATTR_CEPH_PREFIX) - 1)",
      "#define XATTR_CEPH_PREFIX \"ceph.\""
    ],
    "globals_used": [
      "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "xattr"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "newval"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "newname"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_sync_setxattr",
          "args": [
            "dentry",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sync_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "846-899",
          "snippet": "static int ceph_sync_setxattr(struct dentry *dentry, const char *name,\n\t\t\t      const char *value, size_t size, int flags)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(dentry->d_sb);\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mds_request *req;\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_pagelist *pagelist = NULL;\n\tint err;\n\n\tif (size > 0) {\n\t\t/* copy value into pagelist */\n\t\tpagelist = kmalloc(sizeof(*pagelist), GFP_NOFS);\n\t\tif (!pagelist)\n\t\t\treturn -ENOMEM;\n\n\t\tceph_pagelist_init(pagelist);\n\t\terr = ceph_pagelist_append(pagelist, value, size);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else if (!value) {\n\t\tflags |= CEPH_XATTR_REMOVE;\n\t}\n\n\tdout(\"setxattr value=%.*s\\n\", (int)size, value);\n\n\t/* do request */\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_SETXATTR,\n\t\t\t\t       USE_AUTH_MDS);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_inode_drop = CEPH_CAP_XATTR_SHARED;\n\treq->r_num_caps = 1;\n\treq->r_args.setxattr.flags = cpu_to_le32(flags);\n\treq->r_path2 = kstrdup(name, GFP_NOFS);\n\n\treq->r_pagelist = pagelist;\n\tpagelist = NULL;\n\n\tdout(\"xattr.ver (before): %lld\\n\", ci->i_xattrs.version);\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tceph_mdsc_put_request(req);\n\tdout(\"xattr.ver (after): %lld\\n\", ci->i_xattrs.version);\n\nout:\n\tif (pagelist)\n\t\tceph_pagelist_release(pagelist);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nstatic int ceph_sync_setxattr(struct dentry *dentry, const char *name,\n\t\t\t      const char *value, size_t size, int flags)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(dentry->d_sb);\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mds_request *req;\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_pagelist *pagelist = NULL;\n\tint err;\n\n\tif (size > 0) {\n\t\t/* copy value into pagelist */\n\t\tpagelist = kmalloc(sizeof(*pagelist), GFP_NOFS);\n\t\tif (!pagelist)\n\t\t\treturn -ENOMEM;\n\n\t\tceph_pagelist_init(pagelist);\n\t\terr = ceph_pagelist_append(pagelist, value, size);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else if (!value) {\n\t\tflags |= CEPH_XATTR_REMOVE;\n\t}\n\n\tdout(\"setxattr value=%.*s\\n\", (int)size, value);\n\n\t/* do request */\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_SETXATTR,\n\t\t\t\t       USE_AUTH_MDS);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_inode_drop = CEPH_CAP_XATTR_SHARED;\n\treq->r_num_caps = 1;\n\treq->r_args.setxattr.flags = cpu_to_le32(flags);\n\treq->r_path2 = kstrdup(name, GFP_NOFS);\n\n\treq->r_pagelist = pagelist;\n\tpagelist = NULL;\n\n\tdout(\"xattr.ver (before): %lld\\n\", ci->i_xattrs.version);\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tceph_mdsc_put_request(req);\n\tdout(\"xattr.ver (after): %lld\\n\", ci->i_xattrs.version);\n\nout:\n\tif (pagelist)\n\t\tceph_pagelist_release(pagelist);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mark_inode_dirty",
          "args": [
            "inode",
            "dirty"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1181-1285",
          "snippet": "void __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)\n\nvoid __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_mark_dirty_caps",
          "args": [
            "ci",
            "CEPH_CAP_XATTR_EXCL"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_mark_dirty_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1389-1423",
          "snippet": "int __ceph_mark_dirty_caps(struct ceph_inode_info *ci, int mask)\n{\n\tstruct ceph_mds_client *mdsc =\n\t\tceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tint was = ci->i_dirty_caps;\n\tint dirty = 0;\n\n\tdout(\"__mark_dirty_caps %p %s dirty %s -> %s\\n\", &ci->vfs_inode,\n\t     ceph_cap_string(mask), ceph_cap_string(was),\n\t     ceph_cap_string(was | mask));\n\tci->i_dirty_caps |= mask;\n\tif (was == 0) {\n\t\tif (!ci->i_head_snapc)\n\t\t\tci->i_head_snapc = ceph_get_snap_context(\n\t\t\t\tci->i_snap_realm->cached_context);\n\t\tdout(\" inode %p now dirty snapc %p auth cap %p\\n\",\n\t\t     &ci->vfs_inode, ci->i_head_snapc, ci->i_auth_cap);\n\t\tWARN_ON(!ci->i_auth_cap);\n\t\tBUG_ON(!list_empty(&ci->i_dirty_item));\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t\tlist_add(&ci->i_dirty_item, &mdsc->cap_dirty);\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\tif (ci->i_flushing_caps == 0) {\n\t\t\tihold(inode);\n\t\t\tdirty |= I_DIRTY_SYNC;\n\t\t}\n\t}\n\tBUG_ON(list_empty(&ci->i_dirty_item));\n\tif (((was | ci->i_flushing_caps) & CEPH_CAP_FILE_BUFFER) &&\n\t    (mask & CEPH_CAP_FILE_BUFFER))\n\t\tdirty |= I_DIRTY_DATASYNC;\n\t__cap_delay_requeue(mdsc, ci);\n\treturn dirty;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_mark_dirty_caps(struct ceph_inode_info *ci, int mask)\n{\n\tstruct ceph_mds_client *mdsc =\n\t\tceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tint was = ci->i_dirty_caps;\n\tint dirty = 0;\n\n\tdout(\"__mark_dirty_caps %p %s dirty %s -> %s\\n\", &ci->vfs_inode,\n\t     ceph_cap_string(mask), ceph_cap_string(was),\n\t     ceph_cap_string(was | mask));\n\tci->i_dirty_caps |= mask;\n\tif (was == 0) {\n\t\tif (!ci->i_head_snapc)\n\t\t\tci->i_head_snapc = ceph_get_snap_context(\n\t\t\t\tci->i_snap_realm->cached_context);\n\t\tdout(\" inode %p now dirty snapc %p auth cap %p\\n\",\n\t\t     &ci->vfs_inode, ci->i_head_snapc, ci->i_auth_cap);\n\t\tWARN_ON(!ci->i_auth_cap);\n\t\tBUG_ON(!list_empty(&ci->i_dirty_item));\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t\tlist_add(&ci->i_dirty_item, &mdsc->cap_dirty);\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\tif (ci->i_flushing_caps == 0) {\n\t\t\tihold(inode);\n\t\t\tdirty |= I_DIRTY_SYNC;\n\t\t}\n\t}\n\tBUG_ON(list_empty(&ci->i_dirty_item));\n\tif (((was | ci->i_flushing_caps) & CEPH_CAP_FILE_BUFFER) &&\n\t    (mask & CEPH_CAP_FILE_BUFFER))\n\t\tdirty |= I_DIRTY_DATASYNC;\n\t__cap_delay_requeue(mdsc, ci);\n\treturn dirty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_xattr",
          "args": [
            "ci",
            "newname",
            "name_len",
            "newval",
            "val_len",
            "flags",
            "value ? 1 : -1",
            "&xattr"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "__set_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "338-432",
          "snippet": "static int __set_xattr(struct ceph_inode_info *ci,\n\t\t\t   const char *name, int name_len,\n\t\t\t   const char *val, int val_len,\n\t\t\t   int flags, int update_xattr,\n\t\t\t   struct ceph_inode_xattr **newxattr)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\tint c;\n\tint new = 0;\n\n\tp = &ci->i_xattrs.index.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\txattr = rb_entry(parent, struct ceph_inode_xattr, node);\n\t\tc = strncmp(name, xattr->name, min(name_len, xattr->name_len));\n\t\tif (c < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (c > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tif (name_len == xattr->name_len)\n\t\t\t\tbreak;\n\t\t\telse if (name_len < xattr->name_len)\n\t\t\t\tp = &(*p)->rb_left;\n\t\t\telse\n\t\t\t\tp = &(*p)->rb_right;\n\t\t}\n\t\txattr = NULL;\n\t}\n\n\tif (update_xattr) {\n\t\tint err = 0;\n\t\tif (xattr && (flags & XATTR_CREATE))\n\t\t\terr = -EEXIST;\n\t\telse if (!xattr && (flags & XATTR_REPLACE))\n\t\t\terr = -ENODATA;\n\t\tif (err) {\n\t\t\tkfree(name);\n\t\t\tkfree(val);\n\t\t\treturn err;\n\t\t}\n\t\tif (update_xattr < 0) {\n\t\t\tif (xattr)\n\t\t\t\t__remove_xattr(ci, xattr);\n\t\t\tkfree(name);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!xattr) {\n\t\tnew = 1;\n\t\txattr = *newxattr;\n\t\txattr->name = name;\n\t\txattr->name_len = name_len;\n\t\txattr->should_free_name = update_xattr;\n\n\t\tci->i_xattrs.count++;\n\t\tdout(\"__set_xattr count=%d\\n\", ci->i_xattrs.count);\n\t} else {\n\t\tkfree(*newxattr);\n\t\t*newxattr = NULL;\n\t\tif (xattr->should_free_val)\n\t\t\tkfree((void *)xattr->val);\n\n\t\tif (update_xattr) {\n\t\t\tkfree((void *)name);\n\t\t\tname = xattr->name;\n\t\t}\n\t\tci->i_xattrs.names_size -= xattr->name_len;\n\t\tci->i_xattrs.vals_size -= xattr->val_len;\n\t}\n\tci->i_xattrs.names_size += name_len;\n\tci->i_xattrs.vals_size += val_len;\n\tif (val)\n\t\txattr->val = val;\n\telse\n\t\txattr->val = \"\";\n\n\txattr->val_len = val_len;\n\txattr->dirty = update_xattr;\n\txattr->should_free_val = (val && update_xattr);\n\n\tif (new) {\n\t\trb_link_node(&xattr->node, parent, p);\n\t\trb_insert_color(&xattr->node, &ci->i_xattrs.index);\n\t\tdout(\"__set_xattr_val p=%p\\n\", p);\n\t}\n\n\tdout(\"__set_xattr_val added %llx.%llx xattr %p %s=%.*s\\n\",\n\t     ceph_vinop(&ci->vfs_inode), xattr, name, val_len, val);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nstatic int __set_xattr(struct ceph_inode_info *ci,\n\t\t\t   const char *name, int name_len,\n\t\t\t   const char *val, int val_len,\n\t\t\t   int flags, int update_xattr,\n\t\t\t   struct ceph_inode_xattr **newxattr)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\tint c;\n\tint new = 0;\n\n\tp = &ci->i_xattrs.index.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\txattr = rb_entry(parent, struct ceph_inode_xattr, node);\n\t\tc = strncmp(name, xattr->name, min(name_len, xattr->name_len));\n\t\tif (c < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (c > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tif (name_len == xattr->name_len)\n\t\t\t\tbreak;\n\t\t\telse if (name_len < xattr->name_len)\n\t\t\t\tp = &(*p)->rb_left;\n\t\t\telse\n\t\t\t\tp = &(*p)->rb_right;\n\t\t}\n\t\txattr = NULL;\n\t}\n\n\tif (update_xattr) {\n\t\tint err = 0;\n\t\tif (xattr && (flags & XATTR_CREATE))\n\t\t\terr = -EEXIST;\n\t\telse if (!xattr && (flags & XATTR_REPLACE))\n\t\t\terr = -ENODATA;\n\t\tif (err) {\n\t\t\tkfree(name);\n\t\t\tkfree(val);\n\t\t\treturn err;\n\t\t}\n\t\tif (update_xattr < 0) {\n\t\t\tif (xattr)\n\t\t\t\t__remove_xattr(ci, xattr);\n\t\t\tkfree(name);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!xattr) {\n\t\tnew = 1;\n\t\txattr = *newxattr;\n\t\txattr->name = name;\n\t\txattr->name_len = name_len;\n\t\txattr->should_free_name = update_xattr;\n\n\t\tci->i_xattrs.count++;\n\t\tdout(\"__set_xattr count=%d\\n\", ci->i_xattrs.count);\n\t} else {\n\t\tkfree(*newxattr);\n\t\t*newxattr = NULL;\n\t\tif (xattr->should_free_val)\n\t\t\tkfree((void *)xattr->val);\n\n\t\tif (update_xattr) {\n\t\t\tkfree((void *)name);\n\t\t\tname = xattr->name;\n\t\t}\n\t\tci->i_xattrs.names_size -= xattr->name_len;\n\t\tci->i_xattrs.vals_size -= xattr->val_len;\n\t}\n\tci->i_xattrs.names_size += name_len;\n\tci->i_xattrs.vals_size += val_len;\n\tif (val)\n\t\txattr->val = val;\n\telse\n\t\txattr->val = \"\";\n\n\txattr->val_len = val_len;\n\txattr->dirty = update_xattr;\n\txattr->should_free_val = (val && update_xattr);\n\n\tif (new) {\n\t\trb_link_node(&xattr->node, parent, p);\n\t\trb_insert_color(&xattr->node, &ci->i_xattrs.index);\n\t\tdout(\"__set_xattr_val p=%p\\n\", p);\n\t}\n\n\tdout(\"__set_xattr_val added %llx.%llx xattr %p %s=%.*s\\n\",\n\t     ceph_vinop(&ci->vfs_inode), xattr, name, val_len, val);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_buffer_put",
          "args": [
            "ci->i_xattrs.prealloc_blob"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_buffer_new",
          "args": [
            "required_blob_size",
            "GFP_NOFS"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" preaallocating new blob size=%d\\n\"",
            "required_blob_size"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_required_blob_size",
          "args": [
            "ci",
            "name_len",
            "val_len"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "__get_required_blob_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "651-669",
          "snippet": "static int __get_required_blob_size(struct ceph_inode_info *ci, int name_size,\n\t\t\t\t    int val_size)\n{\n\t/*\n\t * 4 bytes for the length, and additional 4 bytes per each xattr name,\n\t * 4 bytes per each value\n\t */\n\tint size = 4 + ci->i_xattrs.count*(4 + 4) +\n\t\t\t     ci->i_xattrs.names_size +\n\t\t\t     ci->i_xattrs.vals_size;\n\tdout(\"__get_required_blob_size c=%d names.size=%d vals.size=%d\\n\",\n\t     ci->i_xattrs.count, ci->i_xattrs.names_size,\n\t     ci->i_xattrs.vals_size);\n\n\tif (name_size)\n\t\tsize += 4 + 4 + name_size + val_size;\n\n\treturn size;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nstatic int __get_required_blob_size(struct ceph_inode_info *ci, int name_size,\n\t\t\t\t    int val_size)\n{\n\t/*\n\t * 4 bytes for the length, and additional 4 bytes per each xattr name,\n\t * 4 bytes per each value\n\t */\n\tint size = 4 + ci->i_xattrs.count*(4 + 4) +\n\t\t\t     ci->i_xattrs.names_size +\n\t\t\t     ci->i_xattrs.vals_size;\n\tdout(\"__get_required_blob_size c=%d names.size=%d vals.size=%d\\n\",\n\t     ci->i_xattrs.count, ci->i_xattrs.names_size,\n\t     ci->i_xattrs.vals_size);\n\n\tif (name_size)\n\t\tsize += 4 + 4 + name_size + val_size;\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__build_xattrs",
          "args": [
            "inode"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "__build_xattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "563-649",
          "snippet": "static int __build_xattrs(struct inode *inode)\n\t__releases(ci->i_ceph_lock)\n\t__acquires(ci->i_ceph_lock)\n{\n\tu32 namelen;\n\tu32 numattr = 0;\n\tvoid *p, *end;\n\tu32 len;\n\tconst char *name, *val;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint xattr_version;\n\tstruct ceph_inode_xattr **xattrs = NULL;\n\tint err = 0;\n\tint i;\n\n\tdout(\"__build_xattrs() len=%d\\n\",\n\t     ci->i_xattrs.blob ? (int)ci->i_xattrs.blob->vec.iov_len : 0);\n\n\tif (ci->i_xattrs.index_version >= ci->i_xattrs.version)\n\t\treturn 0; /* already built */\n\n\t__ceph_destroy_xattrs(ci);\n\nstart:\n\t/* updated internal xattr rb tree */\n\tif (ci->i_xattrs.blob && ci->i_xattrs.blob->vec.iov_len > 4) {\n\t\tp = ci->i_xattrs.blob->vec.iov_base;\n\t\tend = p + ci->i_xattrs.blob->vec.iov_len;\n\t\tceph_decode_32_safe(&p, end, numattr, bad);\n\t\txattr_version = ci->i_xattrs.version;\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\txattrs = kcalloc(numattr, sizeof(struct ceph_inode_xattr *),\n\t\t\t\t GFP_NOFS);\n\t\terr = -ENOMEM;\n\t\tif (!xattrs)\n\t\t\tgoto bad_lock;\n\n\t\tfor (i = 0; i < numattr; i++) {\n\t\t\txattrs[i] = kmalloc(sizeof(struct ceph_inode_xattr),\n\t\t\t\t\t    GFP_NOFS);\n\t\t\tif (!xattrs[i])\n\t\t\t\tgoto bad_lock;\n\t\t}\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tif (ci->i_xattrs.version != xattr_version) {\n\t\t\t/* lost a race, retry */\n\t\t\tfor (i = 0; i < numattr; i++)\n\t\t\t\tkfree(xattrs[i]);\n\t\t\tkfree(xattrs);\n\t\t\txattrs = NULL;\n\t\t\tgoto start;\n\t\t}\n\t\terr = -EIO;\n\t\twhile (numattr--) {\n\t\t\tceph_decode_32_safe(&p, end, len, bad);\n\t\t\tnamelen = len;\n\t\t\tname = p;\n\t\t\tp += len;\n\t\t\tceph_decode_32_safe(&p, end, len, bad);\n\t\t\tval = p;\n\t\t\tp += len;\n\n\t\t\terr = __set_xattr(ci, name, namelen, val, len,\n\t\t\t\t\t  0, 0, &xattrs[numattr]);\n\n\t\t\tif (err < 0)\n\t\t\t\tgoto bad;\n\t\t}\n\t\tkfree(xattrs);\n\t}\n\tci->i_xattrs.index_version = ci->i_xattrs.version;\n\tci->i_xattrs.dirty = false;\n\n\treturn err;\nbad_lock:\n\tspin_lock(&ci->i_ceph_lock);\nbad:\n\tif (xattrs) {\n\t\tfor (i = 0; i < numattr; i++)\n\t\t\tkfree(xattrs[i]);\n\t\tkfree(xattrs);\n\t}\n\tci->i_xattrs.names_size = 0;\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nstatic int __build_xattrs(struct inode *inode)\n\t__releases(ci->i_ceph_lock)\n\t__acquires(ci->i_ceph_lock)\n{\n\tu32 namelen;\n\tu32 numattr = 0;\n\tvoid *p, *end;\n\tu32 len;\n\tconst char *name, *val;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint xattr_version;\n\tstruct ceph_inode_xattr **xattrs = NULL;\n\tint err = 0;\n\tint i;\n\n\tdout(\"__build_xattrs() len=%d\\n\",\n\t     ci->i_xattrs.blob ? (int)ci->i_xattrs.blob->vec.iov_len : 0);\n\n\tif (ci->i_xattrs.index_version >= ci->i_xattrs.version)\n\t\treturn 0; /* already built */\n\n\t__ceph_destroy_xattrs(ci);\n\nstart:\n\t/* updated internal xattr rb tree */\n\tif (ci->i_xattrs.blob && ci->i_xattrs.blob->vec.iov_len > 4) {\n\t\tp = ci->i_xattrs.blob->vec.iov_base;\n\t\tend = p + ci->i_xattrs.blob->vec.iov_len;\n\t\tceph_decode_32_safe(&p, end, numattr, bad);\n\t\txattr_version = ci->i_xattrs.version;\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\txattrs = kcalloc(numattr, sizeof(struct ceph_inode_xattr *),\n\t\t\t\t GFP_NOFS);\n\t\terr = -ENOMEM;\n\t\tif (!xattrs)\n\t\t\tgoto bad_lock;\n\n\t\tfor (i = 0; i < numattr; i++) {\n\t\t\txattrs[i] = kmalloc(sizeof(struct ceph_inode_xattr),\n\t\t\t\t\t    GFP_NOFS);\n\t\t\tif (!xattrs[i])\n\t\t\t\tgoto bad_lock;\n\t\t}\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tif (ci->i_xattrs.version != xattr_version) {\n\t\t\t/* lost a race, retry */\n\t\t\tfor (i = 0; i < numattr; i++)\n\t\t\t\tkfree(xattrs[i]);\n\t\t\tkfree(xattrs);\n\t\t\txattrs = NULL;\n\t\t\tgoto start;\n\t\t}\n\t\terr = -EIO;\n\t\twhile (numattr--) {\n\t\t\tceph_decode_32_safe(&p, end, len, bad);\n\t\t\tnamelen = len;\n\t\t\tname = p;\n\t\t\tp += len;\n\t\t\tceph_decode_32_safe(&p, end, len, bad);\n\t\t\tval = p;\n\t\t\tp += len;\n\n\t\t\terr = __set_xattr(ci, name, namelen, val, len,\n\t\t\t\t\t  0, 0, &xattrs[numattr]);\n\n\t\t\tif (err < 0)\n\t\t\t\tgoto bad;\n\t\t}\n\t\tkfree(xattrs);\n\t}\n\tci->i_xattrs.index_version = ci->i_xattrs.version;\n\tci->i_xattrs.dirty = false;\n\n\treturn err;\nbad_lock:\n\tspin_lock(&ci->i_ceph_lock);\nbad:\n\tif (xattrs) {\n\t\tfor (i = 0; i < numattr; i++)\n\t\t\tkfree(xattrs[i]);\n\t\tkfree(xattrs);\n\t}\n\tci->i_xattrs.names_size = 0;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"setxattr %p issued %s\\n\"",
            "inode",
            "ceph_cap_string(issued)"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "issued"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_issued",
          "args": [
            "ci",
            "NULL"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_issued_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "700-715",
          "snippet": "int __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct ceph_inode_xattr)",
            "GFP_NOFS"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "value",
            "val_len",
            "GFP_NOFS"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "name",
            "name_len + 1",
            "GFP_NOFS"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_CEPH_PREFIX",
            "XATTR_CEPH_PREFIX_LEN"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_match_vxattr",
          "args": [
            "inode",
            "name"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_match_vxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "322-336",
          "snippet": "static struct ceph_vxattr *ceph_match_vxattr(struct inode *inode,\n\t\t\t\t\t\tconst char *name)\n{\n\tstruct ceph_vxattr *vxattr = ceph_inode_vxattrs(inode);\n\n\tif (vxattr) {\n\t\twhile (vxattr->name) {\n\t\t\tif (!strcmp(vxattr->name, name))\n\t\t\t\treturn vxattr;\n\t\t\tvxattr++;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_vxattr *ceph_match_vxattr(struct inode *inode,\n\t\t\t\t\t\tconst char *name)\n{\n\tstruct ceph_vxattr *vxattr = ceph_inode_vxattrs(inode);\n\n\tif (vxattr) {\n\t\twhile (vxattr->name) {\n\t\t\tif (!strcmp(vxattr->name, name))\n\t\t\t\treturn vxattr;\n\t\t\tvxattr++;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_is_valid_xattr",
          "args": [
            "name"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_is_valid_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "31-39",
          "snippet": "static bool ceph_is_valid_xattr(const char *name)\n{\n\treturn !strncmp(name, XATTR_CEPH_PREFIX, XATTR_CEPH_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\tXATTR_SECURITY_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define XATTR_CEPH_PREFIX_LEN (sizeof (XATTR_CEPH_PREFIX) - 1)",
            "#define XATTR_CEPH_PREFIX \"ceph.\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define XATTR_CEPH_PREFIX_LEN (sizeof (XATTR_CEPH_PREFIX) - 1)\n#define XATTR_CEPH_PREFIX \"ceph.\"\n\nstatic bool ceph_is_valid_xattr(const char *name)\n{\n\treturn !strncmp(name, XATTR_CEPH_PREFIX, XATTR_CEPH_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\tXATTR_SECURITY_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_vxattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "273-280",
          "snippet": "static struct ceph_vxattr *ceph_inode_vxattrs(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn ceph_dir_vxattrs;\n\telse if (S_ISREG(inode->i_mode))\n\t\treturn ceph_file_vxattrs;\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ceph_vxattr ceph_dir_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.dir.layout\",\n\t\t.name_size = sizeof(\"ceph.dir.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(dir, layout, object_size),\n\tXATTR_LAYOUT_FIELD(dir, layout, pool),\n\tXATTR_NAME_CEPH(dir, entries),\n\tXATTR_NAME_CEPH(dir, files),\n\tXATTR_NAME_CEPH(dir, subdirs),\n\tXATTR_NAME_CEPH(dir, rentries),\n\tXATTR_NAME_CEPH(dir, rfiles),\n\tXATTR_NAME_CEPH(dir, rsubdirs),\n\tXATTR_NAME_CEPH(dir, rbytes),\n\tXATTR_NAME_CEPH(dir, rctime),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};",
            "static struct ceph_vxattr ceph_file_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.file.layout\",\n\t\t.name_size = sizeof(\"ceph.file.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(file, layout, object_size),\n\tXATTR_LAYOUT_FIELD(file, layout, pool),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_vxattr ceph_dir_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.dir.layout\",\n\t\t.name_size = sizeof(\"ceph.dir.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(dir, layout, object_size),\n\tXATTR_LAYOUT_FIELD(dir, layout, pool),\n\tXATTR_NAME_CEPH(dir, entries),\n\tXATTR_NAME_CEPH(dir, files),\n\tXATTR_NAME_CEPH(dir, subdirs),\n\tXATTR_NAME_CEPH(dir, rentries),\n\tXATTR_NAME_CEPH(dir, rfiles),\n\tXATTR_NAME_CEPH(dir, rsubdirs),\n\tXATTR_NAME_CEPH(dir, rbytes),\n\tXATTR_NAME_CEPH(dir, rctime),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};\nstatic struct ceph_vxattr ceph_file_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.file.layout\",\n\t\t.name_size = sizeof(\"ceph.file.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(file, layout, object_size),\n\tXATTR_LAYOUT_FIELD(file, layout, pool),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};\n\nstatic struct ceph_vxattr *ceph_inode_vxattrs(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn ceph_dir_vxattrs;\n\telse if (S_ISREG(inode->i_mode))\n\t\treturn ceph_file_vxattrs;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define XATTR_CEPH_PREFIX_LEN (sizeof (XATTR_CEPH_PREFIX) - 1)\n#define XATTR_CEPH_PREFIX \"ceph.\"\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nint __ceph_setxattr(struct dentry *dentry, const char *name,\n\t\t\tconst void *value, size_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ceph_vxattr *vxattr;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint issued;\n\tint err;\n\tint dirty = 0;\n\tint name_len = strlen(name);\n\tint val_len = size;\n\tchar *newname = NULL;\n\tchar *newval = NULL;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\tint required_blob_size;\n\n\tif (!ceph_is_valid_xattr(name))\n\t\treturn -EOPNOTSUPP;\n\n\tvxattr = ceph_match_vxattr(inode, name);\n\tif (vxattr && vxattr->readonly)\n\t\treturn -EOPNOTSUPP;\n\n\t/* pass any unhandled ceph.* xattrs through to the MDS */\n\tif (!strncmp(name, XATTR_CEPH_PREFIX, XATTR_CEPH_PREFIX_LEN))\n\t\tgoto do_sync_unlocked;\n\n\t/* preallocate memory for xattr name, value, index node */\n\terr = -ENOMEM;\n\tnewname = kmemdup(name, name_len + 1, GFP_NOFS);\n\tif (!newname)\n\t\tgoto out;\n\n\tif (val_len) {\n\t\tnewval = kmemdup(value, val_len, GFP_NOFS);\n\t\tif (!newval)\n\t\t\tgoto out;\n\t}\n\n\txattr = kmalloc(sizeof(struct ceph_inode_xattr), GFP_NOFS);\n\tif (!xattr)\n\t\tgoto out;\n\n\tspin_lock(&ci->i_ceph_lock);\nretry:\n\tissued = __ceph_caps_issued(ci, NULL);\n\tdout(\"setxattr %p issued %s\\n\", inode, ceph_cap_string(issued));\n\tif (ci->i_xattrs.version == 0 || !(issued & CEPH_CAP_XATTR_EXCL))\n\t\tgoto do_sync;\n\t__build_xattrs(inode);\n\n\trequired_blob_size = __get_required_blob_size(ci, name_len, val_len);\n\n\tif (!ci->i_xattrs.prealloc_blob ||\n\t    required_blob_size > ci->i_xattrs.prealloc_blob->alloc_len) {\n\t\tstruct ceph_buffer *blob;\n\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tdout(\" preaallocating new blob size=%d\\n\", required_blob_size);\n\t\tblob = ceph_buffer_new(required_blob_size, GFP_NOFS);\n\t\tif (!blob)\n\t\t\tgoto out;\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tif (ci->i_xattrs.prealloc_blob)\n\t\t\tceph_buffer_put(ci->i_xattrs.prealloc_blob);\n\t\tci->i_xattrs.prealloc_blob = blob;\n\t\tgoto retry;\n\t}\n\n\terr = __set_xattr(ci, newname, name_len, newval, val_len,\n\t\t\t  flags, value ? 1 : -1, &xattr);\n\n\tif (!err) {\n\t\tdirty = __ceph_mark_dirty_caps(ci, CEPH_CAP_XATTR_EXCL);\n\t\tci->i_xattrs.dirty = true;\n\t\tinode->i_ctime = CURRENT_TIME;\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (dirty)\n\t\t__mark_inode_dirty(inode, dirty);\n\treturn err;\n\ndo_sync:\n\tspin_unlock(&ci->i_ceph_lock);\ndo_sync_unlocked:\n\terr = ceph_sync_setxattr(dentry, name, value, size, flags);\nout:\n\tkfree(newname);\n\tkfree(newval);\n\tkfree(xattr);\n\treturn err;\n}"
  },
  {
    "function_name": "ceph_sync_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "846-899",
    "snippet": "static int ceph_sync_setxattr(struct dentry *dentry, const char *name,\n\t\t\t      const char *value, size_t size, int flags)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(dentry->d_sb);\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mds_request *req;\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_pagelist *pagelist = NULL;\n\tint err;\n\n\tif (size > 0) {\n\t\t/* copy value into pagelist */\n\t\tpagelist = kmalloc(sizeof(*pagelist), GFP_NOFS);\n\t\tif (!pagelist)\n\t\t\treturn -ENOMEM;\n\n\t\tceph_pagelist_init(pagelist);\n\t\terr = ceph_pagelist_append(pagelist, value, size);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else if (!value) {\n\t\tflags |= CEPH_XATTR_REMOVE;\n\t}\n\n\tdout(\"setxattr value=%.*s\\n\", (int)size, value);\n\n\t/* do request */\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_SETXATTR,\n\t\t\t\t       USE_AUTH_MDS);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_inode_drop = CEPH_CAP_XATTR_SHARED;\n\treq->r_num_caps = 1;\n\treq->r_args.setxattr.flags = cpu_to_le32(flags);\n\treq->r_path2 = kstrdup(name, GFP_NOFS);\n\n\treq->r_pagelist = pagelist;\n\tpagelist = NULL;\n\n\tdout(\"xattr.ver (before): %lld\\n\", ci->i_xattrs.version);\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tceph_mdsc_put_request(req);\n\tdout(\"xattr.ver (after): %lld\\n\", ci->i_xattrs.version);\n\nout:\n\tif (pagelist)\n\t\tceph_pagelist_release(pagelist);\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_pagelist_release",
          "args": [
            "pagelist"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"xattr.ver (after): %lld\\n\"",
            "ci->i_xattrs.version"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_put_request",
          "args": [
            "req"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.h",
          "lines": "377-380",
          "snippet": "static inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}",
          "includes": [
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mdsmap.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kref.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/auth.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/types.h>\n#include <linux/spinlock.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kref.h>\n#include <linux/completion.h>\n\nstatic inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_do_request",
          "args": [
            "mdsc",
            "NULL",
            "req"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_do_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2212-2284",
          "snippet": "int ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nint ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"xattr.ver (before): %lld\\n\"",
            "ci->i_xattrs.version"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "name",
            "GFP_NOFS"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "flags"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_create_request",
          "args": [
            "mdsc",
            "CEPH_MDS_OP_SETXATTR",
            "USE_AUTH_MDS"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_create_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1640-1665",
          "snippet": "struct ceph_mds_request *\nceph_mdsc_create_request(struct ceph_mds_client *mdsc, int op, int mode)\n{\n\tstruct ceph_mds_request *req = kzalloc(sizeof(*req), GFP_NOFS);\n\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&req->r_fill_mutex);\n\treq->r_mdsc = mdsc;\n\treq->r_started = jiffies;\n\treq->r_resend_mds = -1;\n\tINIT_LIST_HEAD(&req->r_unsafe_dir_item);\n\treq->r_fmode = -1;\n\tkref_init(&req->r_kref);\n\tINIT_LIST_HEAD(&req->r_wait);\n\tinit_completion(&req->r_completion);\n\tinit_completion(&req->r_safe_completion);\n\tINIT_LIST_HEAD(&req->r_unsafe_item);\n\n\treq->r_stamp = CURRENT_TIME;\n\n\treq->r_op = op;\n\treq->r_direct_mode = mode;\n\treturn req;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_mds_request *\nceph_mdsc_create_request(struct ceph_mds_client *mdsc, int op, int mode)\n{\n\tstruct ceph_mds_request *req = kzalloc(sizeof(*req), GFP_NOFS);\n\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&req->r_fill_mutex);\n\treq->r_mdsc = mdsc;\n\treq->r_started = jiffies;\n\treq->r_resend_mds = -1;\n\tINIT_LIST_HEAD(&req->r_unsafe_dir_item);\n\treq->r_fmode = -1;\n\tkref_init(&req->r_kref);\n\tINIT_LIST_HEAD(&req->r_wait);\n\tinit_completion(&req->r_completion);\n\tinit_completion(&req->r_safe_completion);\n\tINIT_LIST_HEAD(&req->r_unsafe_item);\n\n\treq->r_stamp = CURRENT_TIME;\n\n\treq->r_op = op;\n\treq->r_direct_mode = mode;\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"setxattr value=%.*s\\n\"",
            "(int)size",
            "value"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_pagelist_append",
          "args": [
            "pagelist",
            "value",
            "size"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_pagelist_init",
          "args": [
            "pagelist"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*pagelist)",
            "GFP_NOFS"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_vxattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "273-280",
          "snippet": "static struct ceph_vxattr *ceph_inode_vxattrs(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn ceph_dir_vxattrs;\n\telse if (S_ISREG(inode->i_mode))\n\t\treturn ceph_file_vxattrs;\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ceph_vxattr ceph_dir_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.dir.layout\",\n\t\t.name_size = sizeof(\"ceph.dir.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(dir, layout, object_size),\n\tXATTR_LAYOUT_FIELD(dir, layout, pool),\n\tXATTR_NAME_CEPH(dir, entries),\n\tXATTR_NAME_CEPH(dir, files),\n\tXATTR_NAME_CEPH(dir, subdirs),\n\tXATTR_NAME_CEPH(dir, rentries),\n\tXATTR_NAME_CEPH(dir, rfiles),\n\tXATTR_NAME_CEPH(dir, rsubdirs),\n\tXATTR_NAME_CEPH(dir, rbytes),\n\tXATTR_NAME_CEPH(dir, rctime),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};",
            "static struct ceph_vxattr ceph_file_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.file.layout\",\n\t\t.name_size = sizeof(\"ceph.file.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(file, layout, object_size),\n\tXATTR_LAYOUT_FIELD(file, layout, pool),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_vxattr ceph_dir_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.dir.layout\",\n\t\t.name_size = sizeof(\"ceph.dir.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(dir, layout, object_size),\n\tXATTR_LAYOUT_FIELD(dir, layout, pool),\n\tXATTR_NAME_CEPH(dir, entries),\n\tXATTR_NAME_CEPH(dir, files),\n\tXATTR_NAME_CEPH(dir, subdirs),\n\tXATTR_NAME_CEPH(dir, rentries),\n\tXATTR_NAME_CEPH(dir, rfiles),\n\tXATTR_NAME_CEPH(dir, rsubdirs),\n\tXATTR_NAME_CEPH(dir, rbytes),\n\tXATTR_NAME_CEPH(dir, rctime),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};\nstatic struct ceph_vxattr ceph_file_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.file.layout\",\n\t\t.name_size = sizeof(\"ceph.file.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(file, layout, object_size),\n\tXATTR_LAYOUT_FIELD(file, layout, pool),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};\n\nstatic struct ceph_vxattr *ceph_inode_vxattrs(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn ceph_dir_vxattrs;\n\telse if (S_ISREG(inode->i_mode))\n\t\treturn ceph_file_vxattrs;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "dentry->d_sb"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nstatic int ceph_sync_setxattr(struct dentry *dentry, const char *name,\n\t\t\t      const char *value, size_t size, int flags)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(dentry->d_sb);\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mds_request *req;\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_pagelist *pagelist = NULL;\n\tint err;\n\n\tif (size > 0) {\n\t\t/* copy value into pagelist */\n\t\tpagelist = kmalloc(sizeof(*pagelist), GFP_NOFS);\n\t\tif (!pagelist)\n\t\t\treturn -ENOMEM;\n\n\t\tceph_pagelist_init(pagelist);\n\t\terr = ceph_pagelist_append(pagelist, value, size);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else if (!value) {\n\t\tflags |= CEPH_XATTR_REMOVE;\n\t}\n\n\tdout(\"setxattr value=%.*s\\n\", (int)size, value);\n\n\t/* do request */\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_SETXATTR,\n\t\t\t\t       USE_AUTH_MDS);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_inode_drop = CEPH_CAP_XATTR_SHARED;\n\treq->r_num_caps = 1;\n\treq->r_args.setxattr.flags = cpu_to_le32(flags);\n\treq->r_path2 = kstrdup(name, GFP_NOFS);\n\n\treq->r_pagelist = pagelist;\n\tpagelist = NULL;\n\n\tdout(\"xattr.ver (before): %lld\\n\", ci->i_xattrs.version);\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tceph_mdsc_put_request(req);\n\tdout(\"xattr.ver (after): %lld\\n\", ci->i_xattrs.version);\n\nout:\n\tif (pagelist)\n\t\tceph_pagelist_release(pagelist);\n\treturn err;\n}"
  },
  {
    "function_name": "ceph_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "782-844",
    "snippet": "ssize_t ceph_listxattr(struct dentry *dentry, char *names, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_vxattr *vxattrs = ceph_inode_vxattrs(inode);\n\tu32 vir_namelen = 0;\n\tu32 namelen;\n\tint err;\n\tu32 len;\n\tint i;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"listxattr %p ver=%lld index_ver=%lld\\n\", inode,\n\t     ci->i_xattrs.version, ci->i_xattrs.index_version);\n\n\tif (ci->i_xattrs.version == 0 ||\n\t    !__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 1)) {\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\terr = ceph_do_getattr(inode, CEPH_STAT_CAP_XATTR, true);\n\t\tif (err)\n\t\t\treturn err;\n\t\tspin_lock(&ci->i_ceph_lock);\n\t}\n\n\terr = __build_xattrs(inode);\n\tif (err < 0)\n\t\tgoto out;\n\t/*\n\t * Start with virtual dir xattr names (if any) (including\n\t * terminating '\\0' characters for each).\n\t */\n\tvir_namelen = ceph_vxattrs_name_size(vxattrs);\n\n\t/* adding 1 byte per each variable due to the null termination */\n\tnamelen = ci->i_xattrs.names_size + ci->i_xattrs.count;\n\terr = -ERANGE;\n\tif (size && vir_namelen + namelen > size)\n\t\tgoto out;\n\n\terr = namelen + vir_namelen;\n\tif (size == 0)\n\t\tgoto out;\n\n\tnames = __copy_xattr_names(ci, names);\n\n\t/* virtual xattr names, too */\n\terr = namelen;\n\tif (vxattrs) {\n\t\tfor (i = 0; vxattrs[i].name; i++) {\n\t\t\tif (!vxattrs[i].hidden &&\n\t\t\t    !(vxattrs[i].exists_cb &&\n\t\t\t      !vxattrs[i].exists_cb(ci))) {\n\t\t\t\tlen = sprintf(names, \"%s\", vxattrs[i].name);\n\t\t\t\tnames += len + 1;\n\t\t\t\terr += len + 1;\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "names",
            "\"%s\"",
            "vxattrs[i].name"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vxattrs[i].exists_cb",
          "args": [
            "ci"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_xattr_names",
          "args": [
            "ci",
            "names"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "__copy_xattr_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "512-534",
          "snippet": "static char *__copy_xattr_names(struct ceph_inode_info *ci,\n\t\t\t\tchar *dest)\n{\n\tstruct rb_node *p;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\n\tp = rb_first(&ci->i_xattrs.index);\n\tdout(\"__copy_xattr_names count=%d\\n\", ci->i_xattrs.count);\n\n\twhile (p) {\n\t\txattr = rb_entry(p, struct ceph_inode_xattr, node);\n\t\tmemcpy(dest, xattr->name, xattr->name_len);\n\t\tdest[xattr->name_len] = '\\0';\n\n\t\tdout(\"dest=%s %p (%s) (%d/%d)\\n\", dest, xattr, xattr->name,\n\t\t     xattr->name_len, ci->i_xattrs.names_size);\n\n\t\tdest += xattr->name_len + 1;\n\t\tp = rb_next(p);\n\t}\n\n\treturn dest;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nstatic char *__copy_xattr_names(struct ceph_inode_info *ci,\n\t\t\t\tchar *dest)\n{\n\tstruct rb_node *p;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\n\tp = rb_first(&ci->i_xattrs.index);\n\tdout(\"__copy_xattr_names count=%d\\n\", ci->i_xattrs.count);\n\n\twhile (p) {\n\t\txattr = rb_entry(p, struct ceph_inode_xattr, node);\n\t\tmemcpy(dest, xattr->name, xattr->name_len);\n\t\tdest[xattr->name_len] = '\\0';\n\n\t\tdout(\"dest=%s %p (%s) (%d/%d)\\n\", dest, xattr, xattr->name,\n\t\t     xattr->name_len, ci->i_xattrs.names_size);\n\n\t\tdest += xattr->name_len + 1;\n\t\tp = rb_next(p);\n\t}\n\n\treturn dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_vxattrs_name_size",
          "args": [
            "vxattrs"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_vxattrs_name_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "282-290",
          "snippet": "static size_t ceph_vxattrs_name_size(struct ceph_vxattr *vxattrs)\n{\n\tif (vxattrs == ceph_dir_vxattrs)\n\t\treturn ceph_dir_vxattrs_name_size;\n\tif (vxattrs == ceph_file_vxattrs)\n\t\treturn ceph_file_vxattrs_name_size;\n\tBUG_ON(vxattrs);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ceph_vxattr ceph_dir_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.dir.layout\",\n\t\t.name_size = sizeof(\"ceph.dir.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(dir, layout, object_size),\n\tXATTR_LAYOUT_FIELD(dir, layout, pool),\n\tXATTR_NAME_CEPH(dir, entries),\n\tXATTR_NAME_CEPH(dir, files),\n\tXATTR_NAME_CEPH(dir, subdirs),\n\tXATTR_NAME_CEPH(dir, rentries),\n\tXATTR_NAME_CEPH(dir, rfiles),\n\tXATTR_NAME_CEPH(dir, rsubdirs),\n\tXATTR_NAME_CEPH(dir, rbytes),\n\tXATTR_NAME_CEPH(dir, rctime),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};",
            "static size_t ceph_dir_vxattrs_name_size;",
            "static struct ceph_vxattr ceph_file_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.file.layout\",\n\t\t.name_size = sizeof(\"ceph.file.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(file, layout, object_size),\n\tXATTR_LAYOUT_FIELD(file, layout, pool),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};",
            "static size_t ceph_file_vxattrs_name_size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_vxattr ceph_dir_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.dir.layout\",\n\t\t.name_size = sizeof(\"ceph.dir.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(dir, layout, object_size),\n\tXATTR_LAYOUT_FIELD(dir, layout, pool),\n\tXATTR_NAME_CEPH(dir, entries),\n\tXATTR_NAME_CEPH(dir, files),\n\tXATTR_NAME_CEPH(dir, subdirs),\n\tXATTR_NAME_CEPH(dir, rentries),\n\tXATTR_NAME_CEPH(dir, rfiles),\n\tXATTR_NAME_CEPH(dir, rsubdirs),\n\tXATTR_NAME_CEPH(dir, rbytes),\n\tXATTR_NAME_CEPH(dir, rctime),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};\nstatic size_t ceph_dir_vxattrs_name_size;\nstatic struct ceph_vxattr ceph_file_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.file.layout\",\n\t\t.name_size = sizeof(\"ceph.file.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(file, layout, object_size),\n\tXATTR_LAYOUT_FIELD(file, layout, pool),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};\nstatic size_t ceph_file_vxattrs_name_size;\n\nstatic size_t ceph_vxattrs_name_size(struct ceph_vxattr *vxattrs)\n{\n\tif (vxattrs == ceph_dir_vxattrs)\n\t\treturn ceph_dir_vxattrs_name_size;\n\tif (vxattrs == ceph_file_vxattrs)\n\t\treturn ceph_file_vxattrs_name_size;\n\tBUG_ON(vxattrs);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__build_xattrs",
          "args": [
            "inode"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "__build_xattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "563-649",
          "snippet": "static int __build_xattrs(struct inode *inode)\n\t__releases(ci->i_ceph_lock)\n\t__acquires(ci->i_ceph_lock)\n{\n\tu32 namelen;\n\tu32 numattr = 0;\n\tvoid *p, *end;\n\tu32 len;\n\tconst char *name, *val;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint xattr_version;\n\tstruct ceph_inode_xattr **xattrs = NULL;\n\tint err = 0;\n\tint i;\n\n\tdout(\"__build_xattrs() len=%d\\n\",\n\t     ci->i_xattrs.blob ? (int)ci->i_xattrs.blob->vec.iov_len : 0);\n\n\tif (ci->i_xattrs.index_version >= ci->i_xattrs.version)\n\t\treturn 0; /* already built */\n\n\t__ceph_destroy_xattrs(ci);\n\nstart:\n\t/* updated internal xattr rb tree */\n\tif (ci->i_xattrs.blob && ci->i_xattrs.blob->vec.iov_len > 4) {\n\t\tp = ci->i_xattrs.blob->vec.iov_base;\n\t\tend = p + ci->i_xattrs.blob->vec.iov_len;\n\t\tceph_decode_32_safe(&p, end, numattr, bad);\n\t\txattr_version = ci->i_xattrs.version;\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\txattrs = kcalloc(numattr, sizeof(struct ceph_inode_xattr *),\n\t\t\t\t GFP_NOFS);\n\t\terr = -ENOMEM;\n\t\tif (!xattrs)\n\t\t\tgoto bad_lock;\n\n\t\tfor (i = 0; i < numattr; i++) {\n\t\t\txattrs[i] = kmalloc(sizeof(struct ceph_inode_xattr),\n\t\t\t\t\t    GFP_NOFS);\n\t\t\tif (!xattrs[i])\n\t\t\t\tgoto bad_lock;\n\t\t}\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tif (ci->i_xattrs.version != xattr_version) {\n\t\t\t/* lost a race, retry */\n\t\t\tfor (i = 0; i < numattr; i++)\n\t\t\t\tkfree(xattrs[i]);\n\t\t\tkfree(xattrs);\n\t\t\txattrs = NULL;\n\t\t\tgoto start;\n\t\t}\n\t\terr = -EIO;\n\t\twhile (numattr--) {\n\t\t\tceph_decode_32_safe(&p, end, len, bad);\n\t\t\tnamelen = len;\n\t\t\tname = p;\n\t\t\tp += len;\n\t\t\tceph_decode_32_safe(&p, end, len, bad);\n\t\t\tval = p;\n\t\t\tp += len;\n\n\t\t\terr = __set_xattr(ci, name, namelen, val, len,\n\t\t\t\t\t  0, 0, &xattrs[numattr]);\n\n\t\t\tif (err < 0)\n\t\t\t\tgoto bad;\n\t\t}\n\t\tkfree(xattrs);\n\t}\n\tci->i_xattrs.index_version = ci->i_xattrs.version;\n\tci->i_xattrs.dirty = false;\n\n\treturn err;\nbad_lock:\n\tspin_lock(&ci->i_ceph_lock);\nbad:\n\tif (xattrs) {\n\t\tfor (i = 0; i < numattr; i++)\n\t\t\tkfree(xattrs[i]);\n\t\tkfree(xattrs);\n\t}\n\tci->i_xattrs.names_size = 0;\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nstatic int __build_xattrs(struct inode *inode)\n\t__releases(ci->i_ceph_lock)\n\t__acquires(ci->i_ceph_lock)\n{\n\tu32 namelen;\n\tu32 numattr = 0;\n\tvoid *p, *end;\n\tu32 len;\n\tconst char *name, *val;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint xattr_version;\n\tstruct ceph_inode_xattr **xattrs = NULL;\n\tint err = 0;\n\tint i;\n\n\tdout(\"__build_xattrs() len=%d\\n\",\n\t     ci->i_xattrs.blob ? (int)ci->i_xattrs.blob->vec.iov_len : 0);\n\n\tif (ci->i_xattrs.index_version >= ci->i_xattrs.version)\n\t\treturn 0; /* already built */\n\n\t__ceph_destroy_xattrs(ci);\n\nstart:\n\t/* updated internal xattr rb tree */\n\tif (ci->i_xattrs.blob && ci->i_xattrs.blob->vec.iov_len > 4) {\n\t\tp = ci->i_xattrs.blob->vec.iov_base;\n\t\tend = p + ci->i_xattrs.blob->vec.iov_len;\n\t\tceph_decode_32_safe(&p, end, numattr, bad);\n\t\txattr_version = ci->i_xattrs.version;\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\txattrs = kcalloc(numattr, sizeof(struct ceph_inode_xattr *),\n\t\t\t\t GFP_NOFS);\n\t\terr = -ENOMEM;\n\t\tif (!xattrs)\n\t\t\tgoto bad_lock;\n\n\t\tfor (i = 0; i < numattr; i++) {\n\t\t\txattrs[i] = kmalloc(sizeof(struct ceph_inode_xattr),\n\t\t\t\t\t    GFP_NOFS);\n\t\t\tif (!xattrs[i])\n\t\t\t\tgoto bad_lock;\n\t\t}\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tif (ci->i_xattrs.version != xattr_version) {\n\t\t\t/* lost a race, retry */\n\t\t\tfor (i = 0; i < numattr; i++)\n\t\t\t\tkfree(xattrs[i]);\n\t\t\tkfree(xattrs);\n\t\t\txattrs = NULL;\n\t\t\tgoto start;\n\t\t}\n\t\terr = -EIO;\n\t\twhile (numattr--) {\n\t\t\tceph_decode_32_safe(&p, end, len, bad);\n\t\t\tnamelen = len;\n\t\t\tname = p;\n\t\t\tp += len;\n\t\t\tceph_decode_32_safe(&p, end, len, bad);\n\t\t\tval = p;\n\t\t\tp += len;\n\n\t\t\terr = __set_xattr(ci, name, namelen, val, len,\n\t\t\t\t\t  0, 0, &xattrs[numattr]);\n\n\t\t\tif (err < 0)\n\t\t\t\tgoto bad;\n\t\t}\n\t\tkfree(xattrs);\n\t}\n\tci->i_xattrs.index_version = ci->i_xattrs.version;\n\tci->i_xattrs.dirty = false;\n\n\treturn err;\nbad_lock:\n\tspin_lock(&ci->i_ceph_lock);\nbad:\n\tif (xattrs) {\n\t\tfor (i = 0; i < numattr; i++)\n\t\t\tkfree(xattrs[i]);\n\t\tkfree(xattrs);\n\t}\n\tci->i_xattrs.names_size = 0;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_do_getattr",
          "args": [
            "inode",
            "CEPH_STAT_CAP_XATTR",
            "true"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_do_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "751-754",
          "snippet": "static inline int ceph_do_getattr(struct inode *inode, int mask, bool force)\n{\n\treturn __ceph_do_getattr(inode, NULL, mask, force);\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline int ceph_do_getattr(struct inode *inode, int mask, bool force)\n{\n\treturn __ceph_do_getattr(inode, NULL, mask, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_issued_mask",
          "args": [
            "ci",
            "CEPH_CAP_XATTR_SHARED",
            "1"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_issued_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "742-796",
          "snippet": "int __ceph_caps_issued_mask(struct ceph_inode_info *ci, int mask, int touch)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\tint have = ci->i_snap_caps;\n\n\tif ((have & mask) == mask) {\n\t\tdout(\"__ceph_caps_issued_mask %p snap issued %s\"\n\t\t     \" (mask %s)\\n\", &ci->vfs_inode,\n\t\t     ceph_cap_string(have),\n\t\t     ceph_cap_string(mask));\n\t\treturn 1;\n\t}\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\tif ((cap->issued & mask) == mask) {\n\t\t\tdout(\"__ceph_caps_issued_mask %p cap %p issued %s\"\n\t\t\t     \" (mask %s)\\n\", &ci->vfs_inode, cap,\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(mask));\n\t\t\tif (touch)\n\t\t\t\t__touch_cap(cap);\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* does a combination of caps satisfy mask? */\n\t\thave |= cap->issued;\n\t\tif ((have & mask) == mask) {\n\t\t\tdout(\"__ceph_caps_issued_mask %p combo issued %s\"\n\t\t\t     \" (mask %s)\\n\", &ci->vfs_inode,\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(mask));\n\t\t\tif (touch) {\n\t\t\t\tstruct rb_node *q;\n\n\t\t\t\t/* touch this + preceding caps */\n\t\t\t\t__touch_cap(cap);\n\t\t\t\tfor (q = rb_first(&ci->i_caps); q != p;\n\t\t\t\t     q = rb_next(q)) {\n\t\t\t\t\tcap = rb_entry(q, struct ceph_cap,\n\t\t\t\t\t\t       ci_node);\n\t\t\t\t\tif (!__cap_is_valid(cap))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t__touch_cap(cap);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_issued_mask(struct ceph_inode_info *ci, int mask, int touch)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\tint have = ci->i_snap_caps;\n\n\tif ((have & mask) == mask) {\n\t\tdout(\"__ceph_caps_issued_mask %p snap issued %s\"\n\t\t     \" (mask %s)\\n\", &ci->vfs_inode,\n\t\t     ceph_cap_string(have),\n\t\t     ceph_cap_string(mask));\n\t\treturn 1;\n\t}\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\tif ((cap->issued & mask) == mask) {\n\t\t\tdout(\"__ceph_caps_issued_mask %p cap %p issued %s\"\n\t\t\t     \" (mask %s)\\n\", &ci->vfs_inode, cap,\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(mask));\n\t\t\tif (touch)\n\t\t\t\t__touch_cap(cap);\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* does a combination of caps satisfy mask? */\n\t\thave |= cap->issued;\n\t\tif ((have & mask) == mask) {\n\t\t\tdout(\"__ceph_caps_issued_mask %p combo issued %s\"\n\t\t\t     \" (mask %s)\\n\", &ci->vfs_inode,\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(mask));\n\t\t\tif (touch) {\n\t\t\t\tstruct rb_node *q;\n\n\t\t\t\t/* touch this + preceding caps */\n\t\t\t\t__touch_cap(cap);\n\t\t\t\tfor (q = rb_first(&ci->i_caps); q != p;\n\t\t\t\t     q = rb_next(q)) {\n\t\t\t\t\tcap = rb_entry(q, struct ceph_cap,\n\t\t\t\t\t\t       ci_node);\n\t\t\t\t\tif (!__cap_is_valid(cap))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t__touch_cap(cap);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"listxattr %p ver=%lld index_ver=%lld\\n\"",
            "inode",
            "ci->i_xattrs.version",
            "ci->i_xattrs.index_version"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode_vxattrs",
          "args": [
            "inode"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_vxattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "273-280",
          "snippet": "static struct ceph_vxattr *ceph_inode_vxattrs(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn ceph_dir_vxattrs;\n\telse if (S_ISREG(inode->i_mode))\n\t\treturn ceph_file_vxattrs;\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ceph_vxattr ceph_dir_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.dir.layout\",\n\t\t.name_size = sizeof(\"ceph.dir.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(dir, layout, object_size),\n\tXATTR_LAYOUT_FIELD(dir, layout, pool),\n\tXATTR_NAME_CEPH(dir, entries),\n\tXATTR_NAME_CEPH(dir, files),\n\tXATTR_NAME_CEPH(dir, subdirs),\n\tXATTR_NAME_CEPH(dir, rentries),\n\tXATTR_NAME_CEPH(dir, rfiles),\n\tXATTR_NAME_CEPH(dir, rsubdirs),\n\tXATTR_NAME_CEPH(dir, rbytes),\n\tXATTR_NAME_CEPH(dir, rctime),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};",
            "static struct ceph_vxattr ceph_file_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.file.layout\",\n\t\t.name_size = sizeof(\"ceph.file.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(file, layout, object_size),\n\tXATTR_LAYOUT_FIELD(file, layout, pool),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_vxattr ceph_dir_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.dir.layout\",\n\t\t.name_size = sizeof(\"ceph.dir.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(dir, layout, object_size),\n\tXATTR_LAYOUT_FIELD(dir, layout, pool),\n\tXATTR_NAME_CEPH(dir, entries),\n\tXATTR_NAME_CEPH(dir, files),\n\tXATTR_NAME_CEPH(dir, subdirs),\n\tXATTR_NAME_CEPH(dir, rentries),\n\tXATTR_NAME_CEPH(dir, rfiles),\n\tXATTR_NAME_CEPH(dir, rsubdirs),\n\tXATTR_NAME_CEPH(dir, rbytes),\n\tXATTR_NAME_CEPH(dir, rctime),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};\nstatic struct ceph_vxattr ceph_file_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.file.layout\",\n\t\t.name_size = sizeof(\"ceph.file.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(file, layout, object_size),\n\tXATTR_LAYOUT_FIELD(file, layout, pool),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};\n\nstatic struct ceph_vxattr *ceph_inode_vxattrs(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn ceph_dir_vxattrs;\n\telse if (S_ISREG(inode->i_mode))\n\t\treturn ceph_file_vxattrs;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nssize_t ceph_listxattr(struct dentry *dentry, char *names, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_vxattr *vxattrs = ceph_inode_vxattrs(inode);\n\tu32 vir_namelen = 0;\n\tu32 namelen;\n\tint err;\n\tu32 len;\n\tint i;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"listxattr %p ver=%lld index_ver=%lld\\n\", inode,\n\t     ci->i_xattrs.version, ci->i_xattrs.index_version);\n\n\tif (ci->i_xattrs.version == 0 ||\n\t    !__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 1)) {\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\terr = ceph_do_getattr(inode, CEPH_STAT_CAP_XATTR, true);\n\t\tif (err)\n\t\t\treturn err;\n\t\tspin_lock(&ci->i_ceph_lock);\n\t}\n\n\terr = __build_xattrs(inode);\n\tif (err < 0)\n\t\tgoto out;\n\t/*\n\t * Start with virtual dir xattr names (if any) (including\n\t * terminating '\\0' characters for each).\n\t */\n\tvir_namelen = ceph_vxattrs_name_size(vxattrs);\n\n\t/* adding 1 byte per each variable due to the null termination */\n\tnamelen = ci->i_xattrs.names_size + ci->i_xattrs.count;\n\terr = -ERANGE;\n\tif (size && vir_namelen + namelen > size)\n\t\tgoto out;\n\n\terr = namelen + vir_namelen;\n\tif (size == 0)\n\t\tgoto out;\n\n\tnames = __copy_xattr_names(ci, names);\n\n\t/* virtual xattr names, too */\n\terr = namelen;\n\tif (vxattrs) {\n\t\tfor (i = 0; vxattrs[i].name; i++) {\n\t\t\tif (!vxattrs[i].hidden &&\n\t\t\t    !(vxattrs[i].exists_cb &&\n\t\t\t      !vxattrs[i].exists_cb(ci))) {\n\t\t\t\tlen = sprintf(names, \"%s\", vxattrs[i].name);\n\t\t\t\tnames += len + 1;\n\t\t\t\terr += len + 1;\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn err;\n}"
  },
  {
    "function_name": "ceph_getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "773-780",
    "snippet": "ssize_t ceph_getxattr(struct dentry *dentry, const char *name, void *value,\n\t\t      size_t size)\n{\n\tif (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn generic_getxattr(dentry, name, value, size);\n\n\treturn __ceph_getxattr(dentry->d_inode, name, value, size);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ceph_getxattr",
          "args": [
            "dentry->d_inode",
            "name",
            "value",
            "size"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "717-771",
          "snippet": "ssize_t __ceph_getxattr(struct inode *inode, const char *name, void *value,\n\t\t      size_t size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint err;\n\tstruct ceph_inode_xattr *xattr;\n\tstruct ceph_vxattr *vxattr = NULL;\n\n\tif (!ceph_is_valid_xattr(name))\n\t\treturn -ENODATA;\n\n\t/* let's see if a virtual xattr was requested */\n\tvxattr = ceph_match_vxattr(inode, name);\n\tif (vxattr && !(vxattr->exists_cb && !vxattr->exists_cb(ci))) {\n\t\terr = vxattr->getxattr_cb(ci, value, size);\n\t\treturn err;\n\t}\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"getxattr %p ver=%lld index_ver=%lld\\n\", inode,\n\t     ci->i_xattrs.version, ci->i_xattrs.index_version);\n\n\tif (ci->i_xattrs.version == 0 ||\n\t    !__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 1)) {\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t/* get xattrs from mds (if we don't already have them) */\n\t\terr = ceph_do_getattr(inode, CEPH_STAT_CAP_XATTR, true);\n\t\tif (err)\n\t\t\treturn err;\n\t\tspin_lock(&ci->i_ceph_lock);\n\t}\n\n\terr = __build_xattrs(inode);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = -ENODATA;  /* == ENOATTR */\n\txattr = __get_xattr(ci, name);\n\tif (!xattr)\n\t\tgoto out;\n\n\terr = -ERANGE;\n\tif (size && size < xattr->val_len)\n\t\tgoto out;\n\n\terr = xattr->val_len;\n\tif (size == 0)\n\t\tgoto out;\n\n\tmemcpy(value, xattr->val, xattr->val_len);\n\nout:\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nssize_t __ceph_getxattr(struct inode *inode, const char *name, void *value,\n\t\t      size_t size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint err;\n\tstruct ceph_inode_xattr *xattr;\n\tstruct ceph_vxattr *vxattr = NULL;\n\n\tif (!ceph_is_valid_xattr(name))\n\t\treturn -ENODATA;\n\n\t/* let's see if a virtual xattr was requested */\n\tvxattr = ceph_match_vxattr(inode, name);\n\tif (vxattr && !(vxattr->exists_cb && !vxattr->exists_cb(ci))) {\n\t\terr = vxattr->getxattr_cb(ci, value, size);\n\t\treturn err;\n\t}\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"getxattr %p ver=%lld index_ver=%lld\\n\", inode,\n\t     ci->i_xattrs.version, ci->i_xattrs.index_version);\n\n\tif (ci->i_xattrs.version == 0 ||\n\t    !__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 1)) {\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t/* get xattrs from mds (if we don't already have them) */\n\t\terr = ceph_do_getattr(inode, CEPH_STAT_CAP_XATTR, true);\n\t\tif (err)\n\t\t\treturn err;\n\t\tspin_lock(&ci->i_ceph_lock);\n\t}\n\n\terr = __build_xattrs(inode);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = -ENODATA;  /* == ENOATTR */\n\txattr = __get_xattr(ci, name);\n\tif (!xattr)\n\t\tgoto out;\n\n\terr = -ERANGE;\n\tif (size && size < xattr->val_len)\n\t\tgoto out;\n\n\terr = xattr->val_len;\n\tif (size == 0)\n\t\tgoto out;\n\n\tmemcpy(value, xattr->val, xattr->val_len);\n\nout:\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_getxattr",
          "args": [
            "dentry",
            "name",
            "value",
            "size"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "generic_getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "715-724",
          "snippet": "ssize_t\ngeneric_getxattr(struct dentry *dentry, const char *name, void *buffer, size_t size)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->get(dentry, name, buffer, size, handler->flags);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\ngeneric_getxattr(struct dentry *dentry, const char *name, void *buffer, size_t size)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(dentry->d_sb->s_xattr, &name);\n\tif (!handler)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->get(dentry, name, buffer, size, handler->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_SYSTEM_PREFIX",
            "XATTR_SYSTEM_PREFIX_LEN"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nssize_t ceph_getxattr(struct dentry *dentry, const char *name, void *value,\n\t\t      size_t size)\n{\n\tif (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn generic_getxattr(dentry, name, value, size);\n\n\treturn __ceph_getxattr(dentry->d_inode, name, value, size);\n}"
  },
  {
    "function_name": "__ceph_getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "717-771",
    "snippet": "ssize_t __ceph_getxattr(struct inode *inode, const char *name, void *value,\n\t\t      size_t size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint err;\n\tstruct ceph_inode_xattr *xattr;\n\tstruct ceph_vxattr *vxattr = NULL;\n\n\tif (!ceph_is_valid_xattr(name))\n\t\treturn -ENODATA;\n\n\t/* let's see if a virtual xattr was requested */\n\tvxattr = ceph_match_vxattr(inode, name);\n\tif (vxattr && !(vxattr->exists_cb && !vxattr->exists_cb(ci))) {\n\t\terr = vxattr->getxattr_cb(ci, value, size);\n\t\treturn err;\n\t}\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"getxattr %p ver=%lld index_ver=%lld\\n\", inode,\n\t     ci->i_xattrs.version, ci->i_xattrs.index_version);\n\n\tif (ci->i_xattrs.version == 0 ||\n\t    !__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 1)) {\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t/* get xattrs from mds (if we don't already have them) */\n\t\terr = ceph_do_getattr(inode, CEPH_STAT_CAP_XATTR, true);\n\t\tif (err)\n\t\t\treturn err;\n\t\tspin_lock(&ci->i_ceph_lock);\n\t}\n\n\terr = __build_xattrs(inode);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = -ENODATA;  /* == ENOATTR */\n\txattr = __get_xattr(ci, name);\n\tif (!xattr)\n\t\tgoto out;\n\n\terr = -ERANGE;\n\tif (size && size < xattr->val_len)\n\t\tgoto out;\n\n\terr = xattr->val_len;\n\tif (size == 0)\n\t\tgoto out;\n\n\tmemcpy(value, xattr->val, xattr->val_len);\n\nout:\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "value",
            "xattr->val",
            "xattr->val_len"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_xattr",
          "args": [
            "ci",
            "name"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "__get_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "434-464",
          "snippet": "static struct ceph_inode_xattr *__get_xattr(struct ceph_inode_info *ci,\n\t\t\t   const char *name)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\tint name_len = strlen(name);\n\tint c;\n\n\tp = &ci->i_xattrs.index.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\txattr = rb_entry(parent, struct ceph_inode_xattr, node);\n\t\tc = strncmp(name, xattr->name, xattr->name_len);\n\t\tif (c == 0 && name_len > xattr->name_len)\n\t\t\tc = 1;\n\t\tif (c < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (c > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tdout(\"__get_xattr %s: found %.*s\\n\", name,\n\t\t\t     xattr->val_len, xattr->val);\n\t\t\treturn xattr;\n\t\t}\n\t}\n\n\tdout(\"__get_xattr %s: not found\\n\", name);\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nstatic struct ceph_inode_xattr *__get_xattr(struct ceph_inode_info *ci,\n\t\t\t   const char *name)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\tint name_len = strlen(name);\n\tint c;\n\n\tp = &ci->i_xattrs.index.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\txattr = rb_entry(parent, struct ceph_inode_xattr, node);\n\t\tc = strncmp(name, xattr->name, xattr->name_len);\n\t\tif (c == 0 && name_len > xattr->name_len)\n\t\t\tc = 1;\n\t\tif (c < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (c > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tdout(\"__get_xattr %s: found %.*s\\n\", name,\n\t\t\t     xattr->val_len, xattr->val);\n\t\t\treturn xattr;\n\t\t}\n\t}\n\n\tdout(\"__get_xattr %s: not found\\n\", name);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__build_xattrs",
          "args": [
            "inode"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "__build_xattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "563-649",
          "snippet": "static int __build_xattrs(struct inode *inode)\n\t__releases(ci->i_ceph_lock)\n\t__acquires(ci->i_ceph_lock)\n{\n\tu32 namelen;\n\tu32 numattr = 0;\n\tvoid *p, *end;\n\tu32 len;\n\tconst char *name, *val;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint xattr_version;\n\tstruct ceph_inode_xattr **xattrs = NULL;\n\tint err = 0;\n\tint i;\n\n\tdout(\"__build_xattrs() len=%d\\n\",\n\t     ci->i_xattrs.blob ? (int)ci->i_xattrs.blob->vec.iov_len : 0);\n\n\tif (ci->i_xattrs.index_version >= ci->i_xattrs.version)\n\t\treturn 0; /* already built */\n\n\t__ceph_destroy_xattrs(ci);\n\nstart:\n\t/* updated internal xattr rb tree */\n\tif (ci->i_xattrs.blob && ci->i_xattrs.blob->vec.iov_len > 4) {\n\t\tp = ci->i_xattrs.blob->vec.iov_base;\n\t\tend = p + ci->i_xattrs.blob->vec.iov_len;\n\t\tceph_decode_32_safe(&p, end, numattr, bad);\n\t\txattr_version = ci->i_xattrs.version;\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\txattrs = kcalloc(numattr, sizeof(struct ceph_inode_xattr *),\n\t\t\t\t GFP_NOFS);\n\t\terr = -ENOMEM;\n\t\tif (!xattrs)\n\t\t\tgoto bad_lock;\n\n\t\tfor (i = 0; i < numattr; i++) {\n\t\t\txattrs[i] = kmalloc(sizeof(struct ceph_inode_xattr),\n\t\t\t\t\t    GFP_NOFS);\n\t\t\tif (!xattrs[i])\n\t\t\t\tgoto bad_lock;\n\t\t}\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tif (ci->i_xattrs.version != xattr_version) {\n\t\t\t/* lost a race, retry */\n\t\t\tfor (i = 0; i < numattr; i++)\n\t\t\t\tkfree(xattrs[i]);\n\t\t\tkfree(xattrs);\n\t\t\txattrs = NULL;\n\t\t\tgoto start;\n\t\t}\n\t\terr = -EIO;\n\t\twhile (numattr--) {\n\t\t\tceph_decode_32_safe(&p, end, len, bad);\n\t\t\tnamelen = len;\n\t\t\tname = p;\n\t\t\tp += len;\n\t\t\tceph_decode_32_safe(&p, end, len, bad);\n\t\t\tval = p;\n\t\t\tp += len;\n\n\t\t\terr = __set_xattr(ci, name, namelen, val, len,\n\t\t\t\t\t  0, 0, &xattrs[numattr]);\n\n\t\t\tif (err < 0)\n\t\t\t\tgoto bad;\n\t\t}\n\t\tkfree(xattrs);\n\t}\n\tci->i_xattrs.index_version = ci->i_xattrs.version;\n\tci->i_xattrs.dirty = false;\n\n\treturn err;\nbad_lock:\n\tspin_lock(&ci->i_ceph_lock);\nbad:\n\tif (xattrs) {\n\t\tfor (i = 0; i < numattr; i++)\n\t\t\tkfree(xattrs[i]);\n\t\tkfree(xattrs);\n\t}\n\tci->i_xattrs.names_size = 0;\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nstatic int __build_xattrs(struct inode *inode)\n\t__releases(ci->i_ceph_lock)\n\t__acquires(ci->i_ceph_lock)\n{\n\tu32 namelen;\n\tu32 numattr = 0;\n\tvoid *p, *end;\n\tu32 len;\n\tconst char *name, *val;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint xattr_version;\n\tstruct ceph_inode_xattr **xattrs = NULL;\n\tint err = 0;\n\tint i;\n\n\tdout(\"__build_xattrs() len=%d\\n\",\n\t     ci->i_xattrs.blob ? (int)ci->i_xattrs.blob->vec.iov_len : 0);\n\n\tif (ci->i_xattrs.index_version >= ci->i_xattrs.version)\n\t\treturn 0; /* already built */\n\n\t__ceph_destroy_xattrs(ci);\n\nstart:\n\t/* updated internal xattr rb tree */\n\tif (ci->i_xattrs.blob && ci->i_xattrs.blob->vec.iov_len > 4) {\n\t\tp = ci->i_xattrs.blob->vec.iov_base;\n\t\tend = p + ci->i_xattrs.blob->vec.iov_len;\n\t\tceph_decode_32_safe(&p, end, numattr, bad);\n\t\txattr_version = ci->i_xattrs.version;\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\txattrs = kcalloc(numattr, sizeof(struct ceph_inode_xattr *),\n\t\t\t\t GFP_NOFS);\n\t\terr = -ENOMEM;\n\t\tif (!xattrs)\n\t\t\tgoto bad_lock;\n\n\t\tfor (i = 0; i < numattr; i++) {\n\t\t\txattrs[i] = kmalloc(sizeof(struct ceph_inode_xattr),\n\t\t\t\t\t    GFP_NOFS);\n\t\t\tif (!xattrs[i])\n\t\t\t\tgoto bad_lock;\n\t\t}\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tif (ci->i_xattrs.version != xattr_version) {\n\t\t\t/* lost a race, retry */\n\t\t\tfor (i = 0; i < numattr; i++)\n\t\t\t\tkfree(xattrs[i]);\n\t\t\tkfree(xattrs);\n\t\t\txattrs = NULL;\n\t\t\tgoto start;\n\t\t}\n\t\terr = -EIO;\n\t\twhile (numattr--) {\n\t\t\tceph_decode_32_safe(&p, end, len, bad);\n\t\t\tnamelen = len;\n\t\t\tname = p;\n\t\t\tp += len;\n\t\t\tceph_decode_32_safe(&p, end, len, bad);\n\t\t\tval = p;\n\t\t\tp += len;\n\n\t\t\terr = __set_xattr(ci, name, namelen, val, len,\n\t\t\t\t\t  0, 0, &xattrs[numattr]);\n\n\t\t\tif (err < 0)\n\t\t\t\tgoto bad;\n\t\t}\n\t\tkfree(xattrs);\n\t}\n\tci->i_xattrs.index_version = ci->i_xattrs.version;\n\tci->i_xattrs.dirty = false;\n\n\treturn err;\nbad_lock:\n\tspin_lock(&ci->i_ceph_lock);\nbad:\n\tif (xattrs) {\n\t\tfor (i = 0; i < numattr; i++)\n\t\t\tkfree(xattrs[i]);\n\t\tkfree(xattrs);\n\t}\n\tci->i_xattrs.names_size = 0;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_do_getattr",
          "args": [
            "inode",
            "CEPH_STAT_CAP_XATTR",
            "true"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_do_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "751-754",
          "snippet": "static inline int ceph_do_getattr(struct inode *inode, int mask, bool force)\n{\n\treturn __ceph_do_getattr(inode, NULL, mask, force);\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline int ceph_do_getattr(struct inode *inode, int mask, bool force)\n{\n\treturn __ceph_do_getattr(inode, NULL, mask, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_issued_mask",
          "args": [
            "ci",
            "CEPH_CAP_XATTR_SHARED",
            "1"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_issued_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "742-796",
          "snippet": "int __ceph_caps_issued_mask(struct ceph_inode_info *ci, int mask, int touch)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\tint have = ci->i_snap_caps;\n\n\tif ((have & mask) == mask) {\n\t\tdout(\"__ceph_caps_issued_mask %p snap issued %s\"\n\t\t     \" (mask %s)\\n\", &ci->vfs_inode,\n\t\t     ceph_cap_string(have),\n\t\t     ceph_cap_string(mask));\n\t\treturn 1;\n\t}\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\tif ((cap->issued & mask) == mask) {\n\t\t\tdout(\"__ceph_caps_issued_mask %p cap %p issued %s\"\n\t\t\t     \" (mask %s)\\n\", &ci->vfs_inode, cap,\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(mask));\n\t\t\tif (touch)\n\t\t\t\t__touch_cap(cap);\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* does a combination of caps satisfy mask? */\n\t\thave |= cap->issued;\n\t\tif ((have & mask) == mask) {\n\t\t\tdout(\"__ceph_caps_issued_mask %p combo issued %s\"\n\t\t\t     \" (mask %s)\\n\", &ci->vfs_inode,\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(mask));\n\t\t\tif (touch) {\n\t\t\t\tstruct rb_node *q;\n\n\t\t\t\t/* touch this + preceding caps */\n\t\t\t\t__touch_cap(cap);\n\t\t\t\tfor (q = rb_first(&ci->i_caps); q != p;\n\t\t\t\t     q = rb_next(q)) {\n\t\t\t\t\tcap = rb_entry(q, struct ceph_cap,\n\t\t\t\t\t\t       ci_node);\n\t\t\t\t\tif (!__cap_is_valid(cap))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t__touch_cap(cap);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_issued_mask(struct ceph_inode_info *ci, int mask, int touch)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\tint have = ci->i_snap_caps;\n\n\tif ((have & mask) == mask) {\n\t\tdout(\"__ceph_caps_issued_mask %p snap issued %s\"\n\t\t     \" (mask %s)\\n\", &ci->vfs_inode,\n\t\t     ceph_cap_string(have),\n\t\t     ceph_cap_string(mask));\n\t\treturn 1;\n\t}\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\tif ((cap->issued & mask) == mask) {\n\t\t\tdout(\"__ceph_caps_issued_mask %p cap %p issued %s\"\n\t\t\t     \" (mask %s)\\n\", &ci->vfs_inode, cap,\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(mask));\n\t\t\tif (touch)\n\t\t\t\t__touch_cap(cap);\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* does a combination of caps satisfy mask? */\n\t\thave |= cap->issued;\n\t\tif ((have & mask) == mask) {\n\t\t\tdout(\"__ceph_caps_issued_mask %p combo issued %s\"\n\t\t\t     \" (mask %s)\\n\", &ci->vfs_inode,\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(mask));\n\t\t\tif (touch) {\n\t\t\t\tstruct rb_node *q;\n\n\t\t\t\t/* touch this + preceding caps */\n\t\t\t\t__touch_cap(cap);\n\t\t\t\tfor (q = rb_first(&ci->i_caps); q != p;\n\t\t\t\t     q = rb_next(q)) {\n\t\t\t\t\tcap = rb_entry(q, struct ceph_cap,\n\t\t\t\t\t\t       ci_node);\n\t\t\t\t\tif (!__cap_is_valid(cap))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t__touch_cap(cap);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"getxattr %p ver=%lld index_ver=%lld\\n\"",
            "inode",
            "ci->i_xattrs.version",
            "ci->i_xattrs.index_version"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vxattr->getxattr_cb",
          "args": [
            "ci",
            "value",
            "size"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vxattr->exists_cb",
          "args": [
            "ci"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_match_vxattr",
          "args": [
            "inode",
            "name"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_match_vxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "322-336",
          "snippet": "static struct ceph_vxattr *ceph_match_vxattr(struct inode *inode,\n\t\t\t\t\t\tconst char *name)\n{\n\tstruct ceph_vxattr *vxattr = ceph_inode_vxattrs(inode);\n\n\tif (vxattr) {\n\t\twhile (vxattr->name) {\n\t\t\tif (!strcmp(vxattr->name, name))\n\t\t\t\treturn vxattr;\n\t\t\tvxattr++;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_vxattr *ceph_match_vxattr(struct inode *inode,\n\t\t\t\t\t\tconst char *name)\n{\n\tstruct ceph_vxattr *vxattr = ceph_inode_vxattrs(inode);\n\n\tif (vxattr) {\n\t\twhile (vxattr->name) {\n\t\t\tif (!strcmp(vxattr->name, name))\n\t\t\t\treturn vxattr;\n\t\t\tvxattr++;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_is_valid_xattr",
          "args": [
            "name"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_is_valid_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "31-39",
          "snippet": "static bool ceph_is_valid_xattr(const char *name)\n{\n\treturn !strncmp(name, XATTR_CEPH_PREFIX, XATTR_CEPH_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\tXATTR_SECURITY_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define XATTR_CEPH_PREFIX_LEN (sizeof (XATTR_CEPH_PREFIX) - 1)",
            "#define XATTR_CEPH_PREFIX \"ceph.\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define XATTR_CEPH_PREFIX_LEN (sizeof (XATTR_CEPH_PREFIX) - 1)\n#define XATTR_CEPH_PREFIX \"ceph.\"\n\nstatic bool ceph_is_valid_xattr(const char *name)\n{\n\treturn !strncmp(name, XATTR_CEPH_PREFIX, XATTR_CEPH_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\tXATTR_SECURITY_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_vxattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "273-280",
          "snippet": "static struct ceph_vxattr *ceph_inode_vxattrs(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn ceph_dir_vxattrs;\n\telse if (S_ISREG(inode->i_mode))\n\t\treturn ceph_file_vxattrs;\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ceph_vxattr ceph_dir_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.dir.layout\",\n\t\t.name_size = sizeof(\"ceph.dir.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(dir, layout, object_size),\n\tXATTR_LAYOUT_FIELD(dir, layout, pool),\n\tXATTR_NAME_CEPH(dir, entries),\n\tXATTR_NAME_CEPH(dir, files),\n\tXATTR_NAME_CEPH(dir, subdirs),\n\tXATTR_NAME_CEPH(dir, rentries),\n\tXATTR_NAME_CEPH(dir, rfiles),\n\tXATTR_NAME_CEPH(dir, rsubdirs),\n\tXATTR_NAME_CEPH(dir, rbytes),\n\tXATTR_NAME_CEPH(dir, rctime),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};",
            "static struct ceph_vxattr ceph_file_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.file.layout\",\n\t\t.name_size = sizeof(\"ceph.file.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(file, layout, object_size),\n\tXATTR_LAYOUT_FIELD(file, layout, pool),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_vxattr ceph_dir_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.dir.layout\",\n\t\t.name_size = sizeof(\"ceph.dir.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(dir, layout, object_size),\n\tXATTR_LAYOUT_FIELD(dir, layout, pool),\n\tXATTR_NAME_CEPH(dir, entries),\n\tXATTR_NAME_CEPH(dir, files),\n\tXATTR_NAME_CEPH(dir, subdirs),\n\tXATTR_NAME_CEPH(dir, rentries),\n\tXATTR_NAME_CEPH(dir, rfiles),\n\tXATTR_NAME_CEPH(dir, rsubdirs),\n\tXATTR_NAME_CEPH(dir, rbytes),\n\tXATTR_NAME_CEPH(dir, rctime),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};\nstatic struct ceph_vxattr ceph_file_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.file.layout\",\n\t\t.name_size = sizeof(\"ceph.file.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(file, layout, object_size),\n\tXATTR_LAYOUT_FIELD(file, layout, pool),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};\n\nstatic struct ceph_vxattr *ceph_inode_vxattrs(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn ceph_dir_vxattrs;\n\telse if (S_ISREG(inode->i_mode))\n\t\treturn ceph_file_vxattrs;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nssize_t __ceph_getxattr(struct inode *inode, const char *name, void *value,\n\t\t      size_t size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint err;\n\tstruct ceph_inode_xattr *xattr;\n\tstruct ceph_vxattr *vxattr = NULL;\n\n\tif (!ceph_is_valid_xattr(name))\n\t\treturn -ENODATA;\n\n\t/* let's see if a virtual xattr was requested */\n\tvxattr = ceph_match_vxattr(inode, name);\n\tif (vxattr && !(vxattr->exists_cb && !vxattr->exists_cb(ci))) {\n\t\terr = vxattr->getxattr_cb(ci, value, size);\n\t\treturn err;\n\t}\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"getxattr %p ver=%lld index_ver=%lld\\n\", inode,\n\t     ci->i_xattrs.version, ci->i_xattrs.index_version);\n\n\tif (ci->i_xattrs.version == 0 ||\n\t    !__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 1)) {\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t/* get xattrs from mds (if we don't already have them) */\n\t\terr = ceph_do_getattr(inode, CEPH_STAT_CAP_XATTR, true);\n\t\tif (err)\n\t\t\treturn err;\n\t\tspin_lock(&ci->i_ceph_lock);\n\t}\n\n\terr = __build_xattrs(inode);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = -ENODATA;  /* == ENOATTR */\n\txattr = __get_xattr(ci, name);\n\tif (!xattr)\n\t\tgoto out;\n\n\terr = -ERANGE;\n\tif (size && size < xattr->val_len)\n\t\tgoto out;\n\n\terr = xattr->val_len;\n\tif (size == 0)\n\t\tgoto out;\n\n\tmemcpy(value, xattr->val, xattr->val_len);\n\nout:\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn err;\n}"
  },
  {
    "function_name": "__ceph_build_xattrs_blob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "675-715",
    "snippet": "void __ceph_build_xattrs_blob(struct ceph_inode_info *ci)\n{\n\tstruct rb_node *p;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\tvoid *dest;\n\n\tdout(\"__build_xattrs_blob %p\\n\", &ci->vfs_inode);\n\tif (ci->i_xattrs.dirty) {\n\t\tint need = __get_required_blob_size(ci, 0, 0);\n\n\t\tBUG_ON(need > ci->i_xattrs.prealloc_blob->alloc_len);\n\n\t\tp = rb_first(&ci->i_xattrs.index);\n\t\tdest = ci->i_xattrs.prealloc_blob->vec.iov_base;\n\n\t\tceph_encode_32(&dest, ci->i_xattrs.count);\n\t\twhile (p) {\n\t\t\txattr = rb_entry(p, struct ceph_inode_xattr, node);\n\n\t\t\tceph_encode_32(&dest, xattr->name_len);\n\t\t\tmemcpy(dest, xattr->name, xattr->name_len);\n\t\t\tdest += xattr->name_len;\n\t\t\tceph_encode_32(&dest, xattr->val_len);\n\t\t\tmemcpy(dest, xattr->val, xattr->val_len);\n\t\t\tdest += xattr->val_len;\n\n\t\t\tp = rb_next(p);\n\t\t}\n\n\t\t/* adjust buffer len; it may be larger than we need */\n\t\tci->i_xattrs.prealloc_blob->vec.iov_len =\n\t\t\tdest - ci->i_xattrs.prealloc_blob->vec.iov_base;\n\n\t\tif (ci->i_xattrs.blob)\n\t\t\tceph_buffer_put(ci->i_xattrs.blob);\n\t\tci->i_xattrs.blob = ci->i_xattrs.prealloc_blob;\n\t\tci->i_xattrs.prealloc_blob = NULL;\n\t\tci->i_xattrs.dirty = false;\n\t\tci->i_xattrs.version++;\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_buffer_put",
          "args": [
            "ci->i_xattrs.blob"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "p"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest",
            "xattr->val",
            "xattr->val_len"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_encode_32",
          "args": [
            "&dest",
            "xattr->val_len"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest",
            "xattr->name",
            "xattr->name_len"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_encode_32",
          "args": [
            "&dest",
            "xattr->name_len"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "p",
            "structceph_inode_xattr",
            "node"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_encode_32",
          "args": [
            "&dest",
            "ci->i_xattrs.count"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ci->i_xattrs.index"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "need > ci->i_xattrs.prealloc_blob->alloc_len"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_required_blob_size",
          "args": [
            "ci",
            "0",
            "0"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "__get_required_blob_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "651-669",
          "snippet": "static int __get_required_blob_size(struct ceph_inode_info *ci, int name_size,\n\t\t\t\t    int val_size)\n{\n\t/*\n\t * 4 bytes for the length, and additional 4 bytes per each xattr name,\n\t * 4 bytes per each value\n\t */\n\tint size = 4 + ci->i_xattrs.count*(4 + 4) +\n\t\t\t     ci->i_xattrs.names_size +\n\t\t\t     ci->i_xattrs.vals_size;\n\tdout(\"__get_required_blob_size c=%d names.size=%d vals.size=%d\\n\",\n\t     ci->i_xattrs.count, ci->i_xattrs.names_size,\n\t     ci->i_xattrs.vals_size);\n\n\tif (name_size)\n\t\tsize += 4 + 4 + name_size + val_size;\n\n\treturn size;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nstatic int __get_required_blob_size(struct ceph_inode_info *ci, int name_size,\n\t\t\t\t    int val_size)\n{\n\t/*\n\t * 4 bytes for the length, and additional 4 bytes per each xattr name,\n\t * 4 bytes per each value\n\t */\n\tint size = 4 + ci->i_xattrs.count*(4 + 4) +\n\t\t\t     ci->i_xattrs.names_size +\n\t\t\t     ci->i_xattrs.vals_size;\n\tdout(\"__get_required_blob_size c=%d names.size=%d vals.size=%d\\n\",\n\t     ci->i_xattrs.count, ci->i_xattrs.names_size,\n\t     ci->i_xattrs.vals_size);\n\n\tif (name_size)\n\t\tsize += 4 + 4 + name_size + val_size;\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__build_xattrs_blob %p\\n\"",
            "&ci->vfs_inode"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nvoid __ceph_build_xattrs_blob(struct ceph_inode_info *ci)\n{\n\tstruct rb_node *p;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\tvoid *dest;\n\n\tdout(\"__build_xattrs_blob %p\\n\", &ci->vfs_inode);\n\tif (ci->i_xattrs.dirty) {\n\t\tint need = __get_required_blob_size(ci, 0, 0);\n\n\t\tBUG_ON(need > ci->i_xattrs.prealloc_blob->alloc_len);\n\n\t\tp = rb_first(&ci->i_xattrs.index);\n\t\tdest = ci->i_xattrs.prealloc_blob->vec.iov_base;\n\n\t\tceph_encode_32(&dest, ci->i_xattrs.count);\n\t\twhile (p) {\n\t\t\txattr = rb_entry(p, struct ceph_inode_xattr, node);\n\n\t\t\tceph_encode_32(&dest, xattr->name_len);\n\t\t\tmemcpy(dest, xattr->name, xattr->name_len);\n\t\t\tdest += xattr->name_len;\n\t\t\tceph_encode_32(&dest, xattr->val_len);\n\t\t\tmemcpy(dest, xattr->val, xattr->val_len);\n\t\t\tdest += xattr->val_len;\n\n\t\t\tp = rb_next(p);\n\t\t}\n\n\t\t/* adjust buffer len; it may be larger than we need */\n\t\tci->i_xattrs.prealloc_blob->vec.iov_len =\n\t\t\tdest - ci->i_xattrs.prealloc_blob->vec.iov_base;\n\n\t\tif (ci->i_xattrs.blob)\n\t\t\tceph_buffer_put(ci->i_xattrs.blob);\n\t\tci->i_xattrs.blob = ci->i_xattrs.prealloc_blob;\n\t\tci->i_xattrs.prealloc_blob = NULL;\n\t\tci->i_xattrs.dirty = false;\n\t\tci->i_xattrs.version++;\n\t}\n}"
  },
  {
    "function_name": "__get_required_blob_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "651-669",
    "snippet": "static int __get_required_blob_size(struct ceph_inode_info *ci, int name_size,\n\t\t\t\t    int val_size)\n{\n\t/*\n\t * 4 bytes for the length, and additional 4 bytes per each xattr name,\n\t * 4 bytes per each value\n\t */\n\tint size = 4 + ci->i_xattrs.count*(4 + 4) +\n\t\t\t     ci->i_xattrs.names_size +\n\t\t\t     ci->i_xattrs.vals_size;\n\tdout(\"__get_required_blob_size c=%d names.size=%d vals.size=%d\\n\",\n\t     ci->i_xattrs.count, ci->i_xattrs.names_size,\n\t     ci->i_xattrs.vals_size);\n\n\tif (name_size)\n\t\tsize += 4 + 4 + name_size + val_size;\n\n\treturn size;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__get_required_blob_size c=%d names.size=%d vals.size=%d\\n\"",
            "ci->i_xattrs.count",
            "ci->i_xattrs.names_size",
            "ci->i_xattrs.vals_size"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nstatic int __get_required_blob_size(struct ceph_inode_info *ci, int name_size,\n\t\t\t\t    int val_size)\n{\n\t/*\n\t * 4 bytes for the length, and additional 4 bytes per each xattr name,\n\t * 4 bytes per each value\n\t */\n\tint size = 4 + ci->i_xattrs.count*(4 + 4) +\n\t\t\t     ci->i_xattrs.names_size +\n\t\t\t     ci->i_xattrs.vals_size;\n\tdout(\"__get_required_blob_size c=%d names.size=%d vals.size=%d\\n\",\n\t     ci->i_xattrs.count, ci->i_xattrs.names_size,\n\t     ci->i_xattrs.vals_size);\n\n\tif (name_size)\n\t\tsize += 4 + 4 + name_size + val_size;\n\n\treturn size;\n}"
  },
  {
    "function_name": "__build_xattrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "563-649",
    "snippet": "static int __build_xattrs(struct inode *inode)\n\t__releases(ci->i_ceph_lock)\n\t__acquires(ci->i_ceph_lock)\n{\n\tu32 namelen;\n\tu32 numattr = 0;\n\tvoid *p, *end;\n\tu32 len;\n\tconst char *name, *val;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint xattr_version;\n\tstruct ceph_inode_xattr **xattrs = NULL;\n\tint err = 0;\n\tint i;\n\n\tdout(\"__build_xattrs() len=%d\\n\",\n\t     ci->i_xattrs.blob ? (int)ci->i_xattrs.blob->vec.iov_len : 0);\n\n\tif (ci->i_xattrs.index_version >= ci->i_xattrs.version)\n\t\treturn 0; /* already built */\n\n\t__ceph_destroy_xattrs(ci);\n\nstart:\n\t/* updated internal xattr rb tree */\n\tif (ci->i_xattrs.blob && ci->i_xattrs.blob->vec.iov_len > 4) {\n\t\tp = ci->i_xattrs.blob->vec.iov_base;\n\t\tend = p + ci->i_xattrs.blob->vec.iov_len;\n\t\tceph_decode_32_safe(&p, end, numattr, bad);\n\t\txattr_version = ci->i_xattrs.version;\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\txattrs = kcalloc(numattr, sizeof(struct ceph_inode_xattr *),\n\t\t\t\t GFP_NOFS);\n\t\terr = -ENOMEM;\n\t\tif (!xattrs)\n\t\t\tgoto bad_lock;\n\n\t\tfor (i = 0; i < numattr; i++) {\n\t\t\txattrs[i] = kmalloc(sizeof(struct ceph_inode_xattr),\n\t\t\t\t\t    GFP_NOFS);\n\t\t\tif (!xattrs[i])\n\t\t\t\tgoto bad_lock;\n\t\t}\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tif (ci->i_xattrs.version != xattr_version) {\n\t\t\t/* lost a race, retry */\n\t\t\tfor (i = 0; i < numattr; i++)\n\t\t\t\tkfree(xattrs[i]);\n\t\t\tkfree(xattrs);\n\t\t\txattrs = NULL;\n\t\t\tgoto start;\n\t\t}\n\t\terr = -EIO;\n\t\twhile (numattr--) {\n\t\t\tceph_decode_32_safe(&p, end, len, bad);\n\t\t\tnamelen = len;\n\t\t\tname = p;\n\t\t\tp += len;\n\t\t\tceph_decode_32_safe(&p, end, len, bad);\n\t\t\tval = p;\n\t\t\tp += len;\n\n\t\t\terr = __set_xattr(ci, name, namelen, val, len,\n\t\t\t\t\t  0, 0, &xattrs[numattr]);\n\n\t\t\tif (err < 0)\n\t\t\t\tgoto bad;\n\t\t}\n\t\tkfree(xattrs);\n\t}\n\tci->i_xattrs.index_version = ci->i_xattrs.version;\n\tci->i_xattrs.dirty = false;\n\n\treturn err;\nbad_lock:\n\tspin_lock(&ci->i_ceph_lock);\nbad:\n\tif (xattrs) {\n\t\tfor (i = 0; i < numattr; i++)\n\t\t\tkfree(xattrs[i]);\n\t\tkfree(xattrs);\n\t}\n\tci->i_xattrs.names_size = 0;\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "xattrs"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "xattrs[i]"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "xattrs"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_xattr",
          "args": [
            "ci",
            "name",
            "namelen",
            "val",
            "len",
            "0",
            "0",
            "&xattrs[numattr]"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "__set_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "338-432",
          "snippet": "static int __set_xattr(struct ceph_inode_info *ci,\n\t\t\t   const char *name, int name_len,\n\t\t\t   const char *val, int val_len,\n\t\t\t   int flags, int update_xattr,\n\t\t\t   struct ceph_inode_xattr **newxattr)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\tint c;\n\tint new = 0;\n\n\tp = &ci->i_xattrs.index.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\txattr = rb_entry(parent, struct ceph_inode_xattr, node);\n\t\tc = strncmp(name, xattr->name, min(name_len, xattr->name_len));\n\t\tif (c < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (c > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tif (name_len == xattr->name_len)\n\t\t\t\tbreak;\n\t\t\telse if (name_len < xattr->name_len)\n\t\t\t\tp = &(*p)->rb_left;\n\t\t\telse\n\t\t\t\tp = &(*p)->rb_right;\n\t\t}\n\t\txattr = NULL;\n\t}\n\n\tif (update_xattr) {\n\t\tint err = 0;\n\t\tif (xattr && (flags & XATTR_CREATE))\n\t\t\terr = -EEXIST;\n\t\telse if (!xattr && (flags & XATTR_REPLACE))\n\t\t\terr = -ENODATA;\n\t\tif (err) {\n\t\t\tkfree(name);\n\t\t\tkfree(val);\n\t\t\treturn err;\n\t\t}\n\t\tif (update_xattr < 0) {\n\t\t\tif (xattr)\n\t\t\t\t__remove_xattr(ci, xattr);\n\t\t\tkfree(name);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!xattr) {\n\t\tnew = 1;\n\t\txattr = *newxattr;\n\t\txattr->name = name;\n\t\txattr->name_len = name_len;\n\t\txattr->should_free_name = update_xattr;\n\n\t\tci->i_xattrs.count++;\n\t\tdout(\"__set_xattr count=%d\\n\", ci->i_xattrs.count);\n\t} else {\n\t\tkfree(*newxattr);\n\t\t*newxattr = NULL;\n\t\tif (xattr->should_free_val)\n\t\t\tkfree((void *)xattr->val);\n\n\t\tif (update_xattr) {\n\t\t\tkfree((void *)name);\n\t\t\tname = xattr->name;\n\t\t}\n\t\tci->i_xattrs.names_size -= xattr->name_len;\n\t\tci->i_xattrs.vals_size -= xattr->val_len;\n\t}\n\tci->i_xattrs.names_size += name_len;\n\tci->i_xattrs.vals_size += val_len;\n\tif (val)\n\t\txattr->val = val;\n\telse\n\t\txattr->val = \"\";\n\n\txattr->val_len = val_len;\n\txattr->dirty = update_xattr;\n\txattr->should_free_val = (val && update_xattr);\n\n\tif (new) {\n\t\trb_link_node(&xattr->node, parent, p);\n\t\trb_insert_color(&xattr->node, &ci->i_xattrs.index);\n\t\tdout(\"__set_xattr_val p=%p\\n\", p);\n\t}\n\n\tdout(\"__set_xattr_val added %llx.%llx xattr %p %s=%.*s\\n\",\n\t     ceph_vinop(&ci->vfs_inode), xattr, name, val_len, val);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nstatic int __set_xattr(struct ceph_inode_info *ci,\n\t\t\t   const char *name, int name_len,\n\t\t\t   const char *val, int val_len,\n\t\t\t   int flags, int update_xattr,\n\t\t\t   struct ceph_inode_xattr **newxattr)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\tint c;\n\tint new = 0;\n\n\tp = &ci->i_xattrs.index.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\txattr = rb_entry(parent, struct ceph_inode_xattr, node);\n\t\tc = strncmp(name, xattr->name, min(name_len, xattr->name_len));\n\t\tif (c < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (c > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tif (name_len == xattr->name_len)\n\t\t\t\tbreak;\n\t\t\telse if (name_len < xattr->name_len)\n\t\t\t\tp = &(*p)->rb_left;\n\t\t\telse\n\t\t\t\tp = &(*p)->rb_right;\n\t\t}\n\t\txattr = NULL;\n\t}\n\n\tif (update_xattr) {\n\t\tint err = 0;\n\t\tif (xattr && (flags & XATTR_CREATE))\n\t\t\terr = -EEXIST;\n\t\telse if (!xattr && (flags & XATTR_REPLACE))\n\t\t\terr = -ENODATA;\n\t\tif (err) {\n\t\t\tkfree(name);\n\t\t\tkfree(val);\n\t\t\treturn err;\n\t\t}\n\t\tif (update_xattr < 0) {\n\t\t\tif (xattr)\n\t\t\t\t__remove_xattr(ci, xattr);\n\t\t\tkfree(name);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!xattr) {\n\t\tnew = 1;\n\t\txattr = *newxattr;\n\t\txattr->name = name;\n\t\txattr->name_len = name_len;\n\t\txattr->should_free_name = update_xattr;\n\n\t\tci->i_xattrs.count++;\n\t\tdout(\"__set_xattr count=%d\\n\", ci->i_xattrs.count);\n\t} else {\n\t\tkfree(*newxattr);\n\t\t*newxattr = NULL;\n\t\tif (xattr->should_free_val)\n\t\t\tkfree((void *)xattr->val);\n\n\t\tif (update_xattr) {\n\t\t\tkfree((void *)name);\n\t\t\tname = xattr->name;\n\t\t}\n\t\tci->i_xattrs.names_size -= xattr->name_len;\n\t\tci->i_xattrs.vals_size -= xattr->val_len;\n\t}\n\tci->i_xattrs.names_size += name_len;\n\tci->i_xattrs.vals_size += val_len;\n\tif (val)\n\t\txattr->val = val;\n\telse\n\t\txattr->val = \"\";\n\n\txattr->val_len = val_len;\n\txattr->dirty = update_xattr;\n\txattr->should_free_val = (val && update_xattr);\n\n\tif (new) {\n\t\trb_link_node(&xattr->node, parent, p);\n\t\trb_insert_color(&xattr->node, &ci->i_xattrs.index);\n\t\tdout(\"__set_xattr_val p=%p\\n\", p);\n\t}\n\n\tdout(\"__set_xattr_val added %llx.%llx xattr %p %s=%.*s\\n\",\n\t     ceph_vinop(&ci->vfs_inode), xattr, name, val_len, val);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_decode_32_safe",
          "args": [
            "&p",
            "end",
            "len",
            "bad"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32_safe",
          "args": [
            "&p",
            "end",
            "len",
            "bad"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "xattrs"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "xattrs[i]"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct ceph_inode_xattr)",
            "GFP_NOFS"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "numattr",
            "sizeof(struct ceph_inode_xattr *)",
            "GFP_NOFS"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_decode_32_safe",
          "args": [
            "&p",
            "end",
            "numattr",
            "bad"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_destroy_xattrs",
          "args": [
            "ci"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_destroy_xattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "536-561",
          "snippet": "void __ceph_destroy_xattrs(struct ceph_inode_info *ci)\n{\n\tstruct rb_node *p, *tmp;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\n\tp = rb_first(&ci->i_xattrs.index);\n\n\tdout(\"__ceph_destroy_xattrs p=%p\\n\", p);\n\n\twhile (p) {\n\t\txattr = rb_entry(p, struct ceph_inode_xattr, node);\n\t\ttmp = p;\n\t\tp = rb_next(tmp);\n\t\tdout(\"__ceph_destroy_xattrs next p=%p (%.*s)\\n\", p,\n\t\t     xattr->name_len, xattr->name);\n\t\trb_erase(tmp, &ci->i_xattrs.index);\n\n\t\t__free_xattr(xattr);\n\t}\n\n\tci->i_xattrs.names_size = 0;\n\tci->i_xattrs.vals_size = 0;\n\tci->i_xattrs.index_version = 0;\n\tci->i_xattrs.count = 0;\n\tci->i_xattrs.index = RB_ROOT;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nvoid __ceph_destroy_xattrs(struct ceph_inode_info *ci)\n{\n\tstruct rb_node *p, *tmp;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\n\tp = rb_first(&ci->i_xattrs.index);\n\n\tdout(\"__ceph_destroy_xattrs p=%p\\n\", p);\n\n\twhile (p) {\n\t\txattr = rb_entry(p, struct ceph_inode_xattr, node);\n\t\ttmp = p;\n\t\tp = rb_next(tmp);\n\t\tdout(\"__ceph_destroy_xattrs next p=%p (%.*s)\\n\", p,\n\t\t     xattr->name_len, xattr->name);\n\t\trb_erase(tmp, &ci->i_xattrs.index);\n\n\t\t__free_xattr(xattr);\n\t}\n\n\tci->i_xattrs.names_size = 0;\n\tci->i_xattrs.vals_size = 0;\n\tci->i_xattrs.index_version = 0;\n\tci->i_xattrs.count = 0;\n\tci->i_xattrs.index = RB_ROOT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__build_xattrs() len=%d\\n\"",
            "ci->i_xattrs.blob ? (int)ci->i_xattrs.blob->vec.iov_len : 0"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_vxattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "273-280",
          "snippet": "static struct ceph_vxattr *ceph_inode_vxattrs(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn ceph_dir_vxattrs;\n\telse if (S_ISREG(inode->i_mode))\n\t\treturn ceph_file_vxattrs;\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ceph_vxattr ceph_dir_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.dir.layout\",\n\t\t.name_size = sizeof(\"ceph.dir.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(dir, layout, object_size),\n\tXATTR_LAYOUT_FIELD(dir, layout, pool),\n\tXATTR_NAME_CEPH(dir, entries),\n\tXATTR_NAME_CEPH(dir, files),\n\tXATTR_NAME_CEPH(dir, subdirs),\n\tXATTR_NAME_CEPH(dir, rentries),\n\tXATTR_NAME_CEPH(dir, rfiles),\n\tXATTR_NAME_CEPH(dir, rsubdirs),\n\tXATTR_NAME_CEPH(dir, rbytes),\n\tXATTR_NAME_CEPH(dir, rctime),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};",
            "static struct ceph_vxattr ceph_file_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.file.layout\",\n\t\t.name_size = sizeof(\"ceph.file.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(file, layout, object_size),\n\tXATTR_LAYOUT_FIELD(file, layout, pool),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_vxattr ceph_dir_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.dir.layout\",\n\t\t.name_size = sizeof(\"ceph.dir.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(dir, layout, object_size),\n\tXATTR_LAYOUT_FIELD(dir, layout, pool),\n\tXATTR_NAME_CEPH(dir, entries),\n\tXATTR_NAME_CEPH(dir, files),\n\tXATTR_NAME_CEPH(dir, subdirs),\n\tXATTR_NAME_CEPH(dir, rentries),\n\tXATTR_NAME_CEPH(dir, rfiles),\n\tXATTR_NAME_CEPH(dir, rsubdirs),\n\tXATTR_NAME_CEPH(dir, rbytes),\n\tXATTR_NAME_CEPH(dir, rctime),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};\nstatic struct ceph_vxattr ceph_file_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.file.layout\",\n\t\t.name_size = sizeof(\"ceph.file.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(file, layout, object_size),\n\tXATTR_LAYOUT_FIELD(file, layout, pool),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};\n\nstatic struct ceph_vxattr *ceph_inode_vxattrs(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn ceph_dir_vxattrs;\n\telse if (S_ISREG(inode->i_mode))\n\t\treturn ceph_file_vxattrs;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "ci->i_ceph_lock"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "ci->i_ceph_lock"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nstatic int __build_xattrs(struct inode *inode)\n\t__releases(ci->i_ceph_lock)\n\t__acquires(ci->i_ceph_lock)\n{\n\tu32 namelen;\n\tu32 numattr = 0;\n\tvoid *p, *end;\n\tu32 len;\n\tconst char *name, *val;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint xattr_version;\n\tstruct ceph_inode_xattr **xattrs = NULL;\n\tint err = 0;\n\tint i;\n\n\tdout(\"__build_xattrs() len=%d\\n\",\n\t     ci->i_xattrs.blob ? (int)ci->i_xattrs.blob->vec.iov_len : 0);\n\n\tif (ci->i_xattrs.index_version >= ci->i_xattrs.version)\n\t\treturn 0; /* already built */\n\n\t__ceph_destroy_xattrs(ci);\n\nstart:\n\t/* updated internal xattr rb tree */\n\tif (ci->i_xattrs.blob && ci->i_xattrs.blob->vec.iov_len > 4) {\n\t\tp = ci->i_xattrs.blob->vec.iov_base;\n\t\tend = p + ci->i_xattrs.blob->vec.iov_len;\n\t\tceph_decode_32_safe(&p, end, numattr, bad);\n\t\txattr_version = ci->i_xattrs.version;\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\txattrs = kcalloc(numattr, sizeof(struct ceph_inode_xattr *),\n\t\t\t\t GFP_NOFS);\n\t\terr = -ENOMEM;\n\t\tif (!xattrs)\n\t\t\tgoto bad_lock;\n\n\t\tfor (i = 0; i < numattr; i++) {\n\t\t\txattrs[i] = kmalloc(sizeof(struct ceph_inode_xattr),\n\t\t\t\t\t    GFP_NOFS);\n\t\t\tif (!xattrs[i])\n\t\t\t\tgoto bad_lock;\n\t\t}\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tif (ci->i_xattrs.version != xattr_version) {\n\t\t\t/* lost a race, retry */\n\t\t\tfor (i = 0; i < numattr; i++)\n\t\t\t\tkfree(xattrs[i]);\n\t\t\tkfree(xattrs);\n\t\t\txattrs = NULL;\n\t\t\tgoto start;\n\t\t}\n\t\terr = -EIO;\n\t\twhile (numattr--) {\n\t\t\tceph_decode_32_safe(&p, end, len, bad);\n\t\t\tnamelen = len;\n\t\t\tname = p;\n\t\t\tp += len;\n\t\t\tceph_decode_32_safe(&p, end, len, bad);\n\t\t\tval = p;\n\t\t\tp += len;\n\n\t\t\terr = __set_xattr(ci, name, namelen, val, len,\n\t\t\t\t\t  0, 0, &xattrs[numattr]);\n\n\t\t\tif (err < 0)\n\t\t\t\tgoto bad;\n\t\t}\n\t\tkfree(xattrs);\n\t}\n\tci->i_xattrs.index_version = ci->i_xattrs.version;\n\tci->i_xattrs.dirty = false;\n\n\treturn err;\nbad_lock:\n\tspin_lock(&ci->i_ceph_lock);\nbad:\n\tif (xattrs) {\n\t\tfor (i = 0; i < numattr; i++)\n\t\t\tkfree(xattrs[i]);\n\t\tkfree(xattrs);\n\t}\n\tci->i_xattrs.names_size = 0;\n\treturn err;\n}"
  },
  {
    "function_name": "__ceph_destroy_xattrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "536-561",
    "snippet": "void __ceph_destroy_xattrs(struct ceph_inode_info *ci)\n{\n\tstruct rb_node *p, *tmp;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\n\tp = rb_first(&ci->i_xattrs.index);\n\n\tdout(\"__ceph_destroy_xattrs p=%p\\n\", p);\n\n\twhile (p) {\n\t\txattr = rb_entry(p, struct ceph_inode_xattr, node);\n\t\ttmp = p;\n\t\tp = rb_next(tmp);\n\t\tdout(\"__ceph_destroy_xattrs next p=%p (%.*s)\\n\", p,\n\t\t     xattr->name_len, xattr->name);\n\t\trb_erase(tmp, &ci->i_xattrs.index);\n\n\t\t__free_xattr(xattr);\n\t}\n\n\tci->i_xattrs.names_size = 0;\n\tci->i_xattrs.vals_size = 0;\n\tci->i_xattrs.index_version = 0;\n\tci->i_xattrs.count = 0;\n\tci->i_xattrs.index = RB_ROOT;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_xattr",
          "args": [
            "xattr"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "__free_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "466-476",
          "snippet": "static void __free_xattr(struct ceph_inode_xattr *xattr)\n{\n\tBUG_ON(!xattr);\n\n\tif (xattr->should_free_name)\n\t\tkfree((void *)xattr->name);\n\tif (xattr->should_free_val)\n\t\tkfree((void *)xattr->val);\n\n\tkfree(xattr);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nstatic void __free_xattr(struct ceph_inode_xattr *xattr)\n{\n\tBUG_ON(!xattr);\n\n\tif (xattr->should_free_name)\n\t\tkfree((void *)xattr->name);\n\tif (xattr->should_free_val)\n\t\tkfree((void *)xattr->val);\n\n\tkfree(xattr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "tmp",
            "&ci->i_xattrs.index"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__ceph_destroy_xattrs next p=%p (%.*s)\\n\"",
            "p",
            "xattr->name_len",
            "xattr->name"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "tmp"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "p",
            "structceph_inode_xattr",
            "node"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__ceph_destroy_xattrs p=%p\\n\"",
            "p"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ci->i_xattrs.index"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nvoid __ceph_destroy_xattrs(struct ceph_inode_info *ci)\n{\n\tstruct rb_node *p, *tmp;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\n\tp = rb_first(&ci->i_xattrs.index);\n\n\tdout(\"__ceph_destroy_xattrs p=%p\\n\", p);\n\n\twhile (p) {\n\t\txattr = rb_entry(p, struct ceph_inode_xattr, node);\n\t\ttmp = p;\n\t\tp = rb_next(tmp);\n\t\tdout(\"__ceph_destroy_xattrs next p=%p (%.*s)\\n\", p,\n\t\t     xattr->name_len, xattr->name);\n\t\trb_erase(tmp, &ci->i_xattrs.index);\n\n\t\t__free_xattr(xattr);\n\t}\n\n\tci->i_xattrs.names_size = 0;\n\tci->i_xattrs.vals_size = 0;\n\tci->i_xattrs.index_version = 0;\n\tci->i_xattrs.count = 0;\n\tci->i_xattrs.index = RB_ROOT;\n}"
  },
  {
    "function_name": "__copy_xattr_names",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "512-534",
    "snippet": "static char *__copy_xattr_names(struct ceph_inode_info *ci,\n\t\t\t\tchar *dest)\n{\n\tstruct rb_node *p;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\n\tp = rb_first(&ci->i_xattrs.index);\n\tdout(\"__copy_xattr_names count=%d\\n\", ci->i_xattrs.count);\n\n\twhile (p) {\n\t\txattr = rb_entry(p, struct ceph_inode_xattr, node);\n\t\tmemcpy(dest, xattr->name, xattr->name_len);\n\t\tdest[xattr->name_len] = '\\0';\n\n\t\tdout(\"dest=%s %p (%s) (%d/%d)\\n\", dest, xattr, xattr->name,\n\t\t     xattr->name_len, ci->i_xattrs.names_size);\n\n\t\tdest += xattr->name_len + 1;\n\t\tp = rb_next(p);\n\t}\n\n\treturn dest;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "p"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"dest=%s %p (%s) (%d/%d)\\n\"",
            "dest",
            "xattr",
            "xattr->name",
            "xattr->name_len",
            "ci->i_xattrs.names_size"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest",
            "xattr->name",
            "xattr->name_len"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "p",
            "structceph_inode_xattr",
            "node"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__copy_xattr_names count=%d\\n\"",
            "ci->i_xattrs.count"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ci->i_xattrs.index"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nstatic char *__copy_xattr_names(struct ceph_inode_info *ci,\n\t\t\t\tchar *dest)\n{\n\tstruct rb_node *p;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\n\tp = rb_first(&ci->i_xattrs.index);\n\tdout(\"__copy_xattr_names count=%d\\n\", ci->i_xattrs.count);\n\n\twhile (p) {\n\t\txattr = rb_entry(p, struct ceph_inode_xattr, node);\n\t\tmemcpy(dest, xattr->name, xattr->name_len);\n\t\tdest[xattr->name_len] = '\\0';\n\n\t\tdout(\"dest=%s %p (%s) (%d/%d)\\n\", dest, xattr, xattr->name,\n\t\t     xattr->name_len, ci->i_xattrs.names_size);\n\n\t\tdest += xattr->name_len + 1;\n\t\tp = rb_next(p);\n\t}\n\n\treturn dest;\n}"
  },
  {
    "function_name": "__remove_xattr_by_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "499-510",
    "snippet": "static int __remove_xattr_by_name(struct ceph_inode_info *ci,\n\t\t\t   const char *name)\n{\n\tstruct rb_node **p;\n\tstruct ceph_inode_xattr *xattr;\n\tint err;\n\n\tp = &ci->i_xattrs.index.rb_node;\n\txattr = __get_xattr(ci, name);\n\terr = __remove_xattr(ci, xattr);\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__remove_xattr",
          "args": [
            "ci",
            "xattr"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_xattr_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "499-510",
          "snippet": "static int __remove_xattr_by_name(struct ceph_inode_info *ci,\n\t\t\t   const char *name)\n{\n\tstruct rb_node **p;\n\tstruct ceph_inode_xattr *xattr;\n\tint err;\n\n\tp = &ci->i_xattrs.index.rb_node;\n\txattr = __get_xattr(ci, name);\n\terr = __remove_xattr(ci, xattr);\n\treturn err;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "__get_xattr",
          "args": [
            "ci",
            "name"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "__get_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "434-464",
          "snippet": "static struct ceph_inode_xattr *__get_xattr(struct ceph_inode_info *ci,\n\t\t\t   const char *name)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\tint name_len = strlen(name);\n\tint c;\n\n\tp = &ci->i_xattrs.index.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\txattr = rb_entry(parent, struct ceph_inode_xattr, node);\n\t\tc = strncmp(name, xattr->name, xattr->name_len);\n\t\tif (c == 0 && name_len > xattr->name_len)\n\t\t\tc = 1;\n\t\tif (c < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (c > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tdout(\"__get_xattr %s: found %.*s\\n\", name,\n\t\t\t     xattr->val_len, xattr->val);\n\t\t\treturn xattr;\n\t\t}\n\t}\n\n\tdout(\"__get_xattr %s: not found\\n\", name);\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nstatic struct ceph_inode_xattr *__get_xattr(struct ceph_inode_info *ci,\n\t\t\t   const char *name)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\tint name_len = strlen(name);\n\tint c;\n\n\tp = &ci->i_xattrs.index.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\txattr = rb_entry(parent, struct ceph_inode_xattr, node);\n\t\tc = strncmp(name, xattr->name, xattr->name_len);\n\t\tif (c == 0 && name_len > xattr->name_len)\n\t\t\tc = 1;\n\t\tif (c < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (c > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tdout(\"__get_xattr %s: found %.*s\\n\", name,\n\t\t\t     xattr->val_len, xattr->val);\n\t\t\treturn xattr;\n\t\t}\n\t}\n\n\tdout(\"__get_xattr %s: not found\\n\", name);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nstatic int __remove_xattr_by_name(struct ceph_inode_info *ci,\n\t\t\t   const char *name)\n{\n\tstruct rb_node **p;\n\tstruct ceph_inode_xattr *xattr;\n\tint err;\n\n\tp = &ci->i_xattrs.index.rb_node;\n\txattr = __get_xattr(ci, name);\n\terr = __remove_xattr(ci, xattr);\n\treturn err;\n}"
  },
  {
    "function_name": "__remove_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "478-497",
    "snippet": "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr)\n{\n\tif (!xattr)\n\t\treturn -ENODATA;\n\n\trb_erase(&xattr->node, &ci->i_xattrs.index);\n\n\tif (xattr->should_free_name)\n\t\tkfree((void *)xattr->name);\n\tif (xattr->should_free_val)\n\t\tkfree((void *)xattr->val);\n\n\tci->i_xattrs.names_size -= xattr->name_len;\n\tci->i_xattrs.vals_size -= xattr->val_len;\n\tci->i_xattrs.count--;\n\tkfree(xattr);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "xattr"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "(void *)xattr->val"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "(void *)xattr->name"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&xattr->node",
            "&ci->i_xattrs.index"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr)\n{\n\tif (!xattr)\n\t\treturn -ENODATA;\n\n\trb_erase(&xattr->node, &ci->i_xattrs.index);\n\n\tif (xattr->should_free_name)\n\t\tkfree((void *)xattr->name);\n\tif (xattr->should_free_val)\n\t\tkfree((void *)xattr->val);\n\n\tci->i_xattrs.names_size -= xattr->name_len;\n\tci->i_xattrs.vals_size -= xattr->val_len;\n\tci->i_xattrs.count--;\n\tkfree(xattr);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__free_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "466-476",
    "snippet": "static void __free_xattr(struct ceph_inode_xattr *xattr)\n{\n\tBUG_ON(!xattr);\n\n\tif (xattr->should_free_name)\n\t\tkfree((void *)xattr->name);\n\tif (xattr->should_free_val)\n\t\tkfree((void *)xattr->val);\n\n\tkfree(xattr);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "xattr"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "(void *)xattr->val"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "(void *)xattr->name"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!xattr"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nstatic void __free_xattr(struct ceph_inode_xattr *xattr)\n{\n\tBUG_ON(!xattr);\n\n\tif (xattr->should_free_name)\n\t\tkfree((void *)xattr->name);\n\tif (xattr->should_free_val)\n\t\tkfree((void *)xattr->val);\n\n\tkfree(xattr);\n}"
  },
  {
    "function_name": "__get_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "434-464",
    "snippet": "static struct ceph_inode_xattr *__get_xattr(struct ceph_inode_info *ci,\n\t\t\t   const char *name)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\tint name_len = strlen(name);\n\tint c;\n\n\tp = &ci->i_xattrs.index.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\txattr = rb_entry(parent, struct ceph_inode_xattr, node);\n\t\tc = strncmp(name, xattr->name, xattr->name_len);\n\t\tif (c == 0 && name_len > xattr->name_len)\n\t\t\tc = 1;\n\t\tif (c < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (c > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tdout(\"__get_xattr %s: found %.*s\\n\", name,\n\t\t\t     xattr->val_len, xattr->val);\n\t\t\treturn xattr;\n\t\t}\n\t}\n\n\tdout(\"__get_xattr %s: not found\\n\", name);\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__get_xattr %s: not found\\n\"",
            "name"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__get_xattr %s: found %.*s\\n\"",
            "name",
            "xattr->val_len",
            "xattr->val"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "xattr->name",
            "xattr->name_len"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structceph_inode_xattr",
            "node"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nstatic struct ceph_inode_xattr *__get_xattr(struct ceph_inode_info *ci,\n\t\t\t   const char *name)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\tint name_len = strlen(name);\n\tint c;\n\n\tp = &ci->i_xattrs.index.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\txattr = rb_entry(parent, struct ceph_inode_xattr, node);\n\t\tc = strncmp(name, xattr->name, xattr->name_len);\n\t\tif (c == 0 && name_len > xattr->name_len)\n\t\t\tc = 1;\n\t\tif (c < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (c > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tdout(\"__get_xattr %s: found %.*s\\n\", name,\n\t\t\t     xattr->val_len, xattr->val);\n\t\t\treturn xattr;\n\t\t}\n\t}\n\n\tdout(\"__get_xattr %s: not found\\n\", name);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "__set_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "338-432",
    "snippet": "static int __set_xattr(struct ceph_inode_info *ci,\n\t\t\t   const char *name, int name_len,\n\t\t\t   const char *val, int val_len,\n\t\t\t   int flags, int update_xattr,\n\t\t\t   struct ceph_inode_xattr **newxattr)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\tint c;\n\tint new = 0;\n\n\tp = &ci->i_xattrs.index.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\txattr = rb_entry(parent, struct ceph_inode_xattr, node);\n\t\tc = strncmp(name, xattr->name, min(name_len, xattr->name_len));\n\t\tif (c < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (c > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tif (name_len == xattr->name_len)\n\t\t\t\tbreak;\n\t\t\telse if (name_len < xattr->name_len)\n\t\t\t\tp = &(*p)->rb_left;\n\t\t\telse\n\t\t\t\tp = &(*p)->rb_right;\n\t\t}\n\t\txattr = NULL;\n\t}\n\n\tif (update_xattr) {\n\t\tint err = 0;\n\t\tif (xattr && (flags & XATTR_CREATE))\n\t\t\terr = -EEXIST;\n\t\telse if (!xattr && (flags & XATTR_REPLACE))\n\t\t\terr = -ENODATA;\n\t\tif (err) {\n\t\t\tkfree(name);\n\t\t\tkfree(val);\n\t\t\treturn err;\n\t\t}\n\t\tif (update_xattr < 0) {\n\t\t\tif (xattr)\n\t\t\t\t__remove_xattr(ci, xattr);\n\t\t\tkfree(name);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!xattr) {\n\t\tnew = 1;\n\t\txattr = *newxattr;\n\t\txattr->name = name;\n\t\txattr->name_len = name_len;\n\t\txattr->should_free_name = update_xattr;\n\n\t\tci->i_xattrs.count++;\n\t\tdout(\"__set_xattr count=%d\\n\", ci->i_xattrs.count);\n\t} else {\n\t\tkfree(*newxattr);\n\t\t*newxattr = NULL;\n\t\tif (xattr->should_free_val)\n\t\t\tkfree((void *)xattr->val);\n\n\t\tif (update_xattr) {\n\t\t\tkfree((void *)name);\n\t\t\tname = xattr->name;\n\t\t}\n\t\tci->i_xattrs.names_size -= xattr->name_len;\n\t\tci->i_xattrs.vals_size -= xattr->val_len;\n\t}\n\tci->i_xattrs.names_size += name_len;\n\tci->i_xattrs.vals_size += val_len;\n\tif (val)\n\t\txattr->val = val;\n\telse\n\t\txattr->val = \"\";\n\n\txattr->val_len = val_len;\n\txattr->dirty = update_xattr;\n\txattr->should_free_val = (val && update_xattr);\n\n\tif (new) {\n\t\trb_link_node(&xattr->node, parent, p);\n\t\trb_insert_color(&xattr->node, &ci->i_xattrs.index);\n\t\tdout(\"__set_xattr_val p=%p\\n\", p);\n\t}\n\n\tdout(\"__set_xattr_val added %llx.%llx xattr %p %s=%.*s\\n\",\n\t     ceph_vinop(&ci->vfs_inode), xattr, name, val_len, val);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__set_xattr_val added %llx.%llx xattr %p %s=%.*s\\n\"",
            "ceph_vinop(&ci->vfs_inode)",
            "xattr",
            "name",
            "val_len",
            "val"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "&ci->vfs_inode"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__set_xattr_val p=%p\\n\"",
            "p"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&xattr->node",
            "&ci->i_xattrs.index"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&xattr->node",
            "parent",
            "p"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "(void *)name"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "(void *)xattr->val"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "*newxattr"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__set_xattr count=%d\\n\"",
            "ci->i_xattrs.count"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__remove_xattr",
          "args": [
            "ci",
            "xattr"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_xattr_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "499-510",
          "snippet": "static int __remove_xattr_by_name(struct ceph_inode_info *ci,\n\t\t\t   const char *name)\n{\n\tstruct rb_node **p;\n\tstruct ceph_inode_xattr *xattr;\n\tint err;\n\n\tp = &ci->i_xattrs.index.rb_node;\n\txattr = __get_xattr(ci, name);\n\terr = __remove_xattr(ci, xattr);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nstatic int __remove_xattr_by_name(struct ceph_inode_info *ci,\n\t\t\t   const char *name)\n{\n\tstruct rb_node **p;\n\tstruct ceph_inode_xattr *xattr;\n\tint err;\n\n\tp = &ci->i_xattrs.index.rb_node;\n\txattr = __get_xattr(ci, name);\n\terr = __remove_xattr(ci, xattr);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "val"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "xattr->name",
            "min(name_len, xattr->name_len)"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "name_len",
            "xattr->name_len"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_adjust_min_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "143-149",
          "snippet": "void ceph_adjust_min_caps(struct ceph_mds_client *mdsc, int delta)\n{\n\tspin_lock(&mdsc->caps_list_lock);\n\tmdsc->caps_min_count += delta;\n\tBUG_ON(mdsc->caps_min_count < 0);\n\tspin_unlock(&mdsc->caps_list_lock);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_adjust_min_caps(struct ceph_mds_client *mdsc, int delta)\n{\n\tspin_lock(&mdsc->caps_list_lock);\n\tmdsc->caps_min_count += delta;\n\tBUG_ON(mdsc->caps_min_count < 0);\n\tspin_unlock(&mdsc->caps_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structceph_inode_xattr",
            "node"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nstatic int __set_xattr(struct ceph_inode_info *ci,\n\t\t\t   const char *name, int name_len,\n\t\t\t   const char *val, int val_len,\n\t\t\t   int flags, int update_xattr,\n\t\t\t   struct ceph_inode_xattr **newxattr)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\tint c;\n\tint new = 0;\n\n\tp = &ci->i_xattrs.index.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\txattr = rb_entry(parent, struct ceph_inode_xattr, node);\n\t\tc = strncmp(name, xattr->name, min(name_len, xattr->name_len));\n\t\tif (c < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (c > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tif (name_len == xattr->name_len)\n\t\t\t\tbreak;\n\t\t\telse if (name_len < xattr->name_len)\n\t\t\t\tp = &(*p)->rb_left;\n\t\t\telse\n\t\t\t\tp = &(*p)->rb_right;\n\t\t}\n\t\txattr = NULL;\n\t}\n\n\tif (update_xattr) {\n\t\tint err = 0;\n\t\tif (xattr && (flags & XATTR_CREATE))\n\t\t\terr = -EEXIST;\n\t\telse if (!xattr && (flags & XATTR_REPLACE))\n\t\t\terr = -ENODATA;\n\t\tif (err) {\n\t\t\tkfree(name);\n\t\t\tkfree(val);\n\t\t\treturn err;\n\t\t}\n\t\tif (update_xattr < 0) {\n\t\t\tif (xattr)\n\t\t\t\t__remove_xattr(ci, xattr);\n\t\t\tkfree(name);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!xattr) {\n\t\tnew = 1;\n\t\txattr = *newxattr;\n\t\txattr->name = name;\n\t\txattr->name_len = name_len;\n\t\txattr->should_free_name = update_xattr;\n\n\t\tci->i_xattrs.count++;\n\t\tdout(\"__set_xattr count=%d\\n\", ci->i_xattrs.count);\n\t} else {\n\t\tkfree(*newxattr);\n\t\t*newxattr = NULL;\n\t\tif (xattr->should_free_val)\n\t\t\tkfree((void *)xattr->val);\n\n\t\tif (update_xattr) {\n\t\t\tkfree((void *)name);\n\t\t\tname = xattr->name;\n\t\t}\n\t\tci->i_xattrs.names_size -= xattr->name_len;\n\t\tci->i_xattrs.vals_size -= xattr->val_len;\n\t}\n\tci->i_xattrs.names_size += name_len;\n\tci->i_xattrs.vals_size += val_len;\n\tif (val)\n\t\txattr->val = val;\n\telse\n\t\txattr->val = \"\";\n\n\txattr->val_len = val_len;\n\txattr->dirty = update_xattr;\n\txattr->should_free_val = (val && update_xattr);\n\n\tif (new) {\n\t\trb_link_node(&xattr->node, parent, p);\n\t\trb_insert_color(&xattr->node, &ci->i_xattrs.index);\n\t\tdout(\"__set_xattr_val p=%p\\n\", p);\n\t}\n\n\tdout(\"__set_xattr_val added %llx.%llx xattr %p %s=%.*s\\n\",\n\t     ceph_vinop(&ci->vfs_inode), xattr, name, val_len, val);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ceph_match_vxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "322-336",
    "snippet": "static struct ceph_vxattr *ceph_match_vxattr(struct inode *inode,\n\t\t\t\t\t\tconst char *name)\n{\n\tstruct ceph_vxattr *vxattr = ceph_inode_vxattrs(inode);\n\n\tif (vxattr) {\n\t\twhile (vxattr->name) {\n\t\t\tif (!strcmp(vxattr->name, name))\n\t\t\t\treturn vxattr;\n\t\t\tvxattr++;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "vxattr->name",
            "name"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode_vxattrs",
          "args": [
            "inode"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_vxattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "273-280",
          "snippet": "static struct ceph_vxattr *ceph_inode_vxattrs(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn ceph_dir_vxattrs;\n\telse if (S_ISREG(inode->i_mode))\n\t\treturn ceph_file_vxattrs;\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ceph_vxattr ceph_dir_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.dir.layout\",\n\t\t.name_size = sizeof(\"ceph.dir.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(dir, layout, object_size),\n\tXATTR_LAYOUT_FIELD(dir, layout, pool),\n\tXATTR_NAME_CEPH(dir, entries),\n\tXATTR_NAME_CEPH(dir, files),\n\tXATTR_NAME_CEPH(dir, subdirs),\n\tXATTR_NAME_CEPH(dir, rentries),\n\tXATTR_NAME_CEPH(dir, rfiles),\n\tXATTR_NAME_CEPH(dir, rsubdirs),\n\tXATTR_NAME_CEPH(dir, rbytes),\n\tXATTR_NAME_CEPH(dir, rctime),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};",
            "static struct ceph_vxattr ceph_file_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.file.layout\",\n\t\t.name_size = sizeof(\"ceph.file.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(file, layout, object_size),\n\tXATTR_LAYOUT_FIELD(file, layout, pool),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_vxattr ceph_dir_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.dir.layout\",\n\t\t.name_size = sizeof(\"ceph.dir.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(dir, layout, object_size),\n\tXATTR_LAYOUT_FIELD(dir, layout, pool),\n\tXATTR_NAME_CEPH(dir, entries),\n\tXATTR_NAME_CEPH(dir, files),\n\tXATTR_NAME_CEPH(dir, subdirs),\n\tXATTR_NAME_CEPH(dir, rentries),\n\tXATTR_NAME_CEPH(dir, rfiles),\n\tXATTR_NAME_CEPH(dir, rsubdirs),\n\tXATTR_NAME_CEPH(dir, rbytes),\n\tXATTR_NAME_CEPH(dir, rctime),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};\nstatic struct ceph_vxattr ceph_file_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.file.layout\",\n\t\t.name_size = sizeof(\"ceph.file.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(file, layout, object_size),\n\tXATTR_LAYOUT_FIELD(file, layout, pool),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};\n\nstatic struct ceph_vxattr *ceph_inode_vxattrs(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn ceph_dir_vxattrs;\n\telse if (S_ISREG(inode->i_mode))\n\t\treturn ceph_file_vxattrs;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_vxattr *ceph_match_vxattr(struct inode *inode,\n\t\t\t\t\t\tconst char *name)\n{\n\tstruct ceph_vxattr *vxattr = ceph_inode_vxattrs(inode);\n\n\tif (vxattr) {\n\t\twhile (vxattr->name) {\n\t\t\tif (!strcmp(vxattr->name, name))\n\t\t\t\treturn vxattr;\n\t\t\tvxattr++;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "ceph_xattr_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "316-320",
    "snippet": "void ceph_xattr_exit(void)\n{\n\tceph_dir_vxattrs_name_size = 0;\n\tceph_file_vxattrs_name_size = 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static size_t ceph_dir_vxattrs_name_size;",
      "static size_t ceph_file_vxattrs_name_size;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic size_t ceph_dir_vxattrs_name_size;\nstatic size_t ceph_file_vxattrs_name_size;\n\nvoid ceph_xattr_exit(void)\n{\n\tceph_dir_vxattrs_name_size = 0;\n\tceph_file_vxattrs_name_size = 0;\n}"
  },
  {
    "function_name": "ceph_xattr_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "310-314",
    "snippet": "void __init ceph_xattr_init(void)\n{\n\tceph_dir_vxattrs_name_size = vxattrs_name_size(ceph_dir_vxattrs);\n\tceph_file_vxattrs_name_size = vxattrs_name_size(ceph_file_vxattrs);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ceph_vxattr ceph_dir_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.dir.layout\",\n\t\t.name_size = sizeof(\"ceph.dir.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(dir, layout, object_size),\n\tXATTR_LAYOUT_FIELD(dir, layout, pool),\n\tXATTR_NAME_CEPH(dir, entries),\n\tXATTR_NAME_CEPH(dir, files),\n\tXATTR_NAME_CEPH(dir, subdirs),\n\tXATTR_NAME_CEPH(dir, rentries),\n\tXATTR_NAME_CEPH(dir, rfiles),\n\tXATTR_NAME_CEPH(dir, rsubdirs),\n\tXATTR_NAME_CEPH(dir, rbytes),\n\tXATTR_NAME_CEPH(dir, rctime),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};",
      "static size_t ceph_dir_vxattrs_name_size;",
      "static struct ceph_vxattr ceph_file_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.file.layout\",\n\t\t.name_size = sizeof(\"ceph.file.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(file, layout, object_size),\n\tXATTR_LAYOUT_FIELD(file, layout, pool),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};",
      "static size_t ceph_file_vxattrs_name_size;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vxattrs_name_size",
          "args": [
            "ceph_file_vxattrs"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "vxattrs_name_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "296-306",
          "snippet": "static size_t __init vxattrs_name_size(struct ceph_vxattr *vxattrs)\n{\n\tstruct ceph_vxattr *vxattr;\n\tsize_t size = 0;\n\n\tfor (vxattr = vxattrs; vxattr->name; vxattr++)\n\t\tif (!vxattr->hidden)\n\t\t\tsize += vxattr->name_size;\n\n\treturn size;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic size_t __init vxattrs_name_size(struct ceph_vxattr *vxattrs)\n{\n\tstruct ceph_vxattr *vxattr;\n\tsize_t size = 0;\n\n\tfor (vxattr = vxattrs; vxattr->name; vxattr++)\n\t\tif (!vxattr->hidden)\n\t\t\tsize += vxattr->name_size;\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_vxattr ceph_dir_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.dir.layout\",\n\t\t.name_size = sizeof(\"ceph.dir.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(dir, layout, object_size),\n\tXATTR_LAYOUT_FIELD(dir, layout, pool),\n\tXATTR_NAME_CEPH(dir, entries),\n\tXATTR_NAME_CEPH(dir, files),\n\tXATTR_NAME_CEPH(dir, subdirs),\n\tXATTR_NAME_CEPH(dir, rentries),\n\tXATTR_NAME_CEPH(dir, rfiles),\n\tXATTR_NAME_CEPH(dir, rsubdirs),\n\tXATTR_NAME_CEPH(dir, rbytes),\n\tXATTR_NAME_CEPH(dir, rctime),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};\nstatic size_t ceph_dir_vxattrs_name_size;\nstatic struct ceph_vxattr ceph_file_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.file.layout\",\n\t\t.name_size = sizeof(\"ceph.file.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(file, layout, object_size),\n\tXATTR_LAYOUT_FIELD(file, layout, pool),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};\nstatic size_t ceph_file_vxattrs_name_size;\n\nvoid __init ceph_xattr_init(void)\n{\n\tceph_dir_vxattrs_name_size = vxattrs_name_size(ceph_dir_vxattrs);\n\tceph_file_vxattrs_name_size = vxattrs_name_size(ceph_file_vxattrs);\n}"
  },
  {
    "function_name": "vxattrs_name_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "296-306",
    "snippet": "static size_t __init vxattrs_name_size(struct ceph_vxattr *vxattrs)\n{\n\tstruct ceph_vxattr *vxattr;\n\tsize_t size = 0;\n\n\tfor (vxattr = vxattrs; vxattr->name; vxattr++)\n\t\tif (!vxattr->hidden)\n\t\t\tsize += vxattr->name_size;\n\n\treturn size;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic size_t __init vxattrs_name_size(struct ceph_vxattr *vxattrs)\n{\n\tstruct ceph_vxattr *vxattr;\n\tsize_t size = 0;\n\n\tfor (vxattr = vxattrs; vxattr->name; vxattr++)\n\t\tif (!vxattr->hidden)\n\t\t\tsize += vxattr->name_size;\n\n\treturn size;\n}"
  },
  {
    "function_name": "ceph_vxattrs_name_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "282-290",
    "snippet": "static size_t ceph_vxattrs_name_size(struct ceph_vxattr *vxattrs)\n{\n\tif (vxattrs == ceph_dir_vxattrs)\n\t\treturn ceph_dir_vxattrs_name_size;\n\tif (vxattrs == ceph_file_vxattrs)\n\t\treturn ceph_file_vxattrs_name_size;\n\tBUG_ON(vxattrs);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ceph_vxattr ceph_dir_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.dir.layout\",\n\t\t.name_size = sizeof(\"ceph.dir.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(dir, layout, object_size),\n\tXATTR_LAYOUT_FIELD(dir, layout, pool),\n\tXATTR_NAME_CEPH(dir, entries),\n\tXATTR_NAME_CEPH(dir, files),\n\tXATTR_NAME_CEPH(dir, subdirs),\n\tXATTR_NAME_CEPH(dir, rentries),\n\tXATTR_NAME_CEPH(dir, rfiles),\n\tXATTR_NAME_CEPH(dir, rsubdirs),\n\tXATTR_NAME_CEPH(dir, rbytes),\n\tXATTR_NAME_CEPH(dir, rctime),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};",
      "static size_t ceph_dir_vxattrs_name_size;",
      "static struct ceph_vxattr ceph_file_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.file.layout\",\n\t\t.name_size = sizeof(\"ceph.file.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(file, layout, object_size),\n\tXATTR_LAYOUT_FIELD(file, layout, pool),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};",
      "static size_t ceph_file_vxattrs_name_size;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "vxattrs"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_vxattr ceph_dir_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.dir.layout\",\n\t\t.name_size = sizeof(\"ceph.dir.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(dir, layout, object_size),\n\tXATTR_LAYOUT_FIELD(dir, layout, pool),\n\tXATTR_NAME_CEPH(dir, entries),\n\tXATTR_NAME_CEPH(dir, files),\n\tXATTR_NAME_CEPH(dir, subdirs),\n\tXATTR_NAME_CEPH(dir, rentries),\n\tXATTR_NAME_CEPH(dir, rfiles),\n\tXATTR_NAME_CEPH(dir, rsubdirs),\n\tXATTR_NAME_CEPH(dir, rbytes),\n\tXATTR_NAME_CEPH(dir, rctime),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};\nstatic size_t ceph_dir_vxattrs_name_size;\nstatic struct ceph_vxattr ceph_file_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.file.layout\",\n\t\t.name_size = sizeof(\"ceph.file.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(file, layout, object_size),\n\tXATTR_LAYOUT_FIELD(file, layout, pool),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};\nstatic size_t ceph_file_vxattrs_name_size;\n\nstatic size_t ceph_vxattrs_name_size(struct ceph_vxattr *vxattrs)\n{\n\tif (vxattrs == ceph_dir_vxattrs)\n\t\treturn ceph_dir_vxattrs_name_size;\n\tif (vxattrs == ceph_file_vxattrs)\n\t\treturn ceph_file_vxattrs_name_size;\n\tBUG_ON(vxattrs);\n\treturn 0;\n}"
  },
  {
    "function_name": "ceph_inode_vxattrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "273-280",
    "snippet": "static struct ceph_vxattr *ceph_inode_vxattrs(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn ceph_dir_vxattrs;\n\telse if (S_ISREG(inode->i_mode))\n\t\treturn ceph_file_vxattrs;\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ceph_vxattr ceph_dir_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.dir.layout\",\n\t\t.name_size = sizeof(\"ceph.dir.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(dir, layout, object_size),\n\tXATTR_LAYOUT_FIELD(dir, layout, pool),\n\tXATTR_NAME_CEPH(dir, entries),\n\tXATTR_NAME_CEPH(dir, files),\n\tXATTR_NAME_CEPH(dir, subdirs),\n\tXATTR_NAME_CEPH(dir, rentries),\n\tXATTR_NAME_CEPH(dir, rfiles),\n\tXATTR_NAME_CEPH(dir, rsubdirs),\n\tXATTR_NAME_CEPH(dir, rbytes),\n\tXATTR_NAME_CEPH(dir, rctime),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};",
      "static struct ceph_vxattr ceph_file_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.file.layout\",\n\t\t.name_size = sizeof(\"ceph.file.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(file, layout, object_size),\n\tXATTR_LAYOUT_FIELD(file, layout, pool),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_vxattr ceph_dir_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.dir.layout\",\n\t\t.name_size = sizeof(\"ceph.dir.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(dir, layout, object_size),\n\tXATTR_LAYOUT_FIELD(dir, layout, pool),\n\tXATTR_NAME_CEPH(dir, entries),\n\tXATTR_NAME_CEPH(dir, files),\n\tXATTR_NAME_CEPH(dir, subdirs),\n\tXATTR_NAME_CEPH(dir, rentries),\n\tXATTR_NAME_CEPH(dir, rfiles),\n\tXATTR_NAME_CEPH(dir, rsubdirs),\n\tXATTR_NAME_CEPH(dir, rbytes),\n\tXATTR_NAME_CEPH(dir, rctime),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};\nstatic struct ceph_vxattr ceph_file_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.file.layout\",\n\t\t.name_size = sizeof(\"ceph.file.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(file, layout, object_size),\n\tXATTR_LAYOUT_FIELD(file, layout, pool),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};\n\nstatic struct ceph_vxattr *ceph_inode_vxattrs(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn ceph_dir_vxattrs;\n\telse if (S_ISREG(inode->i_mode))\n\t\treturn ceph_file_vxattrs;\n\treturn NULL;\n}"
  },
  {
    "function_name": "ceph_vxattrcb_dir_rctime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "198-203",
    "snippet": "static size_t ceph_vxattrcb_dir_rctime(struct ceph_inode_info *ci, char *val,\n\t\t\t\t       size_t size)\n{\n\treturn snprintf(val, size, \"%ld.09%ld\", (long)ci->i_rctime.tv_sec,\n\t\t\t(long)ci->i_rctime.tv_nsec);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "val",
            "size",
            "\"%ld.09%ld\"",
            "(long)ci->i_rctime.tv_sec",
            "(long)ci->i_rctime.tv_nsec"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic size_t ceph_vxattrcb_dir_rctime(struct ceph_inode_info *ci, char *val,\n\t\t\t\t       size_t size)\n{\n\treturn snprintf(val, size, \"%ld.09%ld\", (long)ci->i_rctime.tv_sec,\n\t\t\t(long)ci->i_rctime.tv_nsec);\n}"
  },
  {
    "function_name": "ceph_vxattrcb_dir_rbytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "192-196",
    "snippet": "static size_t ceph_vxattrcb_dir_rbytes(struct ceph_inode_info *ci, char *val,\n\t\t\t\t       size_t size)\n{\n\treturn snprintf(val, size, \"%lld\", ci->i_rbytes);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "val",
            "size",
            "\"%lld\"",
            "ci->i_rbytes"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic size_t ceph_vxattrcb_dir_rbytes(struct ceph_inode_info *ci, char *val,\n\t\t\t\t       size_t size)\n{\n\treturn snprintf(val, size, \"%lld\", ci->i_rbytes);\n}"
  },
  {
    "function_name": "ceph_vxattrcb_dir_rsubdirs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "186-190",
    "snippet": "static size_t ceph_vxattrcb_dir_rsubdirs(struct ceph_inode_info *ci, char *val,\n\t\t\t\t\t size_t size)\n{\n\treturn snprintf(val, size, \"%lld\", ci->i_rsubdirs);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "val",
            "size",
            "\"%lld\"",
            "ci->i_rsubdirs"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic size_t ceph_vxattrcb_dir_rsubdirs(struct ceph_inode_info *ci, char *val,\n\t\t\t\t\t size_t size)\n{\n\treturn snprintf(val, size, \"%lld\", ci->i_rsubdirs);\n}"
  },
  {
    "function_name": "ceph_vxattrcb_dir_rfiles",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "180-184",
    "snippet": "static size_t ceph_vxattrcb_dir_rfiles(struct ceph_inode_info *ci, char *val,\n\t\t\t\t       size_t size)\n{\n\treturn snprintf(val, size, \"%lld\", ci->i_rfiles);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "val",
            "size",
            "\"%lld\"",
            "ci->i_rfiles"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic size_t ceph_vxattrcb_dir_rfiles(struct ceph_inode_info *ci, char *val,\n\t\t\t\t       size_t size)\n{\n\treturn snprintf(val, size, \"%lld\", ci->i_rfiles);\n}"
  },
  {
    "function_name": "ceph_vxattrcb_dir_rentries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "174-178",
    "snippet": "static size_t ceph_vxattrcb_dir_rentries(struct ceph_inode_info *ci, char *val,\n\t\t\t\t\t size_t size)\n{\n\treturn snprintf(val, size, \"%lld\", ci->i_rfiles + ci->i_rsubdirs);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "val",
            "size",
            "\"%lld\"",
            "ci->i_rfiles + ci->i_rsubdirs"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic size_t ceph_vxattrcb_dir_rentries(struct ceph_inode_info *ci, char *val,\n\t\t\t\t\t size_t size)\n{\n\treturn snprintf(val, size, \"%lld\", ci->i_rfiles + ci->i_rsubdirs);\n}"
  },
  {
    "function_name": "ceph_vxattrcb_dir_subdirs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "168-172",
    "snippet": "static size_t ceph_vxattrcb_dir_subdirs(struct ceph_inode_info *ci, char *val,\n\t\t\t\t\tsize_t size)\n{\n\treturn snprintf(val, size, \"%lld\", ci->i_subdirs);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "val",
            "size",
            "\"%lld\"",
            "ci->i_subdirs"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic size_t ceph_vxattrcb_dir_subdirs(struct ceph_inode_info *ci, char *val,\n\t\t\t\t\tsize_t size)\n{\n\treturn snprintf(val, size, \"%lld\", ci->i_subdirs);\n}"
  },
  {
    "function_name": "ceph_vxattrcb_dir_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "162-166",
    "snippet": "static size_t ceph_vxattrcb_dir_files(struct ceph_inode_info *ci, char *val,\n\t\t\t\t      size_t size)\n{\n\treturn snprintf(val, size, \"%lld\", ci->i_files);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "val",
            "size",
            "\"%lld\"",
            "ci->i_files"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic size_t ceph_vxattrcb_dir_files(struct ceph_inode_info *ci, char *val,\n\t\t\t\t      size_t size)\n{\n\treturn snprintf(val, size, \"%lld\", ci->i_files);\n}"
  },
  {
    "function_name": "ceph_vxattrcb_dir_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "156-160",
    "snippet": "static size_t ceph_vxattrcb_dir_entries(struct ceph_inode_info *ci, char *val,\n\t\t\t\t\tsize_t size)\n{\n\treturn snprintf(val, size, \"%lld\", ci->i_files + ci->i_subdirs);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "val",
            "size",
            "\"%lld\"",
            "ci->i_files + ci->i_subdirs"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic size_t ceph_vxattrcb_dir_entries(struct ceph_inode_info *ci, char *val,\n\t\t\t\t\tsize_t size)\n{\n\treturn snprintf(val, size, \"%lld\", ci->i_files + ci->i_subdirs);\n}"
  },
  {
    "function_name": "ceph_vxattrcb_layout_pool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "135-152",
    "snippet": "static size_t ceph_vxattrcb_layout_pool(struct ceph_inode_info *ci,\n\t\t\t\t\tchar *val, size_t size)\n{\n\tint ret;\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(ci->vfs_inode.i_sb);\n\tstruct ceph_osd_client *osdc = &fsc->client->osdc;\n\ts64 pool = ceph_file_layout_pg_pool(ci->i_layout);\n\tconst char *pool_name;\n\n\tdown_read(&osdc->map_sem);\n\tpool_name = ceph_pg_pool_name_by_id(osdc->osdmap, pool);\n\tif (pool_name)\n\t\tret = snprintf(val, size, \"%s\", pool_name);\n\telse\n\t\tret = snprintf(val, size, \"%lld\", (unsigned long long)pool);\n\tup_read(&osdc->map_sem);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&osdc->map_sem"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "val",
            "size",
            "\"%lld\"",
            "(unsigned long long)pool"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "val",
            "size",
            "\"%s\"",
            "pool_name"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_pg_pool_name_by_id",
          "args": [
            "osdc->osdmap",
            "pool"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&osdc->map_sem"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_file_layout_pg_pool",
          "args": [
            "ci->i_layout"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "ci->vfs_inode.i_sb"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic size_t ceph_vxattrcb_layout_pool(struct ceph_inode_info *ci,\n\t\t\t\t\tchar *val, size_t size)\n{\n\tint ret;\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(ci->vfs_inode.i_sb);\n\tstruct ceph_osd_client *osdc = &fsc->client->osdc;\n\ts64 pool = ceph_file_layout_pg_pool(ci->i_layout);\n\tconst char *pool_name;\n\n\tdown_read(&osdc->map_sem);\n\tpool_name = ceph_pg_pool_name_by_id(osdc->osdmap, pool);\n\tif (pool_name)\n\t\tret = snprintf(val, size, \"%s\", pool_name);\n\telse\n\t\tret = snprintf(val, size, \"%lld\", (unsigned long long)pool);\n\tup_read(&osdc->map_sem);\n\treturn ret;\n}"
  },
  {
    "function_name": "ceph_vxattrcb_layout_object_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "128-133",
    "snippet": "static size_t ceph_vxattrcb_layout_object_size(struct ceph_inode_info *ci,\n\t\t\t\t\t       char *val, size_t size)\n{\n\treturn snprintf(val, size, \"%lld\",\n\t       (unsigned long long)ceph_file_layout_object_size(ci->i_layout));\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "val",
            "size",
            "\"%lld\"",
            "(unsigned long long)ceph_file_layout_object_size(ci->i_layout)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_file_layout_object_size",
          "args": [
            "ci->i_layout"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic size_t ceph_vxattrcb_layout_object_size(struct ceph_inode_info *ci,\n\t\t\t\t\t       char *val, size_t size)\n{\n\treturn snprintf(val, size, \"%lld\",\n\t       (unsigned long long)ceph_file_layout_object_size(ci->i_layout));\n}"
  },
  {
    "function_name": "ceph_vxattrcb_layout_stripe_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "121-126",
    "snippet": "static size_t ceph_vxattrcb_layout_stripe_count(struct ceph_inode_info *ci,\n\t\t\t\t\t\tchar *val, size_t size)\n{\n\treturn snprintf(val, size, \"%lld\",\n\t       (unsigned long long)ceph_file_layout_stripe_count(ci->i_layout));\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "val",
            "size",
            "\"%lld\"",
            "(unsigned long long)ceph_file_layout_stripe_count(ci->i_layout)"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_file_layout_stripe_count",
          "args": [
            "ci->i_layout"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic size_t ceph_vxattrcb_layout_stripe_count(struct ceph_inode_info *ci,\n\t\t\t\t\t\tchar *val, size_t size)\n{\n\treturn snprintf(val, size, \"%lld\",\n\t       (unsigned long long)ceph_file_layout_stripe_count(ci->i_layout));\n}"
  },
  {
    "function_name": "ceph_vxattrcb_layout_stripe_unit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "114-119",
    "snippet": "static size_t ceph_vxattrcb_layout_stripe_unit(struct ceph_inode_info *ci,\n\t\t\t\t\t       char *val, size_t size)\n{\n\treturn snprintf(val, size, \"%lld\",\n\t\t\t(unsigned long long)ceph_file_layout_su(ci->i_layout));\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "val",
            "size",
            "\"%lld\"",
            "(unsigned long long)ceph_file_layout_su(ci->i_layout)"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_file_layout_su",
          "args": [
            "ci->i_layout"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic size_t ceph_vxattrcb_layout_stripe_unit(struct ceph_inode_info *ci,\n\t\t\t\t\t       char *val, size_t size)\n{\n\treturn snprintf(val, size, \"%lld\",\n\t\t\t(unsigned long long)ceph_file_layout_su(ci->i_layout));\n}"
  },
  {
    "function_name": "ceph_vxattrcb_layout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "67-112",
    "snippet": "static size_t ceph_vxattrcb_layout(struct ceph_inode_info *ci, char *val,\n\t\t\t\t   size_t size)\n{\n\tint ret;\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(ci->vfs_inode.i_sb);\n\tstruct ceph_osd_client *osdc = &fsc->client->osdc;\n\ts64 pool = ceph_file_layout_pg_pool(ci->i_layout);\n\tconst char *pool_name;\n\tchar buf[128];\n\n\tdout(\"ceph_vxattrcb_layout %p\\n\", &ci->vfs_inode);\n\tdown_read(&osdc->map_sem);\n\tpool_name = ceph_pg_pool_name_by_id(osdc->osdmap, pool);\n\tif (pool_name) {\n\t\tsize_t len = strlen(pool_name);\n\t\tret = snprintf(buf, sizeof(buf),\n\t\t\"stripe_unit=%lld stripe_count=%lld object_size=%lld pool=\",\n\t\t(unsigned long long)ceph_file_layout_su(ci->i_layout),\n\t\t(unsigned long long)ceph_file_layout_stripe_count(ci->i_layout),\n\t        (unsigned long long)ceph_file_layout_object_size(ci->i_layout));\n\t\tif (!size) {\n\t\t\tret += len;\n\t\t} else if (ret + len > size) {\n\t\t\tret = -ERANGE;\n\t\t} else {\n\t\t\tmemcpy(val, buf, ret);\n\t\t\tmemcpy(val + ret, pool_name, len);\n\t\t\tret += len;\n\t\t}\n\t} else {\n\t\tret = snprintf(buf, sizeof(buf),\n\t\t\"stripe_unit=%lld stripe_count=%lld object_size=%lld pool=%lld\",\n\t\t(unsigned long long)ceph_file_layout_su(ci->i_layout),\n\t\t(unsigned long long)ceph_file_layout_stripe_count(ci->i_layout),\n\t        (unsigned long long)ceph_file_layout_object_size(ci->i_layout),\n\t\t(unsigned long long)pool);\n\t\tif (size) {\n\t\t\tif (ret <= size)\n\t\t\t\tmemcpy(val, buf, ret);\n\t\t\telse\n\t\t\t\tret = -ERANGE;\n\t\t}\n\t}\n\tup_read(&osdc->map_sem);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&osdc->map_sem"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "val",
            "buf",
            "ret"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"stripe_unit=%lld stripe_count=%lld object_size=%lld pool=%lld\"",
            "(unsigned long long)ceph_file_layout_su(ci->i_layout)",
            "(unsigned long long)ceph_file_layout_stripe_count(ci->i_layout)",
            "(unsigned long long)ceph_file_layout_object_size(ci->i_layout)",
            "(unsigned long long)pool"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_file_layout_object_size",
          "args": [
            "ci->i_layout"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_file_layout_stripe_count",
          "args": [
            "ci->i_layout"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_file_layout_su",
          "args": [
            "ci->i_layout"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "val + ret",
            "pool_name",
            "len"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "val",
            "buf",
            "ret"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"stripe_unit=%lld stripe_count=%lld object_size=%lld pool=\"",
            "(unsigned long long)ceph_file_layout_su(ci->i_layout)",
            "(unsigned long long)ceph_file_layout_stripe_count(ci->i_layout)",
            "(unsigned long long)ceph_file_layout_object_size(ci->i_layout)"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_file_layout_object_size",
          "args": [
            "ci->i_layout"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_file_layout_stripe_count",
          "args": [
            "ci->i_layout"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_file_layout_su",
          "args": [
            "ci->i_layout"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pool_name"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_pg_pool_name_by_id",
          "args": [
            "osdc->osdmap",
            "pool"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&osdc->map_sem"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"ceph_vxattrcb_layout %p\\n\"",
            "&ci->vfs_inode"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_file_layout_pg_pool",
          "args": [
            "ci->i_layout"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "ci->vfs_inode.i_sb"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic size_t ceph_vxattrcb_layout(struct ceph_inode_info *ci, char *val,\n\t\t\t\t   size_t size)\n{\n\tint ret;\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(ci->vfs_inode.i_sb);\n\tstruct ceph_osd_client *osdc = &fsc->client->osdc;\n\ts64 pool = ceph_file_layout_pg_pool(ci->i_layout);\n\tconst char *pool_name;\n\tchar buf[128];\n\n\tdout(\"ceph_vxattrcb_layout %p\\n\", &ci->vfs_inode);\n\tdown_read(&osdc->map_sem);\n\tpool_name = ceph_pg_pool_name_by_id(osdc->osdmap, pool);\n\tif (pool_name) {\n\t\tsize_t len = strlen(pool_name);\n\t\tret = snprintf(buf, sizeof(buf),\n\t\t\"stripe_unit=%lld stripe_count=%lld object_size=%lld pool=\",\n\t\t(unsigned long long)ceph_file_layout_su(ci->i_layout),\n\t\t(unsigned long long)ceph_file_layout_stripe_count(ci->i_layout),\n\t        (unsigned long long)ceph_file_layout_object_size(ci->i_layout));\n\t\tif (!size) {\n\t\t\tret += len;\n\t\t} else if (ret + len > size) {\n\t\t\tret = -ERANGE;\n\t\t} else {\n\t\t\tmemcpy(val, buf, ret);\n\t\t\tmemcpy(val + ret, pool_name, len);\n\t\t\tret += len;\n\t\t}\n\t} else {\n\t\tret = snprintf(buf, sizeof(buf),\n\t\t\"stripe_unit=%lld stripe_count=%lld object_size=%lld pool=%lld\",\n\t\t(unsigned long long)ceph_file_layout_su(ci->i_layout),\n\t\t(unsigned long long)ceph_file_layout_stripe_count(ci->i_layout),\n\t        (unsigned long long)ceph_file_layout_object_size(ci->i_layout),\n\t\t(unsigned long long)pool);\n\t\tif (size) {\n\t\t\tif (ret <= size)\n\t\t\t\tmemcpy(val, buf, ret);\n\t\t\telse\n\t\t\t\tret = -ERANGE;\n\t\t}\n\t}\n\tup_read(&osdc->map_sem);\n\treturn ret;\n}"
  },
  {
    "function_name": "ceph_vxattrcb_layout_exists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "56-65",
    "snippet": "static bool ceph_vxattrcb_layout_exists(struct ceph_inode_info *ci)\n{\n\tsize_t s;\n\tchar *p = (char *)&ci->i_layout;\n\n\tfor (s = 0; s < sizeof(ci->i_layout); s++, p++)\n\t\tif (*p)\n\t\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic bool ceph_vxattrcb_layout_exists(struct ceph_inode_info *ci)\n{\n\tsize_t s;\n\tchar *p = (char *)&ci->i_layout;\n\n\tfor (s = 0; s < sizeof(ci->i_layout); s++, p++)\n\t\tif (*p)\n\t\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "ceph_is_valid_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
    "lines": "31-39",
    "snippet": "static bool ceph_is_valid_xattr(const char *name)\n{\n\treturn !strncmp(name, XATTR_CEPH_PREFIX, XATTR_CEPH_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\tXATTR_SECURITY_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [
      "#define XATTR_CEPH_PREFIX_LEN (sizeof (XATTR_CEPH_PREFIX) - 1)",
      "#define XATTR_CEPH_PREFIX \"ceph.\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_USER_PREFIX",
            "XATTR_USER_PREFIX_LEN"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_TRUSTED_PREFIX",
            "XATTR_TRUSTED_PREFIX_LEN"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_SYSTEM_PREFIX",
            "XATTR_SYSTEM_PREFIX_LEN"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_SECURITY_PREFIX",
            "XATTR_SECURITY_PREFIX_LEN"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_CEPH_PREFIX",
            "XATTR_CEPH_PREFIX_LEN"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define XATTR_CEPH_PREFIX_LEN (sizeof (XATTR_CEPH_PREFIX) - 1)\n#define XATTR_CEPH_PREFIX \"ceph.\"\n\nstatic bool ceph_is_valid_xattr(const char *name)\n{\n\treturn !strncmp(name, XATTR_CEPH_PREFIX, XATTR_CEPH_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\tXATTR_SECURITY_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) ||\n\t       !strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN);\n}"
  }
]