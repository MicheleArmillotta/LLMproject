[
  {
    "function_name": "pnfs_layout_mark_request_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
    "lines": "842-869",
    "snippet": "void\npnfs_layout_mark_request_commit(struct nfs_page *req,\n\t\t\t\tstruct pnfs_layout_segment *lseg,\n\t\t\t\tstruct nfs_commit_info *cinfo,\n\t\t\t\tu32 ds_commit_idx)\n{\n\tstruct list_head *list;\n\tstruct pnfs_commit_bucket *buckets;\n\n\tspin_lock(cinfo->lock);\n\tbuckets = cinfo->ds->buckets;\n\tlist = &buckets[ds_commit_idx].written;\n\tif (list_empty(list)) {\n\t\t/* Non-empty buckets hold a reference on the lseg.  That ref\n\t\t * is normally transferred to the COMMIT call and released\n\t\t * there.  It could also be released if the last req is pulled\n\t\t * off due to a rewrite, in which case it will be done in\n\t\t * pnfs_common_clear_request_commit\n\t\t */\n\t\tWARN_ON_ONCE(buckets[ds_commit_idx].wlseg != NULL);\n\t\tbuckets[ds_commit_idx].wlseg = pnfs_get_lseg(lseg);\n\t}\n\tset_bit(PG_COMMIT_TO_DS, &req->wb_flags);\n\tcinfo->ds->nwritten++;\n\tspin_unlock(cinfo->lock);\n\n\tnfs_request_add_commit_list(req, list, cinfo);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_request_add_commit_list",
          "args": [
            "req",
            "list",
            "cinfo"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_request_add_commit_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "783-794",
          "snippet": "void\nnfs_request_add_commit_list(struct nfs_page *req, struct list_head *dst,\n\t\t\t    struct nfs_commit_info *cinfo)\n{\n\tset_bit(PG_CLEAN, &(req)->wb_flags);\n\tspin_lock(cinfo->lock);\n\tnfs_list_add_request(req, dst);\n\tcinfo->mds->ncommit++;\n\tspin_unlock(cinfo->lock);\n\tif (!cinfo->dreq)\n\t\tnfs_mark_page_unstable(req->wb_page);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nvoid\nnfs_request_add_commit_list(struct nfs_page *req, struct list_head *dst,\n\t\t\t    struct nfs_commit_info *cinfo)\n{\n\tset_bit(PG_CLEAN, &(req)->wb_flags);\n\tspin_lock(cinfo->lock);\n\tnfs_list_add_request(req, dst);\n\tcinfo->mds->ncommit++;\n\tspin_unlock(cinfo->lock);\n\tif (!cinfo->dreq)\n\t\tnfs_mark_page_unstable(req->wb_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "cinfo->lock"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "PG_COMMIT_TO_DS",
            "&req->wb_flags"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_get_lseg",
          "args": [
            "lseg"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_get_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "539-543",
          "snippet": "static inline struct pnfs_layout_segment *\npnfs_get_lseg(struct pnfs_layout_segment *lseg)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline struct pnfs_layout_segment *\npnfs_get_lseg(struct pnfs_layout_segment *lseg)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "buckets[ds_commit_idx].wlseg != NULL"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "list"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "cinfo->lock"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_layout_mark_request_commit(struct nfs_page *req,\n\t\t\t\tstruct pnfs_layout_segment *lseg,\n\t\t\t\tstruct nfs_commit_info *cinfo,\n\t\t\t\tu32 ds_commit_idx)\n{\n\tstruct list_head *list;\n\tstruct pnfs_commit_bucket *buckets;\n\n\tspin_lock(cinfo->lock);\n\tbuckets = cinfo->ds->buckets;\n\tlist = &buckets[ds_commit_idx].written;\n\tif (list_empty(list)) {\n\t\t/* Non-empty buckets hold a reference on the lseg.  That ref\n\t\t * is normally transferred to the COMMIT call and released\n\t\t * there.  It could also be released if the last req is pulled\n\t\t * off due to a rewrite, in which case it will be done in\n\t\t * pnfs_common_clear_request_commit\n\t\t */\n\t\tWARN_ON_ONCE(buckets[ds_commit_idx].wlseg != NULL);\n\t\tbuckets[ds_commit_idx].wlseg = pnfs_get_lseg(lseg);\n\t}\n\tset_bit(PG_COMMIT_TO_DS, &req->wb_flags);\n\tcinfo->ds->nwritten++;\n\tspin_unlock(cinfo->lock);\n\n\tnfs_request_add_commit_list(req, list, cinfo);\n}"
  },
  {
    "function_name": "nfs4_decode_mp_ds_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
    "lines": "697-839",
    "snippet": "struct nfs4_pnfs_ds_addr *\nnfs4_decode_mp_ds_addr(struct net *net, struct xdr_stream *xdr, gfp_t gfp_flags)\n{\n\tstruct nfs4_pnfs_ds_addr *da = NULL;\n\tchar *buf, *portstr;\n\t__be16 port;\n\tint nlen, rlen;\n\tint tmp[2];\n\t__be32 *p;\n\tchar *netid, *match_netid;\n\tsize_t len, match_netid_len;\n\tchar *startsep = \"\";\n\tchar *endsep = \"\";\n\n\n\t/* r_netid */\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_err;\n\tnlen = be32_to_cpup(p++);\n\n\tp = xdr_inline_decode(xdr, nlen);\n\tif (unlikely(!p))\n\t\tgoto out_err;\n\n\tnetid = kmalloc(nlen+1, gfp_flags);\n\tif (unlikely(!netid))\n\t\tgoto out_err;\n\n\tnetid[nlen] = '\\0';\n\tmemcpy(netid, p, nlen);\n\n\t/* r_addr: ip/ip6addr with port in dec octets - see RFC 5665 */\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_free_netid;\n\trlen = be32_to_cpup(p);\n\n\tp = xdr_inline_decode(xdr, rlen);\n\tif (unlikely(!p))\n\t\tgoto out_free_netid;\n\n\t/* port is \".ABC.DEF\", 8 chars max */\n\tif (rlen > INET6_ADDRSTRLEN + IPV6_SCOPE_ID_LEN + 8) {\n\t\tdprintk(\"%s: Invalid address, length %d\\n\", __func__,\n\t\t\trlen);\n\t\tgoto out_free_netid;\n\t}\n\tbuf = kmalloc(rlen + 1, gfp_flags);\n\tif (!buf) {\n\t\tdprintk(\"%s: Not enough memory\\n\", __func__);\n\t\tgoto out_free_netid;\n\t}\n\tbuf[rlen] = '\\0';\n\tmemcpy(buf, p, rlen);\n\n\t/* replace port '.' with '-' */\n\tportstr = strrchr(buf, '.');\n\tif (!portstr) {\n\t\tdprintk(\"%s: Failed finding expected dot in port\\n\",\n\t\t\t__func__);\n\t\tgoto out_free_buf;\n\t}\n\t*portstr = '-';\n\n\t/* find '.' between address and port */\n\tportstr = strrchr(buf, '.');\n\tif (!portstr) {\n\t\tdprintk(\"%s: Failed finding expected dot between address and \"\n\t\t\t\"port\\n\", __func__);\n\t\tgoto out_free_buf;\n\t}\n\t*portstr = '\\0';\n\n\tda = kzalloc(sizeof(*da), gfp_flags);\n\tif (unlikely(!da))\n\t\tgoto out_free_buf;\n\n\tINIT_LIST_HEAD(&da->da_node);\n\n\tif (!rpc_pton(net, buf, portstr-buf, (struct sockaddr *)&da->da_addr,\n\t\t      sizeof(da->da_addr))) {\n\t\tdprintk(\"%s: error parsing address %s\\n\", __func__, buf);\n\t\tgoto out_free_da;\n\t}\n\n\tportstr++;\n\tsscanf(portstr, \"%d-%d\", &tmp[0], &tmp[1]);\n\tport = htons((tmp[0] << 8) | (tmp[1]));\n\n\tswitch (da->da_addr.ss_family) {\n\tcase AF_INET:\n\t\t((struct sockaddr_in *)&da->da_addr)->sin_port = port;\n\t\tda->da_addrlen = sizeof(struct sockaddr_in);\n\t\tmatch_netid = \"tcp\";\n\t\tmatch_netid_len = 3;\n\t\tbreak;\n\n\tcase AF_INET6:\n\t\t((struct sockaddr_in6 *)&da->da_addr)->sin6_port = port;\n\t\tda->da_addrlen = sizeof(struct sockaddr_in6);\n\t\tmatch_netid = \"tcp6\";\n\t\tmatch_netid_len = 4;\n\t\tstartsep = \"[\";\n\t\tendsep = \"]\";\n\t\tbreak;\n\n\tdefault:\n\t\tdprintk(\"%s: unsupported address family: %u\\n\",\n\t\t\t__func__, da->da_addr.ss_family);\n\t\tgoto out_free_da;\n\t}\n\n\tif (nlen != match_netid_len || strncmp(netid, match_netid, nlen)) {\n\t\tdprintk(\"%s: ERROR: r_netid \\\"%s\\\" != \\\"%s\\\"\\n\",\n\t\t\t__func__, netid, match_netid);\n\t\tgoto out_free_da;\n\t}\n\n\t/* save human readable address */\n\tlen = strlen(startsep) + strlen(buf) + strlen(endsep) + 7;\n\tda->da_remotestr = kzalloc(len, gfp_flags);\n\n\t/* NULL is ok, only used for dprintk */\n\tif (da->da_remotestr)\n\t\tsnprintf(da->da_remotestr, len, \"%s%s%s:%u\", startsep,\n\t\t\t buf, endsep, ntohs(port));\n\n\tdprintk(\"%s: Parsed DS addr %s\\n\", __func__, da->da_remotestr);\n\tkfree(buf);\n\tkfree(netid);\n\treturn da;\n\nout_free_da:\n\tkfree(da);\nout_free_buf:\n\tdprintk(\"%s: Error parsing DS addr: %s\\n\", __func__, buf);\n\tkfree(buf);\nout_free_netid:\n\tkfree(netid);\nout_err:\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "netid"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Error parsing DS addr: %s\\n\"",
            "__func__",
            "buf"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "da"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "netid"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Parsed DS addr %s\\n\"",
            "__func__",
            "da->da_remotestr"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "da->da_remotestr",
            "len",
            "\"%s%s%s:%u\"",
            "startsep",
            "buf",
            "endsep",
            "ntohs(port)"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "port"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "len",
            "gfp_flags"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "endsep"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: ERROR: r_netid \\\"%s\\\" != \\\"%s\\\"\\n\"",
            "__func__",
            "netid",
            "match_netid"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "netid",
            "match_netid",
            "nlen"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: unsupported address family: %u\\n\"",
            "__func__",
            "da->da_addr.ss_family"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "(tmp[0] << 8) | (tmp[1])"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "portstr",
            "\"%d-%d\"",
            "&tmp[0]",
            "&tmp[1]"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: error parsing address %s\\n\"",
            "__func__",
            "buf"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_pton",
          "args": [
            "net",
            "buf",
            "portstr-buf",
            "(struct sockaddr *)&da->da_addr",
            "sizeof(da->da_addr)"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&da->da_node"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!da"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*da)",
            "gfp_flags"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Failed finding expected dot between address and \"\n\t\t\t\"port\\n\"",
            "__func__"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "buf",
            "'.'"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Failed finding expected dot in port\\n\"",
            "__func__"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "buf",
            "'.'"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "p",
            "rlen"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Not enough memory\\n\"",
            "__func__"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "rlen + 1",
            "gfp_flags"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Invalid address, length %d\\n\"",
            "__func__",
            "rlen"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "rlen"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "4"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "netid",
            "p",
            "nlen"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!netid"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "nlen"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "4"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstruct nfs4_pnfs_ds_addr *\nnfs4_decode_mp_ds_addr(struct net *net, struct xdr_stream *xdr, gfp_t gfp_flags)\n{\n\tstruct nfs4_pnfs_ds_addr *da = NULL;\n\tchar *buf, *portstr;\n\t__be16 port;\n\tint nlen, rlen;\n\tint tmp[2];\n\t__be32 *p;\n\tchar *netid, *match_netid;\n\tsize_t len, match_netid_len;\n\tchar *startsep = \"\";\n\tchar *endsep = \"\";\n\n\n\t/* r_netid */\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_err;\n\tnlen = be32_to_cpup(p++);\n\n\tp = xdr_inline_decode(xdr, nlen);\n\tif (unlikely(!p))\n\t\tgoto out_err;\n\n\tnetid = kmalloc(nlen+1, gfp_flags);\n\tif (unlikely(!netid))\n\t\tgoto out_err;\n\n\tnetid[nlen] = '\\0';\n\tmemcpy(netid, p, nlen);\n\n\t/* r_addr: ip/ip6addr with port in dec octets - see RFC 5665 */\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_free_netid;\n\trlen = be32_to_cpup(p);\n\n\tp = xdr_inline_decode(xdr, rlen);\n\tif (unlikely(!p))\n\t\tgoto out_free_netid;\n\n\t/* port is \".ABC.DEF\", 8 chars max */\n\tif (rlen > INET6_ADDRSTRLEN + IPV6_SCOPE_ID_LEN + 8) {\n\t\tdprintk(\"%s: Invalid address, length %d\\n\", __func__,\n\t\t\trlen);\n\t\tgoto out_free_netid;\n\t}\n\tbuf = kmalloc(rlen + 1, gfp_flags);\n\tif (!buf) {\n\t\tdprintk(\"%s: Not enough memory\\n\", __func__);\n\t\tgoto out_free_netid;\n\t}\n\tbuf[rlen] = '\\0';\n\tmemcpy(buf, p, rlen);\n\n\t/* replace port '.' with '-' */\n\tportstr = strrchr(buf, '.');\n\tif (!portstr) {\n\t\tdprintk(\"%s: Failed finding expected dot in port\\n\",\n\t\t\t__func__);\n\t\tgoto out_free_buf;\n\t}\n\t*portstr = '-';\n\n\t/* find '.' between address and port */\n\tportstr = strrchr(buf, '.');\n\tif (!portstr) {\n\t\tdprintk(\"%s: Failed finding expected dot between address and \"\n\t\t\t\"port\\n\", __func__);\n\t\tgoto out_free_buf;\n\t}\n\t*portstr = '\\0';\n\n\tda = kzalloc(sizeof(*da), gfp_flags);\n\tif (unlikely(!da))\n\t\tgoto out_free_buf;\n\n\tINIT_LIST_HEAD(&da->da_node);\n\n\tif (!rpc_pton(net, buf, portstr-buf, (struct sockaddr *)&da->da_addr,\n\t\t      sizeof(da->da_addr))) {\n\t\tdprintk(\"%s: error parsing address %s\\n\", __func__, buf);\n\t\tgoto out_free_da;\n\t}\n\n\tportstr++;\n\tsscanf(portstr, \"%d-%d\", &tmp[0], &tmp[1]);\n\tport = htons((tmp[0] << 8) | (tmp[1]));\n\n\tswitch (da->da_addr.ss_family) {\n\tcase AF_INET:\n\t\t((struct sockaddr_in *)&da->da_addr)->sin_port = port;\n\t\tda->da_addrlen = sizeof(struct sockaddr_in);\n\t\tmatch_netid = \"tcp\";\n\t\tmatch_netid_len = 3;\n\t\tbreak;\n\n\tcase AF_INET6:\n\t\t((struct sockaddr_in6 *)&da->da_addr)->sin6_port = port;\n\t\tda->da_addrlen = sizeof(struct sockaddr_in6);\n\t\tmatch_netid = \"tcp6\";\n\t\tmatch_netid_len = 4;\n\t\tstartsep = \"[\";\n\t\tendsep = \"]\";\n\t\tbreak;\n\n\tdefault:\n\t\tdprintk(\"%s: unsupported address family: %u\\n\",\n\t\t\t__func__, da->da_addr.ss_family);\n\t\tgoto out_free_da;\n\t}\n\n\tif (nlen != match_netid_len || strncmp(netid, match_netid, nlen)) {\n\t\tdprintk(\"%s: ERROR: r_netid \\\"%s\\\" != \\\"%s\\\"\\n\",\n\t\t\t__func__, netid, match_netid);\n\t\tgoto out_free_da;\n\t}\n\n\t/* save human readable address */\n\tlen = strlen(startsep) + strlen(buf) + strlen(endsep) + 7;\n\tda->da_remotestr = kzalloc(len, gfp_flags);\n\n\t/* NULL is ok, only used for dprintk */\n\tif (da->da_remotestr)\n\t\tsnprintf(da->da_remotestr, len, \"%s%s%s:%u\", startsep,\n\t\t\t buf, endsep, ntohs(port));\n\n\tdprintk(\"%s: Parsed DS addr %s\\n\", __func__, da->da_remotestr);\n\tkfree(buf);\n\tkfree(netid);\n\treturn da;\n\nout_free_da:\n\tkfree(da);\nout_free_buf:\n\tdprintk(\"%s: Error parsing DS addr: %s\\n\", __func__, buf);\n\tkfree(buf);\nout_free_netid:\n\tkfree(netid);\nout_err:\n\treturn NULL;\n}"
  },
  {
    "function_name": "nfs4_pnfs_ds_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
    "lines": "664-691",
    "snippet": "void nfs4_pnfs_ds_connect(struct nfs_server *mds_srv, struct nfs4_pnfs_ds *ds,\n\t\t\t  struct nfs4_deviceid_node *devid, unsigned int timeo,\n\t\t\t  unsigned int retrans, u32 version,\n\t\t\t  u32 minor_version, rpc_authflavor_t au_flavor)\n{\n\tif (test_and_set_bit(NFS4DS_CONNECTING, &ds->ds_state) == 0) {\n\t\tint err = 0;\n\n\t\tif (version == 3) {\n\t\t\terr = _nfs4_pnfs_v3_ds_connect(mds_srv, ds, timeo,\n\t\t\t\t\t\t       retrans, au_flavor);\n\t\t} else if (version == 4) {\n\t\t\terr = _nfs4_pnfs_v4_ds_connect(mds_srv, ds, timeo,\n\t\t\t\t\t\t       retrans, minor_version,\n\t\t\t\t\t\t       au_flavor);\n\t\t} else {\n\t\t\tdprintk(\"%s: unsupported DS version %d\\n\", __func__,\n\t\t\t\tversion);\n\t\t\terr = -EPROTONOSUPPORT;\n\t\t}\n\n\t\tif (err)\n\t\t\tnfs4_mark_deviceid_unavailable(devid);\n\t\tnfs4_clear_ds_conn_bit(ds);\n\t} else {\n\t\tnfs4_wait_ds_connect(ds);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct nfs_client *(*get_v3_ds_connect)(\n\t\t\tstruct nfs_client *mds_clp,\n\t\t\tconst struct sockaddr *ds_addr,\n\t\t\tint ds_addrlen,\n\t\t\tint ds_proto,\n\t\t\tunsigned int ds_timeo,\n\t\t\tunsigned int ds_retrans,\n\t\t\trpc_authflavor_t au_flavor);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_wait_ds_connect",
          "args": [
            "ds"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_wait_ds_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "530-535",
          "snippet": "static void nfs4_wait_ds_connect(struct nfs4_pnfs_ds *ds)\n{\n\tmight_sleep();\n\twait_on_bit(&ds->ds_state, NFS4DS_CONNECTING,\n\t\t\tTASK_KILLABLE);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void nfs4_wait_ds_connect(struct nfs4_pnfs_ds *ds)\n{\n\tmight_sleep();\n\twait_on_bit(&ds->ds_state, NFS4DS_CONNECTING,\n\t\t\tTASK_KILLABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_clear_ds_conn_bit",
          "args": [
            "ds"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_clear_ds_conn_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "537-543",
          "snippet": "static void nfs4_clear_ds_conn_bit(struct nfs4_pnfs_ds *ds)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(NFS4DS_CONNECTING, &ds->ds_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&ds->ds_state, NFS4DS_CONNECTING);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void nfs4_clear_ds_conn_bit(struct nfs4_pnfs_ds *ds)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(NFS4DS_CONNECTING, &ds->ds_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&ds->ds_state, NFS4DS_CONNECTING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_mark_deviceid_unavailable",
          "args": [
            "devid"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_mark_deviceid_unavailable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "281-286",
          "snippet": "void\nnfs4_mark_deviceid_unavailable(struct nfs4_deviceid_node *node)\n{\n\tnode->timestamp_unavailable = jiffies;\n\tset_bit(NFS_DEVICEID_UNAVAILABLE, &node->flags);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nvoid\nnfs4_mark_deviceid_unavailable(struct nfs4_deviceid_node *node)\n{\n\tnode->timestamp_unavailable = jiffies;\n\tset_bit(NFS_DEVICEID_UNAVAILABLE, &node->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: unsupported DS version %d\\n\"",
            "__func__",
            "version"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_nfs4_pnfs_v4_ds_connect",
          "args": [
            "mds_srv",
            "ds",
            "timeo",
            "retrans",
            "minor_version",
            "au_flavor"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "_nfs4_pnfs_v4_ds_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "613-657",
          "snippet": "static int _nfs4_pnfs_v4_ds_connect(struct nfs_server *mds_srv,\n\t\t\t\t struct nfs4_pnfs_ds *ds,\n\t\t\t\t unsigned int timeo,\n\t\t\t\t unsigned int retrans,\n\t\t\t\t u32 minor_version,\n\t\t\t\t rpc_authflavor_t au_flavor)\n{\n\tstruct nfs_client *clp = ERR_PTR(-EIO);\n\tstruct nfs4_pnfs_ds_addr *da;\n\tint status = 0;\n\n\tdprintk(\"--> %s DS %s au_flavor %d\\n\", __func__, ds->ds_remotestr,\n\t\tau_flavor);\n\n\tlist_for_each_entry(da, &ds->ds_addrs, da_node) {\n\t\tdprintk(\"%s: DS %s: trying address %s\\n\",\n\t\t\t__func__, ds->ds_remotestr, da->da_remotestr);\n\n\t\tclp = nfs4_set_ds_client(mds_srv->nfs_client,\n\t\t\t\t\t(struct sockaddr *)&da->da_addr,\n\t\t\t\t\tda->da_addrlen, IPPROTO_TCP,\n\t\t\t\t\ttimeo, retrans, minor_version,\n\t\t\t\t\tau_flavor);\n\t\tif (!IS_ERR(clp))\n\t\t\tbreak;\n\t}\n\n\tif (IS_ERR(clp)) {\n\t\tstatus = PTR_ERR(clp);\n\t\tgoto out;\n\t}\n\n\tstatus = nfs4_init_ds_session(clp, mds_srv->nfs_client->cl_lease_time);\n\tif (status)\n\t\tgoto out_put;\n\n\tsmp_wmb();\n\tds->ds_clp = clp;\n\tdprintk(\"%s [new] addr: %s\\n\", __func__, ds->ds_remotestr);\nout:\n\treturn status;\nout_put:\n\tnfs_put_client(clp);\n\tgoto out;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfs_client *(*get_v3_ds_connect)(\n\t\t\tstruct nfs_client *mds_clp,\n\t\t\tconst struct sockaddr *ds_addr,\n\t\t\tint ds_addrlen,\n\t\t\tint ds_proto,\n\t\t\tunsigned int ds_timeo,\n\t\t\tunsigned int ds_retrans,\n\t\t\trpc_authflavor_t au_flavor);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct nfs_client *(*get_v3_ds_connect)(\n\t\t\tstruct nfs_client *mds_clp,\n\t\t\tconst struct sockaddr *ds_addr,\n\t\t\tint ds_addrlen,\n\t\t\tint ds_proto,\n\t\t\tunsigned int ds_timeo,\n\t\t\tunsigned int ds_retrans,\n\t\t\trpc_authflavor_t au_flavor);\n\nstatic int _nfs4_pnfs_v4_ds_connect(struct nfs_server *mds_srv,\n\t\t\t\t struct nfs4_pnfs_ds *ds,\n\t\t\t\t unsigned int timeo,\n\t\t\t\t unsigned int retrans,\n\t\t\t\t u32 minor_version,\n\t\t\t\t rpc_authflavor_t au_flavor)\n{\n\tstruct nfs_client *clp = ERR_PTR(-EIO);\n\tstruct nfs4_pnfs_ds_addr *da;\n\tint status = 0;\n\n\tdprintk(\"--> %s DS %s au_flavor %d\\n\", __func__, ds->ds_remotestr,\n\t\tau_flavor);\n\n\tlist_for_each_entry(da, &ds->ds_addrs, da_node) {\n\t\tdprintk(\"%s: DS %s: trying address %s\\n\",\n\t\t\t__func__, ds->ds_remotestr, da->da_remotestr);\n\n\t\tclp = nfs4_set_ds_client(mds_srv->nfs_client,\n\t\t\t\t\t(struct sockaddr *)&da->da_addr,\n\t\t\t\t\tda->da_addrlen, IPPROTO_TCP,\n\t\t\t\t\ttimeo, retrans, minor_version,\n\t\t\t\t\tau_flavor);\n\t\tif (!IS_ERR(clp))\n\t\t\tbreak;\n\t}\n\n\tif (IS_ERR(clp)) {\n\t\tstatus = PTR_ERR(clp);\n\t\tgoto out;\n\t}\n\n\tstatus = nfs4_init_ds_session(clp, mds_srv->nfs_client->cl_lease_time);\n\tif (status)\n\t\tgoto out_put;\n\n\tsmp_wmb();\n\tds->ds_clp = clp;\n\tdprintk(\"%s [new] addr: %s\\n\", __func__, ds->ds_remotestr);\nout:\n\treturn status;\nout_put:\n\tnfs_put_client(clp);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_nfs4_pnfs_v3_ds_connect",
          "args": [
            "mds_srv",
            "ds",
            "timeo",
            "retrans",
            "au_flavor"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "_nfs4_pnfs_v3_ds_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "573-611",
          "snippet": "static int _nfs4_pnfs_v3_ds_connect(struct nfs_server *mds_srv,\n\t\t\t\t struct nfs4_pnfs_ds *ds,\n\t\t\t\t unsigned int timeo,\n\t\t\t\t unsigned int retrans,\n\t\t\t\t rpc_authflavor_t au_flavor)\n{\n\tstruct nfs_client *clp = ERR_PTR(-EIO);\n\tstruct nfs4_pnfs_ds_addr *da;\n\tint status = 0;\n\n\tdprintk(\"--> %s DS %s au_flavor %d\\n\", __func__,\n\t\tds->ds_remotestr, au_flavor);\n\n\tif (!load_v3_ds_connect())\n\t\tgoto out;\n\n\tlist_for_each_entry(da, &ds->ds_addrs, da_node) {\n\t\tdprintk(\"%s: DS %s: trying address %s\\n\",\n\t\t\t__func__, ds->ds_remotestr, da->da_remotestr);\n\n\t\tclp = get_v3_ds_connect(mds_srv->nfs_client,\n\t\t\t\t\t(struct sockaddr *)&da->da_addr,\n\t\t\t\t\tda->da_addrlen, IPPROTO_TCP,\n\t\t\t\t\ttimeo, retrans, au_flavor);\n\t\tif (!IS_ERR(clp))\n\t\t\tbreak;\n\t}\n\n\tif (IS_ERR(clp)) {\n\t\tstatus = PTR_ERR(clp);\n\t\tgoto out;\n\t}\n\n\tsmp_wmb();\n\tds->ds_clp = clp;\n\tdprintk(\"%s [new] addr: %s\\n\", __func__, ds->ds_remotestr);\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfs_client *(*get_v3_ds_connect)(\n\t\t\tstruct nfs_client *mds_clp,\n\t\t\tconst struct sockaddr *ds_addr,\n\t\t\tint ds_addrlen,\n\t\t\tint ds_proto,\n\t\t\tunsigned int ds_timeo,\n\t\t\tunsigned int ds_retrans,\n\t\t\trpc_authflavor_t au_flavor);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct nfs_client *(*get_v3_ds_connect)(\n\t\t\tstruct nfs_client *mds_clp,\n\t\t\tconst struct sockaddr *ds_addr,\n\t\t\tint ds_addrlen,\n\t\t\tint ds_proto,\n\t\t\tunsigned int ds_timeo,\n\t\t\tunsigned int ds_retrans,\n\t\t\trpc_authflavor_t au_flavor);\n\nstatic int _nfs4_pnfs_v3_ds_connect(struct nfs_server *mds_srv,\n\t\t\t\t struct nfs4_pnfs_ds *ds,\n\t\t\t\t unsigned int timeo,\n\t\t\t\t unsigned int retrans,\n\t\t\t\t rpc_authflavor_t au_flavor)\n{\n\tstruct nfs_client *clp = ERR_PTR(-EIO);\n\tstruct nfs4_pnfs_ds_addr *da;\n\tint status = 0;\n\n\tdprintk(\"--> %s DS %s au_flavor %d\\n\", __func__,\n\t\tds->ds_remotestr, au_flavor);\n\n\tif (!load_v3_ds_connect())\n\t\tgoto out;\n\n\tlist_for_each_entry(da, &ds->ds_addrs, da_node) {\n\t\tdprintk(\"%s: DS %s: trying address %s\\n\",\n\t\t\t__func__, ds->ds_remotestr, da->da_remotestr);\n\n\t\tclp = get_v3_ds_connect(mds_srv->nfs_client,\n\t\t\t\t\t(struct sockaddr *)&da->da_addr,\n\t\t\t\t\tda->da_addrlen, IPPROTO_TCP,\n\t\t\t\t\ttimeo, retrans, au_flavor);\n\t\tif (!IS_ERR(clp))\n\t\t\tbreak;\n\t}\n\n\tif (IS_ERR(clp)) {\n\t\tstatus = PTR_ERR(clp);\n\t\tgoto out;\n\t}\n\n\tsmp_wmb();\n\tds->ds_clp = clp;\n\tdprintk(\"%s [new] addr: %s\\n\", __func__, ds->ds_remotestr);\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "NFS4DS_CONNECTING",
            "&ds->ds_state"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct nfs_client *(*get_v3_ds_connect)(\n\t\t\tstruct nfs_client *mds_clp,\n\t\t\tconst struct sockaddr *ds_addr,\n\t\t\tint ds_addrlen,\n\t\t\tint ds_proto,\n\t\t\tunsigned int ds_timeo,\n\t\t\tunsigned int ds_retrans,\n\t\t\trpc_authflavor_t au_flavor);\n\nvoid nfs4_pnfs_ds_connect(struct nfs_server *mds_srv, struct nfs4_pnfs_ds *ds,\n\t\t\t  struct nfs4_deviceid_node *devid, unsigned int timeo,\n\t\t\t  unsigned int retrans, u32 version,\n\t\t\t  u32 minor_version, rpc_authflavor_t au_flavor)\n{\n\tif (test_and_set_bit(NFS4DS_CONNECTING, &ds->ds_state) == 0) {\n\t\tint err = 0;\n\n\t\tif (version == 3) {\n\t\t\terr = _nfs4_pnfs_v3_ds_connect(mds_srv, ds, timeo,\n\t\t\t\t\t\t       retrans, au_flavor);\n\t\t} else if (version == 4) {\n\t\t\terr = _nfs4_pnfs_v4_ds_connect(mds_srv, ds, timeo,\n\t\t\t\t\t\t       retrans, minor_version,\n\t\t\t\t\t\t       au_flavor);\n\t\t} else {\n\t\t\tdprintk(\"%s: unsupported DS version %d\\n\", __func__,\n\t\t\t\tversion);\n\t\t\terr = -EPROTONOSUPPORT;\n\t\t}\n\n\t\tif (err)\n\t\t\tnfs4_mark_deviceid_unavailable(devid);\n\t\tnfs4_clear_ds_conn_bit(ds);\n\t} else {\n\t\tnfs4_wait_ds_connect(ds);\n\t}\n}"
  },
  {
    "function_name": "_nfs4_pnfs_v4_ds_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
    "lines": "613-657",
    "snippet": "static int _nfs4_pnfs_v4_ds_connect(struct nfs_server *mds_srv,\n\t\t\t\t struct nfs4_pnfs_ds *ds,\n\t\t\t\t unsigned int timeo,\n\t\t\t\t unsigned int retrans,\n\t\t\t\t u32 minor_version,\n\t\t\t\t rpc_authflavor_t au_flavor)\n{\n\tstruct nfs_client *clp = ERR_PTR(-EIO);\n\tstruct nfs4_pnfs_ds_addr *da;\n\tint status = 0;\n\n\tdprintk(\"--> %s DS %s au_flavor %d\\n\", __func__, ds->ds_remotestr,\n\t\tau_flavor);\n\n\tlist_for_each_entry(da, &ds->ds_addrs, da_node) {\n\t\tdprintk(\"%s: DS %s: trying address %s\\n\",\n\t\t\t__func__, ds->ds_remotestr, da->da_remotestr);\n\n\t\tclp = nfs4_set_ds_client(mds_srv->nfs_client,\n\t\t\t\t\t(struct sockaddr *)&da->da_addr,\n\t\t\t\t\tda->da_addrlen, IPPROTO_TCP,\n\t\t\t\t\ttimeo, retrans, minor_version,\n\t\t\t\t\tau_flavor);\n\t\tif (!IS_ERR(clp))\n\t\t\tbreak;\n\t}\n\n\tif (IS_ERR(clp)) {\n\t\tstatus = PTR_ERR(clp);\n\t\tgoto out;\n\t}\n\n\tstatus = nfs4_init_ds_session(clp, mds_srv->nfs_client->cl_lease_time);\n\tif (status)\n\t\tgoto out_put;\n\n\tsmp_wmb();\n\tds->ds_clp = clp;\n\tdprintk(\"%s [new] addr: %s\\n\", __func__, ds->ds_remotestr);\nout:\n\treturn status;\nout_put:\n\tnfs_put_client(clp);\n\tgoto out;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct nfs_client *(*get_v3_ds_connect)(\n\t\t\tstruct nfs_client *mds_clp,\n\t\t\tconst struct sockaddr *ds_addr,\n\t\t\tint ds_addrlen,\n\t\t\tint ds_proto,\n\t\t\tunsigned int ds_timeo,\n\t\t\tunsigned int ds_retrans,\n\t\t\trpc_authflavor_t au_flavor);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_put_client",
          "args": [
            "clp"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_put_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/client.c",
          "lines": "267-286",
          "snippet": "void nfs_put_client(struct nfs_client *clp)\n{\n\tstruct nfs_net *nn;\n\n\tif (!clp)\n\t\treturn;\n\n\tdprintk(\"--> nfs_put_client({%d})\\n\", atomic_read(&clp->cl_count));\n\tnn = net_generic(clp->cl_net, nfs_net_id);\n\n\tif (atomic_dec_and_lock(&clp->cl_count, &nn->nfs_client_lock)) {\n\t\tlist_del(&clp->cl_share_link);\n\t\tnfs_cb_idr_remove_locked(clp);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\tWARN_ON_ONCE(!list_empty(&clp->cl_superblocks));\n\n\t\tclp->rpc_ops->free_client(clp);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <net/ipv6.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/xprtrdma.h>",
            "#include <linux/sunrpc/xprtsock.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/nfs_xdr.h>\n#include <net/ipv6.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/nfs_idmap.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/xprtrdma.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid nfs_put_client(struct nfs_client *clp)\n{\n\tstruct nfs_net *nn;\n\n\tif (!clp)\n\t\treturn;\n\n\tdprintk(\"--> nfs_put_client({%d})\\n\", atomic_read(&clp->cl_count));\n\tnn = net_generic(clp->cl_net, nfs_net_id);\n\n\tif (atomic_dec_and_lock(&clp->cl_count, &nn->nfs_client_lock)) {\n\t\tlist_del(&clp->cl_share_link);\n\t\tnfs_cb_idr_remove_locked(clp);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\tWARN_ON_ONCE(!list_empty(&clp->cl_superblocks));\n\n\t\tclp->rpc_ops->free_client(clp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s [new] addr: %s\\n\"",
            "__func__",
            "ds->ds_remotestr"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_init_ds_session",
          "args": [
            "clp",
            "mds_srv->nfs_client->cl_lease_time"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_init_ds_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4session.c",
          "lines": "539-562",
          "snippet": "int nfs4_init_ds_session(struct nfs_client *clp, unsigned long lease_time)\n{\n\tstruct nfs4_session *session = clp->cl_session;\n\tint ret;\n\n\tspin_lock(&clp->cl_lock);\n\tif (test_and_clear_bit(NFS4_SESSION_INITING, &session->session_state)) {\n\t\t/*\n\t\t * Do not set NFS_CS_CHECK_LEASE_TIME instead set the\n\t\t * DS lease to be equal to the MDS lease.\n\t\t */\n\t\tclp->cl_lease_time = lease_time;\n\t\tclp->cl_last_renewal = jiffies;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\tret = nfs41_check_session_ready(clp);\n\tif (ret)\n\t\treturn ret;\n\t/* Test for the DS role */\n\tif (!is_ds_client(clp))\n\t\treturn -ENODEV;\n\treturn 0;\n}",
          "includes": [
            "#include \"callback.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"callback.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nint nfs4_init_ds_session(struct nfs_client *clp, unsigned long lease_time)\n{\n\tstruct nfs4_session *session = clp->cl_session;\n\tint ret;\n\n\tspin_lock(&clp->cl_lock);\n\tif (test_and_clear_bit(NFS4_SESSION_INITING, &session->session_state)) {\n\t\t/*\n\t\t * Do not set NFS_CS_CHECK_LEASE_TIME instead set the\n\t\t * DS lease to be equal to the MDS lease.\n\t\t */\n\t\tclp->cl_lease_time = lease_time;\n\t\tclp->cl_last_renewal = jiffies;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\tret = nfs41_check_session_ready(clp);\n\tif (ret)\n\t\treturn ret;\n\t/* Test for the DS role */\n\tif (!is_ds_client(clp))\n\t\treturn -ENODEV;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "clp"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "clp"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "clp"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_set_ds_client",
          "args": [
            "mds_srv->nfs_client",
            "(struct sockaddr *)&da->da_addr",
            "da->da_addrlen",
            "IPPROTO_TCP",
            "timeo",
            "retrans",
            "minor_version",
            "au_flavor"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_set_ds_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4client.c",
          "lines": "849-881",
          "snippet": "struct nfs_client *nfs4_set_ds_client(struct nfs_client* mds_clp,\n\t\tconst struct sockaddr *ds_addr, int ds_addrlen,\n\t\tint ds_proto, unsigned int ds_timeo, unsigned int ds_retrans,\n\t\tu32 minor_version, rpc_authflavor_t au_flavor)\n{\n\tstruct nfs_client_initdata cl_init = {\n\t\t.addr = ds_addr,\n\t\t.addrlen = ds_addrlen,\n\t\t.nfs_mod = &nfs_v4,\n\t\t.proto = ds_proto,\n\t\t.minorversion = minor_version,\n\t\t.net = mds_clp->cl_net,\n\t};\n\tstruct rpc_timeout ds_timeout;\n\tstruct nfs_client *clp;\n\tchar buf[INET6_ADDRSTRLEN + 1];\n\n\tif (rpc_ntop(ds_addr, buf, sizeof(buf)) <= 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tcl_init.hostname = buf;\n\n\t/*\n\t * Set an authflavor equual to the MDS value. Use the MDS nfs_client\n\t * cl_ipaddr so as to use the same EXCHANGE_ID co_ownerid as the MDS\n\t * (section 13.1 RFC 5661).\n\t */\n\tnfs_init_timeout_values(&ds_timeout, ds_proto, ds_timeo, ds_retrans);\n\tclp = nfs_get_client(&cl_init, &ds_timeout, mds_clp->cl_ipaddr,\n\t\t\t     au_flavor);\n\n\tdprintk(\"<-- %s %p\\n\", __func__, clp);\n\treturn clp;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"internal.h\"",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/auth.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"internal.h\"\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/auth.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n\nstruct nfs_client *nfs4_set_ds_client(struct nfs_client* mds_clp,\n\t\tconst struct sockaddr *ds_addr, int ds_addrlen,\n\t\tint ds_proto, unsigned int ds_timeo, unsigned int ds_retrans,\n\t\tu32 minor_version, rpc_authflavor_t au_flavor)\n{\n\tstruct nfs_client_initdata cl_init = {\n\t\t.addr = ds_addr,\n\t\t.addrlen = ds_addrlen,\n\t\t.nfs_mod = &nfs_v4,\n\t\t.proto = ds_proto,\n\t\t.minorversion = minor_version,\n\t\t.net = mds_clp->cl_net,\n\t};\n\tstruct rpc_timeout ds_timeout;\n\tstruct nfs_client *clp;\n\tchar buf[INET6_ADDRSTRLEN + 1];\n\n\tif (rpc_ntop(ds_addr, buf, sizeof(buf)) <= 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tcl_init.hostname = buf;\n\n\t/*\n\t * Set an authflavor equual to the MDS value. Use the MDS nfs_client\n\t * cl_ipaddr so as to use the same EXCHANGE_ID co_ownerid as the MDS\n\t * (section 13.1 RFC 5661).\n\t */\n\tnfs_init_timeout_values(&ds_timeout, ds_proto, ds_timeo, ds_retrans);\n\tclp = nfs_get_client(&cl_init, &ds_timeout, mds_clp->cl_ipaddr,\n\t\t\t     au_flavor);\n\n\tdprintk(\"<-- %s %p\\n\", __func__, clp);\n\treturn clp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: DS %s: trying address %s\\n\"",
            "__func__",
            "ds->ds_remotestr",
            "da->da_remotestr"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "da",
            "&ds->ds_addrs",
            "da_node"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"--> %s DS %s au_flavor %d\\n\"",
            "__func__",
            "ds->ds_remotestr",
            "au_flavor"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct nfs_client *(*get_v3_ds_connect)(\n\t\t\tstruct nfs_client *mds_clp,\n\t\t\tconst struct sockaddr *ds_addr,\n\t\t\tint ds_addrlen,\n\t\t\tint ds_proto,\n\t\t\tunsigned int ds_timeo,\n\t\t\tunsigned int ds_retrans,\n\t\t\trpc_authflavor_t au_flavor);\n\nstatic int _nfs4_pnfs_v4_ds_connect(struct nfs_server *mds_srv,\n\t\t\t\t struct nfs4_pnfs_ds *ds,\n\t\t\t\t unsigned int timeo,\n\t\t\t\t unsigned int retrans,\n\t\t\t\t u32 minor_version,\n\t\t\t\t rpc_authflavor_t au_flavor)\n{\n\tstruct nfs_client *clp = ERR_PTR(-EIO);\n\tstruct nfs4_pnfs_ds_addr *da;\n\tint status = 0;\n\n\tdprintk(\"--> %s DS %s au_flavor %d\\n\", __func__, ds->ds_remotestr,\n\t\tau_flavor);\n\n\tlist_for_each_entry(da, &ds->ds_addrs, da_node) {\n\t\tdprintk(\"%s: DS %s: trying address %s\\n\",\n\t\t\t__func__, ds->ds_remotestr, da->da_remotestr);\n\n\t\tclp = nfs4_set_ds_client(mds_srv->nfs_client,\n\t\t\t\t\t(struct sockaddr *)&da->da_addr,\n\t\t\t\t\tda->da_addrlen, IPPROTO_TCP,\n\t\t\t\t\ttimeo, retrans, minor_version,\n\t\t\t\t\tau_flavor);\n\t\tif (!IS_ERR(clp))\n\t\t\tbreak;\n\t}\n\n\tif (IS_ERR(clp)) {\n\t\tstatus = PTR_ERR(clp);\n\t\tgoto out;\n\t}\n\n\tstatus = nfs4_init_ds_session(clp, mds_srv->nfs_client->cl_lease_time);\n\tif (status)\n\t\tgoto out_put;\n\n\tsmp_wmb();\n\tds->ds_clp = clp;\n\tdprintk(\"%s [new] addr: %s\\n\", __func__, ds->ds_remotestr);\nout:\n\treturn status;\nout_put:\n\tnfs_put_client(clp);\n\tgoto out;\n}"
  },
  {
    "function_name": "_nfs4_pnfs_v3_ds_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
    "lines": "573-611",
    "snippet": "static int _nfs4_pnfs_v3_ds_connect(struct nfs_server *mds_srv,\n\t\t\t\t struct nfs4_pnfs_ds *ds,\n\t\t\t\t unsigned int timeo,\n\t\t\t\t unsigned int retrans,\n\t\t\t\t rpc_authflavor_t au_flavor)\n{\n\tstruct nfs_client *clp = ERR_PTR(-EIO);\n\tstruct nfs4_pnfs_ds_addr *da;\n\tint status = 0;\n\n\tdprintk(\"--> %s DS %s au_flavor %d\\n\", __func__,\n\t\tds->ds_remotestr, au_flavor);\n\n\tif (!load_v3_ds_connect())\n\t\tgoto out;\n\n\tlist_for_each_entry(da, &ds->ds_addrs, da_node) {\n\t\tdprintk(\"%s: DS %s: trying address %s\\n\",\n\t\t\t__func__, ds->ds_remotestr, da->da_remotestr);\n\n\t\tclp = get_v3_ds_connect(mds_srv->nfs_client,\n\t\t\t\t\t(struct sockaddr *)&da->da_addr,\n\t\t\t\t\tda->da_addrlen, IPPROTO_TCP,\n\t\t\t\t\ttimeo, retrans, au_flavor);\n\t\tif (!IS_ERR(clp))\n\t\t\tbreak;\n\t}\n\n\tif (IS_ERR(clp)) {\n\t\tstatus = PTR_ERR(clp);\n\t\tgoto out;\n\t}\n\n\tsmp_wmb();\n\tds->ds_clp = clp;\n\tdprintk(\"%s [new] addr: %s\\n\", __func__, ds->ds_remotestr);\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct nfs_client *(*get_v3_ds_connect)(\n\t\t\tstruct nfs_client *mds_clp,\n\t\t\tconst struct sockaddr *ds_addr,\n\t\t\tint ds_addrlen,\n\t\t\tint ds_proto,\n\t\t\tunsigned int ds_timeo,\n\t\t\tunsigned int ds_retrans,\n\t\t\trpc_authflavor_t au_flavor);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s [new] addr: %s\\n\"",
            "__func__",
            "ds->ds_remotestr"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "clp"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "clp"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "clp"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_v3_ds_connect",
          "args": [
            "mds_srv->nfs_client",
            "(struct sockaddr *)&da->da_addr",
            "da->da_addrlen",
            "IPPROTO_TCP",
            "timeo",
            "retrans",
            "au_flavor"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: DS %s: trying address %s\\n\"",
            "__func__",
            "ds->ds_remotestr",
            "da->da_remotestr"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "da",
            "&ds->ds_addrs",
            "da_node"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_v3_ds_connect",
          "args": [],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "load_v3_ds_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "554-562",
          "snippet": "static bool load_v3_ds_connect(void)\n{\n\tif (!get_v3_ds_connect) {\n\t\tget_v3_ds_connect = symbol_request(nfs3_set_ds_client);\n\t\tWARN_ON_ONCE(!get_v3_ds_connect);\n\t}\n\n\treturn(get_v3_ds_connect != NULL);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool load_v3_ds_connect(void)\n{\n\tif (!get_v3_ds_connect) {\n\t\tget_v3_ds_connect = symbol_request(nfs3_set_ds_client);\n\t\tWARN_ON_ONCE(!get_v3_ds_connect);\n\t}\n\n\treturn(get_v3_ds_connect != NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"--> %s DS %s au_flavor %d\\n\"",
            "__func__",
            "ds->ds_remotestr",
            "au_flavor"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct nfs_client *(*get_v3_ds_connect)(\n\t\t\tstruct nfs_client *mds_clp,\n\t\t\tconst struct sockaddr *ds_addr,\n\t\t\tint ds_addrlen,\n\t\t\tint ds_proto,\n\t\t\tunsigned int ds_timeo,\n\t\t\tunsigned int ds_retrans,\n\t\t\trpc_authflavor_t au_flavor);\n\nstatic int _nfs4_pnfs_v3_ds_connect(struct nfs_server *mds_srv,\n\t\t\t\t struct nfs4_pnfs_ds *ds,\n\t\t\t\t unsigned int timeo,\n\t\t\t\t unsigned int retrans,\n\t\t\t\t rpc_authflavor_t au_flavor)\n{\n\tstruct nfs_client *clp = ERR_PTR(-EIO);\n\tstruct nfs4_pnfs_ds_addr *da;\n\tint status = 0;\n\n\tdprintk(\"--> %s DS %s au_flavor %d\\n\", __func__,\n\t\tds->ds_remotestr, au_flavor);\n\n\tif (!load_v3_ds_connect())\n\t\tgoto out;\n\n\tlist_for_each_entry(da, &ds->ds_addrs, da_node) {\n\t\tdprintk(\"%s: DS %s: trying address %s\\n\",\n\t\t\t__func__, ds->ds_remotestr, da->da_remotestr);\n\n\t\tclp = get_v3_ds_connect(mds_srv->nfs_client,\n\t\t\t\t\t(struct sockaddr *)&da->da_addr,\n\t\t\t\t\tda->da_addrlen, IPPROTO_TCP,\n\t\t\t\t\ttimeo, retrans, au_flavor);\n\t\tif (!IS_ERR(clp))\n\t\t\tbreak;\n\t}\n\n\tif (IS_ERR(clp)) {\n\t\tstatus = PTR_ERR(clp);\n\t\tgoto out;\n\t}\n\n\tsmp_wmb();\n\tds->ds_clp = clp;\n\tdprintk(\"%s [new] addr: %s\\n\", __func__, ds->ds_remotestr);\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "nfs4_pnfs_v3_ds_connect_unload",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
    "lines": "564-570",
    "snippet": "void __exit nfs4_pnfs_v3_ds_connect_unload(void)\n{\n\tif (get_v3_ds_connect) {\n\t\tsymbol_put(nfs3_set_ds_client);\n\t\tget_v3_ds_connect = NULL;\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "symbol_put",
          "args": [
            "nfs3_set_ds_client"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid __exit nfs4_pnfs_v3_ds_connect_unload(void)\n{\n\tif (get_v3_ds_connect) {\n\t\tsymbol_put(nfs3_set_ds_client);\n\t\tget_v3_ds_connect = NULL;\n\t}\n}"
  },
  {
    "function_name": "load_v3_ds_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
    "lines": "554-562",
    "snippet": "static bool load_v3_ds_connect(void)\n{\n\tif (!get_v3_ds_connect) {\n\t\tget_v3_ds_connect = symbol_request(nfs3_set_ds_client);\n\t\tWARN_ON_ONCE(!get_v3_ds_connect);\n\t}\n\n\treturn(get_v3_ds_connect != NULL);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!get_v3_ds_connect"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symbol_request",
          "args": [
            "nfs3_set_ds_client"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool load_v3_ds_connect(void)\n{\n\tif (!get_v3_ds_connect) {\n\t\tget_v3_ds_connect = symbol_request(nfs3_set_ds_client);\n\t\tWARN_ON_ONCE(!get_v3_ds_connect);\n\t}\n\n\treturn(get_v3_ds_connect != NULL);\n}"
  },
  {
    "function_name": "nfs4_clear_ds_conn_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
    "lines": "537-543",
    "snippet": "static void nfs4_clear_ds_conn_bit(struct nfs4_pnfs_ds *ds)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(NFS4DS_CONNECTING, &ds->ds_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&ds->ds_state, NFS4DS_CONNECTING);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&ds->ds_state",
            "NFS4DS_CONNECTING"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFS4DS_CONNECTING",
            "&ds->ds_state"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb__before_atomic",
          "args": [],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void nfs4_clear_ds_conn_bit(struct nfs4_pnfs_ds *ds)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(NFS4DS_CONNECTING, &ds->ds_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&ds->ds_state, NFS4DS_CONNECTING);\n}"
  },
  {
    "function_name": "nfs4_wait_ds_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
    "lines": "530-535",
    "snippet": "static void nfs4_wait_ds_connect(struct nfs4_pnfs_ds *ds)\n{\n\tmight_sleep();\n\twait_on_bit(&ds->ds_state, NFS4DS_CONNECTING,\n\t\t\tTASK_KILLABLE);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_bit",
          "args": [
            "&ds->ds_state",
            "NFS4DS_CONNECTING",
            "TASK_KILLABLE"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void nfs4_wait_ds_connect(struct nfs4_pnfs_ds *ds)\n{\n\tmight_sleep();\n\twait_on_bit(&ds->ds_state, NFS4DS_CONNECTING,\n\t\t\tTASK_KILLABLE);\n}"
  },
  {
    "function_name": "nfs4_pnfs_ds_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
    "lines": "485-527",
    "snippet": "struct nfs4_pnfs_ds *\nnfs4_pnfs_ds_add(struct list_head *dsaddrs, gfp_t gfp_flags)\n{\n\tstruct nfs4_pnfs_ds *tmp_ds, *ds = NULL;\n\tchar *remotestr;\n\n\tif (list_empty(dsaddrs)) {\n\t\tdprintk(\"%s: no addresses defined\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tds = kzalloc(sizeof(*ds), gfp_flags);\n\tif (!ds)\n\t\tgoto out;\n\n\t/* this is only used for debugging, so it's ok if its NULL */\n\tremotestr = nfs4_pnfs_remotestr(dsaddrs, gfp_flags);\n\n\tspin_lock(&nfs4_ds_cache_lock);\n\ttmp_ds = _data_server_lookup_locked(dsaddrs);\n\tif (tmp_ds == NULL) {\n\t\tINIT_LIST_HEAD(&ds->ds_addrs);\n\t\tlist_splice_init(dsaddrs, &ds->ds_addrs);\n\t\tds->ds_remotestr = remotestr;\n\t\tatomic_set(&ds->ds_count, 1);\n\t\tINIT_LIST_HEAD(&ds->ds_node);\n\t\tds->ds_clp = NULL;\n\t\tlist_add(&ds->ds_node, &nfs4_data_server_cache);\n\t\tdprintk(\"%s add new data server %s\\n\", __func__,\n\t\t\tds->ds_remotestr);\n\t} else {\n\t\tkfree(remotestr);\n\t\tkfree(ds);\n\t\tatomic_inc(&tmp_ds->ds_count);\n\t\tdprintk(\"%s data server %s found, inc'ed ds_count to %d\\n\",\n\t\t\t__func__, tmp_ds->ds_remotestr,\n\t\t\tatomic_read(&tmp_ds->ds_count));\n\t\tds = tmp_ds;\n\t}\n\tspin_unlock(&nfs4_ds_cache_lock);\nout:\n\treturn ds;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(nfs4_ds_cache_lock);",
      "static LIST_HEAD(nfs4_data_server_cache);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nfs4_ds_cache_lock"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s data server %s found, inc'ed ds_count to %d\\n\"",
            "__func__",
            "tmp_ds->ds_remotestr",
            "atomic_read(&tmp_ds->ds_count)"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tmp_ds->ds_count"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&tmp_ds->ds_count"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ds"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "remotestr"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s add new data server %s\\n\"",
            "__func__",
            "ds->ds_remotestr"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ds->ds_node",
            "&nfs4_data_server_cache"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ds->ds_node"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ds->ds_count",
            "1"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "dsaddrs",
            "&ds->ds_addrs"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ds->ds_addrs"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_data_server_lookup_locked",
          "args": [
            "dsaddrs"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "_data_server_lookup_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "387-396",
          "snippet": "static struct nfs4_pnfs_ds *\n_data_server_lookup_locked(const struct list_head *dsaddrs)\n{\n\tstruct nfs4_pnfs_ds *ds;\n\n\tlist_for_each_entry(ds, &nfs4_data_server_cache, ds_node)\n\t\tif (_same_data_server_addrs_locked(&ds->ds_addrs, dsaddrs))\n\t\t\treturn ds;\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(nfs4_data_server_cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic LIST_HEAD(nfs4_data_server_cache);\n\nstatic struct nfs4_pnfs_ds *\n_data_server_lookup_locked(const struct list_head *dsaddrs)\n{\n\tstruct nfs4_pnfs_ds *ds;\n\n\tlist_for_each_entry(ds, &nfs4_data_server_cache, ds_node)\n\t\tif (_same_data_server_addrs_locked(&ds->ds_addrs, dsaddrs))\n\t\t\treturn ds;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nfs4_ds_cache_lock"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_pnfs_remotestr",
          "args": [
            "dsaddrs",
            "gfp_flags"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_pnfs_remotestr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "436-479",
          "snippet": "static char *\nnfs4_pnfs_remotestr(struct list_head *dsaddrs, gfp_t gfp_flags)\n{\n\tstruct nfs4_pnfs_ds_addr *da;\n\tchar *remotestr;\n\tsize_t len;\n\tchar *p;\n\n\tlen = 3;        /* '{', '}' and eol */\n\tlist_for_each_entry(da, dsaddrs, da_node) {\n\t\tlen += strlen(da->da_remotestr) + 1;    /* string plus comma */\n\t}\n\n\tremotestr = kzalloc(len, gfp_flags);\n\tif (!remotestr)\n\t\treturn NULL;\n\n\tp = remotestr;\n\t*(p++) = '{';\n\tlen--;\n\tlist_for_each_entry(da, dsaddrs, da_node) {\n\t\tsize_t ll = strlen(da->da_remotestr);\n\n\t\tif (ll > len)\n\t\t\tgoto out_err;\n\n\t\tmemcpy(p, da->da_remotestr, ll);\n\t\tp += ll;\n\t\tlen -= ll;\n\n\t\tif (len < 1)\n\t\t\tgoto out_err;\n\t\t(*p++) = ',';\n\t\tlen--;\n\t}\n\tif (len < 2)\n\t\tgoto out_err;\n\t*(p++) = '}';\n\t*p = '\\0';\n\treturn remotestr;\nout_err:\n\tkfree(remotestr);\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic char *\nnfs4_pnfs_remotestr(struct list_head *dsaddrs, gfp_t gfp_flags)\n{\n\tstruct nfs4_pnfs_ds_addr *da;\n\tchar *remotestr;\n\tsize_t len;\n\tchar *p;\n\n\tlen = 3;        /* '{', '}' and eol */\n\tlist_for_each_entry(da, dsaddrs, da_node) {\n\t\tlen += strlen(da->da_remotestr) + 1;    /* string plus comma */\n\t}\n\n\tremotestr = kzalloc(len, gfp_flags);\n\tif (!remotestr)\n\t\treturn NULL;\n\n\tp = remotestr;\n\t*(p++) = '{';\n\tlen--;\n\tlist_for_each_entry(da, dsaddrs, da_node) {\n\t\tsize_t ll = strlen(da->da_remotestr);\n\n\t\tif (ll > len)\n\t\t\tgoto out_err;\n\n\t\tmemcpy(p, da->da_remotestr, ll);\n\t\tp += ll;\n\t\tlen -= ll;\n\n\t\tif (len < 1)\n\t\t\tgoto out_err;\n\t\t(*p++) = ',';\n\t\tlen--;\n\t}\n\tif (len < 2)\n\t\tgoto out_err;\n\t*(p++) = '}';\n\t*p = '\\0';\n\treturn remotestr;\nout_err:\n\tkfree(remotestr);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ds)",
            "gfp_flags"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: no addresses defined\\n\"",
            "__func__"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "dsaddrs"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic DEFINE_SPINLOCK(nfs4_ds_cache_lock);\nstatic LIST_HEAD(nfs4_data_server_cache);\n\nstruct nfs4_pnfs_ds *\nnfs4_pnfs_ds_add(struct list_head *dsaddrs, gfp_t gfp_flags)\n{\n\tstruct nfs4_pnfs_ds *tmp_ds, *ds = NULL;\n\tchar *remotestr;\n\n\tif (list_empty(dsaddrs)) {\n\t\tdprintk(\"%s: no addresses defined\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tds = kzalloc(sizeof(*ds), gfp_flags);\n\tif (!ds)\n\t\tgoto out;\n\n\t/* this is only used for debugging, so it's ok if its NULL */\n\tremotestr = nfs4_pnfs_remotestr(dsaddrs, gfp_flags);\n\n\tspin_lock(&nfs4_ds_cache_lock);\n\ttmp_ds = _data_server_lookup_locked(dsaddrs);\n\tif (tmp_ds == NULL) {\n\t\tINIT_LIST_HEAD(&ds->ds_addrs);\n\t\tlist_splice_init(dsaddrs, &ds->ds_addrs);\n\t\tds->ds_remotestr = remotestr;\n\t\tatomic_set(&ds->ds_count, 1);\n\t\tINIT_LIST_HEAD(&ds->ds_node);\n\t\tds->ds_clp = NULL;\n\t\tlist_add(&ds->ds_node, &nfs4_data_server_cache);\n\t\tdprintk(\"%s add new data server %s\\n\", __func__,\n\t\t\tds->ds_remotestr);\n\t} else {\n\t\tkfree(remotestr);\n\t\tkfree(ds);\n\t\tatomic_inc(&tmp_ds->ds_count);\n\t\tdprintk(\"%s data server %s found, inc'ed ds_count to %d\\n\",\n\t\t\t__func__, tmp_ds->ds_remotestr,\n\t\t\tatomic_read(&tmp_ds->ds_count));\n\t\tds = tmp_ds;\n\t}\n\tspin_unlock(&nfs4_ds_cache_lock);\nout:\n\treturn ds;\n}"
  },
  {
    "function_name": "nfs4_pnfs_remotestr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
    "lines": "436-479",
    "snippet": "static char *\nnfs4_pnfs_remotestr(struct list_head *dsaddrs, gfp_t gfp_flags)\n{\n\tstruct nfs4_pnfs_ds_addr *da;\n\tchar *remotestr;\n\tsize_t len;\n\tchar *p;\n\n\tlen = 3;        /* '{', '}' and eol */\n\tlist_for_each_entry(da, dsaddrs, da_node) {\n\t\tlen += strlen(da->da_remotestr) + 1;    /* string plus comma */\n\t}\n\n\tremotestr = kzalloc(len, gfp_flags);\n\tif (!remotestr)\n\t\treturn NULL;\n\n\tp = remotestr;\n\t*(p++) = '{';\n\tlen--;\n\tlist_for_each_entry(da, dsaddrs, da_node) {\n\t\tsize_t ll = strlen(da->da_remotestr);\n\n\t\tif (ll > len)\n\t\t\tgoto out_err;\n\n\t\tmemcpy(p, da->da_remotestr, ll);\n\t\tp += ll;\n\t\tlen -= ll;\n\n\t\tif (len < 1)\n\t\t\tgoto out_err;\n\t\t(*p++) = ',';\n\t\tlen--;\n\t}\n\tif (len < 2)\n\t\tgoto out_err;\n\t*(p++) = '}';\n\t*p = '\\0';\n\treturn remotestr;\nout_err:\n\tkfree(remotestr);\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "remotestr"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "da->da_remotestr",
            "ll"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "da->da_remotestr"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "da",
            "dsaddrs",
            "da_node"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "len",
            "gfp_flags"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "da",
            "dsaddrs",
            "da_node"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic char *\nnfs4_pnfs_remotestr(struct list_head *dsaddrs, gfp_t gfp_flags)\n{\n\tstruct nfs4_pnfs_ds_addr *da;\n\tchar *remotestr;\n\tsize_t len;\n\tchar *p;\n\n\tlen = 3;        /* '{', '}' and eol */\n\tlist_for_each_entry(da, dsaddrs, da_node) {\n\t\tlen += strlen(da->da_remotestr) + 1;    /* string plus comma */\n\t}\n\n\tremotestr = kzalloc(len, gfp_flags);\n\tif (!remotestr)\n\t\treturn NULL;\n\n\tp = remotestr;\n\t*(p++) = '{';\n\tlen--;\n\tlist_for_each_entry(da, dsaddrs, da_node) {\n\t\tsize_t ll = strlen(da->da_remotestr);\n\n\t\tif (ll > len)\n\t\t\tgoto out_err;\n\n\t\tmemcpy(p, da->da_remotestr, ll);\n\t\tp += ll;\n\t\tlen -= ll;\n\n\t\tif (len < 1)\n\t\t\tgoto out_err;\n\t\t(*p++) = ',';\n\t\tlen--;\n\t}\n\tif (len < 2)\n\t\tgoto out_err;\n\t*(p++) = '}';\n\t*p = '\\0';\n\treturn remotestr;\nout_err:\n\tkfree(remotestr);\n\treturn NULL;\n}"
  },
  {
    "function_name": "nfs4_pnfs_ds_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
    "lines": "421-429",
    "snippet": "void nfs4_pnfs_ds_put(struct nfs4_pnfs_ds *ds)\n{\n\tif (atomic_dec_and_lock(&ds->ds_count,\n\t\t\t\t&nfs4_ds_cache_lock)) {\n\t\tlist_del_init(&ds->ds_node);\n\t\tspin_unlock(&nfs4_ds_cache_lock);\n\t\tdestroy_ds(ds);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(nfs4_ds_cache_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_ds",
          "args": [
            "ds"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_ds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "398-419",
          "snippet": "static void destroy_ds(struct nfs4_pnfs_ds *ds)\n{\n\tstruct nfs4_pnfs_ds_addr *da;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tifdebug(FACILITY)\n\t\tprint_ds(ds);\n\n\tnfs_put_client(ds->ds_clp);\n\n\twhile (!list_empty(&ds->ds_addrs)) {\n\t\tda = list_first_entry(&ds->ds_addrs,\n\t\t\t\t      struct nfs4_pnfs_ds_addr,\n\t\t\t\t      da_node);\n\t\tlist_del_init(&da->da_node);\n\t\tkfree(da->da_remotestr);\n\t\tkfree(da);\n\t}\n\n\tkfree(ds->ds_remotestr);\n\tkfree(ds);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void destroy_ds(struct nfs4_pnfs_ds *ds)\n{\n\tstruct nfs4_pnfs_ds_addr *da;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tifdebug(FACILITY)\n\t\tprint_ds(ds);\n\n\tnfs_put_client(ds->ds_clp);\n\n\twhile (!list_empty(&ds->ds_addrs)) {\n\t\tda = list_first_entry(&ds->ds_addrs,\n\t\t\t\t      struct nfs4_pnfs_ds_addr,\n\t\t\t\t      da_node);\n\t\tlist_del_init(&da->da_node);\n\t\tkfree(da->da_remotestr);\n\t\tkfree(da);\n\t}\n\n\tkfree(ds->ds_remotestr);\n\tkfree(ds);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nfs4_ds_cache_lock"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ds->ds_node"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_lock",
          "args": [
            "&ds->ds_count",
            "&nfs4_ds_cache_lock"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic DEFINE_SPINLOCK(nfs4_ds_cache_lock);\n\nvoid nfs4_pnfs_ds_put(struct nfs4_pnfs_ds *ds)\n{\n\tif (atomic_dec_and_lock(&ds->ds_count,\n\t\t\t\t&nfs4_ds_cache_lock)) {\n\t\tlist_del_init(&ds->ds_node);\n\t\tspin_unlock(&nfs4_ds_cache_lock);\n\t\tdestroy_ds(ds);\n\t}\n}"
  },
  {
    "function_name": "destroy_ds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
    "lines": "398-419",
    "snippet": "static void destroy_ds(struct nfs4_pnfs_ds *ds)\n{\n\tstruct nfs4_pnfs_ds_addr *da;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tifdebug(FACILITY)\n\t\tprint_ds(ds);\n\n\tnfs_put_client(ds->ds_clp);\n\n\twhile (!list_empty(&ds->ds_addrs)) {\n\t\tda = list_first_entry(&ds->ds_addrs,\n\t\t\t\t      struct nfs4_pnfs_ds_addr,\n\t\t\t\t      da_node);\n\t\tlist_del_init(&da->da_node);\n\t\tkfree(da->da_remotestr);\n\t\tkfree(da);\n\t}\n\n\tkfree(ds->ds_remotestr);\n\tkfree(ds);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ds"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ds->ds_remotestr"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "da"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "da->da_remotestr"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&da->da_node"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&ds->ds_addrs",
            "structnfs4_pnfs_ds_addr",
            "da_node"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ds->ds_addrs"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_put_client",
          "args": [
            "ds->ds_clp"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_put_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/client.c",
          "lines": "267-286",
          "snippet": "void nfs_put_client(struct nfs_client *clp)\n{\n\tstruct nfs_net *nn;\n\n\tif (!clp)\n\t\treturn;\n\n\tdprintk(\"--> nfs_put_client({%d})\\n\", atomic_read(&clp->cl_count));\n\tnn = net_generic(clp->cl_net, nfs_net_id);\n\n\tif (atomic_dec_and_lock(&clp->cl_count, &nn->nfs_client_lock)) {\n\t\tlist_del(&clp->cl_share_link);\n\t\tnfs_cb_idr_remove_locked(clp);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\tWARN_ON_ONCE(!list_empty(&clp->cl_superblocks));\n\n\t\tclp->rpc_ops->free_client(clp);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <net/ipv6.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/xprtrdma.h>",
            "#include <linux/sunrpc/xprtsock.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/nfs_xdr.h>\n#include <net/ipv6.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/nfs_idmap.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/xprtrdma.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid nfs_put_client(struct nfs_client *clp)\n{\n\tstruct nfs_net *nn;\n\n\tif (!clp)\n\t\treturn;\n\n\tdprintk(\"--> nfs_put_client({%d})\\n\", atomic_read(&clp->cl_count));\n\tnn = net_generic(clp->cl_net, nfs_net_id);\n\n\tif (atomic_dec_and_lock(&clp->cl_count, &nn->nfs_client_lock)) {\n\t\tlist_del(&clp->cl_share_link);\n\t\tnfs_cb_idr_remove_locked(clp);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\tWARN_ON_ONCE(!list_empty(&clp->cl_superblocks));\n\n\t\tclp->rpc_ops->free_client(clp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"--> %s\\n\"",
            "__func__"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void destroy_ds(struct nfs4_pnfs_ds *ds)\n{\n\tstruct nfs4_pnfs_ds_addr *da;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tifdebug(FACILITY)\n\t\tprint_ds(ds);\n\n\tnfs_put_client(ds->ds_clp);\n\n\twhile (!list_empty(&ds->ds_addrs)) {\n\t\tda = list_first_entry(&ds->ds_addrs,\n\t\t\t\t      struct nfs4_pnfs_ds_addr,\n\t\t\t\t      da_node);\n\t\tlist_del_init(&da->da_node);\n\t\tkfree(da->da_remotestr);\n\t\tkfree(da);\n\t}\n\n\tkfree(ds->ds_remotestr);\n\tkfree(ds);\n}"
  },
  {
    "function_name": "_data_server_lookup_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
    "lines": "387-396",
    "snippet": "static struct nfs4_pnfs_ds *\n_data_server_lookup_locked(const struct list_head *dsaddrs)\n{\n\tstruct nfs4_pnfs_ds *ds;\n\n\tlist_for_each_entry(ds, &nfs4_data_server_cache, ds_node)\n\t\tif (_same_data_server_addrs_locked(&ds->ds_addrs, dsaddrs))\n\t\t\treturn ds;\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(nfs4_data_server_cache);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_same_data_server_addrs_locked",
          "args": [
            "&ds->ds_addrs",
            "dsaddrs"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "_same_data_server_addrs_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "362-382",
          "snippet": "static bool\n_same_data_server_addrs_locked(const struct list_head *dsaddrs1,\n\t\t\t       const struct list_head *dsaddrs2)\n{\n\tstruct nfs4_pnfs_ds_addr *da1, *da2;\n\n\t/* step through both lists, comparing as we go */\n\tfor (da1 = list_first_entry(dsaddrs1, typeof(*da1), da_node),\n\t     da2 = list_first_entry(dsaddrs2, typeof(*da2), da_node);\n\t     da1 != NULL && da2 != NULL;\n\t     da1 = list_entry(da1->da_node.next, typeof(*da1), da_node),\n\t     da2 = list_entry(da2->da_node.next, typeof(*da2), da_node)) {\n\t\tif (!same_sockaddr((struct sockaddr *)&da1->da_addr,\n\t\t\t\t   (struct sockaddr *)&da2->da_addr))\n\t\t\treturn false;\n\t}\n\tif (da1 == NULL && da2 == NULL)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\n_same_data_server_addrs_locked(const struct list_head *dsaddrs1,\n\t\t\t       const struct list_head *dsaddrs2)\n{\n\tstruct nfs4_pnfs_ds_addr *da1, *da2;\n\n\t/* step through both lists, comparing as we go */\n\tfor (da1 = list_first_entry(dsaddrs1, typeof(*da1), da_node),\n\t     da2 = list_first_entry(dsaddrs2, typeof(*da2), da_node);\n\t     da1 != NULL && da2 != NULL;\n\t     da1 = list_entry(da1->da_node.next, typeof(*da1), da_node),\n\t     da2 = list_entry(da2->da_node.next, typeof(*da2), da_node)) {\n\t\tif (!same_sockaddr((struct sockaddr *)&da1->da_addr,\n\t\t\t\t   (struct sockaddr *)&da2->da_addr))\n\t\t\treturn false;\n\t}\n\tif (da1 == NULL && da2 == NULL)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ds",
            "&nfs4_data_server_cache",
            "ds_node"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic LIST_HEAD(nfs4_data_server_cache);\n\nstatic struct nfs4_pnfs_ds *\n_data_server_lookup_locked(const struct list_head *dsaddrs)\n{\n\tstruct nfs4_pnfs_ds *ds;\n\n\tlist_for_each_entry(ds, &nfs4_data_server_cache, ds_node)\n\t\tif (_same_data_server_addrs_locked(&ds->ds_addrs, dsaddrs))\n\t\t\treturn ds;\n\treturn NULL;\n}"
  },
  {
    "function_name": "_same_data_server_addrs_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
    "lines": "362-382",
    "snippet": "static bool\n_same_data_server_addrs_locked(const struct list_head *dsaddrs1,\n\t\t\t       const struct list_head *dsaddrs2)\n{\n\tstruct nfs4_pnfs_ds_addr *da1, *da2;\n\n\t/* step through both lists, comparing as we go */\n\tfor (da1 = list_first_entry(dsaddrs1, typeof(*da1), da_node),\n\t     da2 = list_first_entry(dsaddrs2, typeof(*da2), da_node);\n\t     da1 != NULL && da2 != NULL;\n\t     da1 = list_entry(da1->da_node.next, typeof(*da1), da_node),\n\t     da2 = list_entry(da2->da_node.next, typeof(*da2), da_node)) {\n\t\tif (!same_sockaddr((struct sockaddr *)&da1->da_addr,\n\t\t\t\t   (struct sockaddr *)&da2->da_addr))\n\t\t\treturn false;\n\t}\n\tif (da1 == NULL && da2 == NULL)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "same_sockaddr",
          "args": [
            "(struct sockaddr *)&da1->da_addr",
            "(struct sockaddr *)&da2->da_addr"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "same_sockaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "319-360",
          "snippet": "static bool\nsame_sockaddr(struct sockaddr *addr1, struct sockaddr *addr2)\n{\n\tstruct sockaddr_in *a, *b;\n\tstruct sockaddr_in6 *a6, *b6;\n\n\tif (addr1->sa_family != addr2->sa_family)\n\t\treturn false;\n\n\tswitch (addr1->sa_family) {\n\tcase AF_INET:\n\t\ta = (struct sockaddr_in *)addr1;\n\t\tb = (struct sockaddr_in *)addr2;\n\n\t\tif (a->sin_addr.s_addr == b->sin_addr.s_addr &&\n\t\t    a->sin_port == b->sin_port)\n\t\t\treturn true;\n\t\tbreak;\n\n\tcase AF_INET6:\n\t\ta6 = (struct sockaddr_in6 *)addr1;\n\t\tb6 = (struct sockaddr_in6 *)addr2;\n\n\t\t/* LINKLOCAL addresses must have matching scope_id */\n\t\tif (ipv6_addr_src_scope(&a6->sin6_addr) ==\n\t\t    IPV6_ADDR_SCOPE_LINKLOCAL &&\n\t\t    a6->sin6_scope_id != b6->sin6_scope_id)\n\t\t\treturn false;\n\n\t\tif (ipv6_addr_equal(&a6->sin6_addr, &b6->sin6_addr) &&\n\t\t    a6->sin6_port == b6->sin6_port)\n\t\t\treturn true;\n\t\tbreak;\n\n\tdefault:\n\t\tdprintk(\"%s: unhandled address family: %u\\n\",\n\t\t\t__func__, addr1->sa_family);\n\t\treturn false;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\nsame_sockaddr(struct sockaddr *addr1, struct sockaddr *addr2)\n{\n\tstruct sockaddr_in *a, *b;\n\tstruct sockaddr_in6 *a6, *b6;\n\n\tif (addr1->sa_family != addr2->sa_family)\n\t\treturn false;\n\n\tswitch (addr1->sa_family) {\n\tcase AF_INET:\n\t\ta = (struct sockaddr_in *)addr1;\n\t\tb = (struct sockaddr_in *)addr2;\n\n\t\tif (a->sin_addr.s_addr == b->sin_addr.s_addr &&\n\t\t    a->sin_port == b->sin_port)\n\t\t\treturn true;\n\t\tbreak;\n\n\tcase AF_INET6:\n\t\ta6 = (struct sockaddr_in6 *)addr1;\n\t\tb6 = (struct sockaddr_in6 *)addr2;\n\n\t\t/* LINKLOCAL addresses must have matching scope_id */\n\t\tif (ipv6_addr_src_scope(&a6->sin6_addr) ==\n\t\t    IPV6_ADDR_SCOPE_LINKLOCAL &&\n\t\t    a6->sin6_scope_id != b6->sin6_scope_id)\n\t\t\treturn false;\n\n\t\tif (ipv6_addr_equal(&a6->sin6_addr, &b6->sin6_addr) &&\n\t\t    a6->sin6_port == b6->sin6_port)\n\t\t\treturn true;\n\t\tbreak;\n\n\tdefault:\n\t\tdprintk(\"%s: unhandled address family: %u\\n\",\n\t\t\t__func__, addr1->sa_family);\n\t\treturn false;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "da2->da_node.next",
            "typeof(*da2)",
            "da_node"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*da2"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "da1->da_node.next",
            "typeof(*da1)",
            "da_node"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*da1"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "dsaddrs2",
            "typeof(*da2)",
            "da_node"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*da2"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "dsaddrs1",
            "typeof(*da1)",
            "da_node"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*da1"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\n_same_data_server_addrs_locked(const struct list_head *dsaddrs1,\n\t\t\t       const struct list_head *dsaddrs2)\n{\n\tstruct nfs4_pnfs_ds_addr *da1, *da2;\n\n\t/* step through both lists, comparing as we go */\n\tfor (da1 = list_first_entry(dsaddrs1, typeof(*da1), da_node),\n\t     da2 = list_first_entry(dsaddrs2, typeof(*da2), da_node);\n\t     da1 != NULL && da2 != NULL;\n\t     da1 = list_entry(da1->da_node.next, typeof(*da1), da_node),\n\t     da2 = list_entry(da2->da_node.next, typeof(*da2), da_node)) {\n\t\tif (!same_sockaddr((struct sockaddr *)&da1->da_addr,\n\t\t\t\t   (struct sockaddr *)&da2->da_addr))\n\t\t\treturn false;\n\t}\n\tif (da1 == NULL && da2 == NULL)\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "same_sockaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
    "lines": "319-360",
    "snippet": "static bool\nsame_sockaddr(struct sockaddr *addr1, struct sockaddr *addr2)\n{\n\tstruct sockaddr_in *a, *b;\n\tstruct sockaddr_in6 *a6, *b6;\n\n\tif (addr1->sa_family != addr2->sa_family)\n\t\treturn false;\n\n\tswitch (addr1->sa_family) {\n\tcase AF_INET:\n\t\ta = (struct sockaddr_in *)addr1;\n\t\tb = (struct sockaddr_in *)addr2;\n\n\t\tif (a->sin_addr.s_addr == b->sin_addr.s_addr &&\n\t\t    a->sin_port == b->sin_port)\n\t\t\treturn true;\n\t\tbreak;\n\n\tcase AF_INET6:\n\t\ta6 = (struct sockaddr_in6 *)addr1;\n\t\tb6 = (struct sockaddr_in6 *)addr2;\n\n\t\t/* LINKLOCAL addresses must have matching scope_id */\n\t\tif (ipv6_addr_src_scope(&a6->sin6_addr) ==\n\t\t    IPV6_ADDR_SCOPE_LINKLOCAL &&\n\t\t    a6->sin6_scope_id != b6->sin6_scope_id)\n\t\t\treturn false;\n\n\t\tif (ipv6_addr_equal(&a6->sin6_addr, &b6->sin6_addr) &&\n\t\t    a6->sin6_port == b6->sin6_port)\n\t\t\treturn true;\n\t\tbreak;\n\n\tdefault:\n\t\tdprintk(\"%s: unhandled address family: %u\\n\",\n\t\t\t__func__, addr1->sa_family);\n\t\treturn false;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: unhandled address family: %u\\n\"",
            "__func__",
            "addr1->sa_family"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ipv6_addr_equal",
          "args": [
            "&a6->sin6_addr",
            "&b6->sin6_addr"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ipv6_addr_src_scope",
          "args": [
            "&a6->sin6_addr"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\nsame_sockaddr(struct sockaddr *addr1, struct sockaddr *addr2)\n{\n\tstruct sockaddr_in *a, *b;\n\tstruct sockaddr_in6 *a6, *b6;\n\n\tif (addr1->sa_family != addr2->sa_family)\n\t\treturn false;\n\n\tswitch (addr1->sa_family) {\n\tcase AF_INET:\n\t\ta = (struct sockaddr_in *)addr1;\n\t\tb = (struct sockaddr_in *)addr2;\n\n\t\tif (a->sin_addr.s_addr == b->sin_addr.s_addr &&\n\t\t    a->sin_port == b->sin_port)\n\t\t\treturn true;\n\t\tbreak;\n\n\tcase AF_INET6:\n\t\ta6 = (struct sockaddr_in6 *)addr1;\n\t\tb6 = (struct sockaddr_in6 *)addr2;\n\n\t\t/* LINKLOCAL addresses must have matching scope_id */\n\t\tif (ipv6_addr_src_scope(&a6->sin6_addr) ==\n\t\t    IPV6_ADDR_SCOPE_LINKLOCAL &&\n\t\t    a6->sin6_scope_id != b6->sin6_scope_id)\n\t\t\treturn false;\n\n\t\tif (ipv6_addr_equal(&a6->sin6_addr, &b6->sin6_addr) &&\n\t\t    a6->sin6_port == b6->sin6_port)\n\t\t\treturn true;\n\t\tbreak;\n\n\tdefault:\n\t\tdprintk(\"%s: unhandled address family: %u\\n\",\n\t\t\t__func__, addr1->sa_family);\n\t\treturn false;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "print_ds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
    "lines": "303-317",
    "snippet": "static void\nprint_ds(struct nfs4_pnfs_ds *ds)\n{\n\tif (ds == NULL) {\n\t\tprintk(KERN_WARNING \"%s NULL device\\n\", __func__);\n\t\treturn;\n\t}\n\tprintk(KERN_WARNING \"        ds %s\\n\"\n\t\t\"        ref count %d\\n\"\n\t\t\"        client %p\\n\"\n\t\t\"        cl_exchange_flags %x\\n\",\n\t\tds->ds_remotestr,\n\t\tatomic_read(&ds->ds_count), ds->ds_clp,\n\t\tds->ds_clp ? ds->ds_clp->cl_exchange_flags : 0);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"        ds %s\\n\"\n\t\t\"        ref count %d\\n\"\n\t\t\"        client %p\\n\"\n\t\t\"        cl_exchange_flags %x\\n\"",
            "ds->ds_remotestr",
            "atomic_read(&ds->ds_count)",
            "ds->ds_clp",
            "ds->ds_clp ? ds->ds_clp->cl_exchange_flags : 0"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ds->ds_count"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\nprint_ds(struct nfs4_pnfs_ds *ds)\n{\n\tif (ds == NULL) {\n\t\tprintk(KERN_WARNING \"%s NULL device\\n\", __func__);\n\t\treturn;\n\t}\n\tprintk(KERN_WARNING \"        ds %s\\n\"\n\t\t\"        ref count %d\\n\"\n\t\t\"        client %p\\n\"\n\t\t\"        cl_exchange_flags %x\\n\",\n\t\tds->ds_remotestr,\n\t\tatomic_read(&ds->ds_count), ds->ds_clp,\n\t\tds->ds_clp ? ds->ds_clp->cl_exchange_flags : 0);\n}"
  },
  {
    "function_name": "pnfs_generic_commit_pagelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
    "lines": "233-287",
    "snippet": "int\npnfs_generic_commit_pagelist(struct inode *inode, struct list_head *mds_pages,\n\t\t\t     int how, struct nfs_commit_info *cinfo,\n\t\t\t     int (*initiate_commit)(struct nfs_commit_data *data,\n\t\t\t\t\t\t    int how))\n{\n\tstruct nfs_commit_data *data, *tmp;\n\tLIST_HEAD(list);\n\tunsigned int nreq = 0;\n\n\tif (!list_empty(mds_pages)) {\n\t\tdata = nfs_commitdata_alloc();\n\t\tif (data != NULL) {\n\t\t\tdata->lseg = NULL;\n\t\t\tlist_add(&data->pages, &list);\n\t\t\tnreq++;\n\t\t} else {\n\t\t\tnfs_retry_commit(mds_pages, NULL, cinfo, 0);\n\t\t\tpnfs_generic_retry_commit(cinfo, 0);\n\t\t\tcinfo->completion_ops->error_cleanup(NFS_I(inode));\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tnreq += pnfs_generic_alloc_ds_commits(cinfo, &list);\n\n\tif (nreq == 0) {\n\t\tcinfo->completion_ops->error_cleanup(NFS_I(inode));\n\t\tgoto out;\n\t}\n\n\tatomic_add(nreq, &cinfo->mds->rpcs_out);\n\n\tlist_for_each_entry_safe(data, tmp, &list, pages) {\n\t\tlist_del_init(&data->pages);\n\t\tif (!data->lseg) {\n\t\t\tnfs_init_commit(data, mds_pages, NULL, cinfo);\n\t\t\tnfs_initiate_commit(NFS_CLIENT(inode), data,\n\t\t\t\t\t    NFS_PROTO(data->inode),\n\t\t\t\t\t    data->mds_ops, how, 0);\n\t\t} else {\n\t\t\tstruct pnfs_commit_bucket *buckets;\n\n\t\t\tbuckets = cinfo->ds->buckets;\n\t\t\tnfs_init_commit(data,\n\t\t\t\t\t&buckets[data->ds_commit_index].committing,\n\t\t\t\t\tdata->lseg,\n\t\t\t\t\tcinfo);\n\t\t\tinitiate_commit(data, how);\n\t\t}\n\t}\nout:\n\tcinfo->ds->ncommitting = 0;\n\treturn PNFS_ATTEMPTED;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "initiate_commit",
          "args": [
            "data",
            "how"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_initiate_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "1351-1395",
          "snippet": "static int ff_layout_initiate_commit(struct nfs_commit_data *data, int how)\n{\n\tstruct pnfs_layout_segment *lseg = data->lseg;\n\tstruct nfs4_pnfs_ds *ds;\n\tstruct rpc_clnt *ds_clnt;\n\tstruct rpc_cred *ds_cred;\n\tu32 idx;\n\tint vers;\n\tstruct nfs_fh *fh;\n\n\tidx = calc_ds_index_from_commit(lseg, data->ds_commit_index);\n\tds = nfs4_ff_layout_prepare_ds(lseg, idx, true);\n\tif (!ds)\n\t\tgoto out_err;\n\n\tds_clnt = nfs4_ff_find_or_create_ds_client(lseg, idx, ds->ds_clp,\n\t\t\t\t\t\t   data->inode);\n\tif (IS_ERR(ds_clnt))\n\t\tgoto out_err;\n\n\tds_cred = ff_layout_get_ds_cred(lseg, idx, data->cred);\n\tif (IS_ERR(ds_cred))\n\t\tgoto out_err;\n\n\tvers = nfs4_ff_layout_ds_version(lseg, idx);\n\n\tdprintk(\"%s ino %lu, how %d cl_count %d vers %d\\n\", __func__,\n\t\tdata->inode->i_ino, how, atomic_read(&ds->ds_clp->cl_count),\n\t\tvers);\n\tdata->commit_done_cb = ff_layout_commit_done_cb;\n\tdata->cred = ds_cred;\n\tatomic_inc(&ds->ds_clp->cl_count);\n\tdata->ds_clp = ds->ds_clp;\n\tfh = select_ds_fh_from_commit(lseg, data->ds_commit_index);\n\tif (fh)\n\t\tdata->args.fh = fh;\n\treturn nfs_initiate_commit(ds_clnt, data, ds->ds_clp->rpc_ops,\n\t\t\t\t   vers == 3 ? &ff_layout_commit_call_ops_v3 :\n\t\t\t\t\t       &ff_layout_commit_call_ops_v4,\n\t\t\t\t   how, RPC_TASK_SOFTCONN);\nout_err:\n\tpnfs_generic_prepare_to_resend_writes(data);\n\tpnfs_generic_commit_release(data);\n\treturn -EAGAIN;\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct rpc_call_ops ff_layout_commit_call_ops_v3 = {\n\t.rpc_call_prepare = ff_layout_commit_prepare_v3,\n\t.rpc_call_done = pnfs_generic_write_commit_done,\n\t.rpc_count_stats = ff_layout_commit_count_stats,\n\t.rpc_release = pnfs_generic_commit_release,\n};",
            "static const struct rpc_call_ops ff_layout_commit_call_ops_v4 = {\n\t.rpc_call_prepare = ff_layout_commit_prepare_v4,\n\t.rpc_call_done = pnfs_generic_write_commit_done,\n\t.rpc_count_stats = ff_layout_commit_count_stats,\n\t.rpc_release = pnfs_generic_commit_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic const struct rpc_call_ops ff_layout_commit_call_ops_v3 = {\n\t.rpc_call_prepare = ff_layout_commit_prepare_v3,\n\t.rpc_call_done = pnfs_generic_write_commit_done,\n\t.rpc_count_stats = ff_layout_commit_count_stats,\n\t.rpc_release = pnfs_generic_commit_release,\n};\nstatic const struct rpc_call_ops ff_layout_commit_call_ops_v4 = {\n\t.rpc_call_prepare = ff_layout_commit_prepare_v4,\n\t.rpc_call_done = pnfs_generic_write_commit_done,\n\t.rpc_count_stats = ff_layout_commit_count_stats,\n\t.rpc_release = pnfs_generic_commit_release,\n};\n\nstatic int ff_layout_initiate_commit(struct nfs_commit_data *data, int how)\n{\n\tstruct pnfs_layout_segment *lseg = data->lseg;\n\tstruct nfs4_pnfs_ds *ds;\n\tstruct rpc_clnt *ds_clnt;\n\tstruct rpc_cred *ds_cred;\n\tu32 idx;\n\tint vers;\n\tstruct nfs_fh *fh;\n\n\tidx = calc_ds_index_from_commit(lseg, data->ds_commit_index);\n\tds = nfs4_ff_layout_prepare_ds(lseg, idx, true);\n\tif (!ds)\n\t\tgoto out_err;\n\n\tds_clnt = nfs4_ff_find_or_create_ds_client(lseg, idx, ds->ds_clp,\n\t\t\t\t\t\t   data->inode);\n\tif (IS_ERR(ds_clnt))\n\t\tgoto out_err;\n\n\tds_cred = ff_layout_get_ds_cred(lseg, idx, data->cred);\n\tif (IS_ERR(ds_cred))\n\t\tgoto out_err;\n\n\tvers = nfs4_ff_layout_ds_version(lseg, idx);\n\n\tdprintk(\"%s ino %lu, how %d cl_count %d vers %d\\n\", __func__,\n\t\tdata->inode->i_ino, how, atomic_read(&ds->ds_clp->cl_count),\n\t\tvers);\n\tdata->commit_done_cb = ff_layout_commit_done_cb;\n\tdata->cred = ds_cred;\n\tatomic_inc(&ds->ds_clp->cl_count);\n\tdata->ds_clp = ds->ds_clp;\n\tfh = select_ds_fh_from_commit(lseg, data->ds_commit_index);\n\tif (fh)\n\t\tdata->args.fh = fh;\n\treturn nfs_initiate_commit(ds_clnt, data, ds->ds_clp->rpc_ops,\n\t\t\t\t   vers == 3 ? &ff_layout_commit_call_ops_v3 :\n\t\t\t\t\t       &ff_layout_commit_call_ops_v4,\n\t\t\t\t   how, RPC_TASK_SOFTCONN);\nout_err:\n\tpnfs_generic_prepare_to_resend_writes(data);\n\tpnfs_generic_commit_release(data);\n\treturn -EAGAIN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_init_commit",
          "args": [
            "data",
            "&buckets[data->ds_commit_index].committing",
            "data->lseg",
            "cinfo"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_init_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1588-1619",
          "snippet": "void nfs_init_commit(struct nfs_commit_data *data,\n\t\t     struct list_head *head,\n\t\t     struct pnfs_layout_segment *lseg,\n\t\t     struct nfs_commit_info *cinfo)\n{\n\tstruct nfs_page *first = nfs_list_entry(head->next);\n\tstruct inode *inode = first->wb_context->dentry->d_inode;\n\n\t/* Set up the RPC argument and reply structs\n\t * NB: take care not to mess about with data->commit et al. */\n\n\tlist_splice_init(head, &data->pages);\n\n\tdata->inode\t  = inode;\n\tdata->cred\t  = first->wb_context->cred;\n\tdata->lseg\t  = lseg; /* reference transferred */\n\t/* only set lwb for pnfs commit */\n\tif (lseg)\n\t\tdata->lwb = nfs_get_lwb(&data->pages);\n\tdata->mds_ops     = &nfs_commit_ops;\n\tdata->completion_ops = cinfo->completion_ops;\n\tdata->dreq\t  = cinfo->dreq;\n\n\tdata->args.fh     = NFS_FH(data->inode);\n\t/* Note: we always request a commit of the entire inode */\n\tdata->args.offset = 0;\n\tdata->args.count  = 0;\n\tdata->context     = get_nfs_open_context(first->wb_context);\n\tdata->res.fattr   = &data->fattr;\n\tdata->res.verf    = &data->verf;\n\tnfs_fattr_init(&data->fattr);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct rpc_call_ops nfs_commit_ops;",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static const struct rpc_call_ops nfs_commit_ops = {\n\t.rpc_call_prepare = nfs_commit_prepare,\n\t.rpc_call_done = nfs_commit_done,\n\t.rpc_release = nfs_commit_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic const struct rpc_call_ops nfs_commit_ops;\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic const struct rpc_call_ops nfs_commit_ops = {\n\t.rpc_call_prepare = nfs_commit_prepare,\n\t.rpc_call_done = nfs_commit_done,\n\t.rpc_release = nfs_commit_release,\n};\n\nvoid nfs_init_commit(struct nfs_commit_data *data,\n\t\t     struct list_head *head,\n\t\t     struct pnfs_layout_segment *lseg,\n\t\t     struct nfs_commit_info *cinfo)\n{\n\tstruct nfs_page *first = nfs_list_entry(head->next);\n\tstruct inode *inode = first->wb_context->dentry->d_inode;\n\n\t/* Set up the RPC argument and reply structs\n\t * NB: take care not to mess about with data->commit et al. */\n\n\tlist_splice_init(head, &data->pages);\n\n\tdata->inode\t  = inode;\n\tdata->cred\t  = first->wb_context->cred;\n\tdata->lseg\t  = lseg; /* reference transferred */\n\t/* only set lwb for pnfs commit */\n\tif (lseg)\n\t\tdata->lwb = nfs_get_lwb(&data->pages);\n\tdata->mds_ops     = &nfs_commit_ops;\n\tdata->completion_ops = cinfo->completion_ops;\n\tdata->dreq\t  = cinfo->dreq;\n\n\tdata->args.fh     = NFS_FH(data->inode);\n\t/* Note: we always request a commit of the entire inode */\n\tdata->args.offset = 0;\n\tdata->args.count  = 0;\n\tdata->context     = get_nfs_open_context(first->wb_context);\n\tdata->res.fattr   = &data->fattr;\n\tdata->res.verf    = &data->verf;\n\tnfs_fattr_init(&data->fattr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_initiate_commit",
          "args": [
            "NFS_CLIENT(inode)",
            "data",
            "NFS_PROTO(data->inode)",
            "data->mds_ops",
            "how",
            "0"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_initiate_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1533-1570",
          "snippet": "int nfs_initiate_commit(struct rpc_clnt *clnt, struct nfs_commit_data *data,\n\t\t\tconst struct nfs_rpc_ops *nfs_ops,\n\t\t\tconst struct rpc_call_ops *call_ops,\n\t\t\tint how, int flags)\n{\n\tstruct rpc_task *task;\n\tint priority = flush_task_priority(how);\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &data->args,\n\t\t.rpc_resp = &data->res,\n\t\t.rpc_cred = data->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.task = &data->task,\n\t\t.rpc_client = clnt,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = call_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | flags,\n\t\t.priority = priority,\n\t};\n\t/* Set up the initial task struct.  */\n\tnfs_ops->commit_setup(data, &msg);\n\n\tdprintk(\"NFS: %5u initiated commit call\\n\", data->task.tk_pid);\n\n\tnfs4_state_protect(NFS_SERVER(data->inode)->nfs_client,\n\t\tNFS_SP4_MACH_CRED_COMMIT, &task_setup_data.rpc_client, &msg);\n\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (how & FLUSH_SYNC)\n\t\trpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn 0;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nint nfs_initiate_commit(struct rpc_clnt *clnt, struct nfs_commit_data *data,\n\t\t\tconst struct nfs_rpc_ops *nfs_ops,\n\t\t\tconst struct rpc_call_ops *call_ops,\n\t\t\tint how, int flags)\n{\n\tstruct rpc_task *task;\n\tint priority = flush_task_priority(how);\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &data->args,\n\t\t.rpc_resp = &data->res,\n\t\t.rpc_cred = data->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.task = &data->task,\n\t\t.rpc_client = clnt,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = call_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | flags,\n\t\t.priority = priority,\n\t};\n\t/* Set up the initial task struct.  */\n\tnfs_ops->commit_setup(data, &msg);\n\n\tdprintk(\"NFS: %5u initiated commit call\\n\", data->task.tk_pid);\n\n\tnfs4_state_protect(NFS_SERVER(data->inode)->nfs_client,\n\t\tNFS_SP4_MACH_CRED_COMMIT, &task_setup_data.rpc_client, &msg);\n\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (how & FLUSH_SYNC)\n\t\trpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "data->inode"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_CLIENT",
          "args": [
            "inode"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&data->pages"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "data",
            "tmp",
            "&list",
            "pages"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "nreq",
            "&cinfo->mds->rpcs_out"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cinfo->completion_ops->error_cleanup",
          "args": [
            "NFS_I(inode)"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_generic_alloc_ds_commits",
          "args": [
            "cinfo",
            "&list"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_generic_alloc_ds_commits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "200-230",
          "snippet": "static unsigned int\npnfs_generic_alloc_ds_commits(struct nfs_commit_info *cinfo,\n\t\t\t      struct list_head *list)\n{\n\tstruct pnfs_ds_commit_info *fl_cinfo;\n\tstruct pnfs_commit_bucket *bucket;\n\tstruct nfs_commit_data *data;\n\tint i;\n\tunsigned int nreq = 0;\n\n\tfl_cinfo = cinfo->ds;\n\tbucket = fl_cinfo->buckets;\n\tfor (i = 0; i < fl_cinfo->nbuckets; i++, bucket++) {\n\t\tif (list_empty(&bucket->committing))\n\t\t\tcontinue;\n\t\tdata = nfs_commitdata_alloc();\n\t\tif (!data)\n\t\t\tbreak;\n\t\tdata->ds_commit_index = i;\n\t\tspin_lock(cinfo->lock);\n\t\tdata->lseg = bucket->clseg;\n\t\tbucket->clseg = NULL;\n\t\tspin_unlock(cinfo->lock);\n\t\tlist_add(&data->pages, list);\n\t\tnreq++;\n\t}\n\n\t/* Clean up on error */\n\tpnfs_generic_retry_commit(cinfo, i);\n\treturn nreq;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic unsigned int\npnfs_generic_alloc_ds_commits(struct nfs_commit_info *cinfo,\n\t\t\t      struct list_head *list)\n{\n\tstruct pnfs_ds_commit_info *fl_cinfo;\n\tstruct pnfs_commit_bucket *bucket;\n\tstruct nfs_commit_data *data;\n\tint i;\n\tunsigned int nreq = 0;\n\n\tfl_cinfo = cinfo->ds;\n\tbucket = fl_cinfo->buckets;\n\tfor (i = 0; i < fl_cinfo->nbuckets; i++, bucket++) {\n\t\tif (list_empty(&bucket->committing))\n\t\t\tcontinue;\n\t\tdata = nfs_commitdata_alloc();\n\t\tif (!data)\n\t\t\tbreak;\n\t\tdata->ds_commit_index = i;\n\t\tspin_lock(cinfo->lock);\n\t\tdata->lseg = bucket->clseg;\n\t\tbucket->clseg = NULL;\n\t\tspin_unlock(cinfo->lock);\n\t\tlist_add(&data->pages, list);\n\t\tnreq++;\n\t}\n\n\t/* Clean up on error */\n\tpnfs_generic_retry_commit(cinfo, i);\n\treturn nreq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cinfo->completion_ops->error_cleanup",
          "args": [
            "NFS_I(inode)"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_generic_retry_commit",
          "args": [
            "cinfo",
            "0"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_generic_retry_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "180-198",
          "snippet": "static void pnfs_generic_retry_commit(struct nfs_commit_info *cinfo, int idx)\n{\n\tstruct pnfs_ds_commit_info *fl_cinfo = cinfo->ds;\n\tstruct pnfs_commit_bucket *bucket;\n\tstruct pnfs_layout_segment *freeme;\n\tint i;\n\n\tfor (i = idx; i < fl_cinfo->nbuckets; i++) {\n\t\tbucket = &fl_cinfo->buckets[i];\n\t\tif (list_empty(&bucket->committing))\n\t\t\tcontinue;\n\t\tnfs_retry_commit(&bucket->committing, bucket->clseg, cinfo, i);\n\t\tspin_lock(cinfo->lock);\n\t\tfreeme = bucket->clseg;\n\t\tbucket->clseg = NULL;\n\t\tspin_unlock(cinfo->lock);\n\t\tpnfs_put_lseg(freeme);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void pnfs_generic_retry_commit(struct nfs_commit_info *cinfo, int idx)\n{\n\tstruct pnfs_ds_commit_info *fl_cinfo = cinfo->ds;\n\tstruct pnfs_commit_bucket *bucket;\n\tstruct pnfs_layout_segment *freeme;\n\tint i;\n\n\tfor (i = idx; i < fl_cinfo->nbuckets; i++) {\n\t\tbucket = &fl_cinfo->buckets[i];\n\t\tif (list_empty(&bucket->committing))\n\t\t\tcontinue;\n\t\tnfs_retry_commit(&bucket->committing, bucket->clseg, cinfo, i);\n\t\tspin_lock(cinfo->lock);\n\t\tfreeme = bucket->clseg;\n\t\tbucket->clseg = NULL;\n\t\tspin_unlock(cinfo->lock);\n\t\tpnfs_put_lseg(freeme);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_retry_commit",
          "args": [
            "mds_pages",
            "NULL",
            "cinfo",
            "0"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_retry_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1622-1637",
          "snippet": "void nfs_retry_commit(struct list_head *page_list,\n\t\t      struct pnfs_layout_segment *lseg,\n\t\t      struct nfs_commit_info *cinfo,\n\t\t      u32 ds_commit_idx)\n{\n\tstruct nfs_page *req;\n\n\twhile (!list_empty(page_list)) {\n\t\treq = nfs_list_entry(page_list->next);\n\t\tnfs_list_remove_request(req);\n\t\tnfs_mark_request_commit(req, lseg, cinfo, ds_commit_idx);\n\t\tif (!cinfo->dreq)\n\t\t\tnfs_clear_page_commit(req->wb_page);\n\t\tnfs_unlock_and_release_request(req);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nvoid nfs_retry_commit(struct list_head *page_list,\n\t\t      struct pnfs_layout_segment *lseg,\n\t\t      struct nfs_commit_info *cinfo,\n\t\t      u32 ds_commit_idx)\n{\n\tstruct nfs_page *req;\n\n\twhile (!list_empty(page_list)) {\n\t\treq = nfs_list_entry(page_list->next);\n\t\tnfs_list_remove_request(req);\n\t\tnfs_mark_request_commit(req, lseg, cinfo, ds_commit_idx);\n\t\tif (!cinfo->dreq)\n\t\t\tnfs_clear_page_commit(req->wb_page);\n\t\tnfs_unlock_and_release_request(req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&data->pages",
            "&list"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_commitdata_alloc",
          "args": [],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_commitdata_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "61-70",
          "snippet": "struct nfs_commit_data *nfs_commitdata_alloc(void)\n{\n\tstruct nfs_commit_data *p = mempool_alloc(nfs_commit_mempool, GFP_NOIO);\n\n\tif (p) {\n\t\tmemset(p, 0, sizeof(*p));\n\t\tINIT_LIST_HEAD(&p->pages);\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static mempool_t *nfs_commit_mempool;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic mempool_t *nfs_commit_mempool;\n\nstruct nfs_commit_data *nfs_commitdata_alloc(void)\n{\n\tstruct nfs_commit_data *p = mempool_alloc(nfs_commit_mempool, GFP_NOIO);\n\n\tif (p) {\n\t\tmemset(p, 0, sizeof(*p));\n\t\tINIT_LIST_HEAD(&p->pages);\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "mds_pages"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "list"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint\npnfs_generic_commit_pagelist(struct inode *inode, struct list_head *mds_pages,\n\t\t\t     int how, struct nfs_commit_info *cinfo,\n\t\t\t     int (*initiate_commit)(struct nfs_commit_data *data,\n\t\t\t\t\t\t    int how))\n{\n\tstruct nfs_commit_data *data, *tmp;\n\tLIST_HEAD(list);\n\tunsigned int nreq = 0;\n\n\tif (!list_empty(mds_pages)) {\n\t\tdata = nfs_commitdata_alloc();\n\t\tif (data != NULL) {\n\t\t\tdata->lseg = NULL;\n\t\t\tlist_add(&data->pages, &list);\n\t\t\tnreq++;\n\t\t} else {\n\t\t\tnfs_retry_commit(mds_pages, NULL, cinfo, 0);\n\t\t\tpnfs_generic_retry_commit(cinfo, 0);\n\t\t\tcinfo->completion_ops->error_cleanup(NFS_I(inode));\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tnreq += pnfs_generic_alloc_ds_commits(cinfo, &list);\n\n\tif (nreq == 0) {\n\t\tcinfo->completion_ops->error_cleanup(NFS_I(inode));\n\t\tgoto out;\n\t}\n\n\tatomic_add(nreq, &cinfo->mds->rpcs_out);\n\n\tlist_for_each_entry_safe(data, tmp, &list, pages) {\n\t\tlist_del_init(&data->pages);\n\t\tif (!data->lseg) {\n\t\t\tnfs_init_commit(data, mds_pages, NULL, cinfo);\n\t\t\tnfs_initiate_commit(NFS_CLIENT(inode), data,\n\t\t\t\t\t    NFS_PROTO(data->inode),\n\t\t\t\t\t    data->mds_ops, how, 0);\n\t\t} else {\n\t\t\tstruct pnfs_commit_bucket *buckets;\n\n\t\t\tbuckets = cinfo->ds->buckets;\n\t\t\tnfs_init_commit(data,\n\t\t\t\t\t&buckets[data->ds_commit_index].committing,\n\t\t\t\t\tdata->lseg,\n\t\t\t\t\tcinfo);\n\t\t\tinitiate_commit(data, how);\n\t\t}\n\t}\nout:\n\tcinfo->ds->ncommitting = 0;\n\treturn PNFS_ATTEMPTED;\n}"
  },
  {
    "function_name": "pnfs_generic_alloc_ds_commits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
    "lines": "200-230",
    "snippet": "static unsigned int\npnfs_generic_alloc_ds_commits(struct nfs_commit_info *cinfo,\n\t\t\t      struct list_head *list)\n{\n\tstruct pnfs_ds_commit_info *fl_cinfo;\n\tstruct pnfs_commit_bucket *bucket;\n\tstruct nfs_commit_data *data;\n\tint i;\n\tunsigned int nreq = 0;\n\n\tfl_cinfo = cinfo->ds;\n\tbucket = fl_cinfo->buckets;\n\tfor (i = 0; i < fl_cinfo->nbuckets; i++, bucket++) {\n\t\tif (list_empty(&bucket->committing))\n\t\t\tcontinue;\n\t\tdata = nfs_commitdata_alloc();\n\t\tif (!data)\n\t\t\tbreak;\n\t\tdata->ds_commit_index = i;\n\t\tspin_lock(cinfo->lock);\n\t\tdata->lseg = bucket->clseg;\n\t\tbucket->clseg = NULL;\n\t\tspin_unlock(cinfo->lock);\n\t\tlist_add(&data->pages, list);\n\t\tnreq++;\n\t}\n\n\t/* Clean up on error */\n\tpnfs_generic_retry_commit(cinfo, i);\n\treturn nreq;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_generic_retry_commit",
          "args": [
            "cinfo",
            "i"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_generic_retry_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "180-198",
          "snippet": "static void pnfs_generic_retry_commit(struct nfs_commit_info *cinfo, int idx)\n{\n\tstruct pnfs_ds_commit_info *fl_cinfo = cinfo->ds;\n\tstruct pnfs_commit_bucket *bucket;\n\tstruct pnfs_layout_segment *freeme;\n\tint i;\n\n\tfor (i = idx; i < fl_cinfo->nbuckets; i++) {\n\t\tbucket = &fl_cinfo->buckets[i];\n\t\tif (list_empty(&bucket->committing))\n\t\t\tcontinue;\n\t\tnfs_retry_commit(&bucket->committing, bucket->clseg, cinfo, i);\n\t\tspin_lock(cinfo->lock);\n\t\tfreeme = bucket->clseg;\n\t\tbucket->clseg = NULL;\n\t\tspin_unlock(cinfo->lock);\n\t\tpnfs_put_lseg(freeme);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void pnfs_generic_retry_commit(struct nfs_commit_info *cinfo, int idx)\n{\n\tstruct pnfs_ds_commit_info *fl_cinfo = cinfo->ds;\n\tstruct pnfs_commit_bucket *bucket;\n\tstruct pnfs_layout_segment *freeme;\n\tint i;\n\n\tfor (i = idx; i < fl_cinfo->nbuckets; i++) {\n\t\tbucket = &fl_cinfo->buckets[i];\n\t\tif (list_empty(&bucket->committing))\n\t\t\tcontinue;\n\t\tnfs_retry_commit(&bucket->committing, bucket->clseg, cinfo, i);\n\t\tspin_lock(cinfo->lock);\n\t\tfreeme = bucket->clseg;\n\t\tbucket->clseg = NULL;\n\t\tspin_unlock(cinfo->lock);\n\t\tpnfs_put_lseg(freeme);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&data->pages",
            "list"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "cinfo->lock"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "cinfo->lock"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_commitdata_alloc",
          "args": [],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_commitdata_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "61-70",
          "snippet": "struct nfs_commit_data *nfs_commitdata_alloc(void)\n{\n\tstruct nfs_commit_data *p = mempool_alloc(nfs_commit_mempool, GFP_NOIO);\n\n\tif (p) {\n\t\tmemset(p, 0, sizeof(*p));\n\t\tINIT_LIST_HEAD(&p->pages);\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static mempool_t *nfs_commit_mempool;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic mempool_t *nfs_commit_mempool;\n\nstruct nfs_commit_data *nfs_commitdata_alloc(void)\n{\n\tstruct nfs_commit_data *p = mempool_alloc(nfs_commit_mempool, GFP_NOIO);\n\n\tif (p) {\n\t\tmemset(p, 0, sizeof(*p));\n\t\tINIT_LIST_HEAD(&p->pages);\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&bucket->committing"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic unsigned int\npnfs_generic_alloc_ds_commits(struct nfs_commit_info *cinfo,\n\t\t\t      struct list_head *list)\n{\n\tstruct pnfs_ds_commit_info *fl_cinfo;\n\tstruct pnfs_commit_bucket *bucket;\n\tstruct nfs_commit_data *data;\n\tint i;\n\tunsigned int nreq = 0;\n\n\tfl_cinfo = cinfo->ds;\n\tbucket = fl_cinfo->buckets;\n\tfor (i = 0; i < fl_cinfo->nbuckets; i++, bucket++) {\n\t\tif (list_empty(&bucket->committing))\n\t\t\tcontinue;\n\t\tdata = nfs_commitdata_alloc();\n\t\tif (!data)\n\t\t\tbreak;\n\t\tdata->ds_commit_index = i;\n\t\tspin_lock(cinfo->lock);\n\t\tdata->lseg = bucket->clseg;\n\t\tbucket->clseg = NULL;\n\t\tspin_unlock(cinfo->lock);\n\t\tlist_add(&data->pages, list);\n\t\tnreq++;\n\t}\n\n\t/* Clean up on error */\n\tpnfs_generic_retry_commit(cinfo, i);\n\treturn nreq;\n}"
  },
  {
    "function_name": "pnfs_generic_retry_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
    "lines": "180-198",
    "snippet": "static void pnfs_generic_retry_commit(struct nfs_commit_info *cinfo, int idx)\n{\n\tstruct pnfs_ds_commit_info *fl_cinfo = cinfo->ds;\n\tstruct pnfs_commit_bucket *bucket;\n\tstruct pnfs_layout_segment *freeme;\n\tint i;\n\n\tfor (i = idx; i < fl_cinfo->nbuckets; i++) {\n\t\tbucket = &fl_cinfo->buckets[i];\n\t\tif (list_empty(&bucket->committing))\n\t\t\tcontinue;\n\t\tnfs_retry_commit(&bucket->committing, bucket->clseg, cinfo, i);\n\t\tspin_lock(cinfo->lock);\n\t\tfreeme = bucket->clseg;\n\t\tbucket->clseg = NULL;\n\t\tspin_unlock(cinfo->lock);\n\t\tpnfs_put_lseg(freeme);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_put_lseg",
          "args": [
            "freeme"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_put_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "545-547",
          "snippet": "static inline void pnfs_put_lseg(struct pnfs_layout_segment *lseg)\n{\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void pnfs_put_lseg(struct pnfs_layout_segment *lseg)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "cinfo->lock"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "cinfo->lock"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_retry_commit",
          "args": [
            "&bucket->committing",
            "bucket->clseg",
            "cinfo",
            "i"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_retry_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1622-1637",
          "snippet": "void nfs_retry_commit(struct list_head *page_list,\n\t\t      struct pnfs_layout_segment *lseg,\n\t\t      struct nfs_commit_info *cinfo,\n\t\t      u32 ds_commit_idx)\n{\n\tstruct nfs_page *req;\n\n\twhile (!list_empty(page_list)) {\n\t\treq = nfs_list_entry(page_list->next);\n\t\tnfs_list_remove_request(req);\n\t\tnfs_mark_request_commit(req, lseg, cinfo, ds_commit_idx);\n\t\tif (!cinfo->dreq)\n\t\t\tnfs_clear_page_commit(req->wb_page);\n\t\tnfs_unlock_and_release_request(req);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nvoid nfs_retry_commit(struct list_head *page_list,\n\t\t      struct pnfs_layout_segment *lseg,\n\t\t      struct nfs_commit_info *cinfo,\n\t\t      u32 ds_commit_idx)\n{\n\tstruct nfs_page *req;\n\n\twhile (!list_empty(page_list)) {\n\t\treq = nfs_list_entry(page_list->next);\n\t\tnfs_list_remove_request(req);\n\t\tnfs_mark_request_commit(req, lseg, cinfo, ds_commit_idx);\n\t\tif (!cinfo->dreq)\n\t\t\tnfs_clear_page_commit(req->wb_page);\n\t\tnfs_unlock_and_release_request(req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&bucket->committing"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void pnfs_generic_retry_commit(struct nfs_commit_info *cinfo, int idx)\n{\n\tstruct pnfs_ds_commit_info *fl_cinfo = cinfo->ds;\n\tstruct pnfs_commit_bucket *bucket;\n\tstruct pnfs_layout_segment *freeme;\n\tint i;\n\n\tfor (i = idx; i < fl_cinfo->nbuckets; i++) {\n\t\tbucket = &fl_cinfo->buckets[i];\n\t\tif (list_empty(&bucket->committing))\n\t\t\tcontinue;\n\t\tnfs_retry_commit(&bucket->committing, bucket->clseg, cinfo, i);\n\t\tspin_lock(cinfo->lock);\n\t\tfreeme = bucket->clseg;\n\t\tbucket->clseg = NULL;\n\t\tspin_unlock(cinfo->lock);\n\t\tpnfs_put_lseg(freeme);\n\t}\n}"
  },
  {
    "function_name": "pnfs_generic_recover_commit_reqs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
    "lines": "156-177",
    "snippet": "void pnfs_generic_recover_commit_reqs(struct list_head *dst,\n\t\t\t\t      struct nfs_commit_info *cinfo)\n{\n\tstruct pnfs_commit_bucket *b;\n\tstruct pnfs_layout_segment *freeme;\n\tint i;\n\n\tlockdep_assert_held(cinfo->lock);\nrestart:\n\tfor (i = 0, b = cinfo->ds->buckets; i < cinfo->ds->nbuckets; i++, b++) {\n\t\tif (pnfs_generic_transfer_commit_list(&b->written, dst,\n\t\t\t\t\t\t      cinfo, 0)) {\n\t\t\tfreeme = b->wlseg;\n\t\t\tb->wlseg = NULL;\n\t\t\tspin_unlock(cinfo->lock);\n\t\t\tpnfs_put_lseg(freeme);\n\t\t\tspin_lock(cinfo->lock);\n\t\t\tgoto restart;\n\t\t}\n\t}\n\tcinfo->ds->nwritten = 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "cinfo->lock"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_put_lseg",
          "args": [
            "freeme"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_put_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "545-547",
          "snippet": "static inline void pnfs_put_lseg(struct pnfs_layout_segment *lseg)\n{\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void pnfs_put_lseg(struct pnfs_layout_segment *lseg)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "cinfo->lock"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_generic_transfer_commit_list",
          "args": [
            "&b->written",
            "dst",
            "cinfo",
            "0"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_generic_transfer_commit_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "90-111",
          "snippet": "static int\npnfs_generic_transfer_commit_list(struct list_head *src, struct list_head *dst,\n\t\t\t\t  struct nfs_commit_info *cinfo, int max)\n{\n\tstruct nfs_page *req, *tmp;\n\tint ret = 0;\n\n\tlist_for_each_entry_safe(req, tmp, src, wb_list) {\n\t\tif (!nfs_lock_request(req))\n\t\t\tcontinue;\n\t\tkref_get(&req->wb_kref);\n\t\tif (cond_resched_lock(cinfo->lock))\n\t\t\tlist_safe_reset_next(req, tmp, wb_list);\n\t\tnfs_request_remove_commit_list(req, cinfo);\n\t\tclear_bit(PG_COMMIT_TO_DS, &req->wb_flags);\n\t\tnfs_list_add_request(req, dst);\n\t\tret++;\n\t\tif ((ret == max) && !cinfo->dreq)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\npnfs_generic_transfer_commit_list(struct list_head *src, struct list_head *dst,\n\t\t\t\t  struct nfs_commit_info *cinfo, int max)\n{\n\tstruct nfs_page *req, *tmp;\n\tint ret = 0;\n\n\tlist_for_each_entry_safe(req, tmp, src, wb_list) {\n\t\tif (!nfs_lock_request(req))\n\t\t\tcontinue;\n\t\tkref_get(&req->wb_kref);\n\t\tif (cond_resched_lock(cinfo->lock))\n\t\t\tlist_safe_reset_next(req, tmp, wb_list);\n\t\tnfs_request_remove_commit_list(req, cinfo);\n\t\tclear_bit(PG_COMMIT_TO_DS, &req->wb_flags);\n\t\tnfs_list_add_request(req, dst);\n\t\tret++;\n\t\tif ((ret == max) && !cinfo->dreq)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "cinfo->lock"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_generic_recover_commit_reqs(struct list_head *dst,\n\t\t\t\t      struct nfs_commit_info *cinfo)\n{\n\tstruct pnfs_commit_bucket *b;\n\tstruct pnfs_layout_segment *freeme;\n\tint i;\n\n\tlockdep_assert_held(cinfo->lock);\nrestart:\n\tfor (i = 0, b = cinfo->ds->buckets; i < cinfo->ds->nbuckets; i++, b++) {\n\t\tif (pnfs_generic_transfer_commit_list(&b->written, dst,\n\t\t\t\t\t\t      cinfo, 0)) {\n\t\t\tfreeme = b->wlseg;\n\t\t\tb->wlseg = NULL;\n\t\t\tspin_unlock(cinfo->lock);\n\t\t\tpnfs_put_lseg(freeme);\n\t\t\tspin_lock(cinfo->lock);\n\t\t\tgoto restart;\n\t\t}\n\t}\n\tcinfo->ds->nwritten = 0;\n}"
  },
  {
    "function_name": "pnfs_generic_scan_commit_lists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
    "lines": "139-152",
    "snippet": "int pnfs_generic_scan_commit_lists(struct nfs_commit_info *cinfo,\n\t\t\t\t   int max)\n{\n\tint i, rv = 0, cnt;\n\n\tlockdep_assert_held(cinfo->lock);\n\tfor (i = 0; i < cinfo->ds->nbuckets && max != 0; i++) {\n\t\tcnt = pnfs_generic_scan_ds_commit_list(&cinfo->ds->buckets[i],\n\t\t\t\t\t\t       cinfo, max);\n\t\tmax -= cnt;\n\t\trv += cnt;\n\t}\n\treturn rv;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_generic_scan_ds_commit_list",
          "args": [
            "&cinfo->ds->buckets[i]",
            "cinfo",
            "max"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_generic_scan_ds_commit_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "113-134",
          "snippet": "static int\npnfs_generic_scan_ds_commit_list(struct pnfs_commit_bucket *bucket,\n\t\t\t\t struct nfs_commit_info *cinfo,\n\t\t\t\t int max)\n{\n\tstruct list_head *src = &bucket->written;\n\tstruct list_head *dst = &bucket->committing;\n\tint ret;\n\n\tlockdep_assert_held(cinfo->lock);\n\tret = pnfs_generic_transfer_commit_list(src, dst, cinfo, max);\n\tif (ret) {\n\t\tcinfo->ds->nwritten -= ret;\n\t\tcinfo->ds->ncommitting += ret;\n\t\tbucket->clseg = bucket->wlseg;\n\t\tif (list_empty(src))\n\t\t\tbucket->wlseg = NULL;\n\t\telse\n\t\t\tpnfs_get_lseg(bucket->clseg);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\npnfs_generic_scan_ds_commit_list(struct pnfs_commit_bucket *bucket,\n\t\t\t\t struct nfs_commit_info *cinfo,\n\t\t\t\t int max)\n{\n\tstruct list_head *src = &bucket->written;\n\tstruct list_head *dst = &bucket->committing;\n\tint ret;\n\n\tlockdep_assert_held(cinfo->lock);\n\tret = pnfs_generic_transfer_commit_list(src, dst, cinfo, max);\n\tif (ret) {\n\t\tcinfo->ds->nwritten -= ret;\n\t\tcinfo->ds->ncommitting += ret;\n\t\tbucket->clseg = bucket->wlseg;\n\t\tif (list_empty(src))\n\t\t\tbucket->wlseg = NULL;\n\t\telse\n\t\t\tpnfs_get_lseg(bucket->clseg);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "cinfo->lock"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint pnfs_generic_scan_commit_lists(struct nfs_commit_info *cinfo,\n\t\t\t\t   int max)\n{\n\tint i, rv = 0, cnt;\n\n\tlockdep_assert_held(cinfo->lock);\n\tfor (i = 0; i < cinfo->ds->nbuckets && max != 0; i++) {\n\t\tcnt = pnfs_generic_scan_ds_commit_list(&cinfo->ds->buckets[i],\n\t\t\t\t\t\t       cinfo, max);\n\t\tmax -= cnt;\n\t\trv += cnt;\n\t}\n\treturn rv;\n}"
  },
  {
    "function_name": "pnfs_generic_scan_ds_commit_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
    "lines": "113-134",
    "snippet": "static int\npnfs_generic_scan_ds_commit_list(struct pnfs_commit_bucket *bucket,\n\t\t\t\t struct nfs_commit_info *cinfo,\n\t\t\t\t int max)\n{\n\tstruct list_head *src = &bucket->written;\n\tstruct list_head *dst = &bucket->committing;\n\tint ret;\n\n\tlockdep_assert_held(cinfo->lock);\n\tret = pnfs_generic_transfer_commit_list(src, dst, cinfo, max);\n\tif (ret) {\n\t\tcinfo->ds->nwritten -= ret;\n\t\tcinfo->ds->ncommitting += ret;\n\t\tbucket->clseg = bucket->wlseg;\n\t\tif (list_empty(src))\n\t\t\tbucket->wlseg = NULL;\n\t\telse\n\t\t\tpnfs_get_lseg(bucket->clseg);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_get_lseg",
          "args": [
            "bucket->clseg"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_get_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "539-543",
          "snippet": "static inline struct pnfs_layout_segment *\npnfs_get_lseg(struct pnfs_layout_segment *lseg)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline struct pnfs_layout_segment *\npnfs_get_lseg(struct pnfs_layout_segment *lseg)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "src"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_generic_transfer_commit_list",
          "args": [
            "src",
            "dst",
            "cinfo",
            "max"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_generic_transfer_commit_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "90-111",
          "snippet": "static int\npnfs_generic_transfer_commit_list(struct list_head *src, struct list_head *dst,\n\t\t\t\t  struct nfs_commit_info *cinfo, int max)\n{\n\tstruct nfs_page *req, *tmp;\n\tint ret = 0;\n\n\tlist_for_each_entry_safe(req, tmp, src, wb_list) {\n\t\tif (!nfs_lock_request(req))\n\t\t\tcontinue;\n\t\tkref_get(&req->wb_kref);\n\t\tif (cond_resched_lock(cinfo->lock))\n\t\t\tlist_safe_reset_next(req, tmp, wb_list);\n\t\tnfs_request_remove_commit_list(req, cinfo);\n\t\tclear_bit(PG_COMMIT_TO_DS, &req->wb_flags);\n\t\tnfs_list_add_request(req, dst);\n\t\tret++;\n\t\tif ((ret == max) && !cinfo->dreq)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\npnfs_generic_transfer_commit_list(struct list_head *src, struct list_head *dst,\n\t\t\t\t  struct nfs_commit_info *cinfo, int max)\n{\n\tstruct nfs_page *req, *tmp;\n\tint ret = 0;\n\n\tlist_for_each_entry_safe(req, tmp, src, wb_list) {\n\t\tif (!nfs_lock_request(req))\n\t\t\tcontinue;\n\t\tkref_get(&req->wb_kref);\n\t\tif (cond_resched_lock(cinfo->lock))\n\t\t\tlist_safe_reset_next(req, tmp, wb_list);\n\t\tnfs_request_remove_commit_list(req, cinfo);\n\t\tclear_bit(PG_COMMIT_TO_DS, &req->wb_flags);\n\t\tnfs_list_add_request(req, dst);\n\t\tret++;\n\t\tif ((ret == max) && !cinfo->dreq)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "cinfo->lock"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\npnfs_generic_scan_ds_commit_list(struct pnfs_commit_bucket *bucket,\n\t\t\t\t struct nfs_commit_info *cinfo,\n\t\t\t\t int max)\n{\n\tstruct list_head *src = &bucket->written;\n\tstruct list_head *dst = &bucket->committing;\n\tint ret;\n\n\tlockdep_assert_held(cinfo->lock);\n\tret = pnfs_generic_transfer_commit_list(src, dst, cinfo, max);\n\tif (ret) {\n\t\tcinfo->ds->nwritten -= ret;\n\t\tcinfo->ds->ncommitting += ret;\n\t\tbucket->clseg = bucket->wlseg;\n\t\tif (list_empty(src))\n\t\t\tbucket->wlseg = NULL;\n\t\telse\n\t\t\tpnfs_get_lseg(bucket->clseg);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "pnfs_generic_transfer_commit_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
    "lines": "90-111",
    "snippet": "static int\npnfs_generic_transfer_commit_list(struct list_head *src, struct list_head *dst,\n\t\t\t\t  struct nfs_commit_info *cinfo, int max)\n{\n\tstruct nfs_page *req, *tmp;\n\tint ret = 0;\n\n\tlist_for_each_entry_safe(req, tmp, src, wb_list) {\n\t\tif (!nfs_lock_request(req))\n\t\t\tcontinue;\n\t\tkref_get(&req->wb_kref);\n\t\tif (cond_resched_lock(cinfo->lock))\n\t\t\tlist_safe_reset_next(req, tmp, wb_list);\n\t\tnfs_request_remove_commit_list(req, cinfo);\n\t\tclear_bit(PG_COMMIT_TO_DS, &req->wb_flags);\n\t\tnfs_list_add_request(req, dst);\n\t\tret++;\n\t\tif ((ret == max) && !cinfo->dreq)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_list_add_request",
          "args": [
            "req",
            "dst"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "PG_COMMIT_TO_DS",
            "&req->wb_flags"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_request_remove_commit_list",
          "args": [
            "req",
            "cinfo"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_request_remove_commit_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "808-816",
          "snippet": "void\nnfs_request_remove_commit_list(struct nfs_page *req,\n\t\t\t       struct nfs_commit_info *cinfo)\n{\n\tif (!test_and_clear_bit(PG_CLEAN, &(req)->wb_flags))\n\t\treturn;\n\tnfs_list_remove_request(req);\n\tcinfo->mds->ncommit--;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nvoid\nnfs_request_remove_commit_list(struct nfs_page *req,\n\t\t\t       struct nfs_commit_info *cinfo)\n{\n\tif (!test_and_clear_bit(PG_CLEAN, &(req)->wb_flags))\n\t\treturn;\n\tnfs_list_remove_request(req);\n\tcinfo->mds->ncommit--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_safe_reset_next",
          "args": [
            "req",
            "tmp",
            "wb_list"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched_lock",
          "args": [
            "cinfo->lock"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&req->wb_kref"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_lock_request",
          "args": [
            "req"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "req",
            "tmp",
            "src",
            "wb_list"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\npnfs_generic_transfer_commit_list(struct list_head *src, struct list_head *dst,\n\t\t\t\t  struct nfs_commit_info *cinfo, int max)\n{\n\tstruct nfs_page *req, *tmp;\n\tint ret = 0;\n\n\tlist_for_each_entry_safe(req, tmp, src, wb_list) {\n\t\tif (!nfs_lock_request(req))\n\t\t\tcontinue;\n\t\tkref_get(&req->wb_kref);\n\t\tif (cond_resched_lock(cinfo->lock))\n\t\t\tlist_safe_reset_next(req, tmp, wb_list);\n\t\tnfs_request_remove_commit_list(req, cinfo);\n\t\tclear_bit(PG_COMMIT_TO_DS, &req->wb_flags);\n\t\tnfs_list_add_request(req, dst);\n\t\tret++;\n\t\tif ((ret == max) && !cinfo->dreq)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "pnfs_generic_clear_request_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
    "lines": "66-87",
    "snippet": "void\npnfs_generic_clear_request_commit(struct nfs_page *req,\n\t\t\t\t  struct nfs_commit_info *cinfo)\n{\n\tstruct pnfs_layout_segment *freeme = NULL;\n\n\tif (!test_and_clear_bit(PG_COMMIT_TO_DS, &req->wb_flags))\n\t\tgoto out;\n\tcinfo->ds->nwritten--;\n\tif (list_is_singular(&req->wb_list)) {\n\t\tstruct pnfs_commit_bucket *bucket;\n\n\t\tbucket = list_first_entry(&req->wb_list,\n\t\t\t\t\t  struct pnfs_commit_bucket,\n\t\t\t\t\t  written);\n\t\tfreeme = bucket->wlseg;\n\t\tbucket->wlseg = NULL;\n\t}\nout:\n\tnfs_request_remove_commit_list(req, cinfo);\n\tpnfs_put_lseg_locked(freeme);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_put_lseg_locked",
          "args": [
            "freeme"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_put_lseg_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "440-457",
          "snippet": "void\npnfs_put_lseg_locked(struct pnfs_layout_segment *lseg)\n{\n\tif (!lseg)\n\t\treturn;\n\n\tassert_spin_locked(&lseg->pls_layout->plh_inode->i_lock);\n\n\tdprintk(\"%s: lseg %p ref %d valid %d\\n\", __func__, lseg,\n\t\tatomic_read(&lseg->pls_refcount),\n\t\ttest_bit(NFS_LSEG_VALID, &lseg->pls_flags));\n\tif (atomic_dec_and_test(&lseg->pls_refcount)) {\n\t\tstruct pnfs_layout_hdr *lo = lseg->pls_layout;\n\t\tpnfs_get_layout_hdr(lo);\n\t\tpnfs_layout_remove_lseg(lo, lseg);\n\t\tpnfs_free_lseg_async(lseg);\n\t}\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_put_lseg_locked(struct pnfs_layout_segment *lseg)\n{\n\tif (!lseg)\n\t\treturn;\n\n\tassert_spin_locked(&lseg->pls_layout->plh_inode->i_lock);\n\n\tdprintk(\"%s: lseg %p ref %d valid %d\\n\", __func__, lseg,\n\t\tatomic_read(&lseg->pls_refcount),\n\t\ttest_bit(NFS_LSEG_VALID, &lseg->pls_flags));\n\tif (atomic_dec_and_test(&lseg->pls_refcount)) {\n\t\tstruct pnfs_layout_hdr *lo = lseg->pls_layout;\n\t\tpnfs_get_layout_hdr(lo);\n\t\tpnfs_layout_remove_lseg(lo, lseg);\n\t\tpnfs_free_lseg_async(lseg);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_request_remove_commit_list",
          "args": [
            "req",
            "cinfo"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_request_remove_commit_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "808-816",
          "snippet": "void\nnfs_request_remove_commit_list(struct nfs_page *req,\n\t\t\t       struct nfs_commit_info *cinfo)\n{\n\tif (!test_and_clear_bit(PG_CLEAN, &(req)->wb_flags))\n\t\treturn;\n\tnfs_list_remove_request(req);\n\tcinfo->mds->ncommit--;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nvoid\nnfs_request_remove_commit_list(struct nfs_page *req,\n\t\t\t       struct nfs_commit_info *cinfo)\n{\n\tif (!test_and_clear_bit(PG_CLEAN, &(req)->wb_flags))\n\t\treturn;\n\tnfs_list_remove_request(req);\n\tcinfo->mds->ncommit--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&req->wb_list",
            "structpnfs_commit_bucket",
            "written"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_is_singular",
          "args": [
            "&req->wb_list"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "PG_COMMIT_TO_DS",
            "&req->wb_flags"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_generic_clear_request_commit(struct nfs_page *req,\n\t\t\t\t  struct nfs_commit_info *cinfo)\n{\n\tstruct pnfs_layout_segment *freeme = NULL;\n\n\tif (!test_and_clear_bit(PG_COMMIT_TO_DS, &req->wb_flags))\n\t\tgoto out;\n\tcinfo->ds->nwritten--;\n\tif (list_is_singular(&req->wb_list)) {\n\t\tstruct pnfs_commit_bucket *bucket;\n\n\t\tbucket = list_first_entry(&req->wb_list,\n\t\t\t\t\t  struct pnfs_commit_bucket,\n\t\t\t\t\t  written);\n\t\tfreeme = bucket->wlseg;\n\t\tbucket->wlseg = NULL;\n\t}\nout:\n\tnfs_request_remove_commit_list(req, cinfo);\n\tpnfs_put_lseg_locked(freeme);\n}"
  },
  {
    "function_name": "pnfs_generic_commit_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
    "lines": "51-59",
    "snippet": "void pnfs_generic_commit_release(void *calldata)\n{\n\tstruct nfs_commit_data *data = calldata;\n\n\tdata->completion_ops->completion(data);\n\tpnfs_put_lseg(data->lseg);\n\tnfs_put_client(data->ds_clp);\n\tnfs_commitdata_release(data);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_commitdata_release",
          "args": [
            "data"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_commitdata_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1526-1530",
          "snippet": "void nfs_commitdata_release(struct nfs_commit_data *data)\n{\n\tput_nfs_open_context(data->context);\n\tnfs_commit_free(data);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid nfs_commitdata_release(struct nfs_commit_data *data)\n{\n\tput_nfs_open_context(data->context);\n\tnfs_commit_free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_put_client",
          "args": [
            "data->ds_clp"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_put_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/client.c",
          "lines": "267-286",
          "snippet": "void nfs_put_client(struct nfs_client *clp)\n{\n\tstruct nfs_net *nn;\n\n\tif (!clp)\n\t\treturn;\n\n\tdprintk(\"--> nfs_put_client({%d})\\n\", atomic_read(&clp->cl_count));\n\tnn = net_generic(clp->cl_net, nfs_net_id);\n\n\tif (atomic_dec_and_lock(&clp->cl_count, &nn->nfs_client_lock)) {\n\t\tlist_del(&clp->cl_share_link);\n\t\tnfs_cb_idr_remove_locked(clp);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\tWARN_ON_ONCE(!list_empty(&clp->cl_superblocks));\n\n\t\tclp->rpc_ops->free_client(clp);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <net/ipv6.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/xprtrdma.h>",
            "#include <linux/sunrpc/xprtsock.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/nfs_xdr.h>\n#include <net/ipv6.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/nfs_idmap.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/xprtrdma.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid nfs_put_client(struct nfs_client *clp)\n{\n\tstruct nfs_net *nn;\n\n\tif (!clp)\n\t\treturn;\n\n\tdprintk(\"--> nfs_put_client({%d})\\n\", atomic_read(&clp->cl_count));\n\tnn = net_generic(clp->cl_net, nfs_net_id);\n\n\tif (atomic_dec_and_lock(&clp->cl_count, &nn->nfs_client_lock)) {\n\t\tlist_del(&clp->cl_share_link);\n\t\tnfs_cb_idr_remove_locked(clp);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\tWARN_ON_ONCE(!list_empty(&clp->cl_superblocks));\n\n\t\tclp->rpc_ops->free_client(clp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_put_lseg",
          "args": [
            "data->lseg"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_put_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "545-547",
          "snippet": "static inline void pnfs_put_lseg(struct pnfs_layout_segment *lseg)\n{\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void pnfs_put_lseg(struct pnfs_layout_segment *lseg)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "data->completion_ops->completion",
          "args": [
            "data"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_generic_commit_release(void *calldata)\n{\n\tstruct nfs_commit_data *data = calldata;\n\n\tdata->completion_ops->completion(data);\n\tpnfs_put_lseg(data->lseg);\n\tnfs_put_client(data->ds_clp);\n\tnfs_commitdata_release(data);\n}"
  },
  {
    "function_name": "pnfs_generic_write_commit_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
    "lines": "42-48",
    "snippet": "void pnfs_generic_write_commit_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs_commit_data *wdata = data;\n\n\t/* Note this may cause RPC to be resent */\n\twdata->mds_ops->rpc_call_done(task, data);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wdata->mds_ops->rpc_call_done",
          "args": [
            "task",
            "data"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_generic_write_commit_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs_commit_data *wdata = data;\n\n\t/* Note this may cause RPC to be resent */\n\twdata->mds_ops->rpc_call_done(task, data);\n}"
  },
  {
    "function_name": "pnfs_generic_prepare_to_resend_writes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
    "lines": "31-39",
    "snippet": "void pnfs_generic_prepare_to_resend_writes(struct nfs_commit_data *data)\n{\n\tstruct nfs_page *first = nfs_list_entry(data->pages.next);\n\n\tdata->task.tk_status = 0;\n\tmemcpy(&data->verf.verifier, &first->wb_verf,\n\t       sizeof(data->verf.verifier));\n\tdata->verf.verifier.data[0]++; /* ensure verifier mismatch */\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&data->verf.verifier",
            "&first->wb_verf",
            "sizeof(data->verf.verifier)"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_list_entry",
          "args": [
            "data->pages.next"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_generic_prepare_to_resend_writes(struct nfs_commit_data *data)\n{\n\tstruct nfs_page *first = nfs_list_entry(data->pages.next);\n\n\tdata->task.tk_status = 0;\n\tmemcpy(&data->verf.verifier, &first->wb_verf,\n\t       sizeof(data->verf.verifier));\n\tdata->verf.verifier.data[0]++; /* ensure verifier mismatch */\n}"
  },
  {
    "function_name": "pnfs_generic_rw_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
    "lines": "21-27",
    "snippet": "void pnfs_generic_rw_release(void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\tnfs_put_client(hdr->ds_clp);\n\thdr->mds_ops->rpc_release(data);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hdr->mds_ops->rpc_release",
          "args": [
            "data"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_put_client",
          "args": [
            "hdr->ds_clp"
          ],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_put_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/client.c",
          "lines": "267-286",
          "snippet": "void nfs_put_client(struct nfs_client *clp)\n{\n\tstruct nfs_net *nn;\n\n\tif (!clp)\n\t\treturn;\n\n\tdprintk(\"--> nfs_put_client({%d})\\n\", atomic_read(&clp->cl_count));\n\tnn = net_generic(clp->cl_net, nfs_net_id);\n\n\tif (atomic_dec_and_lock(&clp->cl_count, &nn->nfs_client_lock)) {\n\t\tlist_del(&clp->cl_share_link);\n\t\tnfs_cb_idr_remove_locked(clp);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\tWARN_ON_ONCE(!list_empty(&clp->cl_superblocks));\n\n\t\tclp->rpc_ops->free_client(clp);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <net/ipv6.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/xprtrdma.h>",
            "#include <linux/sunrpc/xprtsock.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/nfs_xdr.h>\n#include <net/ipv6.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/nfs_idmap.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/xprtrdma.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid nfs_put_client(struct nfs_client *clp)\n{\n\tstruct nfs_net *nn;\n\n\tif (!clp)\n\t\treturn;\n\n\tdprintk(\"--> nfs_put_client({%d})\\n\", atomic_read(&clp->cl_count));\n\tnn = net_generic(clp->cl_net, nfs_net_id);\n\n\tif (atomic_dec_and_lock(&clp->cl_count, &nn->nfs_client_lock)) {\n\t\tlist_del(&clp->cl_share_link);\n\t\tnfs_cb_idr_remove_locked(clp);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\tWARN_ON_ONCE(!list_empty(&clp->cl_superblocks));\n\n\t\tclp->rpc_ops->free_client(clp);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_generic_rw_release(void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\tnfs_put_client(hdr->ds_clp);\n\thdr->mds_ops->rpc_release(data);\n}"
  }
]