[
  {
    "function_name": "afs_vlocation_updater",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
    "lines": "621-718",
    "snippet": "static void afs_vlocation_updater(struct work_struct *work)\n{\n\tstruct afs_cache_vlocation vldb;\n\tstruct afs_vlocation *vl, *xvl;\n\ttime_t now;\n\tlong timeout;\n\tint ret;\n\n\t_enter(\"\");\n\n\tnow = get_seconds();\n\n\t/* find a record to update */\n\tspin_lock(&afs_vlocation_updates_lock);\n\tfor (;;) {\n\t\tif (list_empty(&afs_vlocation_updates)) {\n\t\t\tspin_unlock(&afs_vlocation_updates_lock);\n\t\t\t_leave(\" [nothing]\");\n\t\t\treturn;\n\t\t}\n\n\t\tvl = list_entry(afs_vlocation_updates.next,\n\t\t\t\tstruct afs_vlocation, update);\n\t\tif (atomic_read(&vl->usage) > 0)\n\t\t\tbreak;\n\t\tlist_del_init(&vl->update);\n\t}\n\n\ttimeout = vl->update_at - now;\n\tif (timeout > 0) {\n\t\tqueue_delayed_work(afs_vlocation_update_worker,\n\t\t\t\t   &afs_vlocation_update, timeout * HZ);\n\t\tspin_unlock(&afs_vlocation_updates_lock);\n\t\t_leave(\" [nothing]\");\n\t\treturn;\n\t}\n\n\tlist_del_init(&vl->update);\n\tatomic_inc(&vl->usage);\n\tspin_unlock(&afs_vlocation_updates_lock);\n\n\t/* we can now perform the update */\n\t_debug(\"update %s\", vl->vldb.name);\n\tvl->state = AFS_VL_UPDATING;\n\tvl->upd_rej_cnt = 0;\n\tvl->upd_busy_cnt = 0;\n\n\tret = afs_vlocation_update_record(vl, NULL, &vldb);\n\tspin_lock(&vl->lock);\n\tswitch (ret) {\n\tcase 0:\n\t\tafs_vlocation_apply_update(vl, &vldb);\n\t\tvl->state = AFS_VL_VALID;\n\t\tbreak;\n\tcase -ENOMEDIUM:\n\t\tvl->state = AFS_VL_VOLUME_DELETED;\n\t\tbreak;\n\tdefault:\n\t\tvl->state = AFS_VL_UNCERTAIN;\n\t\tbreak;\n\t}\n\tspin_unlock(&vl->lock);\n\twake_up(&vl->waitq);\n\n\t/* and then reschedule */\n\t_debug(\"reschedule\");\n\tvl->update_at = get_seconds() + afs_vlocation_update_timeout;\n\n\tspin_lock(&afs_vlocation_updates_lock);\n\n\tif (!list_empty(&afs_vlocation_updates)) {\n\t\t/* next update in 10 minutes, but wait at least 1 second more\n\t\t * than the newest record already queued so that we don't spam\n\t\t * the VL server suddenly with lots of requests\n\t\t */\n\t\txvl = list_entry(afs_vlocation_updates.prev,\n\t\t\t\t struct afs_vlocation, update);\n\t\tif (vl->update_at <= xvl->update_at)\n\t\t\tvl->update_at = xvl->update_at + 1;\n\t\txvl = list_entry(afs_vlocation_updates.next,\n\t\t\t\t struct afs_vlocation, update);\n\t\ttimeout = xvl->update_at - now;\n\t\tif (timeout < 0)\n\t\t\ttimeout = 0;\n\t} else {\n\t\ttimeout = afs_vlocation_update_timeout;\n\t}\n\n\tASSERT(list_empty(&vl->update));\n\n\tlist_add_tail(&vl->update, &afs_vlocation_updates);\n\n\t_debug(\"timeout %ld\", timeout);\n\tqueue_delayed_work(afs_vlocation_update_worker,\n\t\t\t   &afs_vlocation_update, timeout * HZ);\n\tspin_unlock(&afs_vlocation_updates_lock);\n\tafs_put_vlocation(vl);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned afs_vlocation_update_timeout = 10 * 60;",
      "static void afs_vlocation_reaper(struct work_struct *);",
      "static void afs_vlocation_updater(struct work_struct *);",
      "static LIST_HEAD(afs_vlocation_updates);",
      "static DEFINE_SPINLOCK(afs_vlocation_updates_lock);",
      "static DECLARE_DELAYED_WORK(afs_vlocation_update, afs_vlocation_updater);",
      "static struct workqueue_struct *afs_vlocation_update_worker;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_put_vlocation",
          "args": [
            "vl"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_vlocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
          "lines": "491-522",
          "snippet": "void afs_put_vlocation(struct afs_vlocation *vl)\n{\n\tif (!vl)\n\t\treturn;\n\n\t_enter(\"%s\", vl->vldb.name);\n\n\tASSERTCMP(atomic_read(&vl->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&vl->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tspin_lock(&afs_vlocation_graveyard_lock);\n\tif (atomic_read(&vl->usage) == 0) {\n\t\t_debug(\"buried\");\n\t\tlist_move_tail(&vl->grave, &afs_vlocation_graveyard);\n\t\tvl->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_vlocation_reap,\n\t\t\t\t   afs_vlocation_timeout * HZ);\n\n\t\t/* suspend updates on this record */\n\t\tif (!list_empty(&vl->update)) {\n\t\t\tspin_lock(&afs_vlocation_updates_lock);\n\t\t\tlist_del_init(&vl->update);\n\t\t\tspin_unlock(&afs_vlocation_updates_lock);\n\t\t}\n\t}\n\tspin_unlock(&afs_vlocation_graveyard_lock);\n\t_leave(\" [killed?]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_vlocation_timeout = 10;",
            "static LIST_HEAD(afs_vlocation_graveyard);",
            "static DEFINE_SPINLOCK(afs_vlocation_updates_lock);",
            "static DEFINE_SPINLOCK(afs_vlocation_graveyard_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic unsigned afs_vlocation_timeout = 10;\nstatic LIST_HEAD(afs_vlocation_graveyard);\nstatic DEFINE_SPINLOCK(afs_vlocation_updates_lock);\nstatic DEFINE_SPINLOCK(afs_vlocation_graveyard_lock);\n\nvoid afs_put_vlocation(struct afs_vlocation *vl)\n{\n\tif (!vl)\n\t\treturn;\n\n\t_enter(\"%s\", vl->vldb.name);\n\n\tASSERTCMP(atomic_read(&vl->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&vl->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tspin_lock(&afs_vlocation_graveyard_lock);\n\tif (atomic_read(&vl->usage) == 0) {\n\t\t_debug(\"buried\");\n\t\tlist_move_tail(&vl->grave, &afs_vlocation_graveyard);\n\t\tvl->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_vlocation_reap,\n\t\t\t\t   afs_vlocation_timeout * HZ);\n\n\t\t/* suspend updates on this record */\n\t\tif (!list_empty(&vl->update)) {\n\t\t\tspin_lock(&afs_vlocation_updates_lock);\n\t\t\tlist_del_init(&vl->update);\n\t\t\tspin_unlock(&afs_vlocation_updates_lock);\n\t\t}\n\t}\n\tspin_unlock(&afs_vlocation_graveyard_lock);\n\t_leave(\" [killed?]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&afs_vlocation_updates_lock"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "afs_vlocation_update_worker",
            "&afs_vlocation_update",
            "timeout * HZ"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"timeout %ld\"",
            "timeout"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&vl->update",
            "&afs_vlocation_updates"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "list_empty(&vl->update)"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&vl->update"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "afs_vlocation_updates.next",
            "structafs_vlocation",
            "update"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "afs_vlocation_updates.prev",
            "structafs_vlocation",
            "update"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&afs_vlocation_updates_lock"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"reschedule\""
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&vl->waitq"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "afs_wake_up_async_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "606-610",
          "snippet": "static void afs_wake_up_async_call(struct afs_call *call)\n{\n\t_enter(\"\");\n\tqueue_work(afs_async_calls, &call->async_work);\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *afs_async_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct workqueue_struct *afs_async_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstatic void afs_wake_up_async_call(struct afs_call *call)\n{\n\t_enter(\"\");\n\tqueue_work(afs_async_calls, &call->async_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vlocation_apply_update",
          "args": [
            "vl",
            "&vldb"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vlocation_apply_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
          "lines": "267-289",
          "snippet": "static void afs_vlocation_apply_update(struct afs_vlocation *vl,\n\t\t\t\t       struct afs_cache_vlocation *vldb)\n{\n\t_debug(\"Done VL Lookup: %s %02x { %08x(%x) %08x(%x) %08x(%x) }\",\n\t       vldb->name, vldb->vidmask,\n\t       ntohl(vldb->servers[0].s_addr), vldb->srvtmask[0],\n\t       ntohl(vldb->servers[1].s_addr), vldb->srvtmask[1],\n\t       ntohl(vldb->servers[2].s_addr), vldb->srvtmask[2]);\n\n\t_debug(\"Vids: %08x %08x %08x\",\n\t       vldb->vid[0], vldb->vid[1], vldb->vid[2]);\n\n\tif (strcmp(vldb->name, vl->vldb.name) != 0)\n\t\tprintk(KERN_NOTICE \"kAFS:\"\n\t\t       \" name of volume '%s' changed to '%s' on server\\n\",\n\t\t       vl->vldb.name, vldb->name);\n\n\tvl->vldb = *vldb;\n\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_update_cookie(vl->cache);\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_vlocation_apply_update(struct afs_vlocation *vl,\n\t\t\t\t       struct afs_cache_vlocation *vldb)\n{\n\t_debug(\"Done VL Lookup: %s %02x { %08x(%x) %08x(%x) %08x(%x) }\",\n\t       vldb->name, vldb->vidmask,\n\t       ntohl(vldb->servers[0].s_addr), vldb->srvtmask[0],\n\t       ntohl(vldb->servers[1].s_addr), vldb->srvtmask[1],\n\t       ntohl(vldb->servers[2].s_addr), vldb->srvtmask[2]);\n\n\t_debug(\"Vids: %08x %08x %08x\",\n\t       vldb->vid[0], vldb->vid[1], vldb->vid[2]);\n\n\tif (strcmp(vldb->name, vl->vldb.name) != 0)\n\t\tprintk(KERN_NOTICE \"kAFS:\"\n\t\t       \" name of volume '%s' changed to '%s' on server\\n\",\n\t\t       vl->vldb.name, vldb->name);\n\n\tvl->vldb = *vldb;\n\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_update_cookie(vl->cache);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vlocation_update_record",
          "args": [
            "vl",
            "NULL",
            "&vldb"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vlocation_update_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
          "lines": "195-262",
          "snippet": "static int afs_vlocation_update_record(struct afs_vlocation *vl,\n\t\t\t\t       struct key *key,\n\t\t\t\t       struct afs_cache_vlocation *vldb)\n{\n\tafs_voltype_t voltype;\n\tafs_volid_t vid;\n\tint ret;\n\n\t/* try to look up a cached volume in the cell VL databases by ID */\n\t_debug(\"Locally Cached: %s %02x { %08x(%x) %08x(%x) %08x(%x) }\",\n\t       vl->vldb.name,\n\t       vl->vldb.vidmask,\n\t       ntohl(vl->vldb.servers[0].s_addr),\n\t       vl->vldb.srvtmask[0],\n\t       ntohl(vl->vldb.servers[1].s_addr),\n\t       vl->vldb.srvtmask[1],\n\t       ntohl(vl->vldb.servers[2].s_addr),\n\t       vl->vldb.srvtmask[2]);\n\n\t_debug(\"Vids: %08x %08x %08x\",\n\t       vl->vldb.vid[0],\n\t       vl->vldb.vid[1],\n\t       vl->vldb.vid[2]);\n\n\tif (vl->vldb.vidmask & AFS_VOL_VTM_RW) {\n\t\tvid = vl->vldb.vid[0];\n\t\tvoltype = AFSVL_RWVOL;\n\t} else if (vl->vldb.vidmask & AFS_VOL_VTM_RO) {\n\t\tvid = vl->vldb.vid[1];\n\t\tvoltype = AFSVL_ROVOL;\n\t} else if (vl->vldb.vidmask & AFS_VOL_VTM_BAK) {\n\t\tvid = vl->vldb.vid[2];\n\t\tvoltype = AFSVL_BACKVOL;\n\t} else {\n\t\tBUG();\n\t\tvid = 0;\n\t\tvoltype = 0;\n\t}\n\n\t/* contact the server to make sure the volume is still available\n\t * - TODO: need to handle disconnected operation here\n\t */\n\tret = afs_vlocation_access_vl_by_id(vl, key, vid, voltype, vldb);\n\tswitch (ret) {\n\t\t/* net error */\n\tdefault:\n\t\tprintk(KERN_WARNING \"kAFS:\"\n\t\t       \" failed to update volume '%s' (%x) up in '%s': %d\\n\",\n\t\t       vl->vldb.name, vid, vl->cell->name, ret);\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\n\t\t/* pulled from local cache into memory */\n\tcase 0:\n\t\t_leave(\" = 0\");\n\t\treturn 0;\n\n\t\t/* uh oh... looks like the volume got deleted */\n\tcase -ENOMEDIUM:\n\t\tprintk(KERN_ERR \"kAFS:\"\n\t\t       \" volume '%s' (%x) does not exist '%s'\\n\",\n\t\t       vl->vldb.name, vid, vl->cell->name);\n\n\t\t/* TODO: make existing record unavailable */\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_vlocation_update_record(struct afs_vlocation *vl,\n\t\t\t\t       struct key *key,\n\t\t\t\t       struct afs_cache_vlocation *vldb)\n{\n\tafs_voltype_t voltype;\n\tafs_volid_t vid;\n\tint ret;\n\n\t/* try to look up a cached volume in the cell VL databases by ID */\n\t_debug(\"Locally Cached: %s %02x { %08x(%x) %08x(%x) %08x(%x) }\",\n\t       vl->vldb.name,\n\t       vl->vldb.vidmask,\n\t       ntohl(vl->vldb.servers[0].s_addr),\n\t       vl->vldb.srvtmask[0],\n\t       ntohl(vl->vldb.servers[1].s_addr),\n\t       vl->vldb.srvtmask[1],\n\t       ntohl(vl->vldb.servers[2].s_addr),\n\t       vl->vldb.srvtmask[2]);\n\n\t_debug(\"Vids: %08x %08x %08x\",\n\t       vl->vldb.vid[0],\n\t       vl->vldb.vid[1],\n\t       vl->vldb.vid[2]);\n\n\tif (vl->vldb.vidmask & AFS_VOL_VTM_RW) {\n\t\tvid = vl->vldb.vid[0];\n\t\tvoltype = AFSVL_RWVOL;\n\t} else if (vl->vldb.vidmask & AFS_VOL_VTM_RO) {\n\t\tvid = vl->vldb.vid[1];\n\t\tvoltype = AFSVL_ROVOL;\n\t} else if (vl->vldb.vidmask & AFS_VOL_VTM_BAK) {\n\t\tvid = vl->vldb.vid[2];\n\t\tvoltype = AFSVL_BACKVOL;\n\t} else {\n\t\tBUG();\n\t\tvid = 0;\n\t\tvoltype = 0;\n\t}\n\n\t/* contact the server to make sure the volume is still available\n\t * - TODO: need to handle disconnected operation here\n\t */\n\tret = afs_vlocation_access_vl_by_id(vl, key, vid, voltype, vldb);\n\tswitch (ret) {\n\t\t/* net error */\n\tdefault:\n\t\tprintk(KERN_WARNING \"kAFS:\"\n\t\t       \" failed to update volume '%s' (%x) up in '%s': %d\\n\",\n\t\t       vl->vldb.name, vid, vl->cell->name, ret);\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\n\t\t/* pulled from local cache into memory */\n\tcase 0:\n\t\t_leave(\" = 0\");\n\t\treturn 0;\n\n\t\t/* uh oh... looks like the volume got deleted */\n\tcase -ENOMEDIUM:\n\t\tprintk(KERN_ERR \"kAFS:\"\n\t\t       \" volume '%s' (%x) does not exist '%s'\\n\",\n\t\t       vl->vldb.name, vid, vl->cell->name);\n\n\t\t/* TODO: make existing record unavailable */\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&vl->usage"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&vl->update"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" [nothing]\""
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&vl->update"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&vl->usage"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "afs_vlocation_updates.next",
            "structafs_vlocation",
            "update"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic unsigned afs_vlocation_update_timeout = 10 * 60;\nstatic void afs_vlocation_reaper(struct work_struct *);\nstatic void afs_vlocation_updater(struct work_struct *);\nstatic LIST_HEAD(afs_vlocation_updates);\nstatic DEFINE_SPINLOCK(afs_vlocation_updates_lock);\nstatic DECLARE_DELAYED_WORK(afs_vlocation_update, afs_vlocation_updater);\nstatic struct workqueue_struct *afs_vlocation_update_worker;\n\nstatic void afs_vlocation_updater(struct work_struct *work)\n{\n\tstruct afs_cache_vlocation vldb;\n\tstruct afs_vlocation *vl, *xvl;\n\ttime_t now;\n\tlong timeout;\n\tint ret;\n\n\t_enter(\"\");\n\n\tnow = get_seconds();\n\n\t/* find a record to update */\n\tspin_lock(&afs_vlocation_updates_lock);\n\tfor (;;) {\n\t\tif (list_empty(&afs_vlocation_updates)) {\n\t\t\tspin_unlock(&afs_vlocation_updates_lock);\n\t\t\t_leave(\" [nothing]\");\n\t\t\treturn;\n\t\t}\n\n\t\tvl = list_entry(afs_vlocation_updates.next,\n\t\t\t\tstruct afs_vlocation, update);\n\t\tif (atomic_read(&vl->usage) > 0)\n\t\t\tbreak;\n\t\tlist_del_init(&vl->update);\n\t}\n\n\ttimeout = vl->update_at - now;\n\tif (timeout > 0) {\n\t\tqueue_delayed_work(afs_vlocation_update_worker,\n\t\t\t\t   &afs_vlocation_update, timeout * HZ);\n\t\tspin_unlock(&afs_vlocation_updates_lock);\n\t\t_leave(\" [nothing]\");\n\t\treturn;\n\t}\n\n\tlist_del_init(&vl->update);\n\tatomic_inc(&vl->usage);\n\tspin_unlock(&afs_vlocation_updates_lock);\n\n\t/* we can now perform the update */\n\t_debug(\"update %s\", vl->vldb.name);\n\tvl->state = AFS_VL_UPDATING;\n\tvl->upd_rej_cnt = 0;\n\tvl->upd_busy_cnt = 0;\n\n\tret = afs_vlocation_update_record(vl, NULL, &vldb);\n\tspin_lock(&vl->lock);\n\tswitch (ret) {\n\tcase 0:\n\t\tafs_vlocation_apply_update(vl, &vldb);\n\t\tvl->state = AFS_VL_VALID;\n\t\tbreak;\n\tcase -ENOMEDIUM:\n\t\tvl->state = AFS_VL_VOLUME_DELETED;\n\t\tbreak;\n\tdefault:\n\t\tvl->state = AFS_VL_UNCERTAIN;\n\t\tbreak;\n\t}\n\tspin_unlock(&vl->lock);\n\twake_up(&vl->waitq);\n\n\t/* and then reschedule */\n\t_debug(\"reschedule\");\n\tvl->update_at = get_seconds() + afs_vlocation_update_timeout;\n\n\tspin_lock(&afs_vlocation_updates_lock);\n\n\tif (!list_empty(&afs_vlocation_updates)) {\n\t\t/* next update in 10 minutes, but wait at least 1 second more\n\t\t * than the newest record already queued so that we don't spam\n\t\t * the VL server suddenly with lots of requests\n\t\t */\n\t\txvl = list_entry(afs_vlocation_updates.prev,\n\t\t\t\t struct afs_vlocation, update);\n\t\tif (vl->update_at <= xvl->update_at)\n\t\t\tvl->update_at = xvl->update_at + 1;\n\t\txvl = list_entry(afs_vlocation_updates.next,\n\t\t\t\t struct afs_vlocation, update);\n\t\ttimeout = xvl->update_at - now;\n\t\tif (timeout < 0)\n\t\t\ttimeout = 0;\n\t} else {\n\t\ttimeout = afs_vlocation_update_timeout;\n\t}\n\n\tASSERT(list_empty(&vl->update));\n\n\tlist_add_tail(&vl->update, &afs_vlocation_updates);\n\n\t_debug(\"timeout %ld\", timeout);\n\tqueue_delayed_work(afs_vlocation_update_worker,\n\t\t\t   &afs_vlocation_update, timeout * HZ);\n\tspin_unlock(&afs_vlocation_updates_lock);\n\tafs_put_vlocation(vl);\n}"
  },
  {
    "function_name": "afs_vlocation_purge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
    "lines": "605-616",
    "snippet": "void afs_vlocation_purge(void)\n{\n\tafs_vlocation_timeout = 0;\n\n\tspin_lock(&afs_vlocation_updates_lock);\n\tlist_del_init(&afs_vlocation_updates);\n\tspin_unlock(&afs_vlocation_updates_lock);\n\tmod_delayed_work(afs_vlocation_update_worker, &afs_vlocation_update, 0);\n\tdestroy_workqueue(afs_vlocation_update_worker);\n\n\tmod_delayed_work(afs_wq, &afs_vlocation_reap, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned afs_vlocation_timeout = 10;",
      "static LIST_HEAD(afs_vlocation_updates);",
      "static DEFINE_SPINLOCK(afs_vlocation_updates_lock);",
      "static struct workqueue_struct *afs_vlocation_update_worker;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_delayed_work",
          "args": [
            "afs_wq",
            "&afs_vlocation_reap",
            "0"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "afs_vlocation_update_worker"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mod_delayed_work",
          "args": [
            "afs_vlocation_update_worker",
            "&afs_vlocation_update",
            "0"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&afs_vlocation_updates_lock"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&afs_vlocation_updates"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&afs_vlocation_updates_lock"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic unsigned afs_vlocation_timeout = 10;\nstatic LIST_HEAD(afs_vlocation_updates);\nstatic DEFINE_SPINLOCK(afs_vlocation_updates_lock);\nstatic struct workqueue_struct *afs_vlocation_update_worker;\n\nvoid afs_vlocation_purge(void)\n{\n\tafs_vlocation_timeout = 0;\n\n\tspin_lock(&afs_vlocation_updates_lock);\n\tlist_del_init(&afs_vlocation_updates);\n\tspin_unlock(&afs_vlocation_updates_lock);\n\tmod_delayed_work(afs_vlocation_update_worker, &afs_vlocation_update, 0);\n\tdestroy_workqueue(afs_vlocation_update_worker);\n\n\tmod_delayed_work(afs_wq, &afs_vlocation_reap, 0);\n}"
  },
  {
    "function_name": "afs_vlocation_update_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
    "lines": "595-600",
    "snippet": "int __init afs_vlocation_update_init(void)\n{\n\tafs_vlocation_update_worker =\n\t\tcreate_singlethread_workqueue(\"kafs_vlupdated\");\n\treturn afs_vlocation_update_worker ? 0 : -ENOMEM;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *afs_vlocation_update_worker;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_singlethread_workqueue",
          "args": [
            "\"kafs_vlupdated\""
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *afs_vlocation_update_worker;\n\nint __init afs_vlocation_update_init(void)\n{\n\tafs_vlocation_update_worker =\n\t\tcreate_singlethread_workqueue(\"kafs_vlupdated\");\n\treturn afs_vlocation_update_worker ? 0 : -ENOMEM;\n}"
  },
  {
    "function_name": "afs_vlocation_reaper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
    "lines": "541-590",
    "snippet": "static void afs_vlocation_reaper(struct work_struct *work)\n{\n\tLIST_HEAD(corpses);\n\tstruct afs_vlocation *vl;\n\tunsigned long delay, expiry;\n\ttime_t now;\n\n\t_enter(\"\");\n\n\tnow = get_seconds();\n\tspin_lock(&afs_vlocation_graveyard_lock);\n\n\twhile (!list_empty(&afs_vlocation_graveyard)) {\n\t\tvl = list_entry(afs_vlocation_graveyard.next,\n\t\t\t\tstruct afs_vlocation, grave);\n\n\t\t_debug(\"check %p\", vl);\n\n\t\t/* the queue is ordered most dead first */\n\t\texpiry = vl->time_of_death + afs_vlocation_timeout;\n\t\tif (expiry > now) {\n\t\t\tdelay = (expiry - now) * HZ;\n\t\t\t_debug(\"delay %lu\", delay);\n\t\t\tmod_delayed_work(afs_wq, &afs_vlocation_reap, delay);\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_lock(&vl->cell->vl_lock);\n\t\tif (atomic_read(&vl->usage) > 0) {\n\t\t\t_debug(\"no reap\");\n\t\t\tlist_del_init(&vl->grave);\n\t\t} else {\n\t\t\t_debug(\"reap\");\n\t\t\tlist_move_tail(&vl->grave, &corpses);\n\t\t\tlist_del_init(&vl->link);\n\t\t}\n\t\tspin_unlock(&vl->cell->vl_lock);\n\t}\n\n\tspin_unlock(&afs_vlocation_graveyard_lock);\n\n\t/* now reap the corpses we've extracted */\n\twhile (!list_empty(&corpses)) {\n\t\tvl = list_entry(corpses.next, struct afs_vlocation, grave);\n\t\tlist_del(&vl->grave);\n\t\tafs_vlocation_destroy(vl);\n\t}\n\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned afs_vlocation_timeout = 10;",
      "static void afs_vlocation_reaper(struct work_struct *);",
      "static void afs_vlocation_updater(struct work_struct *);",
      "static LIST_HEAD(afs_vlocation_graveyard);",
      "static DEFINE_SPINLOCK(afs_vlocation_graveyard_lock);",
      "static DECLARE_DELAYED_WORK(afs_vlocation_reap, afs_vlocation_reaper);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vlocation_destroy",
          "args": [
            "vl"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vlocation_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
          "lines": "527-536",
          "snippet": "static void afs_vlocation_destroy(struct afs_vlocation *vl)\n{\n\t_enter(\"%p\", vl);\n\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_relinquish_cookie(vl->cache, 0);\n#endif\n\tafs_put_cell(vl->cell);\n\tkfree(vl);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_vlocation_destroy(struct afs_vlocation *vl)\n{\n\t_enter(\"%p\", vl);\n\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_relinquish_cookie(vl->cache, 0);\n#endif\n\tafs_put_cell(vl->cell);\n\tkfree(vl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&vl->grave"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "corpses.next",
            "structafs_vlocation",
            "grave"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&corpses"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&afs_vlocation_graveyard_lock"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&vl->link"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&vl->grave",
            "&corpses"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"reap\""
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&vl->grave"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&vl->usage"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vl->cell->vl_lock"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mod_delayed_work",
          "args": [
            "afs_wq",
            "&afs_vlocation_reap",
            "delay"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"delay %lu\"",
            "delay"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "afs_vlocation_graveyard.next",
            "structafs_vlocation",
            "grave"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "corpses"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic unsigned afs_vlocation_timeout = 10;\nstatic void afs_vlocation_reaper(struct work_struct *);\nstatic void afs_vlocation_updater(struct work_struct *);\nstatic LIST_HEAD(afs_vlocation_graveyard);\nstatic DEFINE_SPINLOCK(afs_vlocation_graveyard_lock);\nstatic DECLARE_DELAYED_WORK(afs_vlocation_reap, afs_vlocation_reaper);\n\nstatic void afs_vlocation_reaper(struct work_struct *work)\n{\n\tLIST_HEAD(corpses);\n\tstruct afs_vlocation *vl;\n\tunsigned long delay, expiry;\n\ttime_t now;\n\n\t_enter(\"\");\n\n\tnow = get_seconds();\n\tspin_lock(&afs_vlocation_graveyard_lock);\n\n\twhile (!list_empty(&afs_vlocation_graveyard)) {\n\t\tvl = list_entry(afs_vlocation_graveyard.next,\n\t\t\t\tstruct afs_vlocation, grave);\n\n\t\t_debug(\"check %p\", vl);\n\n\t\t/* the queue is ordered most dead first */\n\t\texpiry = vl->time_of_death + afs_vlocation_timeout;\n\t\tif (expiry > now) {\n\t\t\tdelay = (expiry - now) * HZ;\n\t\t\t_debug(\"delay %lu\", delay);\n\t\t\tmod_delayed_work(afs_wq, &afs_vlocation_reap, delay);\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_lock(&vl->cell->vl_lock);\n\t\tif (atomic_read(&vl->usage) > 0) {\n\t\t\t_debug(\"no reap\");\n\t\t\tlist_del_init(&vl->grave);\n\t\t} else {\n\t\t\t_debug(\"reap\");\n\t\t\tlist_move_tail(&vl->grave, &corpses);\n\t\t\tlist_del_init(&vl->link);\n\t\t}\n\t\tspin_unlock(&vl->cell->vl_lock);\n\t}\n\n\tspin_unlock(&afs_vlocation_graveyard_lock);\n\n\t/* now reap the corpses we've extracted */\n\twhile (!list_empty(&corpses)) {\n\t\tvl = list_entry(corpses.next, struct afs_vlocation, grave);\n\t\tlist_del(&vl->grave);\n\t\tafs_vlocation_destroy(vl);\n\t}\n\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "afs_vlocation_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
    "lines": "527-536",
    "snippet": "static void afs_vlocation_destroy(struct afs_vlocation *vl)\n{\n\t_enter(\"%p\", vl);\n\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_relinquish_cookie(vl->cache, 0);\n#endif\n\tafs_put_cell(vl->cell);\n\tkfree(vl);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vl"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_put_cell",
          "args": [
            "vl->cell"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_cell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cell.c",
          "lines": "343-370",
          "snippet": "void afs_put_cell(struct afs_cell *cell)\n{\n\tif (!cell)\n\t\treturn;\n\n\t_enter(\"%p{%d,%s}\", cell, atomic_read(&cell->usage), cell->name);\n\n\tASSERTCMP(atomic_read(&cell->usage), >, 0);\n\n\t/* to prevent a race, the decrement and the dequeue must be effectively\n\t * atomic */\n\twrite_lock(&afs_cells_lock);\n\n\tif (likely(!atomic_dec_and_test(&cell->usage))) {\n\t\twrite_unlock(&afs_cells_lock);\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tASSERT(list_empty(&cell->servers));\n\tASSERT(list_empty(&cell->vl_list));\n\n\twrite_unlock(&afs_cells_lock);\n\n\twake_up(&afs_cells_freeable_wq);\n\n\t_leave(\" [unused]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/dns_resolver.h>",
            "#include <linux/ctype.h>",
            "#include <linux/key.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(afs_cells_lock);",
            "static DECLARE_WAIT_QUEUE_HEAD(afs_cells_freeable_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/dns_resolver.h>\n#include <linux/ctype.h>\n#include <linux/key.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic DEFINE_RWLOCK(afs_cells_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(afs_cells_freeable_wq);\n\nvoid afs_put_cell(struct afs_cell *cell)\n{\n\tif (!cell)\n\t\treturn;\n\n\t_enter(\"%p{%d,%s}\", cell, atomic_read(&cell->usage), cell->name);\n\n\tASSERTCMP(atomic_read(&cell->usage), >, 0);\n\n\t/* to prevent a race, the decrement and the dequeue must be effectively\n\t * atomic */\n\twrite_lock(&afs_cells_lock);\n\n\tif (likely(!atomic_dec_and_test(&cell->usage))) {\n\t\twrite_unlock(&afs_cells_lock);\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tASSERT(list_empty(&cell->servers));\n\tASSERT(list_empty(&cell->vl_list));\n\n\twrite_unlock(&afs_cells_lock);\n\n\twake_up(&afs_cells_freeable_wq);\n\n\t_leave(\" [unused]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_relinquish_cookie",
          "args": [
            "vl->cache",
            "0"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_relinquish_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "581-618",
          "snippet": "void __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\n\nvoid __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p\"",
            "vl"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_vlocation_destroy(struct afs_vlocation *vl)\n{\n\t_enter(\"%p\", vl);\n\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_relinquish_cookie(vl->cache, 0);\n#endif\n\tafs_put_cell(vl->cell);\n\tkfree(vl);\n}"
  },
  {
    "function_name": "afs_put_vlocation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
    "lines": "491-522",
    "snippet": "void afs_put_vlocation(struct afs_vlocation *vl)\n{\n\tif (!vl)\n\t\treturn;\n\n\t_enter(\"%s\", vl->vldb.name);\n\n\tASSERTCMP(atomic_read(&vl->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&vl->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tspin_lock(&afs_vlocation_graveyard_lock);\n\tif (atomic_read(&vl->usage) == 0) {\n\t\t_debug(\"buried\");\n\t\tlist_move_tail(&vl->grave, &afs_vlocation_graveyard);\n\t\tvl->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_vlocation_reap,\n\t\t\t\t   afs_vlocation_timeout * HZ);\n\n\t\t/* suspend updates on this record */\n\t\tif (!list_empty(&vl->update)) {\n\t\t\tspin_lock(&afs_vlocation_updates_lock);\n\t\t\tlist_del_init(&vl->update);\n\t\t\tspin_unlock(&afs_vlocation_updates_lock);\n\t\t}\n\t}\n\tspin_unlock(&afs_vlocation_graveyard_lock);\n\t_leave(\" [killed?]\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned afs_vlocation_timeout = 10;",
      "static LIST_HEAD(afs_vlocation_graveyard);",
      "static DEFINE_SPINLOCK(afs_vlocation_updates_lock);",
      "static DEFINE_SPINLOCK(afs_vlocation_graveyard_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" [killed?]\""
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&afs_vlocation_graveyard_lock"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&vl->update"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&afs_vlocation_updates_lock"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&vl->update"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "afs_wq",
            "&afs_vlocation_reap",
            "afs_vlocation_timeout * HZ"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&vl->grave",
            "&afs_vlocation_graveyard"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"buried\""
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&vl->usage"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!atomic_dec_and_test(&vl->usage)"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&vl->usage"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "atomic_read(&vl->usage)",
            ">,0"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&vl->usage"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%s\"",
            "vl->vldb.name"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic unsigned afs_vlocation_timeout = 10;\nstatic LIST_HEAD(afs_vlocation_graveyard);\nstatic DEFINE_SPINLOCK(afs_vlocation_updates_lock);\nstatic DEFINE_SPINLOCK(afs_vlocation_graveyard_lock);\n\nvoid afs_put_vlocation(struct afs_vlocation *vl)\n{\n\tif (!vl)\n\t\treturn;\n\n\t_enter(\"%s\", vl->vldb.name);\n\n\tASSERTCMP(atomic_read(&vl->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&vl->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tspin_lock(&afs_vlocation_graveyard_lock);\n\tif (atomic_read(&vl->usage) == 0) {\n\t\t_debug(\"buried\");\n\t\tlist_move_tail(&vl->grave, &afs_vlocation_graveyard);\n\t\tvl->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_vlocation_reap,\n\t\t\t\t   afs_vlocation_timeout * HZ);\n\n\t\t/* suspend updates on this record */\n\t\tif (!list_empty(&vl->update)) {\n\t\t\tspin_lock(&afs_vlocation_updates_lock);\n\t\t\tlist_del_init(&vl->update);\n\t\t\tspin_unlock(&afs_vlocation_updates_lock);\n\t\t}\n\t}\n\tspin_unlock(&afs_vlocation_graveyard_lock);\n\t_leave(\" [killed?]\");\n}"
  },
  {
    "function_name": "afs_vlocation_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
    "lines": "373-486",
    "snippet": "struct afs_vlocation *afs_vlocation_lookup(struct afs_cell *cell,\n\t\t\t\t\t   struct key *key,\n\t\t\t\t\t   const char *name,\n\t\t\t\t\t   size_t namesz)\n{\n\tstruct afs_vlocation *vl;\n\tint ret;\n\n\t_enter(\"{%s},{%x},%*.*s,%zu\",\n\t       cell->name, key_serial(key),\n\t       (int) namesz, (int) namesz, name, namesz);\n\n\tif (namesz >= sizeof(vl->vldb.name)) {\n\t\t_leave(\" = -ENAMETOOLONG\");\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\n\t/* see if we have an in-memory copy first */\n\tdown_write(&cell->vl_sem);\n\tspin_lock(&cell->vl_lock);\n\tlist_for_each_entry(vl, &cell->vl_list, link) {\n\t\tif (vl->vldb.name[namesz] != '\\0')\n\t\t\tcontinue;\n\t\tif (memcmp(vl->vldb.name, name, namesz) == 0)\n\t\t\tgoto found_in_memory;\n\t}\n\tspin_unlock(&cell->vl_lock);\n\n\t/* not in the cell's in-memory lists - create a new record */\n\tvl = afs_vlocation_alloc(cell, name, namesz);\n\tif (!vl) {\n\t\tup_write(&cell->vl_sem);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tafs_get_cell(cell);\n\n\tlist_add_tail(&vl->link, &cell->vl_list);\n\tvl->state = AFS_VL_CREATING;\n\tup_write(&cell->vl_sem);\n\nfill_in_record:\n\tret = afs_vlocation_fill_in_record(vl, key);\n\tif (ret < 0)\n\t\tgoto error_abandon;\n\tspin_lock(&vl->lock);\n\tvl->state = AFS_VL_VALID;\n\tspin_unlock(&vl->lock);\n\twake_up(&vl->waitq);\n\n\t/* update volume entry in local cache */\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_update_cookie(vl->cache);\n#endif\n\n\t/* schedule for regular updates */\n\tafs_vlocation_queue_for_updates(vl);\n\tgoto success;\n\nfound_in_memory:\n\t/* found in memory */\n\t_debug(\"found in memory\");\n\tatomic_inc(&vl->usage);\n\tspin_unlock(&cell->vl_lock);\n\tif (!list_empty(&vl->grave)) {\n\t\tspin_lock(&afs_vlocation_graveyard_lock);\n\t\tlist_del_init(&vl->grave);\n\t\tspin_unlock(&afs_vlocation_graveyard_lock);\n\t}\n\tup_write(&cell->vl_sem);\n\n\t/* see if it was an abandoned record that we might try filling in */\n\tspin_lock(&vl->lock);\n\twhile (vl->state != AFS_VL_VALID) {\n\t\tafs_vlocation_state_t state = vl->state;\n\n\t\t_debug(\"invalid [state %d]\", state);\n\n\t\tif (state == AFS_VL_NEW || state == AFS_VL_NO_VOLUME) {\n\t\t\tvl->state = AFS_VL_CREATING;\n\t\t\tspin_unlock(&vl->lock);\n\t\t\tgoto fill_in_record;\n\t\t}\n\n\t\t/* must now wait for creation or update by someone else to\n\t\t * complete */\n\t\t_debug(\"wait\");\n\n\t\tspin_unlock(&vl->lock);\n\t\tret = wait_event_interruptible(vl->waitq,\n\t\t\t\t\t       vl->state == AFS_VL_NEW ||\n\t\t\t\t\t       vl->state == AFS_VL_VALID ||\n\t\t\t\t\t       vl->state == AFS_VL_NO_VOLUME);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tspin_lock(&vl->lock);\n\t}\n\tspin_unlock(&vl->lock);\n\nsuccess:\n\t_leave(\" = %p\", vl);\n\treturn vl;\n\nerror_abandon:\n\tspin_lock(&vl->lock);\n\tvl->state = AFS_VL_NEW;\n\tspin_unlock(&vl->lock);\n\twake_up(&vl->waitq);\nerror:\n\tASSERT(vl != NULL);\n\tafs_put_vlocation(vl);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(afs_vlocation_graveyard_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_put_vlocation",
          "args": [
            "vl"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_vlocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
          "lines": "491-522",
          "snippet": "void afs_put_vlocation(struct afs_vlocation *vl)\n{\n\tif (!vl)\n\t\treturn;\n\n\t_enter(\"%s\", vl->vldb.name);\n\n\tASSERTCMP(atomic_read(&vl->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&vl->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tspin_lock(&afs_vlocation_graveyard_lock);\n\tif (atomic_read(&vl->usage) == 0) {\n\t\t_debug(\"buried\");\n\t\tlist_move_tail(&vl->grave, &afs_vlocation_graveyard);\n\t\tvl->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_vlocation_reap,\n\t\t\t\t   afs_vlocation_timeout * HZ);\n\n\t\t/* suspend updates on this record */\n\t\tif (!list_empty(&vl->update)) {\n\t\t\tspin_lock(&afs_vlocation_updates_lock);\n\t\t\tlist_del_init(&vl->update);\n\t\t\tspin_unlock(&afs_vlocation_updates_lock);\n\t\t}\n\t}\n\tspin_unlock(&afs_vlocation_graveyard_lock);\n\t_leave(\" [killed?]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_vlocation_timeout = 10;",
            "static LIST_HEAD(afs_vlocation_graveyard);",
            "static DEFINE_SPINLOCK(afs_vlocation_updates_lock);",
            "static DEFINE_SPINLOCK(afs_vlocation_graveyard_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic unsigned afs_vlocation_timeout = 10;\nstatic LIST_HEAD(afs_vlocation_graveyard);\nstatic DEFINE_SPINLOCK(afs_vlocation_updates_lock);\nstatic DEFINE_SPINLOCK(afs_vlocation_graveyard_lock);\n\nvoid afs_put_vlocation(struct afs_vlocation *vl)\n{\n\tif (!vl)\n\t\treturn;\n\n\t_enter(\"%s\", vl->vldb.name);\n\n\tASSERTCMP(atomic_read(&vl->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&vl->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tspin_lock(&afs_vlocation_graveyard_lock);\n\tif (atomic_read(&vl->usage) == 0) {\n\t\t_debug(\"buried\");\n\t\tlist_move_tail(&vl->grave, &afs_vlocation_graveyard);\n\t\tvl->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_vlocation_reap,\n\t\t\t\t   afs_vlocation_timeout * HZ);\n\n\t\t/* suspend updates on this record */\n\t\tif (!list_empty(&vl->update)) {\n\t\t\tspin_lock(&afs_vlocation_updates_lock);\n\t\t\tlist_del_init(&vl->update);\n\t\t\tspin_unlock(&afs_vlocation_updates_lock);\n\t\t}\n\t}\n\tspin_unlock(&afs_vlocation_graveyard_lock);\n\t_leave(\" [killed?]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "vl != NULL"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&vl->waitq"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "afs_wake_up_async_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "606-610",
          "snippet": "static void afs_wake_up_async_call(struct afs_call *call)\n{\n\t_enter(\"\");\n\tqueue_work(afs_async_calls, &call->async_work);\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *afs_async_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct workqueue_struct *afs_async_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstatic void afs_wake_up_async_call(struct afs_call *call)\n{\n\t_enter(\"\");\n\tqueue_work(afs_async_calls, &call->async_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vl->lock"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vl->lock"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "vl->waitq",
            "vl->state == AFS_VL_NEW ||\n\t\t\t\t\t       vl->state == AFS_VL_VALID ||\n\t\t\t\t\t       vl->state == AFS_VL_NO_VOLUME"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"wait\""
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"invalid [state %d]\"",
            "state"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&cell->vl_sem"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&vl->grave"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&vl->grave"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&vl->usage"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_vlocation_queue_for_updates",
          "args": [
            "vl"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vlocation_queue_for_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
          "lines": "338-364",
          "snippet": "static void afs_vlocation_queue_for_updates(struct afs_vlocation *vl)\n{\n\tstruct afs_vlocation *xvl;\n\n\t/* wait at least 10 minutes before updating... */\n\tvl->update_at = get_seconds() + afs_vlocation_update_timeout;\n\n\tspin_lock(&afs_vlocation_updates_lock);\n\n\tif (!list_empty(&afs_vlocation_updates)) {\n\t\t/* ... but wait at least 1 second more than the newest record\n\t\t * already queued so that we don't spam the VL server suddenly\n\t\t * with lots of requests\n\t\t */\n\t\txvl = list_entry(afs_vlocation_updates.prev,\n\t\t\t\t struct afs_vlocation, update);\n\t\tif (vl->update_at <= xvl->update_at)\n\t\t\tvl->update_at = xvl->update_at + 1;\n\t} else {\n\t\tqueue_delayed_work(afs_vlocation_update_worker,\n\t\t\t\t   &afs_vlocation_update,\n\t\t\t\t   afs_vlocation_update_timeout * HZ);\n\t}\n\n\tlist_add_tail(&vl->update, &afs_vlocation_updates);\n\tspin_unlock(&afs_vlocation_updates_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_vlocation_update_timeout = 10 * 60;",
            "static LIST_HEAD(afs_vlocation_updates);",
            "static DEFINE_SPINLOCK(afs_vlocation_updates_lock);",
            "static struct workqueue_struct *afs_vlocation_update_worker;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic unsigned afs_vlocation_update_timeout = 10 * 60;\nstatic LIST_HEAD(afs_vlocation_updates);\nstatic DEFINE_SPINLOCK(afs_vlocation_updates_lock);\nstatic struct workqueue_struct *afs_vlocation_update_worker;\n\nstatic void afs_vlocation_queue_for_updates(struct afs_vlocation *vl)\n{\n\tstruct afs_vlocation *xvl;\n\n\t/* wait at least 10 minutes before updating... */\n\tvl->update_at = get_seconds() + afs_vlocation_update_timeout;\n\n\tspin_lock(&afs_vlocation_updates_lock);\n\n\tif (!list_empty(&afs_vlocation_updates)) {\n\t\t/* ... but wait at least 1 second more than the newest record\n\t\t * already queued so that we don't spam the VL server suddenly\n\t\t * with lots of requests\n\t\t */\n\t\txvl = list_entry(afs_vlocation_updates.prev,\n\t\t\t\t struct afs_vlocation, update);\n\t\tif (vl->update_at <= xvl->update_at)\n\t\t\tvl->update_at = xvl->update_at + 1;\n\t} else {\n\t\tqueue_delayed_work(afs_vlocation_update_worker,\n\t\t\t\t   &afs_vlocation_update,\n\t\t\t\t   afs_vlocation_update_timeout * HZ);\n\t}\n\n\tlist_add_tail(&vl->update, &afs_vlocation_updates);\n\tspin_unlock(&afs_vlocation_updates_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_update_cookie",
          "args": [
            "vl->cache"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_update_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "475-505",
          "snippet": "void __fscache_update_cookie(struct fscache_cookie *cookie)\n{\n\tstruct fscache_object *object;\n\n\tfscache_stat(&fscache_n_updates);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_updates_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"{%s}\", cookie->def->name);\n\n\tBUG_ON(!cookie->def->get_aux);\n\n\tspin_lock(&cookie->lock);\n\n\tif (fscache_cookie_enabled(cookie)) {\n\t\t/* update the index entry on disk in each cache backing this\n\t\t * cookie.\n\t\t */\n\t\thlist_for_each_entry(object,\n\t\t\t\t     &cookie->backing_objects, cookie_link) {\n\t\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_UPDATE);\n\t\t}\n\t}\n\n\tspin_unlock(&cookie->lock);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
            "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nvoid __fscache_update_cookie(struct fscache_cookie *cookie)\n{\n\tstruct fscache_object *object;\n\n\tfscache_stat(&fscache_n_updates);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_updates_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"{%s}\", cookie->def->name);\n\n\tBUG_ON(!cookie->def->get_aux);\n\n\tspin_lock(&cookie->lock);\n\n\tif (fscache_cookie_enabled(cookie)) {\n\t\t/* update the index entry on disk in each cache backing this\n\t\t * cookie.\n\t\t */\n\t\thlist_for_each_entry(object,\n\t\t\t\t     &cookie->backing_objects, cookie_link) {\n\t\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_UPDATE);\n\t\t}\n\t}\n\n\tspin_unlock(&cookie->lock);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vlocation_fill_in_record",
          "args": [
            "vl",
            "key"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vlocation_fill_in_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
          "lines": "295-333",
          "snippet": "static int afs_vlocation_fill_in_record(struct afs_vlocation *vl,\n\t\t\t\t\tstruct key *key)\n{\n\tstruct afs_cache_vlocation vldb;\n\tint ret;\n\n\t_enter(\"\");\n\n\tASSERTCMP(vl->valid, ==, 0);\n\n\tmemset(&vldb, 0, sizeof(vldb));\n\n\t/* see if we have an in-cache copy (will set vl->valid if there is) */\n#ifdef CONFIG_AFS_FSCACHE\n\tvl->cache = fscache_acquire_cookie(vl->cell->cache,\n\t\t\t\t\t   &afs_vlocation_cache_index_def, vl,\n\t\t\t\t\t   true);\n#endif\n\n\tif (vl->valid) {\n\t\t/* try to update a known volume in the cell VL databases by\n\t\t * ID as the name may have changed */\n\t\t_debug(\"found in cache\");\n\t\tret = afs_vlocation_update_record(vl, key, &vldb);\n\t} else {\n\t\t/* try to look up an unknown volume in the cell VL databases by\n\t\t * name */\n\t\tret = afs_vlocation_access_vl_by_name(vl, key, &vldb);\n\t\tif (ret < 0) {\n\t\t\tprintk(\"kAFS: failed to locate '%s' in cell '%s'\\n\",\n\t\t\t       vl->vldb.name, vl->cell->name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tafs_vlocation_apply_update(vl, &vldb);\n\t_leave(\" = 0\");\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_vlocation_fill_in_record(struct afs_vlocation *vl,\n\t\t\t\t\tstruct key *key)\n{\n\tstruct afs_cache_vlocation vldb;\n\tint ret;\n\n\t_enter(\"\");\n\n\tASSERTCMP(vl->valid, ==, 0);\n\n\tmemset(&vldb, 0, sizeof(vldb));\n\n\t/* see if we have an in-cache copy (will set vl->valid if there is) */\n#ifdef CONFIG_AFS_FSCACHE\n\tvl->cache = fscache_acquire_cookie(vl->cell->cache,\n\t\t\t\t\t   &afs_vlocation_cache_index_def, vl,\n\t\t\t\t\t   true);\n#endif\n\n\tif (vl->valid) {\n\t\t/* try to update a known volume in the cell VL databases by\n\t\t * ID as the name may have changed */\n\t\t_debug(\"found in cache\");\n\t\tret = afs_vlocation_update_record(vl, key, &vldb);\n\t} else {\n\t\t/* try to look up an unknown volume in the cell VL databases by\n\t\t * name */\n\t\tret = afs_vlocation_access_vl_by_name(vl, key, &vldb);\n\t\tif (ret < 0) {\n\t\t\tprintk(\"kAFS: failed to locate '%s' in cell '%s'\\n\",\n\t\t\t       vl->vldb.name, vl->cell->name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tafs_vlocation_apply_update(vl, &vldb);\n\t_leave(\" = 0\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&cell->vl_sem"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&vl->link",
            "&cell->vl_list"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_get_cell",
          "args": [
            "cell"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "afs_get_cell_maybe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cell.c",
          "lines": "326-337",
          "snippet": "struct afs_cell *afs_get_cell_maybe(struct afs_cell *cell)\n{\n\twrite_lock(&afs_cells_lock);\n\n\tif (cell && !list_empty(&cell->link))\n\t\tafs_get_cell(cell);\n\telse\n\t\tcell = NULL;\n\n\twrite_unlock(&afs_cells_lock);\n\treturn cell;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/dns_resolver.h>",
            "#include <linux/ctype.h>",
            "#include <linux/key.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(afs_cells_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/dns_resolver.h>\n#include <linux/ctype.h>\n#include <linux/key.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic DEFINE_RWLOCK(afs_cells_lock);\n\nstruct afs_cell *afs_get_cell_maybe(struct afs_cell *cell)\n{\n\twrite_lock(&afs_cells_lock);\n\n\tif (cell && !list_empty(&cell->link))\n\t\tafs_get_cell(cell);\n\telse\n\t\tcell = NULL;\n\n\twrite_unlock(&afs_cells_lock);\n\treturn cell;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&cell->vl_sem"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_vlocation_alloc",
          "args": [
            "cell",
            "name",
            "namesz"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vlocation_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
          "lines": "169-190",
          "snippet": "static struct afs_vlocation *afs_vlocation_alloc(struct afs_cell *cell,\n\t\t\t\t\t\t const char *name,\n\t\t\t\t\t\t size_t namesz)\n{\n\tstruct afs_vlocation *vl;\n\n\tvl = kzalloc(sizeof(struct afs_vlocation), GFP_KERNEL);\n\tif (vl) {\n\t\tvl->cell = cell;\n\t\tvl->state = AFS_VL_NEW;\n\t\tatomic_set(&vl->usage, 1);\n\t\tINIT_LIST_HEAD(&vl->link);\n\t\tINIT_LIST_HEAD(&vl->grave);\n\t\tINIT_LIST_HEAD(&vl->update);\n\t\tinit_waitqueue_head(&vl->waitq);\n\t\tspin_lock_init(&vl->lock);\n\t\tmemcpy(vl->vldb.name, name, namesz);\n\t}\n\n\t_leave(\" = %p\", vl);\n\treturn vl;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct afs_vlocation *afs_vlocation_alloc(struct afs_cell *cell,\n\t\t\t\t\t\t const char *name,\n\t\t\t\t\t\t size_t namesz)\n{\n\tstruct afs_vlocation *vl;\n\n\tvl = kzalloc(sizeof(struct afs_vlocation), GFP_KERNEL);\n\tif (vl) {\n\t\tvl->cell = cell;\n\t\tvl->state = AFS_VL_NEW;\n\t\tatomic_set(&vl->usage, 1);\n\t\tINIT_LIST_HEAD(&vl->link);\n\t\tINIT_LIST_HEAD(&vl->grave);\n\t\tINIT_LIST_HEAD(&vl->update);\n\t\tinit_waitqueue_head(&vl->waitq);\n\t\tspin_lock_init(&vl->lock);\n\t\tmemcpy(vl->vldb.name, name, namesz);\n\t}\n\n\t_leave(\" = %p\", vl);\n\treturn vl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "vl->vldb.name",
            "name",
            "namesz"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "vl",
            "&cell->vl_list",
            "link"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&cell->vl_sem"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -ENAMETOOLONG\""
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%s},{%x},%*.*s,%zu\"",
            "cell->name",
            "key_serial(key)",
            "(int) namesz",
            "(int) namesz",
            "name",
            "namesz"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "key"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(afs_vlocation_graveyard_lock);\n\nstruct afs_vlocation *afs_vlocation_lookup(struct afs_cell *cell,\n\t\t\t\t\t   struct key *key,\n\t\t\t\t\t   const char *name,\n\t\t\t\t\t   size_t namesz)\n{\n\tstruct afs_vlocation *vl;\n\tint ret;\n\n\t_enter(\"{%s},{%x},%*.*s,%zu\",\n\t       cell->name, key_serial(key),\n\t       (int) namesz, (int) namesz, name, namesz);\n\n\tif (namesz >= sizeof(vl->vldb.name)) {\n\t\t_leave(\" = -ENAMETOOLONG\");\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\n\t/* see if we have an in-memory copy first */\n\tdown_write(&cell->vl_sem);\n\tspin_lock(&cell->vl_lock);\n\tlist_for_each_entry(vl, &cell->vl_list, link) {\n\t\tif (vl->vldb.name[namesz] != '\\0')\n\t\t\tcontinue;\n\t\tif (memcmp(vl->vldb.name, name, namesz) == 0)\n\t\t\tgoto found_in_memory;\n\t}\n\tspin_unlock(&cell->vl_lock);\n\n\t/* not in the cell's in-memory lists - create a new record */\n\tvl = afs_vlocation_alloc(cell, name, namesz);\n\tif (!vl) {\n\t\tup_write(&cell->vl_sem);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tafs_get_cell(cell);\n\n\tlist_add_tail(&vl->link, &cell->vl_list);\n\tvl->state = AFS_VL_CREATING;\n\tup_write(&cell->vl_sem);\n\nfill_in_record:\n\tret = afs_vlocation_fill_in_record(vl, key);\n\tif (ret < 0)\n\t\tgoto error_abandon;\n\tspin_lock(&vl->lock);\n\tvl->state = AFS_VL_VALID;\n\tspin_unlock(&vl->lock);\n\twake_up(&vl->waitq);\n\n\t/* update volume entry in local cache */\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_update_cookie(vl->cache);\n#endif\n\n\t/* schedule for regular updates */\n\tafs_vlocation_queue_for_updates(vl);\n\tgoto success;\n\nfound_in_memory:\n\t/* found in memory */\n\t_debug(\"found in memory\");\n\tatomic_inc(&vl->usage);\n\tspin_unlock(&cell->vl_lock);\n\tif (!list_empty(&vl->grave)) {\n\t\tspin_lock(&afs_vlocation_graveyard_lock);\n\t\tlist_del_init(&vl->grave);\n\t\tspin_unlock(&afs_vlocation_graveyard_lock);\n\t}\n\tup_write(&cell->vl_sem);\n\n\t/* see if it was an abandoned record that we might try filling in */\n\tspin_lock(&vl->lock);\n\twhile (vl->state != AFS_VL_VALID) {\n\t\tafs_vlocation_state_t state = vl->state;\n\n\t\t_debug(\"invalid [state %d]\", state);\n\n\t\tif (state == AFS_VL_NEW || state == AFS_VL_NO_VOLUME) {\n\t\t\tvl->state = AFS_VL_CREATING;\n\t\t\tspin_unlock(&vl->lock);\n\t\t\tgoto fill_in_record;\n\t\t}\n\n\t\t/* must now wait for creation or update by someone else to\n\t\t * complete */\n\t\t_debug(\"wait\");\n\n\t\tspin_unlock(&vl->lock);\n\t\tret = wait_event_interruptible(vl->waitq,\n\t\t\t\t\t       vl->state == AFS_VL_NEW ||\n\t\t\t\t\t       vl->state == AFS_VL_VALID ||\n\t\t\t\t\t       vl->state == AFS_VL_NO_VOLUME);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tspin_lock(&vl->lock);\n\t}\n\tspin_unlock(&vl->lock);\n\nsuccess:\n\t_leave(\" = %p\", vl);\n\treturn vl;\n\nerror_abandon:\n\tspin_lock(&vl->lock);\n\tvl->state = AFS_VL_NEW;\n\tspin_unlock(&vl->lock);\n\twake_up(&vl->waitq);\nerror:\n\tASSERT(vl != NULL);\n\tafs_put_vlocation(vl);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "afs_vlocation_queue_for_updates",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
    "lines": "338-364",
    "snippet": "static void afs_vlocation_queue_for_updates(struct afs_vlocation *vl)\n{\n\tstruct afs_vlocation *xvl;\n\n\t/* wait at least 10 minutes before updating... */\n\tvl->update_at = get_seconds() + afs_vlocation_update_timeout;\n\n\tspin_lock(&afs_vlocation_updates_lock);\n\n\tif (!list_empty(&afs_vlocation_updates)) {\n\t\t/* ... but wait at least 1 second more than the newest record\n\t\t * already queued so that we don't spam the VL server suddenly\n\t\t * with lots of requests\n\t\t */\n\t\txvl = list_entry(afs_vlocation_updates.prev,\n\t\t\t\t struct afs_vlocation, update);\n\t\tif (vl->update_at <= xvl->update_at)\n\t\t\tvl->update_at = xvl->update_at + 1;\n\t} else {\n\t\tqueue_delayed_work(afs_vlocation_update_worker,\n\t\t\t\t   &afs_vlocation_update,\n\t\t\t\t   afs_vlocation_update_timeout * HZ);\n\t}\n\n\tlist_add_tail(&vl->update, &afs_vlocation_updates);\n\tspin_unlock(&afs_vlocation_updates_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned afs_vlocation_update_timeout = 10 * 60;",
      "static LIST_HEAD(afs_vlocation_updates);",
      "static DEFINE_SPINLOCK(afs_vlocation_updates_lock);",
      "static struct workqueue_struct *afs_vlocation_update_worker;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&afs_vlocation_updates_lock"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&vl->update",
            "&afs_vlocation_updates"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "afs_vlocation_update_worker",
            "&afs_vlocation_update",
            "afs_vlocation_update_timeout * HZ"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "afs_vlocation_updates.prev",
            "structafs_vlocation",
            "update"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&afs_vlocation_updates"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&afs_vlocation_updates_lock"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic unsigned afs_vlocation_update_timeout = 10 * 60;\nstatic LIST_HEAD(afs_vlocation_updates);\nstatic DEFINE_SPINLOCK(afs_vlocation_updates_lock);\nstatic struct workqueue_struct *afs_vlocation_update_worker;\n\nstatic void afs_vlocation_queue_for_updates(struct afs_vlocation *vl)\n{\n\tstruct afs_vlocation *xvl;\n\n\t/* wait at least 10 minutes before updating... */\n\tvl->update_at = get_seconds() + afs_vlocation_update_timeout;\n\n\tspin_lock(&afs_vlocation_updates_lock);\n\n\tif (!list_empty(&afs_vlocation_updates)) {\n\t\t/* ... but wait at least 1 second more than the newest record\n\t\t * already queued so that we don't spam the VL server suddenly\n\t\t * with lots of requests\n\t\t */\n\t\txvl = list_entry(afs_vlocation_updates.prev,\n\t\t\t\t struct afs_vlocation, update);\n\t\tif (vl->update_at <= xvl->update_at)\n\t\t\tvl->update_at = xvl->update_at + 1;\n\t} else {\n\t\tqueue_delayed_work(afs_vlocation_update_worker,\n\t\t\t\t   &afs_vlocation_update,\n\t\t\t\t   afs_vlocation_update_timeout * HZ);\n\t}\n\n\tlist_add_tail(&vl->update, &afs_vlocation_updates);\n\tspin_unlock(&afs_vlocation_updates_lock);\n}"
  },
  {
    "function_name": "afs_vlocation_fill_in_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
    "lines": "295-333",
    "snippet": "static int afs_vlocation_fill_in_record(struct afs_vlocation *vl,\n\t\t\t\t\tstruct key *key)\n{\n\tstruct afs_cache_vlocation vldb;\n\tint ret;\n\n\t_enter(\"\");\n\n\tASSERTCMP(vl->valid, ==, 0);\n\n\tmemset(&vldb, 0, sizeof(vldb));\n\n\t/* see if we have an in-cache copy (will set vl->valid if there is) */\n#ifdef CONFIG_AFS_FSCACHE\n\tvl->cache = fscache_acquire_cookie(vl->cell->cache,\n\t\t\t\t\t   &afs_vlocation_cache_index_def, vl,\n\t\t\t\t\t   true);\n#endif\n\n\tif (vl->valid) {\n\t\t/* try to update a known volume in the cell VL databases by\n\t\t * ID as the name may have changed */\n\t\t_debug(\"found in cache\");\n\t\tret = afs_vlocation_update_record(vl, key, &vldb);\n\t} else {\n\t\t/* try to look up an unknown volume in the cell VL databases by\n\t\t * name */\n\t\tret = afs_vlocation_access_vl_by_name(vl, key, &vldb);\n\t\tif (ret < 0) {\n\t\t\tprintk(\"kAFS: failed to locate '%s' in cell '%s'\\n\",\n\t\t\t       vl->vldb.name, vl->cell->name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tafs_vlocation_apply_update(vl, &vldb);\n\t_leave(\" = 0\");\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0\""
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vlocation_apply_update",
          "args": [
            "vl",
            "&vldb"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vlocation_apply_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
          "lines": "267-289",
          "snippet": "static void afs_vlocation_apply_update(struct afs_vlocation *vl,\n\t\t\t\t       struct afs_cache_vlocation *vldb)\n{\n\t_debug(\"Done VL Lookup: %s %02x { %08x(%x) %08x(%x) %08x(%x) }\",\n\t       vldb->name, vldb->vidmask,\n\t       ntohl(vldb->servers[0].s_addr), vldb->srvtmask[0],\n\t       ntohl(vldb->servers[1].s_addr), vldb->srvtmask[1],\n\t       ntohl(vldb->servers[2].s_addr), vldb->srvtmask[2]);\n\n\t_debug(\"Vids: %08x %08x %08x\",\n\t       vldb->vid[0], vldb->vid[1], vldb->vid[2]);\n\n\tif (strcmp(vldb->name, vl->vldb.name) != 0)\n\t\tprintk(KERN_NOTICE \"kAFS:\"\n\t\t       \" name of volume '%s' changed to '%s' on server\\n\",\n\t\t       vl->vldb.name, vldb->name);\n\n\tvl->vldb = *vldb;\n\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_update_cookie(vl->cache);\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_vlocation_apply_update(struct afs_vlocation *vl,\n\t\t\t\t       struct afs_cache_vlocation *vldb)\n{\n\t_debug(\"Done VL Lookup: %s %02x { %08x(%x) %08x(%x) %08x(%x) }\",\n\t       vldb->name, vldb->vidmask,\n\t       ntohl(vldb->servers[0].s_addr), vldb->srvtmask[0],\n\t       ntohl(vldb->servers[1].s_addr), vldb->srvtmask[1],\n\t       ntohl(vldb->servers[2].s_addr), vldb->srvtmask[2]);\n\n\t_debug(\"Vids: %08x %08x %08x\",\n\t       vldb->vid[0], vldb->vid[1], vldb->vid[2]);\n\n\tif (strcmp(vldb->name, vl->vldb.name) != 0)\n\t\tprintk(KERN_NOTICE \"kAFS:\"\n\t\t       \" name of volume '%s' changed to '%s' on server\\n\",\n\t\t       vl->vldb.name, vldb->name);\n\n\tvl->vldb = *vldb;\n\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_update_cookie(vl->cache);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"kAFS: failed to locate '%s' in cell '%s'\\n\"",
            "vl->vldb.name",
            "vl->cell->name"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vlocation_access_vl_by_name",
          "args": [
            "vl",
            "key",
            "&vldb"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vlocation_access_vl_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
          "lines": "37-87",
          "snippet": "static int afs_vlocation_access_vl_by_name(struct afs_vlocation *vl,\n\t\t\t\t\t   struct key *key,\n\t\t\t\t\t   struct afs_cache_vlocation *vldb)\n{\n\tstruct afs_cell *cell = vl->cell;\n\tstruct in_addr addr;\n\tint count, ret;\n\n\t_enter(\"%s,%s\", cell->name, vl->vldb.name);\n\n\tdown_write(&vl->cell->vl_sem);\n\tret = -ENOMEDIUM;\n\tfor (count = cell->vl_naddrs; count > 0; count--) {\n\t\taddr = cell->vl_addrs[cell->vl_curr_svix];\n\n\t\t_debug(\"CellServ[%hu]: %08x\", cell->vl_curr_svix, addr.s_addr);\n\n\t\t/* attempt to access the VL server */\n\t\tret = afs_vl_get_entry_by_name(&addr, key, vl->vldb.name, vldb,\n\t\t\t\t\t       &afs_sync_call);\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\tgoto out;\n\t\tcase -ENOMEM:\n\t\tcase -ENONET:\n\t\tcase -ENETUNREACH:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == -ENOMEM || ret == -ENONET)\n\t\t\t\tgoto out;\n\t\t\tgoto rotate;\n\t\tcase -ENOMEDIUM:\n\t\tcase -EKEYREJECTED:\n\t\tcase -EKEYEXPIRED:\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tret = -EIO;\n\t\t\tgoto rotate;\n\t\t}\n\n\t\t/* rotate the server records upon lookup failure */\n\trotate:\n\t\tcell->vl_curr_svix++;\n\t\tcell->vl_curr_svix %= cell->vl_naddrs;\n\t}\n\nout:\n\tup_write(&vl->cell->vl_sem);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_vlocation_access_vl_by_name(struct afs_vlocation *vl,\n\t\t\t\t\t   struct key *key,\n\t\t\t\t\t   struct afs_cache_vlocation *vldb)\n{\n\tstruct afs_cell *cell = vl->cell;\n\tstruct in_addr addr;\n\tint count, ret;\n\n\t_enter(\"%s,%s\", cell->name, vl->vldb.name);\n\n\tdown_write(&vl->cell->vl_sem);\n\tret = -ENOMEDIUM;\n\tfor (count = cell->vl_naddrs; count > 0; count--) {\n\t\taddr = cell->vl_addrs[cell->vl_curr_svix];\n\n\t\t_debug(\"CellServ[%hu]: %08x\", cell->vl_curr_svix, addr.s_addr);\n\n\t\t/* attempt to access the VL server */\n\t\tret = afs_vl_get_entry_by_name(&addr, key, vl->vldb.name, vldb,\n\t\t\t\t\t       &afs_sync_call);\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\tgoto out;\n\t\tcase -ENOMEM:\n\t\tcase -ENONET:\n\t\tcase -ENETUNREACH:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == -ENOMEM || ret == -ENONET)\n\t\t\t\tgoto out;\n\t\t\tgoto rotate;\n\t\tcase -ENOMEDIUM:\n\t\tcase -EKEYREJECTED:\n\t\tcase -EKEYEXPIRED:\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tret = -EIO;\n\t\t\tgoto rotate;\n\t\t}\n\n\t\t/* rotate the server records upon lookup failure */\n\trotate:\n\t\tcell->vl_curr_svix++;\n\t\tcell->vl_curr_svix %= cell->vl_naddrs;\n\t}\n\nout:\n\tup_write(&vl->cell->vl_sem);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vlocation_update_record",
          "args": [
            "vl",
            "key",
            "&vldb"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vlocation_update_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
          "lines": "195-262",
          "snippet": "static int afs_vlocation_update_record(struct afs_vlocation *vl,\n\t\t\t\t       struct key *key,\n\t\t\t\t       struct afs_cache_vlocation *vldb)\n{\n\tafs_voltype_t voltype;\n\tafs_volid_t vid;\n\tint ret;\n\n\t/* try to look up a cached volume in the cell VL databases by ID */\n\t_debug(\"Locally Cached: %s %02x { %08x(%x) %08x(%x) %08x(%x) }\",\n\t       vl->vldb.name,\n\t       vl->vldb.vidmask,\n\t       ntohl(vl->vldb.servers[0].s_addr),\n\t       vl->vldb.srvtmask[0],\n\t       ntohl(vl->vldb.servers[1].s_addr),\n\t       vl->vldb.srvtmask[1],\n\t       ntohl(vl->vldb.servers[2].s_addr),\n\t       vl->vldb.srvtmask[2]);\n\n\t_debug(\"Vids: %08x %08x %08x\",\n\t       vl->vldb.vid[0],\n\t       vl->vldb.vid[1],\n\t       vl->vldb.vid[2]);\n\n\tif (vl->vldb.vidmask & AFS_VOL_VTM_RW) {\n\t\tvid = vl->vldb.vid[0];\n\t\tvoltype = AFSVL_RWVOL;\n\t} else if (vl->vldb.vidmask & AFS_VOL_VTM_RO) {\n\t\tvid = vl->vldb.vid[1];\n\t\tvoltype = AFSVL_ROVOL;\n\t} else if (vl->vldb.vidmask & AFS_VOL_VTM_BAK) {\n\t\tvid = vl->vldb.vid[2];\n\t\tvoltype = AFSVL_BACKVOL;\n\t} else {\n\t\tBUG();\n\t\tvid = 0;\n\t\tvoltype = 0;\n\t}\n\n\t/* contact the server to make sure the volume is still available\n\t * - TODO: need to handle disconnected operation here\n\t */\n\tret = afs_vlocation_access_vl_by_id(vl, key, vid, voltype, vldb);\n\tswitch (ret) {\n\t\t/* net error */\n\tdefault:\n\t\tprintk(KERN_WARNING \"kAFS:\"\n\t\t       \" failed to update volume '%s' (%x) up in '%s': %d\\n\",\n\t\t       vl->vldb.name, vid, vl->cell->name, ret);\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\n\t\t/* pulled from local cache into memory */\n\tcase 0:\n\t\t_leave(\" = 0\");\n\t\treturn 0;\n\n\t\t/* uh oh... looks like the volume got deleted */\n\tcase -ENOMEDIUM:\n\t\tprintk(KERN_ERR \"kAFS:\"\n\t\t       \" volume '%s' (%x) does not exist '%s'\\n\",\n\t\t       vl->vldb.name, vid, vl->cell->name);\n\n\t\t/* TODO: make existing record unavailable */\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_vlocation_update_record(struct afs_vlocation *vl,\n\t\t\t\t       struct key *key,\n\t\t\t\t       struct afs_cache_vlocation *vldb)\n{\n\tafs_voltype_t voltype;\n\tafs_volid_t vid;\n\tint ret;\n\n\t/* try to look up a cached volume in the cell VL databases by ID */\n\t_debug(\"Locally Cached: %s %02x { %08x(%x) %08x(%x) %08x(%x) }\",\n\t       vl->vldb.name,\n\t       vl->vldb.vidmask,\n\t       ntohl(vl->vldb.servers[0].s_addr),\n\t       vl->vldb.srvtmask[0],\n\t       ntohl(vl->vldb.servers[1].s_addr),\n\t       vl->vldb.srvtmask[1],\n\t       ntohl(vl->vldb.servers[2].s_addr),\n\t       vl->vldb.srvtmask[2]);\n\n\t_debug(\"Vids: %08x %08x %08x\",\n\t       vl->vldb.vid[0],\n\t       vl->vldb.vid[1],\n\t       vl->vldb.vid[2]);\n\n\tif (vl->vldb.vidmask & AFS_VOL_VTM_RW) {\n\t\tvid = vl->vldb.vid[0];\n\t\tvoltype = AFSVL_RWVOL;\n\t} else if (vl->vldb.vidmask & AFS_VOL_VTM_RO) {\n\t\tvid = vl->vldb.vid[1];\n\t\tvoltype = AFSVL_ROVOL;\n\t} else if (vl->vldb.vidmask & AFS_VOL_VTM_BAK) {\n\t\tvid = vl->vldb.vid[2];\n\t\tvoltype = AFSVL_BACKVOL;\n\t} else {\n\t\tBUG();\n\t\tvid = 0;\n\t\tvoltype = 0;\n\t}\n\n\t/* contact the server to make sure the volume is still available\n\t * - TODO: need to handle disconnected operation here\n\t */\n\tret = afs_vlocation_access_vl_by_id(vl, key, vid, voltype, vldb);\n\tswitch (ret) {\n\t\t/* net error */\n\tdefault:\n\t\tprintk(KERN_WARNING \"kAFS:\"\n\t\t       \" failed to update volume '%s' (%x) up in '%s': %d\\n\",\n\t\t       vl->vldb.name, vid, vl->cell->name, ret);\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\n\t\t/* pulled from local cache into memory */\n\tcase 0:\n\t\t_leave(\" = 0\");\n\t\treturn 0;\n\n\t\t/* uh oh... looks like the volume got deleted */\n\tcase -ENOMEDIUM:\n\t\tprintk(KERN_ERR \"kAFS:\"\n\t\t       \" volume '%s' (%x) does not exist '%s'\\n\",\n\t\t       vl->vldb.name, vid, vl->cell->name);\n\n\t\t/* TODO: make existing record unavailable */\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"found in cache\""
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_acquire_cookie",
          "args": [
            "vl->cell->cache",
            "&afs_vlocation_cache_index_def",
            "vl",
            "true"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_acquire_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "58-150",
          "snippet": "struct fscache_cookie *__fscache_acquire_cookie(\n\tstruct fscache_cookie *parent,\n\tconst struct fscache_cookie_def *def,\n\tvoid *netfs_data,\n\tbool enable)\n{\n\tstruct fscache_cookie *cookie;\n\n\tBUG_ON(!def);\n\n\t_enter(\"{%s},{%s},%p,%u\",\n\t       parent ? (char *) parent->def->name : \"<no-parent>\",\n\t       def->name, netfs_data, enable);\n\n\tfscache_stat(&fscache_n_acquires);\n\n\t/* if there's no parent cookie, then we don't create one here either */\n\tif (!parent) {\n\t\tfscache_stat(&fscache_n_acquires_null);\n\t\t_leave(\" [no parent]\");\n\t\treturn NULL;\n\t}\n\n\t/* validate the definition */\n\tBUG_ON(!def->get_key);\n\tBUG_ON(!def->name[0]);\n\n\tBUG_ON(def->type == FSCACHE_COOKIE_TYPE_INDEX &&\n\t       parent->def->type != FSCACHE_COOKIE_TYPE_INDEX);\n\n\t/* allocate and initialise a cookie */\n\tcookie = kmem_cache_alloc(fscache_cookie_jar, GFP_KERNEL);\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_acquires_oom);\n\t\t_leave(\" [ENOMEM]\");\n\t\treturn NULL;\n\t}\n\n\tatomic_set(&cookie->usage, 1);\n\tatomic_set(&cookie->n_children, 0);\n\n\t/* We keep the active count elevated until relinquishment to prevent an\n\t * attempt to wake up every time the object operations queue quiesces.\n\t */\n\tatomic_set(&cookie->n_active, 1);\n\n\tatomic_inc(&parent->usage);\n\tatomic_inc(&parent->n_children);\n\n\tcookie->def\t\t= def;\n\tcookie->parent\t\t= parent;\n\tcookie->netfs_data\t= netfs_data;\n\tcookie->flags\t\t= (1 << FSCACHE_COOKIE_NO_DATA_YET);\n\n\t/* radix tree insertion won't use the preallocation pool unless it's\n\t * told it may not wait */\n\tINIT_RADIX_TREE(&cookie->stores, GFP_NOFS & ~__GFP_WAIT);\n\n\tswitch (cookie->def->type) {\n\tcase FSCACHE_COOKIE_TYPE_INDEX:\n\t\tfscache_stat(&fscache_n_cookie_index);\n\t\tbreak;\n\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\n\t\tfscache_stat(&fscache_n_cookie_data);\n\t\tbreak;\n\tdefault:\n\t\tfscache_stat(&fscache_n_cookie_special);\n\t\tbreak;\n\t}\n\n\tif (enable) {\n\t\t/* if the object is an index then we need do nothing more here\n\t\t * - we create indices on disk when we need them as an index\n\t\t * may exist in multiple caches */\n\t\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t\tif (fscache_acquire_non_index_cookie(cookie) == 0) {\n\t\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t\t} else {\n\t\t\t\tatomic_dec(&parent->n_children);\n\t\t\t\t__fscache_cookie_put(cookie);\n\t\t\t\tfscache_stat(&fscache_n_acquires_nobufs);\n\t\t\t\t_leave(\" = NULL\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t}\n\t}\n\n\tfscache_stat(&fscache_n_acquires_ok);\n\t_leave(\" = %p\", cookie);\n\treturn cookie;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *fscache_cookie_jar;",
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
            "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstruct kmem_cache *fscache_cookie_jar;\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nstruct fscache_cookie *__fscache_acquire_cookie(\n\tstruct fscache_cookie *parent,\n\tconst struct fscache_cookie_def *def,\n\tvoid *netfs_data,\n\tbool enable)\n{\n\tstruct fscache_cookie *cookie;\n\n\tBUG_ON(!def);\n\n\t_enter(\"{%s},{%s},%p,%u\",\n\t       parent ? (char *) parent->def->name : \"<no-parent>\",\n\t       def->name, netfs_data, enable);\n\n\tfscache_stat(&fscache_n_acquires);\n\n\t/* if there's no parent cookie, then we don't create one here either */\n\tif (!parent) {\n\t\tfscache_stat(&fscache_n_acquires_null);\n\t\t_leave(\" [no parent]\");\n\t\treturn NULL;\n\t}\n\n\t/* validate the definition */\n\tBUG_ON(!def->get_key);\n\tBUG_ON(!def->name[0]);\n\n\tBUG_ON(def->type == FSCACHE_COOKIE_TYPE_INDEX &&\n\t       parent->def->type != FSCACHE_COOKIE_TYPE_INDEX);\n\n\t/* allocate and initialise a cookie */\n\tcookie = kmem_cache_alloc(fscache_cookie_jar, GFP_KERNEL);\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_acquires_oom);\n\t\t_leave(\" [ENOMEM]\");\n\t\treturn NULL;\n\t}\n\n\tatomic_set(&cookie->usage, 1);\n\tatomic_set(&cookie->n_children, 0);\n\n\t/* We keep the active count elevated until relinquishment to prevent an\n\t * attempt to wake up every time the object operations queue quiesces.\n\t */\n\tatomic_set(&cookie->n_active, 1);\n\n\tatomic_inc(&parent->usage);\n\tatomic_inc(&parent->n_children);\n\n\tcookie->def\t\t= def;\n\tcookie->parent\t\t= parent;\n\tcookie->netfs_data\t= netfs_data;\n\tcookie->flags\t\t= (1 << FSCACHE_COOKIE_NO_DATA_YET);\n\n\t/* radix tree insertion won't use the preallocation pool unless it's\n\t * told it may not wait */\n\tINIT_RADIX_TREE(&cookie->stores, GFP_NOFS & ~__GFP_WAIT);\n\n\tswitch (cookie->def->type) {\n\tcase FSCACHE_COOKIE_TYPE_INDEX:\n\t\tfscache_stat(&fscache_n_cookie_index);\n\t\tbreak;\n\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\n\t\tfscache_stat(&fscache_n_cookie_data);\n\t\tbreak;\n\tdefault:\n\t\tfscache_stat(&fscache_n_cookie_special);\n\t\tbreak;\n\t}\n\n\tif (enable) {\n\t\t/* if the object is an index then we need do nothing more here\n\t\t * - we create indices on disk when we need them as an index\n\t\t * may exist in multiple caches */\n\t\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t\tif (fscache_acquire_non_index_cookie(cookie) == 0) {\n\t\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t\t} else {\n\t\t\t\tatomic_dec(&parent->n_children);\n\t\t\t\t__fscache_cookie_put(cookie);\n\t\t\t\tfscache_stat(&fscache_n_acquires_nobufs);\n\t\t\t\t_leave(\" = NULL\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t}\n\t}\n\n\tfscache_stat(&fscache_n_acquires_ok);\n\t_leave(\" = %p\", cookie);\n\treturn cookie;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&vldb",
            "0",
            "sizeof(vldb)"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "vl->valid",
            "==,0"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_vlocation_fill_in_record(struct afs_vlocation *vl,\n\t\t\t\t\tstruct key *key)\n{\n\tstruct afs_cache_vlocation vldb;\n\tint ret;\n\n\t_enter(\"\");\n\n\tASSERTCMP(vl->valid, ==, 0);\n\n\tmemset(&vldb, 0, sizeof(vldb));\n\n\t/* see if we have an in-cache copy (will set vl->valid if there is) */\n#ifdef CONFIG_AFS_FSCACHE\n\tvl->cache = fscache_acquire_cookie(vl->cell->cache,\n\t\t\t\t\t   &afs_vlocation_cache_index_def, vl,\n\t\t\t\t\t   true);\n#endif\n\n\tif (vl->valid) {\n\t\t/* try to update a known volume in the cell VL databases by\n\t\t * ID as the name may have changed */\n\t\t_debug(\"found in cache\");\n\t\tret = afs_vlocation_update_record(vl, key, &vldb);\n\t} else {\n\t\t/* try to look up an unknown volume in the cell VL databases by\n\t\t * name */\n\t\tret = afs_vlocation_access_vl_by_name(vl, key, &vldb);\n\t\tif (ret < 0) {\n\t\t\tprintk(\"kAFS: failed to locate '%s' in cell '%s'\\n\",\n\t\t\t       vl->vldb.name, vl->cell->name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tafs_vlocation_apply_update(vl, &vldb);\n\t_leave(\" = 0\");\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_vlocation_apply_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
    "lines": "267-289",
    "snippet": "static void afs_vlocation_apply_update(struct afs_vlocation *vl,\n\t\t\t\t       struct afs_cache_vlocation *vldb)\n{\n\t_debug(\"Done VL Lookup: %s %02x { %08x(%x) %08x(%x) %08x(%x) }\",\n\t       vldb->name, vldb->vidmask,\n\t       ntohl(vldb->servers[0].s_addr), vldb->srvtmask[0],\n\t       ntohl(vldb->servers[1].s_addr), vldb->srvtmask[1],\n\t       ntohl(vldb->servers[2].s_addr), vldb->srvtmask[2]);\n\n\t_debug(\"Vids: %08x %08x %08x\",\n\t       vldb->vid[0], vldb->vid[1], vldb->vid[2]);\n\n\tif (strcmp(vldb->name, vl->vldb.name) != 0)\n\t\tprintk(KERN_NOTICE \"kAFS:\"\n\t\t       \" name of volume '%s' changed to '%s' on server\\n\",\n\t\t       vl->vldb.name, vldb->name);\n\n\tvl->vldb = *vldb;\n\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_update_cookie(vl->cache);\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_update_cookie",
          "args": [
            "vl->cache"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_update_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "475-505",
          "snippet": "void __fscache_update_cookie(struct fscache_cookie *cookie)\n{\n\tstruct fscache_object *object;\n\n\tfscache_stat(&fscache_n_updates);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_updates_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"{%s}\", cookie->def->name);\n\n\tBUG_ON(!cookie->def->get_aux);\n\n\tspin_lock(&cookie->lock);\n\n\tif (fscache_cookie_enabled(cookie)) {\n\t\t/* update the index entry on disk in each cache backing this\n\t\t * cookie.\n\t\t */\n\t\thlist_for_each_entry(object,\n\t\t\t\t     &cookie->backing_objects, cookie_link) {\n\t\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_UPDATE);\n\t\t}\n\t}\n\n\tspin_unlock(&cookie->lock);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
            "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nvoid __fscache_update_cookie(struct fscache_cookie *cookie)\n{\n\tstruct fscache_object *object;\n\n\tfscache_stat(&fscache_n_updates);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_updates_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"{%s}\", cookie->def->name);\n\n\tBUG_ON(!cookie->def->get_aux);\n\n\tspin_lock(&cookie->lock);\n\n\tif (fscache_cookie_enabled(cookie)) {\n\t\t/* update the index entry on disk in each cache backing this\n\t\t * cookie.\n\t\t */\n\t\thlist_for_each_entry(object,\n\t\t\t\t     &cookie->backing_objects, cookie_link) {\n\t\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_UPDATE);\n\t\t}\n\t}\n\n\tspin_unlock(&cookie->lock);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"kAFS:\"\n\t\t       \" name of volume '%s' changed to '%s' on server\\n\"",
            "vl->vldb.name",
            "vldb->name"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "vldb->name",
            "vl->vldb.name"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"Vids: %08x %08x %08x\"",
            "vldb->vid[0]",
            "vldb->vid[1]",
            "vldb->vid[2]"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "vldb->servers[2].s_addr"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "vldb->servers[1].s_addr"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "vldb->servers[0].s_addr"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_vlocation_apply_update(struct afs_vlocation *vl,\n\t\t\t\t       struct afs_cache_vlocation *vldb)\n{\n\t_debug(\"Done VL Lookup: %s %02x { %08x(%x) %08x(%x) %08x(%x) }\",\n\t       vldb->name, vldb->vidmask,\n\t       ntohl(vldb->servers[0].s_addr), vldb->srvtmask[0],\n\t       ntohl(vldb->servers[1].s_addr), vldb->srvtmask[1],\n\t       ntohl(vldb->servers[2].s_addr), vldb->srvtmask[2]);\n\n\t_debug(\"Vids: %08x %08x %08x\",\n\t       vldb->vid[0], vldb->vid[1], vldb->vid[2]);\n\n\tif (strcmp(vldb->name, vl->vldb.name) != 0)\n\t\tprintk(KERN_NOTICE \"kAFS:\"\n\t\t       \" name of volume '%s' changed to '%s' on server\\n\",\n\t\t       vl->vldb.name, vldb->name);\n\n\tvl->vldb = *vldb;\n\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_update_cookie(vl->cache);\n#endif\n}"
  },
  {
    "function_name": "afs_vlocation_update_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
    "lines": "195-262",
    "snippet": "static int afs_vlocation_update_record(struct afs_vlocation *vl,\n\t\t\t\t       struct key *key,\n\t\t\t\t       struct afs_cache_vlocation *vldb)\n{\n\tafs_voltype_t voltype;\n\tafs_volid_t vid;\n\tint ret;\n\n\t/* try to look up a cached volume in the cell VL databases by ID */\n\t_debug(\"Locally Cached: %s %02x { %08x(%x) %08x(%x) %08x(%x) }\",\n\t       vl->vldb.name,\n\t       vl->vldb.vidmask,\n\t       ntohl(vl->vldb.servers[0].s_addr),\n\t       vl->vldb.srvtmask[0],\n\t       ntohl(vl->vldb.servers[1].s_addr),\n\t       vl->vldb.srvtmask[1],\n\t       ntohl(vl->vldb.servers[2].s_addr),\n\t       vl->vldb.srvtmask[2]);\n\n\t_debug(\"Vids: %08x %08x %08x\",\n\t       vl->vldb.vid[0],\n\t       vl->vldb.vid[1],\n\t       vl->vldb.vid[2]);\n\n\tif (vl->vldb.vidmask & AFS_VOL_VTM_RW) {\n\t\tvid = vl->vldb.vid[0];\n\t\tvoltype = AFSVL_RWVOL;\n\t} else if (vl->vldb.vidmask & AFS_VOL_VTM_RO) {\n\t\tvid = vl->vldb.vid[1];\n\t\tvoltype = AFSVL_ROVOL;\n\t} else if (vl->vldb.vidmask & AFS_VOL_VTM_BAK) {\n\t\tvid = vl->vldb.vid[2];\n\t\tvoltype = AFSVL_BACKVOL;\n\t} else {\n\t\tBUG();\n\t\tvid = 0;\n\t\tvoltype = 0;\n\t}\n\n\t/* contact the server to make sure the volume is still available\n\t * - TODO: need to handle disconnected operation here\n\t */\n\tret = afs_vlocation_access_vl_by_id(vl, key, vid, voltype, vldb);\n\tswitch (ret) {\n\t\t/* net error */\n\tdefault:\n\t\tprintk(KERN_WARNING \"kAFS:\"\n\t\t       \" failed to update volume '%s' (%x) up in '%s': %d\\n\",\n\t\t       vl->vldb.name, vid, vl->cell->name, ret);\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\n\t\t/* pulled from local cache into memory */\n\tcase 0:\n\t\t_leave(\" = 0\");\n\t\treturn 0;\n\n\t\t/* uh oh... looks like the volume got deleted */\n\tcase -ENOMEDIUM:\n\t\tprintk(KERN_ERR \"kAFS:\"\n\t\t       \" volume '%s' (%x) does not exist '%s'\\n\",\n\t\t       vl->vldb.name, vid, vl->cell->name);\n\n\t\t/* TODO: make existing record unavailable */\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"kAFS:\"\n\t\t       \" volume '%s' (%x) does not exist '%s'\\n\"",
            "vl->vldb.name",
            "vid",
            "vl->cell->name"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0\""
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vlocation_access_vl_by_id",
          "args": [
            "vl",
            "key",
            "vid",
            "voltype",
            "vldb"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vlocation_access_vl_by_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
          "lines": "93-164",
          "snippet": "static int afs_vlocation_access_vl_by_id(struct afs_vlocation *vl,\n\t\t\t\t\t struct key *key,\n\t\t\t\t\t afs_volid_t volid,\n\t\t\t\t\t afs_voltype_t voltype,\n\t\t\t\t\t struct afs_cache_vlocation *vldb)\n{\n\tstruct afs_cell *cell = vl->cell;\n\tstruct in_addr addr;\n\tint count, ret;\n\n\t_enter(\"%s,%x,%d,\", cell->name, volid, voltype);\n\n\tdown_write(&vl->cell->vl_sem);\n\tret = -ENOMEDIUM;\n\tfor (count = cell->vl_naddrs; count > 0; count--) {\n\t\taddr = cell->vl_addrs[cell->vl_curr_svix];\n\n\t\t_debug(\"CellServ[%hu]: %08x\", cell->vl_curr_svix, addr.s_addr);\n\n\t\t/* attempt to access the VL server */\n\t\tret = afs_vl_get_entry_by_id(&addr, key, volid, voltype, vldb,\n\t\t\t\t\t     &afs_sync_call);\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\tgoto out;\n\t\tcase -ENOMEM:\n\t\tcase -ENONET:\n\t\tcase -ENETUNREACH:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == -ENOMEM || ret == -ENONET)\n\t\t\t\tgoto out;\n\t\t\tgoto rotate;\n\t\tcase -EBUSY:\n\t\t\tvl->upd_busy_cnt++;\n\t\t\tif (vl->upd_busy_cnt <= 3) {\n\t\t\t\tif (vl->upd_busy_cnt > 1) {\n\t\t\t\t\t/* second+ BUSY - sleep a little bit */\n\t\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\t\tschedule_timeout(1);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase -ENOMEDIUM:\n\t\t\tvl->upd_rej_cnt++;\n\t\t\tgoto rotate;\n\t\tdefault:\n\t\t\tret = -EIO;\n\t\t\tgoto rotate;\n\t\t}\n\n\t\t/* rotate the server records upon lookup failure */\n\trotate:\n\t\tcell->vl_curr_svix++;\n\t\tcell->vl_curr_svix %= cell->vl_naddrs;\n\t\tvl->upd_busy_cnt = 0;\n\t}\n\nout:\n\tif (ret < 0 && vl->upd_rej_cnt > 0) {\n\t\tprintk(KERN_NOTICE \"kAFS:\"\n\t\t       \" Active volume no longer valid '%s'\\n\",\n\t\t       vl->vldb.name);\n\t\tvl->valid = 0;\n\t\tret = -ENOMEDIUM;\n\t}\n\n\tup_write(&vl->cell->vl_sem);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_vlocation_access_vl_by_id(struct afs_vlocation *vl,\n\t\t\t\t\t struct key *key,\n\t\t\t\t\t afs_volid_t volid,\n\t\t\t\t\t afs_voltype_t voltype,\n\t\t\t\t\t struct afs_cache_vlocation *vldb)\n{\n\tstruct afs_cell *cell = vl->cell;\n\tstruct in_addr addr;\n\tint count, ret;\n\n\t_enter(\"%s,%x,%d,\", cell->name, volid, voltype);\n\n\tdown_write(&vl->cell->vl_sem);\n\tret = -ENOMEDIUM;\n\tfor (count = cell->vl_naddrs; count > 0; count--) {\n\t\taddr = cell->vl_addrs[cell->vl_curr_svix];\n\n\t\t_debug(\"CellServ[%hu]: %08x\", cell->vl_curr_svix, addr.s_addr);\n\n\t\t/* attempt to access the VL server */\n\t\tret = afs_vl_get_entry_by_id(&addr, key, volid, voltype, vldb,\n\t\t\t\t\t     &afs_sync_call);\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\tgoto out;\n\t\tcase -ENOMEM:\n\t\tcase -ENONET:\n\t\tcase -ENETUNREACH:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == -ENOMEM || ret == -ENONET)\n\t\t\t\tgoto out;\n\t\t\tgoto rotate;\n\t\tcase -EBUSY:\n\t\t\tvl->upd_busy_cnt++;\n\t\t\tif (vl->upd_busy_cnt <= 3) {\n\t\t\t\tif (vl->upd_busy_cnt > 1) {\n\t\t\t\t\t/* second+ BUSY - sleep a little bit */\n\t\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\t\tschedule_timeout(1);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase -ENOMEDIUM:\n\t\t\tvl->upd_rej_cnt++;\n\t\t\tgoto rotate;\n\t\tdefault:\n\t\t\tret = -EIO;\n\t\t\tgoto rotate;\n\t\t}\n\n\t\t/* rotate the server records upon lookup failure */\n\trotate:\n\t\tcell->vl_curr_svix++;\n\t\tcell->vl_curr_svix %= cell->vl_naddrs;\n\t\tvl->upd_busy_cnt = 0;\n\t}\n\nout:\n\tif (ret < 0 && vl->upd_rej_cnt > 0) {\n\t\tprintk(KERN_NOTICE \"kAFS:\"\n\t\t       \" Active volume no longer valid '%s'\\n\",\n\t\t       vl->vldb.name);\n\t\tvl->valid = 0;\n\t\tret = -ENOMEDIUM;\n\t}\n\n\tup_write(&vl->cell->vl_sem);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"Vids: %08x %08x %08x\"",
            "vl->vldb.vid[0]",
            "vl->vldb.vid[1]",
            "vl->vldb.vid[2]"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "vl->vldb.servers[2].s_addr"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "vl->vldb.servers[1].s_addr"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "vl->vldb.servers[0].s_addr"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_vlocation_update_record(struct afs_vlocation *vl,\n\t\t\t\t       struct key *key,\n\t\t\t\t       struct afs_cache_vlocation *vldb)\n{\n\tafs_voltype_t voltype;\n\tafs_volid_t vid;\n\tint ret;\n\n\t/* try to look up a cached volume in the cell VL databases by ID */\n\t_debug(\"Locally Cached: %s %02x { %08x(%x) %08x(%x) %08x(%x) }\",\n\t       vl->vldb.name,\n\t       vl->vldb.vidmask,\n\t       ntohl(vl->vldb.servers[0].s_addr),\n\t       vl->vldb.srvtmask[0],\n\t       ntohl(vl->vldb.servers[1].s_addr),\n\t       vl->vldb.srvtmask[1],\n\t       ntohl(vl->vldb.servers[2].s_addr),\n\t       vl->vldb.srvtmask[2]);\n\n\t_debug(\"Vids: %08x %08x %08x\",\n\t       vl->vldb.vid[0],\n\t       vl->vldb.vid[1],\n\t       vl->vldb.vid[2]);\n\n\tif (vl->vldb.vidmask & AFS_VOL_VTM_RW) {\n\t\tvid = vl->vldb.vid[0];\n\t\tvoltype = AFSVL_RWVOL;\n\t} else if (vl->vldb.vidmask & AFS_VOL_VTM_RO) {\n\t\tvid = vl->vldb.vid[1];\n\t\tvoltype = AFSVL_ROVOL;\n\t} else if (vl->vldb.vidmask & AFS_VOL_VTM_BAK) {\n\t\tvid = vl->vldb.vid[2];\n\t\tvoltype = AFSVL_BACKVOL;\n\t} else {\n\t\tBUG();\n\t\tvid = 0;\n\t\tvoltype = 0;\n\t}\n\n\t/* contact the server to make sure the volume is still available\n\t * - TODO: need to handle disconnected operation here\n\t */\n\tret = afs_vlocation_access_vl_by_id(vl, key, vid, voltype, vldb);\n\tswitch (ret) {\n\t\t/* net error */\n\tdefault:\n\t\tprintk(KERN_WARNING \"kAFS:\"\n\t\t       \" failed to update volume '%s' (%x) up in '%s': %d\\n\",\n\t\t       vl->vldb.name, vid, vl->cell->name, ret);\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\n\t\t/* pulled from local cache into memory */\n\tcase 0:\n\t\t_leave(\" = 0\");\n\t\treturn 0;\n\n\t\t/* uh oh... looks like the volume got deleted */\n\tcase -ENOMEDIUM:\n\t\tprintk(KERN_ERR \"kAFS:\"\n\t\t       \" volume '%s' (%x) does not exist '%s'\\n\",\n\t\t       vl->vldb.name, vid, vl->cell->name);\n\n\t\t/* TODO: make existing record unavailable */\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n}"
  },
  {
    "function_name": "afs_vlocation_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
    "lines": "169-190",
    "snippet": "static struct afs_vlocation *afs_vlocation_alloc(struct afs_cell *cell,\n\t\t\t\t\t\t const char *name,\n\t\t\t\t\t\t size_t namesz)\n{\n\tstruct afs_vlocation *vl;\n\n\tvl = kzalloc(sizeof(struct afs_vlocation), GFP_KERNEL);\n\tif (vl) {\n\t\tvl->cell = cell;\n\t\tvl->state = AFS_VL_NEW;\n\t\tatomic_set(&vl->usage, 1);\n\t\tINIT_LIST_HEAD(&vl->link);\n\t\tINIT_LIST_HEAD(&vl->grave);\n\t\tINIT_LIST_HEAD(&vl->update);\n\t\tinit_waitqueue_head(&vl->waitq);\n\t\tspin_lock_init(&vl->lock);\n\t\tmemcpy(vl->vldb.name, name, namesz);\n\t}\n\n\t_leave(\" = %p\", vl);\n\treturn vl;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %p\"",
            "vl"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "vl->vldb.name",
            "name",
            "namesz"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&vl->lock"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&vl->waitq"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&vl->update"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&vl->grave"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&vl->link"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&vl->usage",
            "1"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct afs_vlocation)",
            "GFP_KERNEL"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct afs_vlocation *afs_vlocation_alloc(struct afs_cell *cell,\n\t\t\t\t\t\t const char *name,\n\t\t\t\t\t\t size_t namesz)\n{\n\tstruct afs_vlocation *vl;\n\n\tvl = kzalloc(sizeof(struct afs_vlocation), GFP_KERNEL);\n\tif (vl) {\n\t\tvl->cell = cell;\n\t\tvl->state = AFS_VL_NEW;\n\t\tatomic_set(&vl->usage, 1);\n\t\tINIT_LIST_HEAD(&vl->link);\n\t\tINIT_LIST_HEAD(&vl->grave);\n\t\tINIT_LIST_HEAD(&vl->update);\n\t\tinit_waitqueue_head(&vl->waitq);\n\t\tspin_lock_init(&vl->lock);\n\t\tmemcpy(vl->vldb.name, name, namesz);\n\t}\n\n\t_leave(\" = %p\", vl);\n\treturn vl;\n}"
  },
  {
    "function_name": "afs_vlocation_access_vl_by_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
    "lines": "93-164",
    "snippet": "static int afs_vlocation_access_vl_by_id(struct afs_vlocation *vl,\n\t\t\t\t\t struct key *key,\n\t\t\t\t\t afs_volid_t volid,\n\t\t\t\t\t afs_voltype_t voltype,\n\t\t\t\t\t struct afs_cache_vlocation *vldb)\n{\n\tstruct afs_cell *cell = vl->cell;\n\tstruct in_addr addr;\n\tint count, ret;\n\n\t_enter(\"%s,%x,%d,\", cell->name, volid, voltype);\n\n\tdown_write(&vl->cell->vl_sem);\n\tret = -ENOMEDIUM;\n\tfor (count = cell->vl_naddrs; count > 0; count--) {\n\t\taddr = cell->vl_addrs[cell->vl_curr_svix];\n\n\t\t_debug(\"CellServ[%hu]: %08x\", cell->vl_curr_svix, addr.s_addr);\n\n\t\t/* attempt to access the VL server */\n\t\tret = afs_vl_get_entry_by_id(&addr, key, volid, voltype, vldb,\n\t\t\t\t\t     &afs_sync_call);\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\tgoto out;\n\t\tcase -ENOMEM:\n\t\tcase -ENONET:\n\t\tcase -ENETUNREACH:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == -ENOMEM || ret == -ENONET)\n\t\t\t\tgoto out;\n\t\t\tgoto rotate;\n\t\tcase -EBUSY:\n\t\t\tvl->upd_busy_cnt++;\n\t\t\tif (vl->upd_busy_cnt <= 3) {\n\t\t\t\tif (vl->upd_busy_cnt > 1) {\n\t\t\t\t\t/* second+ BUSY - sleep a little bit */\n\t\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\t\tschedule_timeout(1);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase -ENOMEDIUM:\n\t\t\tvl->upd_rej_cnt++;\n\t\t\tgoto rotate;\n\t\tdefault:\n\t\t\tret = -EIO;\n\t\t\tgoto rotate;\n\t\t}\n\n\t\t/* rotate the server records upon lookup failure */\n\trotate:\n\t\tcell->vl_curr_svix++;\n\t\tcell->vl_curr_svix %= cell->vl_naddrs;\n\t\tvl->upd_busy_cnt = 0;\n\t}\n\nout:\n\tif (ret < 0 && vl->upd_rej_cnt > 0) {\n\t\tprintk(KERN_NOTICE \"kAFS:\"\n\t\t       \" Active volume no longer valid '%s'\\n\",\n\t\t       vl->vldb.name);\n\t\tvl->valid = 0;\n\t\tret = -ENOMEDIUM;\n\t}\n\n\tup_write(&vl->cell->vl_sem);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&vl->cell->vl_sem"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"kAFS:\"\n\t\t       \" Active volume no longer valid '%s'\\n\"",
            "vl->vldb.name"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout",
          "args": [
            "1"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_vl_get_entry_by_id",
          "args": [
            "&addr",
            "key",
            "volid",
            "voltype",
            "vldb",
            "&afs_sync_call"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vl_get_entry_by_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlclient.c",
          "lines": "190-219",
          "snippet": "int afs_vl_get_entry_by_id(struct in_addr *addr,\n\t\t\t   struct key *key,\n\t\t\t   afs_volid_t volid,\n\t\t\t   afs_voltype_t voltype,\n\t\t\t   struct afs_cache_vlocation *entry,\n\t\t\t   const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(&afs_RXVLGetEntryById, 12, 384);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = entry;\n\tcall->service_id = VL_SERVICE;\n\tcall->port = htons(AFS_VL_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(VLGETENTRYBYID);\n\t*bp++ = htonl(volid);\n\t*bp   = htonl(voltype);\n\n\t/* initiate the call */\n\treturn afs_make_call(addr, call, GFP_KERNEL, wait_mode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct afs_call_type afs_RXVLGetEntryById = {\n\t.name\t\t= \"VL.GetEntryById\",\n\t.deliver\t= afs_deliver_vl_get_entry_by_xxx,\n\t.abort_to_error\t= afs_vl_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n\nstatic const struct afs_call_type afs_RXVLGetEntryById = {\n\t.name\t\t= \"VL.GetEntryById\",\n\t.deliver\t= afs_deliver_vl_get_entry_by_xxx,\n\t.abort_to_error\t= afs_vl_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nint afs_vl_get_entry_by_id(struct in_addr *addr,\n\t\t\t   struct key *key,\n\t\t\t   afs_volid_t volid,\n\t\t\t   afs_voltype_t voltype,\n\t\t\t   struct afs_cache_vlocation *entry,\n\t\t\t   const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(&afs_RXVLGetEntryById, 12, 384);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = entry;\n\tcall->service_id = VL_SERVICE;\n\tcall->port = htons(AFS_VL_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(VLGETENTRYBYID);\n\t*bp++ = htonl(volid);\n\t*bp   = htonl(voltype);\n\n\t/* initiate the call */\n\treturn afs_make_call(addr, call, GFP_KERNEL, wait_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"CellServ[%hu]: %08x\"",
            "cell->vl_curr_svix",
            "addr.s_addr"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&vl->cell->vl_sem"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%s,%x,%d,\"",
            "cell->name",
            "volid",
            "voltype"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_vlocation_access_vl_by_id(struct afs_vlocation *vl,\n\t\t\t\t\t struct key *key,\n\t\t\t\t\t afs_volid_t volid,\n\t\t\t\t\t afs_voltype_t voltype,\n\t\t\t\t\t struct afs_cache_vlocation *vldb)\n{\n\tstruct afs_cell *cell = vl->cell;\n\tstruct in_addr addr;\n\tint count, ret;\n\n\t_enter(\"%s,%x,%d,\", cell->name, volid, voltype);\n\n\tdown_write(&vl->cell->vl_sem);\n\tret = -ENOMEDIUM;\n\tfor (count = cell->vl_naddrs; count > 0; count--) {\n\t\taddr = cell->vl_addrs[cell->vl_curr_svix];\n\n\t\t_debug(\"CellServ[%hu]: %08x\", cell->vl_curr_svix, addr.s_addr);\n\n\t\t/* attempt to access the VL server */\n\t\tret = afs_vl_get_entry_by_id(&addr, key, volid, voltype, vldb,\n\t\t\t\t\t     &afs_sync_call);\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\tgoto out;\n\t\tcase -ENOMEM:\n\t\tcase -ENONET:\n\t\tcase -ENETUNREACH:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == -ENOMEM || ret == -ENONET)\n\t\t\t\tgoto out;\n\t\t\tgoto rotate;\n\t\tcase -EBUSY:\n\t\t\tvl->upd_busy_cnt++;\n\t\t\tif (vl->upd_busy_cnt <= 3) {\n\t\t\t\tif (vl->upd_busy_cnt > 1) {\n\t\t\t\t\t/* second+ BUSY - sleep a little bit */\n\t\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\t\tschedule_timeout(1);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase -ENOMEDIUM:\n\t\t\tvl->upd_rej_cnt++;\n\t\t\tgoto rotate;\n\t\tdefault:\n\t\t\tret = -EIO;\n\t\t\tgoto rotate;\n\t\t}\n\n\t\t/* rotate the server records upon lookup failure */\n\trotate:\n\t\tcell->vl_curr_svix++;\n\t\tcell->vl_curr_svix %= cell->vl_naddrs;\n\t\tvl->upd_busy_cnt = 0;\n\t}\n\nout:\n\tif (ret < 0 && vl->upd_rej_cnt > 0) {\n\t\tprintk(KERN_NOTICE \"kAFS:\"\n\t\t       \" Active volume no longer valid '%s'\\n\",\n\t\t       vl->vldb.name);\n\t\tvl->valid = 0;\n\t\tret = -ENOMEDIUM;\n\t}\n\n\tup_write(&vl->cell->vl_sem);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "afs_vlocation_access_vl_by_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
    "lines": "37-87",
    "snippet": "static int afs_vlocation_access_vl_by_name(struct afs_vlocation *vl,\n\t\t\t\t\t   struct key *key,\n\t\t\t\t\t   struct afs_cache_vlocation *vldb)\n{\n\tstruct afs_cell *cell = vl->cell;\n\tstruct in_addr addr;\n\tint count, ret;\n\n\t_enter(\"%s,%s\", cell->name, vl->vldb.name);\n\n\tdown_write(&vl->cell->vl_sem);\n\tret = -ENOMEDIUM;\n\tfor (count = cell->vl_naddrs; count > 0; count--) {\n\t\taddr = cell->vl_addrs[cell->vl_curr_svix];\n\n\t\t_debug(\"CellServ[%hu]: %08x\", cell->vl_curr_svix, addr.s_addr);\n\n\t\t/* attempt to access the VL server */\n\t\tret = afs_vl_get_entry_by_name(&addr, key, vl->vldb.name, vldb,\n\t\t\t\t\t       &afs_sync_call);\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\tgoto out;\n\t\tcase -ENOMEM:\n\t\tcase -ENONET:\n\t\tcase -ENETUNREACH:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == -ENOMEM || ret == -ENONET)\n\t\t\t\tgoto out;\n\t\t\tgoto rotate;\n\t\tcase -ENOMEDIUM:\n\t\tcase -EKEYREJECTED:\n\t\tcase -EKEYEXPIRED:\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tret = -EIO;\n\t\t\tgoto rotate;\n\t\t}\n\n\t\t/* rotate the server records upon lookup failure */\n\trotate:\n\t\tcell->vl_curr_svix++;\n\t\tcell->vl_curr_svix %= cell->vl_naddrs;\n\t}\n\nout:\n\tup_write(&vl->cell->vl_sem);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&vl->cell->vl_sem"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_vl_get_entry_by_name",
          "args": [
            "&addr",
            "key",
            "vl->vldb.name",
            "vldb",
            "&afs_sync_call"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vl_get_entry_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlclient.c",
          "lines": "150-185",
          "snippet": "int afs_vl_get_entry_by_name(struct in_addr *addr,\n\t\t\t     struct key *key,\n\t\t\t     const char *volname,\n\t\t\t     struct afs_cache_vlocation *entry,\n\t\t\t     const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\tsize_t volnamesz, reqsz, padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tvolnamesz = strlen(volname);\n\tpadsz = (4 - (volnamesz & 3)) & 3;\n\treqsz = 8 + volnamesz + padsz;\n\n\tcall = afs_alloc_flat_call(&afs_RXVLGetEntryByName, reqsz, 384);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = entry;\n\tcall->service_id = VL_SERVICE;\n\tcall->port = htons(AFS_VL_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(VLGETENTRYBYNAME);\n\t*bp++ = htonl(volnamesz);\n\tmemcpy(bp, volname, volnamesz);\n\tif (padsz > 0)\n\t\tmemset((void *) bp + volnamesz, 0, padsz);\n\n\t/* initiate the call */\n\treturn afs_make_call(addr, call, GFP_KERNEL, wait_mode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct afs_call_type afs_RXVLGetEntryByName = {\n\t.name\t\t= \"VL.GetEntryByName\",\n\t.deliver\t= afs_deliver_vl_get_entry_by_xxx,\n\t.abort_to_error\t= afs_vl_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n\nstatic const struct afs_call_type afs_RXVLGetEntryByName = {\n\t.name\t\t= \"VL.GetEntryByName\",\n\t.deliver\t= afs_deliver_vl_get_entry_by_xxx,\n\t.abort_to_error\t= afs_vl_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nint afs_vl_get_entry_by_name(struct in_addr *addr,\n\t\t\t     struct key *key,\n\t\t\t     const char *volname,\n\t\t\t     struct afs_cache_vlocation *entry,\n\t\t\t     const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\tsize_t volnamesz, reqsz, padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tvolnamesz = strlen(volname);\n\tpadsz = (4 - (volnamesz & 3)) & 3;\n\treqsz = 8 + volnamesz + padsz;\n\n\tcall = afs_alloc_flat_call(&afs_RXVLGetEntryByName, reqsz, 384);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = entry;\n\tcall->service_id = VL_SERVICE;\n\tcall->port = htons(AFS_VL_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(VLGETENTRYBYNAME);\n\t*bp++ = htonl(volnamesz);\n\tmemcpy(bp, volname, volnamesz);\n\tif (padsz > 0)\n\t\tmemset((void *) bp + volnamesz, 0, padsz);\n\n\t/* initiate the call */\n\treturn afs_make_call(addr, call, GFP_KERNEL, wait_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"CellServ[%hu]: %08x\"",
            "cell->vl_curr_svix",
            "addr.s_addr"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&vl->cell->vl_sem"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%s,%s\"",
            "cell->name",
            "vl->vldb.name"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_vlocation_access_vl_by_name(struct afs_vlocation *vl,\n\t\t\t\t\t   struct key *key,\n\t\t\t\t\t   struct afs_cache_vlocation *vldb)\n{\n\tstruct afs_cell *cell = vl->cell;\n\tstruct in_addr addr;\n\tint count, ret;\n\n\t_enter(\"%s,%s\", cell->name, vl->vldb.name);\n\n\tdown_write(&vl->cell->vl_sem);\n\tret = -ENOMEDIUM;\n\tfor (count = cell->vl_naddrs; count > 0; count--) {\n\t\taddr = cell->vl_addrs[cell->vl_curr_svix];\n\n\t\t_debug(\"CellServ[%hu]: %08x\", cell->vl_curr_svix, addr.s_addr);\n\n\t\t/* attempt to access the VL server */\n\t\tret = afs_vl_get_entry_by_name(&addr, key, vl->vldb.name, vldb,\n\t\t\t\t\t       &afs_sync_call);\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\tgoto out;\n\t\tcase -ENOMEM:\n\t\tcase -ENONET:\n\t\tcase -ENETUNREACH:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == -ENOMEM || ret == -ENONET)\n\t\t\t\tgoto out;\n\t\t\tgoto rotate;\n\t\tcase -ENOMEDIUM:\n\t\tcase -EKEYREJECTED:\n\t\tcase -EKEYEXPIRED:\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tret = -EIO;\n\t\t\tgoto rotate;\n\t\t}\n\n\t\t/* rotate the server records upon lookup failure */\n\trotate:\n\t\tcell->vl_curr_svix++;\n\t\tcell->vl_curr_svix %= cell->vl_naddrs;\n\t}\n\nout:\n\tup_write(&vl->cell->vl_sem);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  }
]