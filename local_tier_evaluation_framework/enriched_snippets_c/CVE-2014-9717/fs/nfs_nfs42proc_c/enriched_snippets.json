[
  {
    "function_name": "nfs42_proc_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs42proc.c",
    "lines": "110-144",
    "snippet": "loff_t nfs42_proc_llseek(struct file *filep, loff_t offset, int whence)\n{\n\tstruct inode *inode = file_inode(filep);\n\tstruct nfs42_seek_args args = {\n\t\t.sa_fh\t\t= NFS_FH(inode),\n\t\t.sa_offset\t= offset,\n\t\t.sa_what\t= (whence == SEEK_HOLE) ?\n\t\t\t\t\tNFS4_CONTENT_HOLE : NFS4_CONTENT_DATA,\n\t};\n\tstruct nfs42_seek_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SEEK],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tint status;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_SEEK))\n\t\treturn -ENOTSUPP;\n\n\tstatus = nfs42_set_rw_stateid(&args.sa_stateid, filep, FMODE_READ);\n\tif (status)\n\t\treturn status;\n\n\tnfs_wb_all(inode);\n\tstatus = nfs4_call_sync(server->client, server, &msg,\n\t\t\t\t&args.seq_args, &res.seq_res, 0);\n\tif (status == -ENOTSUPP)\n\t\tserver->caps &= ~NFS_CAP_SEEK;\n\tif (status)\n\t\treturn status;\n\n\treturn vfs_setpos(filep, res.sr_offset, inode->i_sb->s_maxbytes);\n}",
    "includes": [
      "#include \"nfs42.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs_xdr.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/nfs3.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfs_setpos",
          "args": [
            "filep",
            "res.sr_offset",
            "inode->i_sb->s_maxbytes"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_setpos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "57-69",
          "snippet": "loff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tif (offset < 0 && !unsigned_offsets(file))\n\t\treturn -EINVAL;\n\tif (offset > maxsize)\n\t\treturn -EINVAL;\n\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tfile->f_version = 0;\n\t}\n\treturn offset;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tif (offset < 0 && !unsigned_offsets(file))\n\t\treturn -EINVAL;\n\tif (offset > maxsize)\n\t\treturn -EINVAL;\n\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tfile->f_version = 0;\n\t}\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_call_sync",
          "args": [
            "server->client",
            "server",
            "&msg",
            "&args.seq_args",
            "&res.seq_res",
            "0"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_call_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "884-893",
          "snippet": "int nfs4_call_sync(struct rpc_clnt *clnt,\n\t\t   struct nfs_server *server,\n\t\t   struct rpc_message *msg,\n\t\t   struct nfs4_sequence_args *args,\n\t\t   struct nfs4_sequence_res *res,\n\t\t   int cache_reply)\n{\n\tnfs4_init_sequence(args, res, cache_reply);\n\treturn nfs4_call_sync_sequence(clnt, server, msg, args, res);\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nint nfs4_call_sync(struct rpc_clnt *clnt,\n\t\t   struct nfs_server *server,\n\t\t   struct rpc_message *msg,\n\t\t   struct nfs4_sequence_args *args,\n\t\t   struct nfs4_sequence_res *res,\n\t\t   int cache_reply)\n{\n\tnfs4_init_sequence(args, res, cache_reply);\n\treturn nfs4_call_sync_sequence(clnt, server, msg, args, res);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_wb_all",
          "args": [
            "inode"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_wb_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1841-1857",
          "snippet": "int nfs_wb_all(struct inode *inode)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\tint ret;\n\n\ttrace_nfs_writeback_inode_enter(inode);\n\n\tret = sync_inode(inode, &wbc);\n\n\ttrace_nfs_writeback_inode_exit(inode, ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nint nfs_wb_all(struct inode *inode)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\tint ret;\n\n\ttrace_nfs_writeback_inode_enter(inode);\n\n\tret = sync_inode(inode, &wbc);\n\n\ttrace_nfs_writeback_inode_exit(inode, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs42_set_rw_stateid",
          "args": [
            "&args.sa_stateid",
            "filep",
            "FMODE_READ"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "nfs42_set_rw_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs42proc.c",
          "lines": "14-33",
          "snippet": "static int nfs42_set_rw_stateid(nfs4_stateid *dst, struct file *file,\n\t\t\t\tfmode_t fmode)\n{\n\tstruct nfs_open_context *open;\n\tstruct nfs_lock_context *lock;\n\tint ret;\n\n\topen = get_nfs_open_context(nfs_file_open_context(file));\n\tlock = nfs_get_lock_context(open);\n\tif (IS_ERR(lock)) {\n\t\tput_nfs_open_context(open);\n\t\treturn PTR_ERR(lock);\n\t}\n\n\tret = nfs4_set_rw_stateid(dst, open, lock, fmode);\n\n\tnfs_put_lock_context(lock);\n\tput_nfs_open_context(open);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfs42.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs42.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_fs.h>\n#include <linux/nfs_xdr.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/fs.h>\n\nstatic int nfs42_set_rw_stateid(nfs4_stateid *dst, struct file *file,\n\t\t\t\tfmode_t fmode)\n{\n\tstruct nfs_open_context *open;\n\tstruct nfs_lock_context *lock;\n\tint ret;\n\n\topen = get_nfs_open_context(nfs_file_open_context(file));\n\tlock = nfs_get_lock_context(open);\n\tif (IS_ERR(lock)) {\n\t\tput_nfs_open_context(open);\n\t\treturn PTR_ERR(lock);\n\t}\n\n\tret = nfs4_set_rw_stateid(dst, open, lock, fmode);\n\n\tnfs_put_lock_context(lock);\n\tput_nfs_open_context(open);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_server_capable",
          "args": [
            "inode",
            "NFS_CAP_SEEK"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_FH",
          "args": [
            "inode"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filep"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfs42.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_fs.h>\n#include <linux/nfs_xdr.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/fs.h>\n\nloff_t nfs42_proc_llseek(struct file *filep, loff_t offset, int whence)\n{\n\tstruct inode *inode = file_inode(filep);\n\tstruct nfs42_seek_args args = {\n\t\t.sa_fh\t\t= NFS_FH(inode),\n\t\t.sa_offset\t= offset,\n\t\t.sa_what\t= (whence == SEEK_HOLE) ?\n\t\t\t\t\tNFS4_CONTENT_HOLE : NFS4_CONTENT_DATA,\n\t};\n\tstruct nfs42_seek_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SEEK],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tint status;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_SEEK))\n\t\treturn -ENOTSUPP;\n\n\tstatus = nfs42_set_rw_stateid(&args.sa_stateid, filep, FMODE_READ);\n\tif (status)\n\t\treturn status;\n\n\tnfs_wb_all(inode);\n\tstatus = nfs4_call_sync(server->client, server, &msg,\n\t\t\t\t&args.seq_args, &res.seq_res, 0);\n\tif (status == -ENOTSUPP)\n\t\tserver->caps &= ~NFS_CAP_SEEK;\n\tif (status)\n\t\treturn status;\n\n\treturn vfs_setpos(filep, res.sr_offset, inode->i_sb->s_maxbytes);\n}"
  },
  {
    "function_name": "nfs42_proc_deallocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs42proc.c",
    "lines": "93-108",
    "snippet": "int nfs42_proc_deallocate(struct file *filep, loff_t offset, loff_t len)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_DEALLOCATE],\n\t};\n\tstruct inode *inode = file_inode(filep);\n\tint err;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_DEALLOCATE))\n\t\treturn -EOPNOTSUPP;\n\n\terr = nfs42_proc_fallocate(&msg, filep, offset, len);\n\tif (err == -EOPNOTSUPP)\n\t\tNFS_SERVER(inode)->caps &= ~NFS_CAP_DEALLOCATE;\n\treturn err;\n}",
    "includes": [
      "#include \"nfs42.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs_xdr.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/nfs3.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs42_proc_fallocate",
          "args": [
            "&msg",
            "filep",
            "offset",
            "len"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "nfs42_proc_fallocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs42proc.c",
          "lines": "59-74",
          "snippet": "static int nfs42_proc_fallocate(struct rpc_message *msg, struct file *filep,\n\t\t\t\tloff_t offset, loff_t len)\n{\n\tstruct nfs_server *server = NFS_SERVER(file_inode(filep));\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = _nfs42_proc_fallocate(msg, filep, offset, len);\n\t\tif (err == -ENOTSUPP)\n\t\t\treturn -EOPNOTSUPP;\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\n\treturn err;\n}",
          "includes": [
            "#include \"nfs42.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs42.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_fs.h>\n#include <linux/nfs_xdr.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/fs.h>\n\nstatic int nfs42_proc_fallocate(struct rpc_message *msg, struct file *filep,\n\t\t\t\tloff_t offset, loff_t len)\n{\n\tstruct nfs_server *server = NFS_SERVER(file_inode(filep));\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = _nfs42_proc_fallocate(msg, filep, offset, len);\n\t\tif (err == -ENOTSUPP)\n\t\t\treturn -EOPNOTSUPP;\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_server_capable",
          "args": [
            "inode",
            "NFS_CAP_DEALLOCATE"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filep"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfs42.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_fs.h>\n#include <linux/nfs_xdr.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/fs.h>\n\nint nfs42_proc_deallocate(struct file *filep, loff_t offset, loff_t len)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_DEALLOCATE],\n\t};\n\tstruct inode *inode = file_inode(filep);\n\tint err;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_DEALLOCATE))\n\t\treturn -EOPNOTSUPP;\n\n\terr = nfs42_proc_fallocate(&msg, filep, offset, len);\n\tif (err == -EOPNOTSUPP)\n\t\tNFS_SERVER(inode)->caps &= ~NFS_CAP_DEALLOCATE;\n\treturn err;\n}"
  },
  {
    "function_name": "nfs42_proc_allocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs42proc.c",
    "lines": "76-91",
    "snippet": "int nfs42_proc_allocate(struct file *filep, loff_t offset, loff_t len)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_ALLOCATE],\n\t};\n\tstruct inode *inode = file_inode(filep);\n\tint err;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_ALLOCATE))\n\t\treturn -EOPNOTSUPP;\n\n\terr = nfs42_proc_fallocate(&msg, filep, offset, len);\n\tif (err == -EOPNOTSUPP)\n\t\tNFS_SERVER(inode)->caps &= ~NFS_CAP_ALLOCATE;\n\treturn err;\n}",
    "includes": [
      "#include \"nfs42.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs_xdr.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/nfs3.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs42_proc_fallocate",
          "args": [
            "&msg",
            "filep",
            "offset",
            "len"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "nfs42_proc_fallocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs42proc.c",
          "lines": "59-74",
          "snippet": "static int nfs42_proc_fallocate(struct rpc_message *msg, struct file *filep,\n\t\t\t\tloff_t offset, loff_t len)\n{\n\tstruct nfs_server *server = NFS_SERVER(file_inode(filep));\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = _nfs42_proc_fallocate(msg, filep, offset, len);\n\t\tif (err == -ENOTSUPP)\n\t\t\treturn -EOPNOTSUPP;\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\n\treturn err;\n}",
          "includes": [
            "#include \"nfs42.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs42.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_fs.h>\n#include <linux/nfs_xdr.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/fs.h>\n\nstatic int nfs42_proc_fallocate(struct rpc_message *msg, struct file *filep,\n\t\t\t\tloff_t offset, loff_t len)\n{\n\tstruct nfs_server *server = NFS_SERVER(file_inode(filep));\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = _nfs42_proc_fallocate(msg, filep, offset, len);\n\t\tif (err == -ENOTSUPP)\n\t\t\treturn -EOPNOTSUPP;\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_server_capable",
          "args": [
            "inode",
            "NFS_CAP_ALLOCATE"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filep"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfs42.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_fs.h>\n#include <linux/nfs_xdr.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/fs.h>\n\nint nfs42_proc_allocate(struct file *filep, loff_t offset, loff_t len)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_ALLOCATE],\n\t};\n\tstruct inode *inode = file_inode(filep);\n\tint err;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_ALLOCATE))\n\t\treturn -EOPNOTSUPP;\n\n\terr = nfs42_proc_fallocate(&msg, filep, offset, len);\n\tif (err == -EOPNOTSUPP)\n\t\tNFS_SERVER(inode)->caps &= ~NFS_CAP_ALLOCATE;\n\treturn err;\n}"
  },
  {
    "function_name": "nfs42_proc_fallocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs42proc.c",
    "lines": "59-74",
    "snippet": "static int nfs42_proc_fallocate(struct rpc_message *msg, struct file *filep,\n\t\t\t\tloff_t offset, loff_t len)\n{\n\tstruct nfs_server *server = NFS_SERVER(file_inode(filep));\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = _nfs42_proc_fallocate(msg, filep, offset, len);\n\t\tif (err == -ENOTSUPP)\n\t\t\treturn -EOPNOTSUPP;\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\n\treturn err;\n}",
    "includes": [
      "#include \"nfs42.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs_xdr.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/nfs3.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_handle_exception",
          "args": [
            "server",
            "err",
            "&exception"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_handle_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "345-447",
          "snippet": "int nfs4_handle_exception(struct nfs_server *server, int errorcode, struct nfs4_exception *exception)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state *state = exception->state;\n\tstruct inode *inode = exception->inode;\n\tint ret = errorcode;\n\n\texception->retry = 0;\n\tswitch(errorcode) {\n\t\tcase 0:\n\t\t\treturn 0;\n\t\tcase -NFS4ERR_OPENMODE:\n\t\t\tif (inode && nfs4_have_delegation(inode, FMODE_READ)) {\n\t\t\t\tnfs4_inode_return_delegation(inode);\n\t\t\t\texception->retry = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (state == NULL)\n\t\t\t\tbreak;\n\t\t\tret = nfs4_schedule_stateid_recovery(server, state);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tgoto wait_on_recovery;\n\t\tcase -NFS4ERR_DELEG_REVOKED:\n\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\t\tif (state == NULL)\n\t\t\t\tbreak;\n\t\t\tret = nfs4_schedule_stateid_recovery(server, state);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tgoto wait_on_recovery;\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tif (state != NULL) {\n\t\t\t\tret = nfs4_schedule_stateid_recovery(server, state);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tnfs4_schedule_lease_recovery(clp);\n\t\t\tgoto wait_on_recovery;\n\t\tcase -NFS4ERR_MOVED:\n\t\t\tret = nfs4_schedule_migration_recovery(server);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tgoto wait_on_recovery;\n\t\tcase -NFS4ERR_LEASE_MOVED:\n\t\t\tnfs4_schedule_lease_moved_recovery(clp);\n\t\t\tgoto wait_on_recovery;\n#if defined(CONFIG_NFS_V4_1)\n\t\tcase -NFS4ERR_BADSESSION:\n\t\tcase -NFS4ERR_BADSLOT:\n\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\tcase -NFS4ERR_DEADSESSION:\n\t\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\t\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\t\tdprintk(\"%s ERROR: %d Reset session\\n\", __func__,\n\t\t\t\terrorcode);\n\t\t\tnfs4_schedule_session_recovery(clp->cl_session, errorcode);\n\t\t\tgoto wait_on_recovery;\n#endif /* defined(CONFIG_NFS_V4_1) */\n\t\tcase -NFS4ERR_FILE_OPEN:\n\t\t\tif (exception->timeout > HZ) {\n\t\t\t\t/* We have retried a decent amount, time to\n\t\t\t\t * fail\n\t\t\t\t */\n\t\t\t\tret = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase -NFS4ERR_GRACE:\n\t\tcase -NFS4ERR_DELAY:\n\t\t\tret = nfs4_delay(server->client, &exception->timeout);\n\t\t\tif (ret != 0)\n\t\t\t\tbreak;\n\t\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\t\texception->retry = 1;\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BADOWNER:\n\t\t\t/* The following works around a Linux server bug! */\n\t\tcase -NFS4ERR_BADNAME:\n\t\t\tif (server->caps & NFS_CAP_UIDGID_NOMAP) {\n\t\t\t\tserver->caps &= ~NFS_CAP_UIDGID_NOMAP;\n\t\t\t\texception->retry = 1;\n\t\t\t\tprintk(KERN_WARNING \"NFS: v4 server %s \"\n\t\t\t\t\t\t\"does not accept raw \"\n\t\t\t\t\t\t\"uid/gids. \"\n\t\t\t\t\t\t\"Reenabling the idmapper.\\n\",\n\t\t\t\t\t\tserver->nfs_client->cl_hostname);\n\t\t\t}\n\t}\n\t/* We failed to handle the error */\n\treturn nfs4_map_errors(ret);\nwait_on_recovery:\n\tret = nfs4_wait_clnt_recover(clp);\n\tif (test_bit(NFS_MIG_FAILED, &server->mig_status))\n\t\treturn -EIO;\n\tif (ret == 0)\n\t\texception->retry = 1;\n\treturn ret;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs4_async_handle_error(struct rpc_task *, const struct nfs_server *, struct nfs4_state *, long *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int nfs4_async_handle_error(struct rpc_task *, const struct nfs_server *, struct nfs4_state *, long *);\n\nint nfs4_handle_exception(struct nfs_server *server, int errorcode, struct nfs4_exception *exception)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state *state = exception->state;\n\tstruct inode *inode = exception->inode;\n\tint ret = errorcode;\n\n\texception->retry = 0;\n\tswitch(errorcode) {\n\t\tcase 0:\n\t\t\treturn 0;\n\t\tcase -NFS4ERR_OPENMODE:\n\t\t\tif (inode && nfs4_have_delegation(inode, FMODE_READ)) {\n\t\t\t\tnfs4_inode_return_delegation(inode);\n\t\t\t\texception->retry = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (state == NULL)\n\t\t\t\tbreak;\n\t\t\tret = nfs4_schedule_stateid_recovery(server, state);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tgoto wait_on_recovery;\n\t\tcase -NFS4ERR_DELEG_REVOKED:\n\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\t\tif (state == NULL)\n\t\t\t\tbreak;\n\t\t\tret = nfs4_schedule_stateid_recovery(server, state);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tgoto wait_on_recovery;\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tif (state != NULL) {\n\t\t\t\tret = nfs4_schedule_stateid_recovery(server, state);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tnfs4_schedule_lease_recovery(clp);\n\t\t\tgoto wait_on_recovery;\n\t\tcase -NFS4ERR_MOVED:\n\t\t\tret = nfs4_schedule_migration_recovery(server);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tgoto wait_on_recovery;\n\t\tcase -NFS4ERR_LEASE_MOVED:\n\t\t\tnfs4_schedule_lease_moved_recovery(clp);\n\t\t\tgoto wait_on_recovery;\n#if defined(CONFIG_NFS_V4_1)\n\t\tcase -NFS4ERR_BADSESSION:\n\t\tcase -NFS4ERR_BADSLOT:\n\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\tcase -NFS4ERR_DEADSESSION:\n\t\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\t\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\t\tdprintk(\"%s ERROR: %d Reset session\\n\", __func__,\n\t\t\t\terrorcode);\n\t\t\tnfs4_schedule_session_recovery(clp->cl_session, errorcode);\n\t\t\tgoto wait_on_recovery;\n#endif /* defined(CONFIG_NFS_V4_1) */\n\t\tcase -NFS4ERR_FILE_OPEN:\n\t\t\tif (exception->timeout > HZ) {\n\t\t\t\t/* We have retried a decent amount, time to\n\t\t\t\t * fail\n\t\t\t\t */\n\t\t\t\tret = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase -NFS4ERR_GRACE:\n\t\tcase -NFS4ERR_DELAY:\n\t\t\tret = nfs4_delay(server->client, &exception->timeout);\n\t\t\tif (ret != 0)\n\t\t\t\tbreak;\n\t\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\t\texception->retry = 1;\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BADOWNER:\n\t\t\t/* The following works around a Linux server bug! */\n\t\tcase -NFS4ERR_BADNAME:\n\t\t\tif (server->caps & NFS_CAP_UIDGID_NOMAP) {\n\t\t\t\tserver->caps &= ~NFS_CAP_UIDGID_NOMAP;\n\t\t\t\texception->retry = 1;\n\t\t\t\tprintk(KERN_WARNING \"NFS: v4 server %s \"\n\t\t\t\t\t\t\"does not accept raw \"\n\t\t\t\t\t\t\"uid/gids. \"\n\t\t\t\t\t\t\"Reenabling the idmapper.\\n\",\n\t\t\t\t\t\tserver->nfs_client->cl_hostname);\n\t\t\t}\n\t}\n\t/* We failed to handle the error */\n\treturn nfs4_map_errors(ret);\nwait_on_recovery:\n\tret = nfs4_wait_clnt_recover(clp);\n\tif (test_bit(NFS_MIG_FAILED, &server->mig_status))\n\t\treturn -EIO;\n\tif (ret == 0)\n\t\texception->retry = 1;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_nfs42_proc_fallocate",
          "args": [
            "msg",
            "filep",
            "offset",
            "len"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "_nfs42_proc_fallocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs42proc.c",
          "lines": "35-57",
          "snippet": "static int _nfs42_proc_fallocate(struct rpc_message *msg, struct file *filep,\n\t\t\t\t loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(filep);\n\tstruct nfs42_falloc_args args = {\n\t\t.falloc_fh\t= NFS_FH(inode),\n\t\t.falloc_offset\t= offset,\n\t\t.falloc_length\t= len,\n\t};\n\tstruct nfs42_falloc_res res;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tint status;\n\n\tmsg->rpc_argp = &args;\n\tmsg->rpc_resp = &res;\n\n\tstatus = nfs42_set_rw_stateid(&args.falloc_stateid, filep, FMODE_WRITE);\n\tif (status)\n\t\treturn status;\n\n\treturn nfs4_call_sync(server->client, server, msg,\n\t\t\t      &args.seq_args, &res.seq_res, 0);\n}",
          "includes": [
            "#include \"nfs42.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs42.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_fs.h>\n#include <linux/nfs_xdr.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/fs.h>\n\nstatic int _nfs42_proc_fallocate(struct rpc_message *msg, struct file *filep,\n\t\t\t\t loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(filep);\n\tstruct nfs42_falloc_args args = {\n\t\t.falloc_fh\t= NFS_FH(inode),\n\t\t.falloc_offset\t= offset,\n\t\t.falloc_length\t= len,\n\t};\n\tstruct nfs42_falloc_res res;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tint status;\n\n\tmsg->rpc_argp = &args;\n\tmsg->rpc_resp = &res;\n\n\tstatus = nfs42_set_rw_stateid(&args.falloc_stateid, filep, FMODE_WRITE);\n\tif (status)\n\t\treturn status;\n\n\treturn nfs4_call_sync(server->client, server, msg,\n\t\t\t      &args.seq_args, &res.seq_res, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "file_inode(filep)"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filep"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfs42.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_fs.h>\n#include <linux/nfs_xdr.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/fs.h>\n\nstatic int nfs42_proc_fallocate(struct rpc_message *msg, struct file *filep,\n\t\t\t\tloff_t offset, loff_t len)\n{\n\tstruct nfs_server *server = NFS_SERVER(file_inode(filep));\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = _nfs42_proc_fallocate(msg, filep, offset, len);\n\t\tif (err == -ENOTSUPP)\n\t\t\treturn -EOPNOTSUPP;\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\n\treturn err;\n}"
  },
  {
    "function_name": "_nfs42_proc_fallocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs42proc.c",
    "lines": "35-57",
    "snippet": "static int _nfs42_proc_fallocate(struct rpc_message *msg, struct file *filep,\n\t\t\t\t loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(filep);\n\tstruct nfs42_falloc_args args = {\n\t\t.falloc_fh\t= NFS_FH(inode),\n\t\t.falloc_offset\t= offset,\n\t\t.falloc_length\t= len,\n\t};\n\tstruct nfs42_falloc_res res;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tint status;\n\n\tmsg->rpc_argp = &args;\n\tmsg->rpc_resp = &res;\n\n\tstatus = nfs42_set_rw_stateid(&args.falloc_stateid, filep, FMODE_WRITE);\n\tif (status)\n\t\treturn status;\n\n\treturn nfs4_call_sync(server->client, server, msg,\n\t\t\t      &args.seq_args, &res.seq_res, 0);\n}",
    "includes": [
      "#include \"nfs42.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs_xdr.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/nfs3.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_call_sync",
          "args": [
            "server->client",
            "server",
            "msg",
            "&args.seq_args",
            "&res.seq_res",
            "0"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_call_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "884-893",
          "snippet": "int nfs4_call_sync(struct rpc_clnt *clnt,\n\t\t   struct nfs_server *server,\n\t\t   struct rpc_message *msg,\n\t\t   struct nfs4_sequence_args *args,\n\t\t   struct nfs4_sequence_res *res,\n\t\t   int cache_reply)\n{\n\tnfs4_init_sequence(args, res, cache_reply);\n\treturn nfs4_call_sync_sequence(clnt, server, msg, args, res);\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nint nfs4_call_sync(struct rpc_clnt *clnt,\n\t\t   struct nfs_server *server,\n\t\t   struct rpc_message *msg,\n\t\t   struct nfs4_sequence_args *args,\n\t\t   struct nfs4_sequence_res *res,\n\t\t   int cache_reply)\n{\n\tnfs4_init_sequence(args, res, cache_reply);\n\treturn nfs4_call_sync_sequence(clnt, server, msg, args, res);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs42_set_rw_stateid",
          "args": [
            "&args.falloc_stateid",
            "filep",
            "FMODE_WRITE"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "nfs42_set_rw_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs42proc.c",
          "lines": "14-33",
          "snippet": "static int nfs42_set_rw_stateid(nfs4_stateid *dst, struct file *file,\n\t\t\t\tfmode_t fmode)\n{\n\tstruct nfs_open_context *open;\n\tstruct nfs_lock_context *lock;\n\tint ret;\n\n\topen = get_nfs_open_context(nfs_file_open_context(file));\n\tlock = nfs_get_lock_context(open);\n\tif (IS_ERR(lock)) {\n\t\tput_nfs_open_context(open);\n\t\treturn PTR_ERR(lock);\n\t}\n\n\tret = nfs4_set_rw_stateid(dst, open, lock, fmode);\n\n\tnfs_put_lock_context(lock);\n\tput_nfs_open_context(open);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfs42.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs42.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_fs.h>\n#include <linux/nfs_xdr.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/fs.h>\n\nstatic int nfs42_set_rw_stateid(nfs4_stateid *dst, struct file *file,\n\t\t\t\tfmode_t fmode)\n{\n\tstruct nfs_open_context *open;\n\tstruct nfs_lock_context *lock;\n\tint ret;\n\n\topen = get_nfs_open_context(nfs_file_open_context(file));\n\tlock = nfs_get_lock_context(open);\n\tif (IS_ERR(lock)) {\n\t\tput_nfs_open_context(open);\n\t\treturn PTR_ERR(lock);\n\t}\n\n\tret = nfs4_set_rw_stateid(dst, open, lock, fmode);\n\n\tnfs_put_lock_context(lock);\n\tput_nfs_open_context(open);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_FH",
          "args": [
            "inode"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filep"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfs42.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_fs.h>\n#include <linux/nfs_xdr.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/fs.h>\n\nstatic int _nfs42_proc_fallocate(struct rpc_message *msg, struct file *filep,\n\t\t\t\t loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(filep);\n\tstruct nfs42_falloc_args args = {\n\t\t.falloc_fh\t= NFS_FH(inode),\n\t\t.falloc_offset\t= offset,\n\t\t.falloc_length\t= len,\n\t};\n\tstruct nfs42_falloc_res res;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tint status;\n\n\tmsg->rpc_argp = &args;\n\tmsg->rpc_resp = &res;\n\n\tstatus = nfs42_set_rw_stateid(&args.falloc_stateid, filep, FMODE_WRITE);\n\tif (status)\n\t\treturn status;\n\n\treturn nfs4_call_sync(server->client, server, msg,\n\t\t\t      &args.seq_args, &res.seq_res, 0);\n}"
  },
  {
    "function_name": "nfs42_set_rw_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs42proc.c",
    "lines": "14-33",
    "snippet": "static int nfs42_set_rw_stateid(nfs4_stateid *dst, struct file *file,\n\t\t\t\tfmode_t fmode)\n{\n\tstruct nfs_open_context *open;\n\tstruct nfs_lock_context *lock;\n\tint ret;\n\n\topen = get_nfs_open_context(nfs_file_open_context(file));\n\tlock = nfs_get_lock_context(open);\n\tif (IS_ERR(lock)) {\n\t\tput_nfs_open_context(open);\n\t\treturn PTR_ERR(lock);\n\t}\n\n\tret = nfs4_set_rw_stateid(dst, open, lock, fmode);\n\n\tnfs_put_lock_context(lock);\n\tput_nfs_open_context(open);\n\treturn ret;\n}",
    "includes": [
      "#include \"nfs42.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs_xdr.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/nfs3.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_nfs_open_context",
          "args": [
            "open"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "put_nfs_open_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "833-836",
          "snippet": "void put_nfs_open_context(struct nfs_open_context *ctx)\n{\n\t__put_nfs_open_context(ctx, 0);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid put_nfs_open_context(struct nfs_open_context *ctx)\n{\n\t__put_nfs_open_context(ctx, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_put_lock_context",
          "args": [
            "lock"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_put_lock_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "736-746",
          "snippet": "void nfs_put_lock_context(struct nfs_lock_context *l_ctx)\n{\n\tstruct nfs_open_context *ctx = l_ctx->open_context;\n\tstruct inode *inode = ctx->dentry->d_inode;\n\n\tif (!atomic_dec_and_lock(&l_ctx->count, &inode->i_lock))\n\t\treturn;\n\tlist_del(&l_ctx->list);\n\tspin_unlock(&inode->i_lock);\n\tkfree(l_ctx);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\n\nvoid nfs_put_lock_context(struct nfs_lock_context *l_ctx)\n{\n\tstruct nfs_open_context *ctx = l_ctx->open_context;\n\tstruct inode *inode = ctx->dentry->d_inode;\n\n\tif (!atomic_dec_and_lock(&l_ctx->count, &inode->i_lock))\n\t\treturn;\n\tlist_del(&l_ctx->list);\n\tspin_unlock(&inode->i_lock);\n\tkfree(l_ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_set_rw_stateid",
          "args": [
            "dst",
            "open",
            "lock",
            "fmode"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_set_rw_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "4110-4120",
          "snippet": "int nfs4_set_rw_stateid(nfs4_stateid *stateid,\n\t\tconst struct nfs_open_context *ctx,\n\t\tconst struct nfs_lock_context *l_ctx,\n\t\tfmode_t fmode)\n{\n\tconst struct nfs_lockowner *lockowner = NULL;\n\n\tif (l_ctx != NULL)\n\t\tlockowner = &l_ctx->lockowner;\n\treturn nfs4_select_rw_stateid(stateid, ctx->state, fmode, lockowner);\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nint nfs4_set_rw_stateid(nfs4_stateid *stateid,\n\t\tconst struct nfs_open_context *ctx,\n\t\tconst struct nfs_lock_context *l_ctx,\n\t\tfmode_t fmode)\n{\n\tconst struct nfs_lockowner *lockowner = NULL;\n\n\tif (l_ctx != NULL)\n\t\tlockowner = &l_ctx->lockowner;\n\treturn nfs4_select_rw_stateid(stateid, ctx->state, fmode, lockowner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "lock"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "lock"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_get_lock_context",
          "args": [
            "open"
          ],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_get_lock_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "708-733",
          "snippet": "struct nfs_lock_context *nfs_get_lock_context(struct nfs_open_context *ctx)\n{\n\tstruct nfs_lock_context *res, *new = NULL;\n\tstruct inode *inode = ctx->dentry->d_inode;\n\n\tspin_lock(&inode->i_lock);\n\tres = __nfs_find_lock_context(ctx);\n\tif (res == NULL) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tnew = kmalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (new == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnfs_init_lock_context(new);\n\t\tspin_lock(&inode->i_lock);\n\t\tres = __nfs_find_lock_context(ctx);\n\t\tif (res == NULL) {\n\t\t\tlist_add_tail(&new->list, &ctx->lock_context.list);\n\t\t\tnew->open_context = ctx;\n\t\t\tres = new;\n\t\t\tnew = NULL;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n\tkfree(new);\n\treturn res;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\n\nstruct nfs_lock_context *nfs_get_lock_context(struct nfs_open_context *ctx)\n{\n\tstruct nfs_lock_context *res, *new = NULL;\n\tstruct inode *inode = ctx->dentry->d_inode;\n\n\tspin_lock(&inode->i_lock);\n\tres = __nfs_find_lock_context(ctx);\n\tif (res == NULL) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tnew = kmalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (new == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnfs_init_lock_context(new);\n\t\tspin_lock(&inode->i_lock);\n\t\tres = __nfs_find_lock_context(ctx);\n\t\tif (res == NULL) {\n\t\t\tlist_add_tail(&new->list, &ctx->lock_context.list);\n\t\t\tnew->open_context = ctx;\n\t\t\tres = new;\n\t\t\tnew = NULL;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n\tkfree(new);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nfs_open_context",
          "args": [
            "nfs_file_open_context(file)"
          ],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "get_nfs_open_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "803-808",
          "snippet": "struct nfs_open_context *get_nfs_open_context(struct nfs_open_context *ctx)\n{\n\tif (ctx != NULL)\n\t\tatomic_inc(&ctx->lock_context.count);\n\treturn ctx;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct nfs_open_context *get_nfs_open_context(struct nfs_open_context *ctx)\n{\n\tif (ctx != NULL)\n\t\tatomic_inc(&ctx->lock_context.count);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_file_open_context",
          "args": [
            "file"
          ],
          "line": 21
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs42.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_fs.h>\n#include <linux/nfs_xdr.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/fs.h>\n\nstatic int nfs42_set_rw_stateid(nfs4_stateid *dst, struct file *file,\n\t\t\t\tfmode_t fmode)\n{\n\tstruct nfs_open_context *open;\n\tstruct nfs_lock_context *lock;\n\tint ret;\n\n\topen = get_nfs_open_context(nfs_file_open_context(file));\n\tlock = nfs_get_lock_context(open);\n\tif (IS_ERR(lock)) {\n\t\tput_nfs_open_context(open);\n\t\treturn PTR_ERR(lock);\n\t}\n\n\tret = nfs4_set_rw_stateid(dst, open, lock, fmode);\n\n\tnfs_put_lock_context(lock);\n\tput_nfs_open_context(open);\n\treturn ret;\n}"
  }
]