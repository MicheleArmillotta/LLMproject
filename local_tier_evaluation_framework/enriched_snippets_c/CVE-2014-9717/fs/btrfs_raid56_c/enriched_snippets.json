[
  {
    "function_name": "raid56_parity_submit_scrub_rbio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "2674-2678",
    "snippet": "void raid56_parity_submit_scrub_rbio(struct btrfs_raid_bio *rbio)\n{\n\tif (!lock_stripe_add(rbio))\n\t\tasync_scrub_parity(rbio);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "async_scrub_parity",
          "args": [
            "rbio"
          ],
          "line": 2677
        },
        "resolved": true,
        "details": {
          "function_name": "async_scrub_parity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "2665-2672",
          "snippet": "static void async_scrub_parity(struct btrfs_raid_bio *rbio)\n{\n\tbtrfs_init_work(&rbio->work, btrfs_rmw_helper,\n\t\t\tscrub_parity_work, NULL, NULL);\n\n\tbtrfs_queue_work(rbio->fs_info->rmw_workers,\n\t\t\t &rbio->work);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void rmw_work(struct btrfs_work *work);",
            "static void read_rebuild_work(struct btrfs_work *work);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void rmw_work(struct btrfs_work *work);\nstatic void read_rebuild_work(struct btrfs_work *work);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio)\n{\n\tbtrfs_init_work(&rbio->work, btrfs_rmw_helper,\n\t\t\tscrub_parity_work, NULL, NULL);\n\n\tbtrfs_queue_work(rbio->fs_info->rmw_workers,\n\t\t\t &rbio->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_stripe_add",
          "args": [
            "rbio"
          ],
          "line": 2676
        },
        "resolved": true,
        "details": {
          "function_name": "lock_stripe_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "660-743",
          "snippet": "static noinline int lock_stripe_add(struct btrfs_raid_bio *rbio)\n{\n\tint bucket = rbio_bucket(rbio);\n\tstruct btrfs_stripe_hash *h = rbio->fs_info->stripe_hash_table->table + bucket;\n\tstruct btrfs_raid_bio *cur;\n\tstruct btrfs_raid_bio *pending;\n\tunsigned long flags;\n\tDEFINE_WAIT(wait);\n\tstruct btrfs_raid_bio *freeit = NULL;\n\tstruct btrfs_raid_bio *cache_drop = NULL;\n\tint ret = 0;\n\tint walk = 0;\n\n\tspin_lock_irqsave(&h->lock, flags);\n\tlist_for_each_entry(cur, &h->hash_list, hash_list) {\n\t\twalk++;\n\t\tif (cur->bbio->raid_map[0] == rbio->bbio->raid_map[0]) {\n\t\t\tspin_lock(&cur->bio_list_lock);\n\n\t\t\t/* can we steal this cached rbio's pages? */\n\t\t\tif (bio_list_empty(&cur->bio_list) &&\n\t\t\t    list_empty(&cur->plug_list) &&\n\t\t\t    test_bit(RBIO_CACHE_BIT, &cur->flags) &&\n\t\t\t    !test_bit(RBIO_RMW_LOCKED_BIT, &cur->flags)) {\n\t\t\t\tlist_del_init(&cur->hash_list);\n\t\t\t\tatomic_dec(&cur->refs);\n\n\t\t\t\tsteal_rbio(cur, rbio);\n\t\t\t\tcache_drop = cur;\n\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\n\t\t\t\tgoto lockit;\n\t\t\t}\n\n\t\t\t/* can we merge into the lock owner? */\n\t\t\tif (rbio_can_merge(cur, rbio)) {\n\t\t\t\tmerge_rbio(cur, rbio);\n\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\t\tfreeit = rbio;\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\n\t\t\t/*\n\t\t\t * we couldn't merge with the running\n\t\t\t * rbio, see if we can merge with the\n\t\t\t * pending ones.  We don't have to\n\t\t\t * check for rmw_locked because there\n\t\t\t * is no way they are inside finish_rmw\n\t\t\t * right now\n\t\t\t */\n\t\t\tlist_for_each_entry(pending, &cur->plug_list,\n\t\t\t\t\t    plug_list) {\n\t\t\t\tif (rbio_can_merge(pending, rbio)) {\n\t\t\t\t\tmerge_rbio(pending, rbio);\n\t\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\t\t\tfreeit = rbio;\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* no merging, put us on the tail of the plug list,\n\t\t\t * our rbio will be started with the currently\n\t\t\t * running rbio unlocks\n\t\t\t */\n\t\t\tlist_add_tail(&rbio->plug_list, &cur->plug_list);\n\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\nlockit:\n\tatomic_inc(&rbio->refs);\n\tlist_add(&rbio->hash_list, &h->hash_list);\nout:\n\tspin_unlock_irqrestore(&h->lock, flags);\n\tif (cache_drop)\n\t\tremove_rbio_from_cache(cache_drop);\n\tif (freeit)\n\t\t__free_raid_bio(freeit);\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RBIO_CACHE_BIT\t\t2",
            "#define RBIO_RMW_LOCKED_BIT\t1"
          ],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_BIT\t\t2\n#define RBIO_RMW_LOCKED_BIT\t1\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic noinline int lock_stripe_add(struct btrfs_raid_bio *rbio)\n{\n\tint bucket = rbio_bucket(rbio);\n\tstruct btrfs_stripe_hash *h = rbio->fs_info->stripe_hash_table->table + bucket;\n\tstruct btrfs_raid_bio *cur;\n\tstruct btrfs_raid_bio *pending;\n\tunsigned long flags;\n\tDEFINE_WAIT(wait);\n\tstruct btrfs_raid_bio *freeit = NULL;\n\tstruct btrfs_raid_bio *cache_drop = NULL;\n\tint ret = 0;\n\tint walk = 0;\n\n\tspin_lock_irqsave(&h->lock, flags);\n\tlist_for_each_entry(cur, &h->hash_list, hash_list) {\n\t\twalk++;\n\t\tif (cur->bbio->raid_map[0] == rbio->bbio->raid_map[0]) {\n\t\t\tspin_lock(&cur->bio_list_lock);\n\n\t\t\t/* can we steal this cached rbio's pages? */\n\t\t\tif (bio_list_empty(&cur->bio_list) &&\n\t\t\t    list_empty(&cur->plug_list) &&\n\t\t\t    test_bit(RBIO_CACHE_BIT, &cur->flags) &&\n\t\t\t    !test_bit(RBIO_RMW_LOCKED_BIT, &cur->flags)) {\n\t\t\t\tlist_del_init(&cur->hash_list);\n\t\t\t\tatomic_dec(&cur->refs);\n\n\t\t\t\tsteal_rbio(cur, rbio);\n\t\t\t\tcache_drop = cur;\n\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\n\t\t\t\tgoto lockit;\n\t\t\t}\n\n\t\t\t/* can we merge into the lock owner? */\n\t\t\tif (rbio_can_merge(cur, rbio)) {\n\t\t\t\tmerge_rbio(cur, rbio);\n\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\t\tfreeit = rbio;\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\n\t\t\t/*\n\t\t\t * we couldn't merge with the running\n\t\t\t * rbio, see if we can merge with the\n\t\t\t * pending ones.  We don't have to\n\t\t\t * check for rmw_locked because there\n\t\t\t * is no way they are inside finish_rmw\n\t\t\t * right now\n\t\t\t */\n\t\t\tlist_for_each_entry(pending, &cur->plug_list,\n\t\t\t\t\t    plug_list) {\n\t\t\t\tif (rbio_can_merge(pending, rbio)) {\n\t\t\t\t\tmerge_rbio(pending, rbio);\n\t\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\t\t\tfreeit = rbio;\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* no merging, put us on the tail of the plug list,\n\t\t\t * our rbio will be started with the currently\n\t\t\t * running rbio unlocks\n\t\t\t */\n\t\t\tlist_add_tail(&rbio->plug_list, &cur->plug_list);\n\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\nlockit:\n\tatomic_inc(&rbio->refs);\n\tlist_add(&rbio->hash_list, &h->hash_list);\nout:\n\tspin_unlock_irqrestore(&h->lock, flags);\n\tif (cache_drop)\n\t\tremove_rbio_from_cache(cache_drop);\n\tif (freeit)\n\t\t__free_raid_bio(freeit);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nvoid raid56_parity_submit_scrub_rbio(struct btrfs_raid_bio *rbio)\n{\n\tif (!lock_stripe_add(rbio))\n\t\tasync_scrub_parity(rbio);\n}"
  },
  {
    "function_name": "async_scrub_parity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "2665-2672",
    "snippet": "static void async_scrub_parity(struct btrfs_raid_bio *rbio)\n{\n\tbtrfs_init_work(&rbio->work, btrfs_rmw_helper,\n\t\t\tscrub_parity_work, NULL, NULL);\n\n\tbtrfs_queue_work(rbio->fs_info->rmw_workers,\n\t\t\t &rbio->work);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void rmw_work(struct btrfs_work *work);",
      "static void read_rebuild_work(struct btrfs_work *work);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_queue_work",
          "args": [
            "rbio->fs_info->rmw_workers",
            "&rbio->work"
          ],
          "line": 2670
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "323-333",
          "snippet": "void btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define WORK_HIGH_PRIO_BIT 2"
          ],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);",
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define WORK_HIGH_PRIO_BIT 2\n\nstatic void normal_work_helper(struct btrfs_work *work);\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_init_work",
          "args": [
            "&rbio->work",
            "btrfs_rmw_helper",
            "scrub_parity_work",
            "NULL",
            "NULL"
          ],
          "line": 2667
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "294-305",
          "snippet": "void btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic void normal_work_helper(struct btrfs_work *work);\n\nvoid btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void rmw_work(struct btrfs_work *work);\nstatic void read_rebuild_work(struct btrfs_work *work);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio)\n{\n\tbtrfs_init_work(&rbio->work, btrfs_rmw_helper,\n\t\t\tscrub_parity_work, NULL, NULL);\n\n\tbtrfs_queue_work(rbio->fs_info->rmw_workers,\n\t\t\t &rbio->work);\n}"
  },
  {
    "function_name": "scrub_parity_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "2657-2663",
    "snippet": "static void scrub_parity_work(struct btrfs_work *work)\n{\n\tstruct btrfs_raid_bio *rbio;\n\n\trbio = container_of(work, struct btrfs_raid_bio, work);\n\traid56_parity_scrub_stripe(rbio);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void rmw_work(struct btrfs_work *work);",
      "static void read_rebuild_work(struct btrfs_work *work);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raid56_parity_scrub_stripe",
          "args": [
            "rbio"
          ],
          "line": 2662
        },
        "resolved": true,
        "details": {
          "function_name": "raid56_parity_scrub_stripe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "2568-2655",
          "snippet": "static void raid56_parity_scrub_stripe(struct btrfs_raid_bio *rbio)\n{\n\tint bios_to_read = 0;\n\tstruct bio_list bio_list;\n\tint ret;\n\tint pagenr;\n\tint stripe;\n\tstruct bio *bio;\n\n\tret = alloc_rbio_essential_pages(rbio);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tbio_list_init(&bio_list);\n\n\tatomic_set(&rbio->error, 0);\n\t/*\n\t * build a list of bios to read all the missing parts of this\n\t * stripe\n\t */\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tfor_each_set_bit(pagenr, rbio->dbitmap, rbio->stripe_npages) {\n\t\t\tstruct page *page;\n\t\t\t/*\n\t\t\t * we want to find all the pages missing from\n\t\t\t * the rbio and read them from the disk.  If\n\t\t\t * page_in_rbio finds a page in the bio list\n\t\t\t * we don't need to read it off the stripe.\n\t\t\t */\n\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 1);\n\t\t\tif (page)\n\t\t\t\tcontinue;\n\n\t\t\tpage = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t/*\n\t\t\t * the bio cache may have handed us an uptodate\n\t\t\t * page.  If so, be happy and use it\n\t\t\t */\n\t\t\tif (PageUptodate(page))\n\t\t\t\tcontinue;\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list, page,\n\t\t\t\t       stripe, pagenr, rbio->stripe_len);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tbios_to_read = bio_list_size(&bio_list);\n\tif (!bios_to_read) {\n\t\t/*\n\t\t * this can happen if others have merged with\n\t\t * us, it means there is nothing left to read.\n\t\t * But if there are missing devices it may not be\n\t\t * safe to do the full stripe write yet.\n\t\t */\n\t\tgoto finish;\n\t}\n\n\t/*\n\t * the bbio may be freed once we submit the last bio.  Make sure\n\t * not to touch it after that\n\t */\n\tatomic_set(&rbio->stripes_pending, bios_to_read);\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid56_parity_scrub_end_io;\n\n\t\tbtrfs_bio_wq_end_io(rbio->fs_info, bio,\n\t\t\t\t    BTRFS_WQ_ENDIO_RAID56);\n\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(READ, bio);\n\t}\n\t/* the actual write will happen once the reads are done */\n\treturn;\n\ncleanup:\n\trbio_orig_end_io(rbio, -EIO, 0);\n\treturn;\n\nfinish:\n\tvalidate_rbio_for_parity_scrub(rbio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void raid56_parity_scrub_stripe(struct btrfs_raid_bio *rbio)\n{\n\tint bios_to_read = 0;\n\tstruct bio_list bio_list;\n\tint ret;\n\tint pagenr;\n\tint stripe;\n\tstruct bio *bio;\n\n\tret = alloc_rbio_essential_pages(rbio);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tbio_list_init(&bio_list);\n\n\tatomic_set(&rbio->error, 0);\n\t/*\n\t * build a list of bios to read all the missing parts of this\n\t * stripe\n\t */\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tfor_each_set_bit(pagenr, rbio->dbitmap, rbio->stripe_npages) {\n\t\t\tstruct page *page;\n\t\t\t/*\n\t\t\t * we want to find all the pages missing from\n\t\t\t * the rbio and read them from the disk.  If\n\t\t\t * page_in_rbio finds a page in the bio list\n\t\t\t * we don't need to read it off the stripe.\n\t\t\t */\n\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 1);\n\t\t\tif (page)\n\t\t\t\tcontinue;\n\n\t\t\tpage = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t/*\n\t\t\t * the bio cache may have handed us an uptodate\n\t\t\t * page.  If so, be happy and use it\n\t\t\t */\n\t\t\tif (PageUptodate(page))\n\t\t\t\tcontinue;\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list, page,\n\t\t\t\t       stripe, pagenr, rbio->stripe_len);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tbios_to_read = bio_list_size(&bio_list);\n\tif (!bios_to_read) {\n\t\t/*\n\t\t * this can happen if others have merged with\n\t\t * us, it means there is nothing left to read.\n\t\t * But if there are missing devices it may not be\n\t\t * safe to do the full stripe write yet.\n\t\t */\n\t\tgoto finish;\n\t}\n\n\t/*\n\t * the bbio may be freed once we submit the last bio.  Make sure\n\t * not to touch it after that\n\t */\n\tatomic_set(&rbio->stripes_pending, bios_to_read);\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid56_parity_scrub_end_io;\n\n\t\tbtrfs_bio_wq_end_io(rbio->fs_info, bio,\n\t\t\t\t    BTRFS_WQ_ENDIO_RAID56);\n\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(READ, bio);\n\t}\n\t/* the actual write will happen once the reads are done */\n\treturn;\n\ncleanup:\n\trbio_orig_end_io(rbio, -EIO, 0);\n\treturn;\n\nfinish:\n\tvalidate_rbio_for_parity_scrub(rbio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structbtrfs_raid_bio",
            "work"
          ],
          "line": 2661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void rmw_work(struct btrfs_work *work);\nstatic void read_rebuild_work(struct btrfs_work *work);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void scrub_parity_work(struct btrfs_work *work)\n{\n\tstruct btrfs_raid_bio *rbio;\n\n\trbio = container_of(work, struct btrfs_raid_bio, work);\n\traid56_parity_scrub_stripe(rbio);\n}"
  },
  {
    "function_name": "raid56_parity_scrub_stripe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "2568-2655",
    "snippet": "static void raid56_parity_scrub_stripe(struct btrfs_raid_bio *rbio)\n{\n\tint bios_to_read = 0;\n\tstruct bio_list bio_list;\n\tint ret;\n\tint pagenr;\n\tint stripe;\n\tstruct bio *bio;\n\n\tret = alloc_rbio_essential_pages(rbio);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tbio_list_init(&bio_list);\n\n\tatomic_set(&rbio->error, 0);\n\t/*\n\t * build a list of bios to read all the missing parts of this\n\t * stripe\n\t */\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tfor_each_set_bit(pagenr, rbio->dbitmap, rbio->stripe_npages) {\n\t\t\tstruct page *page;\n\t\t\t/*\n\t\t\t * we want to find all the pages missing from\n\t\t\t * the rbio and read them from the disk.  If\n\t\t\t * page_in_rbio finds a page in the bio list\n\t\t\t * we don't need to read it off the stripe.\n\t\t\t */\n\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 1);\n\t\t\tif (page)\n\t\t\t\tcontinue;\n\n\t\t\tpage = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t/*\n\t\t\t * the bio cache may have handed us an uptodate\n\t\t\t * page.  If so, be happy and use it\n\t\t\t */\n\t\t\tif (PageUptodate(page))\n\t\t\t\tcontinue;\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list, page,\n\t\t\t\t       stripe, pagenr, rbio->stripe_len);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tbios_to_read = bio_list_size(&bio_list);\n\tif (!bios_to_read) {\n\t\t/*\n\t\t * this can happen if others have merged with\n\t\t * us, it means there is nothing left to read.\n\t\t * But if there are missing devices it may not be\n\t\t * safe to do the full stripe write yet.\n\t\t */\n\t\tgoto finish;\n\t}\n\n\t/*\n\t * the bbio may be freed once we submit the last bio.  Make sure\n\t * not to touch it after that\n\t */\n\tatomic_set(&rbio->stripes_pending, bios_to_read);\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid56_parity_scrub_end_io;\n\n\t\tbtrfs_bio_wq_end_io(rbio->fs_info, bio,\n\t\t\t\t    BTRFS_WQ_ENDIO_RAID56);\n\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(READ, bio);\n\t}\n\t/* the actual write will happen once the reads are done */\n\treturn;\n\ncleanup:\n\trbio_orig_end_io(rbio, -EIO, 0);\n\treturn;\n\nfinish:\n\tvalidate_rbio_for_parity_scrub(rbio);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "validate_rbio_for_parity_scrub",
          "args": [
            "rbio"
          ],
          "line": 2654
        },
        "resolved": true,
        "details": {
          "function_name": "validate_rbio_for_parity_scrub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "2484-2536",
          "snippet": "static void validate_rbio_for_parity_scrub(struct btrfs_raid_bio *rbio)\n{\n\tif (atomic_read(&rbio->error) > rbio->bbio->max_errors)\n\t\tgoto cleanup;\n\n\tif (rbio->faila >= 0 || rbio->failb >= 0) {\n\t\tint dfail = 0, failp = -1;\n\n\t\tif (is_data_stripe(rbio, rbio->faila))\n\t\t\tdfail++;\n\t\telse if (is_parity_stripe(rbio->faila))\n\t\t\tfailp = rbio->faila;\n\n\t\tif (is_data_stripe(rbio, rbio->failb))\n\t\t\tdfail++;\n\t\telse if (is_parity_stripe(rbio->failb))\n\t\t\tfailp = rbio->failb;\n\n\t\t/*\n\t\t * Because we can not use a scrubbing parity to repair\n\t\t * the data, so the capability of the repair is declined.\n\t\t * (In the case of RAID5, we can not repair anything)\n\t\t */\n\t\tif (dfail > rbio->bbio->max_errors - 1)\n\t\t\tgoto cleanup;\n\n\t\t/*\n\t\t * If all data is good, only parity is correctly, just\n\t\t * repair the parity.\n\t\t */\n\t\tif (dfail == 0) {\n\t\t\tfinish_parity_scrub(rbio, 0);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * Here means we got one corrupted data stripe and one\n\t\t * corrupted parity on RAID6, if the corrupted parity\n\t\t * is scrubbing parity, luckly, use the other one to repair\n\t\t * the data, or we can not repair the data stripe.\n\t\t */\n\t\tif (failp != rbio->scrubp)\n\t\t\tgoto cleanup;\n\n\t\t__raid_recover_end_io(rbio);\n\t} else {\n\t\tfinish_parity_scrub(rbio, 1);\n\t}\n\treturn;\n\ncleanup:\n\trbio_orig_end_io(rbio, -EIO, 0);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void validate_rbio_for_parity_scrub(struct btrfs_raid_bio *rbio)\n{\n\tif (atomic_read(&rbio->error) > rbio->bbio->max_errors)\n\t\tgoto cleanup;\n\n\tif (rbio->faila >= 0 || rbio->failb >= 0) {\n\t\tint dfail = 0, failp = -1;\n\n\t\tif (is_data_stripe(rbio, rbio->faila))\n\t\t\tdfail++;\n\t\telse if (is_parity_stripe(rbio->faila))\n\t\t\tfailp = rbio->faila;\n\n\t\tif (is_data_stripe(rbio, rbio->failb))\n\t\t\tdfail++;\n\t\telse if (is_parity_stripe(rbio->failb))\n\t\t\tfailp = rbio->failb;\n\n\t\t/*\n\t\t * Because we can not use a scrubbing parity to repair\n\t\t * the data, so the capability of the repair is declined.\n\t\t * (In the case of RAID5, we can not repair anything)\n\t\t */\n\t\tif (dfail > rbio->bbio->max_errors - 1)\n\t\t\tgoto cleanup;\n\n\t\t/*\n\t\t * If all data is good, only parity is correctly, just\n\t\t * repair the parity.\n\t\t */\n\t\tif (dfail == 0) {\n\t\t\tfinish_parity_scrub(rbio, 0);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * Here means we got one corrupted data stripe and one\n\t\t * corrupted parity on RAID6, if the corrupted parity\n\t\t * is scrubbing parity, luckly, use the other one to repair\n\t\t * the data, or we can not repair the data stripe.\n\t\t */\n\t\tif (failp != rbio->scrubp)\n\t\t\tgoto cleanup;\n\n\t\t__raid_recover_end_io(rbio);\n\t} else {\n\t\tfinish_parity_scrub(rbio, 1);\n\t}\n\treturn;\n\ncleanup:\n\trbio_orig_end_io(rbio, -EIO, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rbio_orig_end_io",
          "args": [
            "rbio",
            "-EIO",
            "0"
          ],
          "line": 2650
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_orig_end_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "861-879",
          "snippet": "static void rbio_orig_end_io(struct btrfs_raid_bio *rbio, int err, int uptodate)\n{\n\tstruct bio *cur = bio_list_get(&rbio->bio_list);\n\tstruct bio *next;\n\n\tif (rbio->generic_bio_cnt)\n\t\tbtrfs_bio_counter_sub(rbio->fs_info, rbio->generic_bio_cnt);\n\n\tfree_raid_bio(rbio);\n\n\twhile (cur) {\n\t\tnext = cur->bi_next;\n\t\tcur->bi_next = NULL;\n\t\tif (uptodate)\n\t\t\tset_bit(BIO_UPTODATE, &cur->bi_flags);\n\t\tbio_endio(cur, err);\n\t\tcur = next;\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void rbio_orig_end_io(struct btrfs_raid_bio *rbio, int err, int uptodate)\n{\n\tstruct bio *cur = bio_list_get(&rbio->bio_list);\n\tstruct bio *next;\n\n\tif (rbio->generic_bio_cnt)\n\t\tbtrfs_bio_counter_sub(rbio->fs_info, rbio->generic_bio_cnt);\n\n\tfree_raid_bio(rbio);\n\n\twhile (cur) {\n\t\tnext = cur->bi_next;\n\t\tcur->bi_next = NULL;\n\t\tif (uptodate)\n\t\t\tset_bit(BIO_UPTODATE, &cur->bi_flags);\n\t\tbio_endio(cur, err);\n\t\tcur = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "READ",
            "bio"
          ],
          "line": 2644
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_submit_bio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "3067-3071",
          "snippet": "int btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!test_bit(BIO_UPTODATE, &bio->bi_flags)"
          ],
          "line": 2643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BIO_UPTODATE",
            "&bio->bi_flags"
          ],
          "line": 2643
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_bio_wq_end_io",
          "args": [
            "rbio->fs_info",
            "bio",
            "BTRFS_WQ_ENDIO_RAID56"
          ],
          "line": 2640
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bio_wq_end_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "756-775",
          "snippet": "int btrfs_bio_wq_end_io(struct btrfs_fs_info *info, struct bio *bio,\n\t\t\tenum btrfs_wq_endio_type metadata)\n{\n\tstruct btrfs_end_io_wq *end_io_wq;\n\n\tend_io_wq = kmem_cache_alloc(btrfs_end_io_wq_cache, GFP_NOFS);\n\tif (!end_io_wq)\n\t\treturn -ENOMEM;\n\n\tend_io_wq->private = bio->bi_private;\n\tend_io_wq->end_io = bio->bi_end_io;\n\tend_io_wq->info = info;\n\tend_io_wq->error = 0;\n\tend_io_wq->bio = bio;\n\tend_io_wq->metadata = metadata;\n\n\tbio->bi_private = end_io_wq;\n\tbio->bi_end_io = end_workqueue_bio;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_end_io_wq_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *btrfs_end_io_wq_cache;\n\nint btrfs_bio_wq_end_io(struct btrfs_fs_info *info, struct bio *bio,\n\t\t\tenum btrfs_wq_endio_type metadata)\n{\n\tstruct btrfs_end_io_wq *end_io_wq;\n\n\tend_io_wq = kmem_cache_alloc(btrfs_end_io_wq_cache, GFP_NOFS);\n\tif (!end_io_wq)\n\t\treturn -ENOMEM;\n\n\tend_io_wq->private = bio->bi_private;\n\tend_io_wq->end_io = bio->bi_end_io;\n\tend_io_wq->info = info;\n\tend_io_wq->error = 0;\n\tend_io_wq->bio = bio;\n\tend_io_wq->metadata = metadata;\n\n\tbio->bi_private = end_io_wq;\n\tbio->bi_end_io = end_workqueue_bio;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_list_pop",
          "args": [
            "&bio_list"
          ],
          "line": 2633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&rbio->stripes_pending",
            "bios_to_read"
          ],
          "line": 2631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_list_size",
          "args": [
            "&bio_list"
          ],
          "line": 2616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rbio_add_io_page",
          "args": [
            "rbio",
            "&bio_list",
            "page",
            "stripe",
            "pagenr",
            "rbio->stripe_len"
          ],
          "line": 2609
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_add_io_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1050-1102",
          "snippet": "static int rbio_add_io_page(struct btrfs_raid_bio *rbio,\n\t\t\t    struct bio_list *bio_list,\n\t\t\t    struct page *page,\n\t\t\t    int stripe_nr,\n\t\t\t    unsigned long page_index,\n\t\t\t    unsigned long bio_max_len)\n{\n\tstruct bio *last = bio_list->tail;\n\tu64 last_end = 0;\n\tint ret;\n\tstruct bio *bio;\n\tstruct btrfs_bio_stripe *stripe;\n\tu64 disk_start;\n\n\tstripe = &rbio->bbio->stripes[stripe_nr];\n\tdisk_start = stripe->physical + (page_index << PAGE_CACHE_SHIFT);\n\n\t/* if the device is missing, just fail this stripe */\n\tif (!stripe->dev->bdev)\n\t\treturn fail_rbio_index(rbio, stripe_nr);\n\n\t/* see if we can add this page onto our existing bio */\n\tif (last) {\n\t\tlast_end = (u64)last->bi_iter.bi_sector << 9;\n\t\tlast_end += last->bi_iter.bi_size;\n\n\t\t/*\n\t\t * we can't merge these if they are from different\n\t\t * devices or if they are not contiguous\n\t\t */\n\t\tif (last_end == disk_start && stripe->dev->bdev &&\n\t\t    test_bit(BIO_UPTODATE, &last->bi_flags) &&\n\t\t    last->bi_bdev == stripe->dev->bdev) {\n\t\t\tret = bio_add_page(last, page, PAGE_CACHE_SIZE, 0);\n\t\t\tif (ret == PAGE_CACHE_SIZE)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* put a new bio on the list */\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, bio_max_len >> PAGE_SHIFT?:1);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\n\tbio->bi_iter.bi_size = 0;\n\tbio->bi_bdev = stripe->dev->bdev;\n\tbio->bi_iter.bi_sector = disk_start >> 9;\n\tset_bit(BIO_UPTODATE, &bio->bi_flags);\n\n\tbio_add_page(bio, page, PAGE_CACHE_SIZE, 0);\n\tbio_list_add(bio_list, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int rbio_add_io_page(struct btrfs_raid_bio *rbio,\n\t\t\t    struct bio_list *bio_list,\n\t\t\t    struct page *page,\n\t\t\t    int stripe_nr,\n\t\t\t    unsigned long page_index,\n\t\t\t    unsigned long bio_max_len)\n{\n\tstruct bio *last = bio_list->tail;\n\tu64 last_end = 0;\n\tint ret;\n\tstruct bio *bio;\n\tstruct btrfs_bio_stripe *stripe;\n\tu64 disk_start;\n\n\tstripe = &rbio->bbio->stripes[stripe_nr];\n\tdisk_start = stripe->physical + (page_index << PAGE_CACHE_SHIFT);\n\n\t/* if the device is missing, just fail this stripe */\n\tif (!stripe->dev->bdev)\n\t\treturn fail_rbio_index(rbio, stripe_nr);\n\n\t/* see if we can add this page onto our existing bio */\n\tif (last) {\n\t\tlast_end = (u64)last->bi_iter.bi_sector << 9;\n\t\tlast_end += last->bi_iter.bi_size;\n\n\t\t/*\n\t\t * we can't merge these if they are from different\n\t\t * devices or if they are not contiguous\n\t\t */\n\t\tif (last_end == disk_start && stripe->dev->bdev &&\n\t\t    test_bit(BIO_UPTODATE, &last->bi_flags) &&\n\t\t    last->bi_bdev == stripe->dev->bdev) {\n\t\t\tret = bio_add_page(last, page, PAGE_CACHE_SIZE, 0);\n\t\t\tif (ret == PAGE_CACHE_SIZE)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* put a new bio on the list */\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, bio_max_len >> PAGE_SHIFT?:1);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\n\tbio->bi_iter.bi_size = 0;\n\tbio->bi_bdev = stripe->dev->bdev;\n\tbio->bi_iter.bi_sector = disk_start >> 9;\n\tset_bit(BIO_UPTODATE, &bio->bi_flags);\n\n\tbio_add_page(bio, page, PAGE_CACHE_SIZE, 0);\n\tbio_list_add(bio_list, bio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rbio_stripe_page",
          "args": [
            "rbio",
            "stripe",
            "pagenr"
          ],
          "line": 2601
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_stripe_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1125-1131",
          "snippet": "static struct page *rbio_stripe_page(struct btrfs_raid_bio *rbio, int stripe, int page)\n{\n\tint index;\n\tindex = stripe * (rbio->stripe_len >> PAGE_CACHE_SHIFT);\n\tindex += page;\n\treturn rbio->stripe_pages[index];\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic struct page *rbio_stripe_page(struct btrfs_raid_bio *rbio, int stripe, int page)\n{\n\tint index;\n\tindex = stripe * (rbio->stripe_len >> PAGE_CACHE_SHIFT);\n\tindex += page;\n\treturn rbio->stripe_pages[index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_in_rbio",
          "args": [
            "rbio",
            "stripe",
            "pagenr",
            "1"
          ],
          "line": 2597
        },
        "resolved": true,
        "details": {
          "function_name": "page_in_rbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "923-939",
          "snippet": "static struct page *page_in_rbio(struct btrfs_raid_bio *rbio,\n\t\t\t\t int index, int pagenr, int bio_list_only)\n{\n\tint chunk_page;\n\tstruct page *p = NULL;\n\n\tchunk_page = index * (rbio->stripe_len >> PAGE_SHIFT) + pagenr;\n\n\tspin_lock_irq(&rbio->bio_list_lock);\n\tp = rbio->bio_pages[chunk_page];\n\tspin_unlock_irq(&rbio->bio_list_lock);\n\n\tif (p || bio_list_only)\n\t\treturn p;\n\n\treturn rbio->stripe_pages[chunk_page];\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic struct page *page_in_rbio(struct btrfs_raid_bio *rbio,\n\t\t\t\t int index, int pagenr, int bio_list_only)\n{\n\tint chunk_page;\n\tstruct page *p = NULL;\n\n\tchunk_page = index * (rbio->stripe_len >> PAGE_SHIFT) + pagenr;\n\n\tspin_lock_irq(&rbio->bio_list_lock);\n\tp = rbio->bio_pages[chunk_page];\n\tspin_unlock_irq(&rbio->bio_list_lock);\n\n\tif (p || bio_list_only)\n\t\treturn p;\n\n\treturn rbio->stripe_pages[chunk_page];\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "pagenr",
            "rbio->dbitmap",
            "rbio->stripe_npages"
          ],
          "line": 2589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&rbio->error",
            "0"
          ],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_list_init",
          "args": [
            "&bio_list"
          ],
          "line": 2581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_rbio_essential_pages",
          "args": [
            "rbio"
          ],
          "line": 2577
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_rbio_essential_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "2261-2282",
          "snippet": "static int alloc_rbio_essential_pages(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\tint bit;\n\tint index;\n\tstruct page *page;\n\n\tfor_each_set_bit(bit, rbio->dbitmap, rbio->stripe_npages) {\n\t\tfor (i = 0; i < rbio->real_stripes; i++) {\n\t\t\tindex = i * rbio->stripe_npages + bit;\n\t\t\tif (rbio->stripe_pages[index])\n\t\t\t\tcontinue;\n\n\t\t\tpage = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\t\t\tif (!page)\n\t\t\t\treturn -ENOMEM;\n\t\t\trbio->stripe_pages[index] = page;\n\t\t\tClearPageUptodate(page);\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int alloc_rbio_essential_pages(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\tint bit;\n\tint index;\n\tstruct page *page;\n\n\tfor_each_set_bit(bit, rbio->dbitmap, rbio->stripe_npages) {\n\t\tfor (i = 0; i < rbio->real_stripes; i++) {\n\t\t\tindex = i * rbio->stripe_npages + bit;\n\t\t\tif (rbio->stripe_pages[index])\n\t\t\t\tcontinue;\n\n\t\t\tpage = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\t\t\tif (!page)\n\t\t\t\treturn -ENOMEM;\n\t\t\trbio->stripe_pages[index] = page;\n\t\t\tClearPageUptodate(page);\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void raid56_parity_scrub_stripe(struct btrfs_raid_bio *rbio)\n{\n\tint bios_to_read = 0;\n\tstruct bio_list bio_list;\n\tint ret;\n\tint pagenr;\n\tint stripe;\n\tstruct bio *bio;\n\n\tret = alloc_rbio_essential_pages(rbio);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tbio_list_init(&bio_list);\n\n\tatomic_set(&rbio->error, 0);\n\t/*\n\t * build a list of bios to read all the missing parts of this\n\t * stripe\n\t */\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tfor_each_set_bit(pagenr, rbio->dbitmap, rbio->stripe_npages) {\n\t\t\tstruct page *page;\n\t\t\t/*\n\t\t\t * we want to find all the pages missing from\n\t\t\t * the rbio and read them from the disk.  If\n\t\t\t * page_in_rbio finds a page in the bio list\n\t\t\t * we don't need to read it off the stripe.\n\t\t\t */\n\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 1);\n\t\t\tif (page)\n\t\t\t\tcontinue;\n\n\t\t\tpage = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t/*\n\t\t\t * the bio cache may have handed us an uptodate\n\t\t\t * page.  If so, be happy and use it\n\t\t\t */\n\t\t\tif (PageUptodate(page))\n\t\t\t\tcontinue;\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list, page,\n\t\t\t\t       stripe, pagenr, rbio->stripe_len);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tbios_to_read = bio_list_size(&bio_list);\n\tif (!bios_to_read) {\n\t\t/*\n\t\t * this can happen if others have merged with\n\t\t * us, it means there is nothing left to read.\n\t\t * But if there are missing devices it may not be\n\t\t * safe to do the full stripe write yet.\n\t\t */\n\t\tgoto finish;\n\t}\n\n\t/*\n\t * the bbio may be freed once we submit the last bio.  Make sure\n\t * not to touch it after that\n\t */\n\tatomic_set(&rbio->stripes_pending, bios_to_read);\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid56_parity_scrub_end_io;\n\n\t\tbtrfs_bio_wq_end_io(rbio->fs_info, bio,\n\t\t\t\t    BTRFS_WQ_ENDIO_RAID56);\n\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(READ, bio);\n\t}\n\t/* the actual write will happen once the reads are done */\n\treturn;\n\ncleanup:\n\trbio_orig_end_io(rbio, -EIO, 0);\n\treturn;\n\nfinish:\n\tvalidate_rbio_for_parity_scrub(rbio);\n}"
  },
  {
    "function_name": "raid56_parity_scrub_end_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "2546-2566",
    "snippet": "static void raid56_parity_scrub_end_io(struct bio *bio, int err)\n{\n\tstruct btrfs_raid_bio *rbio = bio->bi_private;\n\n\tif (err)\n\t\tfail_bio_stripe(rbio, bio);\n\telse\n\t\tset_bio_pages_uptodate(bio);\n\n\tbio_put(bio);\n\n\tif (!atomic_dec_and_test(&rbio->stripes_pending))\n\t\treturn;\n\n\t/*\n\t * this will normally call finish_rmw to start our write\n\t * but if there are any failed stripes we'll reconstruct\n\t * from parity first\n\t */\n\tvalidate_rbio_for_parity_scrub(rbio);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
      "static int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "validate_rbio_for_parity_scrub",
          "args": [
            "rbio"
          ],
          "line": 2565
        },
        "resolved": true,
        "details": {
          "function_name": "validate_rbio_for_parity_scrub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "2484-2536",
          "snippet": "static void validate_rbio_for_parity_scrub(struct btrfs_raid_bio *rbio)\n{\n\tif (atomic_read(&rbio->error) > rbio->bbio->max_errors)\n\t\tgoto cleanup;\n\n\tif (rbio->faila >= 0 || rbio->failb >= 0) {\n\t\tint dfail = 0, failp = -1;\n\n\t\tif (is_data_stripe(rbio, rbio->faila))\n\t\t\tdfail++;\n\t\telse if (is_parity_stripe(rbio->faila))\n\t\t\tfailp = rbio->faila;\n\n\t\tif (is_data_stripe(rbio, rbio->failb))\n\t\t\tdfail++;\n\t\telse if (is_parity_stripe(rbio->failb))\n\t\t\tfailp = rbio->failb;\n\n\t\t/*\n\t\t * Because we can not use a scrubbing parity to repair\n\t\t * the data, so the capability of the repair is declined.\n\t\t * (In the case of RAID5, we can not repair anything)\n\t\t */\n\t\tif (dfail > rbio->bbio->max_errors - 1)\n\t\t\tgoto cleanup;\n\n\t\t/*\n\t\t * If all data is good, only parity is correctly, just\n\t\t * repair the parity.\n\t\t */\n\t\tif (dfail == 0) {\n\t\t\tfinish_parity_scrub(rbio, 0);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * Here means we got one corrupted data stripe and one\n\t\t * corrupted parity on RAID6, if the corrupted parity\n\t\t * is scrubbing parity, luckly, use the other one to repair\n\t\t * the data, or we can not repair the data stripe.\n\t\t */\n\t\tif (failp != rbio->scrubp)\n\t\t\tgoto cleanup;\n\n\t\t__raid_recover_end_io(rbio);\n\t} else {\n\t\tfinish_parity_scrub(rbio, 1);\n\t}\n\treturn;\n\ncleanup:\n\trbio_orig_end_io(rbio, -EIO, 0);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void validate_rbio_for_parity_scrub(struct btrfs_raid_bio *rbio)\n{\n\tif (atomic_read(&rbio->error) > rbio->bbio->max_errors)\n\t\tgoto cleanup;\n\n\tif (rbio->faila >= 0 || rbio->failb >= 0) {\n\t\tint dfail = 0, failp = -1;\n\n\t\tif (is_data_stripe(rbio, rbio->faila))\n\t\t\tdfail++;\n\t\telse if (is_parity_stripe(rbio->faila))\n\t\t\tfailp = rbio->faila;\n\n\t\tif (is_data_stripe(rbio, rbio->failb))\n\t\t\tdfail++;\n\t\telse if (is_parity_stripe(rbio->failb))\n\t\t\tfailp = rbio->failb;\n\n\t\t/*\n\t\t * Because we can not use a scrubbing parity to repair\n\t\t * the data, so the capability of the repair is declined.\n\t\t * (In the case of RAID5, we can not repair anything)\n\t\t */\n\t\tif (dfail > rbio->bbio->max_errors - 1)\n\t\t\tgoto cleanup;\n\n\t\t/*\n\t\t * If all data is good, only parity is correctly, just\n\t\t * repair the parity.\n\t\t */\n\t\tif (dfail == 0) {\n\t\t\tfinish_parity_scrub(rbio, 0);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * Here means we got one corrupted data stripe and one\n\t\t * corrupted parity on RAID6, if the corrupted parity\n\t\t * is scrubbing parity, luckly, use the other one to repair\n\t\t * the data, or we can not repair the data stripe.\n\t\t */\n\t\tif (failp != rbio->scrubp)\n\t\t\tgoto cleanup;\n\n\t\t__raid_recover_end_io(rbio);\n\t} else {\n\t\tfinish_parity_scrub(rbio, 1);\n\t}\n\treturn;\n\ncleanup:\n\trbio_orig_end_io(rbio, -EIO, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&rbio->stripes_pending"
          ],
          "line": 2557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 2555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bio_pages_uptodate",
          "args": [
            "bio"
          ],
          "line": 2553
        },
        "resolved": true,
        "details": {
          "function_name": "set_bio_pages_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1432-1441",
          "snippet": "static void set_bio_pages_uptodate(struct bio *bio)\n{\n\tint i;\n\tstruct page *p;\n\n\tfor (i = 0; i < bio->bi_vcnt; i++) {\n\t\tp = bio->bi_io_vec[i].bv_page;\n\t\tSetPageUptodate(p);\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\n\nstatic void set_bio_pages_uptodate(struct bio *bio)\n{\n\tint i;\n\tstruct page *p;\n\n\tfor (i = 0; i < bio->bi_vcnt; i++) {\n\t\tp = bio->bi_io_vec[i].bv_page;\n\t\tSetPageUptodate(p);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fail_bio_stripe",
          "args": [
            "rbio",
            "bio"
          ],
          "line": 2551
        },
        "resolved": true,
        "details": {
          "function_name": "fail_bio_stripe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1417-1426",
          "snippet": "static int fail_bio_stripe(struct btrfs_raid_bio *rbio,\n\t\t\t   struct bio *bio)\n{\n\tint failed = find_bio_stripe(rbio, bio);\n\n\tif (failed < 0)\n\t\treturn -EIO;\n\n\treturn fail_rbio_index(rbio, failed);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio,\n\t\t\t   struct bio *bio)\n{\n\tint failed = find_bio_stripe(rbio, bio);\n\n\tif (failed < 0)\n\t\treturn -EIO;\n\n\treturn fail_rbio_index(rbio, failed);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void raid56_parity_scrub_end_io(struct bio *bio, int err)\n{\n\tstruct btrfs_raid_bio *rbio = bio->bi_private;\n\n\tif (err)\n\t\tfail_bio_stripe(rbio, bio);\n\telse\n\t\tset_bio_pages_uptodate(bio);\n\n\tbio_put(bio);\n\n\tif (!atomic_dec_and_test(&rbio->stripes_pending))\n\t\treturn;\n\n\t/*\n\t * this will normally call finish_rmw to start our write\n\t * but if there are any failed stripes we'll reconstruct\n\t * from parity first\n\t */\n\tvalidate_rbio_for_parity_scrub(rbio);\n}"
  },
  {
    "function_name": "validate_rbio_for_parity_scrub",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "2484-2536",
    "snippet": "static void validate_rbio_for_parity_scrub(struct btrfs_raid_bio *rbio)\n{\n\tif (atomic_read(&rbio->error) > rbio->bbio->max_errors)\n\t\tgoto cleanup;\n\n\tif (rbio->faila >= 0 || rbio->failb >= 0) {\n\t\tint dfail = 0, failp = -1;\n\n\t\tif (is_data_stripe(rbio, rbio->faila))\n\t\t\tdfail++;\n\t\telse if (is_parity_stripe(rbio->faila))\n\t\t\tfailp = rbio->faila;\n\n\t\tif (is_data_stripe(rbio, rbio->failb))\n\t\t\tdfail++;\n\t\telse if (is_parity_stripe(rbio->failb))\n\t\t\tfailp = rbio->failb;\n\n\t\t/*\n\t\t * Because we can not use a scrubbing parity to repair\n\t\t * the data, so the capability of the repair is declined.\n\t\t * (In the case of RAID5, we can not repair anything)\n\t\t */\n\t\tif (dfail > rbio->bbio->max_errors - 1)\n\t\t\tgoto cleanup;\n\n\t\t/*\n\t\t * If all data is good, only parity is correctly, just\n\t\t * repair the parity.\n\t\t */\n\t\tif (dfail == 0) {\n\t\t\tfinish_parity_scrub(rbio, 0);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * Here means we got one corrupted data stripe and one\n\t\t * corrupted parity on RAID6, if the corrupted parity\n\t\t * is scrubbing parity, luckly, use the other one to repair\n\t\t * the data, or we can not repair the data stripe.\n\t\t */\n\t\tif (failp != rbio->scrubp)\n\t\t\tgoto cleanup;\n\n\t\t__raid_recover_end_io(rbio);\n\t} else {\n\t\tfinish_parity_scrub(rbio, 1);\n\t}\n\treturn;\n\ncleanup:\n\trbio_orig_end_io(rbio, -EIO, 0);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rbio_orig_end_io",
          "args": [
            "rbio",
            "-EIO",
            "0"
          ],
          "line": 2535
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_orig_end_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "861-879",
          "snippet": "static void rbio_orig_end_io(struct btrfs_raid_bio *rbio, int err, int uptodate)\n{\n\tstruct bio *cur = bio_list_get(&rbio->bio_list);\n\tstruct bio *next;\n\n\tif (rbio->generic_bio_cnt)\n\t\tbtrfs_bio_counter_sub(rbio->fs_info, rbio->generic_bio_cnt);\n\n\tfree_raid_bio(rbio);\n\n\twhile (cur) {\n\t\tnext = cur->bi_next;\n\t\tcur->bi_next = NULL;\n\t\tif (uptodate)\n\t\t\tset_bit(BIO_UPTODATE, &cur->bi_flags);\n\t\tbio_endio(cur, err);\n\t\tcur = next;\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void rbio_orig_end_io(struct btrfs_raid_bio *rbio, int err, int uptodate)\n{\n\tstruct bio *cur = bio_list_get(&rbio->bio_list);\n\tstruct bio *next;\n\n\tif (rbio->generic_bio_cnt)\n\t\tbtrfs_bio_counter_sub(rbio->fs_info, rbio->generic_bio_cnt);\n\n\tfree_raid_bio(rbio);\n\n\twhile (cur) {\n\t\tnext = cur->bi_next;\n\t\tcur->bi_next = NULL;\n\t\tif (uptodate)\n\t\t\tset_bit(BIO_UPTODATE, &cur->bi_flags);\n\t\tbio_endio(cur, err);\n\t\tcur = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_parity_scrub",
          "args": [
            "rbio",
            "1"
          ],
          "line": 2530
        },
        "resolved": true,
        "details": {
          "function_name": "finish_parity_scrub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "2308-2468",
          "snippet": "static noinline void finish_parity_scrub(struct btrfs_raid_bio *rbio,\n\t\t\t\t\t int need_check)\n{\n\tstruct btrfs_bio *bbio = rbio->bbio;\n\tvoid *pointers[rbio->real_stripes];\n\tDECLARE_BITMAP(pbitmap, rbio->stripe_npages);\n\tint nr_data = rbio->nr_data;\n\tint stripe;\n\tint pagenr;\n\tint p_stripe = -1;\n\tint q_stripe = -1;\n\tstruct page *p_page = NULL;\n\tstruct page *q_page = NULL;\n\tstruct bio_list bio_list;\n\tstruct bio *bio;\n\tint is_replace = 0;\n\tint ret;\n\n\tbio_list_init(&bio_list);\n\n\tif (rbio->real_stripes - rbio->nr_data == 1) {\n\t\tp_stripe = rbio->real_stripes - 1;\n\t} else if (rbio->real_stripes - rbio->nr_data == 2) {\n\t\tp_stripe = rbio->real_stripes - 2;\n\t\tq_stripe = rbio->real_stripes - 1;\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (bbio->num_tgtdevs && bbio->tgtdev_map[rbio->scrubp]) {\n\t\tis_replace = 1;\n\t\tbitmap_copy(pbitmap, rbio->dbitmap, rbio->stripe_npages);\n\t}\n\n\t/*\n\t * Because the higher layers(scrubber) are unlikely to\n\t * use this area of the disk again soon, so don't cache\n\t * it.\n\t */\n\tclear_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n\n\tif (!need_check)\n\t\tgoto writeback;\n\n\tp_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\tif (!p_page)\n\t\tgoto cleanup;\n\tSetPageUptodate(p_page);\n\n\tif (q_stripe != -1) {\n\t\tq_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\t\tif (!q_page) {\n\t\t\t__free_page(p_page);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tSetPageUptodate(q_page);\n\t}\n\n\tatomic_set(&rbio->error, 0);\n\n\tfor_each_set_bit(pagenr, rbio->dbitmap, rbio->stripe_npages) {\n\t\tstruct page *p;\n\t\tvoid *parity;\n\t\t/* first collect one page from each data stripe */\n\t\tfor (stripe = 0; stripe < nr_data; stripe++) {\n\t\t\tp = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\tpointers[stripe] = kmap(p);\n\t\t}\n\n\t\t/* then add the parity stripe */\n\t\tpointers[stripe++] = kmap(p_page);\n\n\t\tif (q_stripe != -1) {\n\n\t\t\t/*\n\t\t\t * raid6, add the qstripe and call the\n\t\t\t * library function to fill in our p/q\n\t\t\t */\n\t\t\tpointers[stripe++] = kmap(q_page);\n\n\t\t\traid6_call.gen_syndrome(rbio->real_stripes, PAGE_SIZE,\n\t\t\t\t\t\tpointers);\n\t\t} else {\n\t\t\t/* raid5 */\n\t\t\tmemcpy(pointers[nr_data], pointers[0], PAGE_SIZE);\n\t\t\trun_xor(pointers + 1, nr_data - 1, PAGE_CACHE_SIZE);\n\t\t}\n\n\t\t/* Check scrubbing pairty and repair it */\n\t\tp = rbio_stripe_page(rbio, rbio->scrubp, pagenr);\n\t\tparity = kmap(p);\n\t\tif (memcmp(parity, pointers[rbio->scrubp], PAGE_CACHE_SIZE))\n\t\t\tmemcpy(parity, pointers[rbio->scrubp], PAGE_CACHE_SIZE);\n\t\telse\n\t\t\t/* Parity is right, needn't writeback */\n\t\t\tbitmap_clear(rbio->dbitmap, pagenr, 1);\n\t\tkunmap(p);\n\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++)\n\t\t\tkunmap(page_in_rbio(rbio, stripe, pagenr, 0));\n\t}\n\n\t__free_page(p_page);\n\tif (q_page)\n\t\t__free_page(q_page);\n\nwriteback:\n\t/*\n\t * time to start writing.  Make bios for everything from the\n\t * higher layers (the bio_list in our rbio) and our p/q.  Ignore\n\t * everything else.\n\t */\n\tfor_each_set_bit(pagenr, rbio->dbitmap, rbio->stripe_npages) {\n\t\tstruct page *page;\n\n\t\tpage = rbio_stripe_page(rbio, rbio->scrubp, pagenr);\n\t\tret = rbio_add_io_page(rbio, &bio_list,\n\t\t\t       page, rbio->scrubp, pagenr, rbio->stripe_len);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (!is_replace)\n\t\tgoto submit_write;\n\n\tfor_each_set_bit(pagenr, pbitmap, rbio->stripe_npages) {\n\t\tstruct page *page;\n\n\t\tpage = rbio_stripe_page(rbio, rbio->scrubp, pagenr);\n\t\tret = rbio_add_io_page(rbio, &bio_list, page,\n\t\t\t\t       bbio->tgtdev_map[rbio->scrubp],\n\t\t\t\t       pagenr, rbio->stripe_len);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\nsubmit_write:\n\tnr_data = bio_list_size(&bio_list);\n\tif (!nr_data) {\n\t\t/* Every parity is right */\n\t\trbio_orig_end_io(rbio, 0, 0);\n\t\treturn;\n\t}\n\n\tatomic_set(&rbio->stripes_pending, nr_data);\n\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid_write_parity_end_io;\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(WRITE, bio);\n\t}\n\treturn;\n\ncleanup:\n\trbio_orig_end_io(rbio, -EIO, 0);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RBIO_CACHE_READY_BIT\t3"
          ],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_parity_scrub(struct btrfs_raid_bio *rbio,\n\t\t\t\t\t int need_check);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_READY_BIT\t3\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_parity_scrub(struct btrfs_raid_bio *rbio,\n\t\t\t\t\t int need_check);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic noinline void finish_parity_scrub(struct btrfs_raid_bio *rbio,\n\t\t\t\t\t int need_check)\n{\n\tstruct btrfs_bio *bbio = rbio->bbio;\n\tvoid *pointers[rbio->real_stripes];\n\tDECLARE_BITMAP(pbitmap, rbio->stripe_npages);\n\tint nr_data = rbio->nr_data;\n\tint stripe;\n\tint pagenr;\n\tint p_stripe = -1;\n\tint q_stripe = -1;\n\tstruct page *p_page = NULL;\n\tstruct page *q_page = NULL;\n\tstruct bio_list bio_list;\n\tstruct bio *bio;\n\tint is_replace = 0;\n\tint ret;\n\n\tbio_list_init(&bio_list);\n\n\tif (rbio->real_stripes - rbio->nr_data == 1) {\n\t\tp_stripe = rbio->real_stripes - 1;\n\t} else if (rbio->real_stripes - rbio->nr_data == 2) {\n\t\tp_stripe = rbio->real_stripes - 2;\n\t\tq_stripe = rbio->real_stripes - 1;\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (bbio->num_tgtdevs && bbio->tgtdev_map[rbio->scrubp]) {\n\t\tis_replace = 1;\n\t\tbitmap_copy(pbitmap, rbio->dbitmap, rbio->stripe_npages);\n\t}\n\n\t/*\n\t * Because the higher layers(scrubber) are unlikely to\n\t * use this area of the disk again soon, so don't cache\n\t * it.\n\t */\n\tclear_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n\n\tif (!need_check)\n\t\tgoto writeback;\n\n\tp_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\tif (!p_page)\n\t\tgoto cleanup;\n\tSetPageUptodate(p_page);\n\n\tif (q_stripe != -1) {\n\t\tq_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\t\tif (!q_page) {\n\t\t\t__free_page(p_page);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tSetPageUptodate(q_page);\n\t}\n\n\tatomic_set(&rbio->error, 0);\n\n\tfor_each_set_bit(pagenr, rbio->dbitmap, rbio->stripe_npages) {\n\t\tstruct page *p;\n\t\tvoid *parity;\n\t\t/* first collect one page from each data stripe */\n\t\tfor (stripe = 0; stripe < nr_data; stripe++) {\n\t\t\tp = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\tpointers[stripe] = kmap(p);\n\t\t}\n\n\t\t/* then add the parity stripe */\n\t\tpointers[stripe++] = kmap(p_page);\n\n\t\tif (q_stripe != -1) {\n\n\t\t\t/*\n\t\t\t * raid6, add the qstripe and call the\n\t\t\t * library function to fill in our p/q\n\t\t\t */\n\t\t\tpointers[stripe++] = kmap(q_page);\n\n\t\t\traid6_call.gen_syndrome(rbio->real_stripes, PAGE_SIZE,\n\t\t\t\t\t\tpointers);\n\t\t} else {\n\t\t\t/* raid5 */\n\t\t\tmemcpy(pointers[nr_data], pointers[0], PAGE_SIZE);\n\t\t\trun_xor(pointers + 1, nr_data - 1, PAGE_CACHE_SIZE);\n\t\t}\n\n\t\t/* Check scrubbing pairty and repair it */\n\t\tp = rbio_stripe_page(rbio, rbio->scrubp, pagenr);\n\t\tparity = kmap(p);\n\t\tif (memcmp(parity, pointers[rbio->scrubp], PAGE_CACHE_SIZE))\n\t\t\tmemcpy(parity, pointers[rbio->scrubp], PAGE_CACHE_SIZE);\n\t\telse\n\t\t\t/* Parity is right, needn't writeback */\n\t\t\tbitmap_clear(rbio->dbitmap, pagenr, 1);\n\t\tkunmap(p);\n\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++)\n\t\t\tkunmap(page_in_rbio(rbio, stripe, pagenr, 0));\n\t}\n\n\t__free_page(p_page);\n\tif (q_page)\n\t\t__free_page(q_page);\n\nwriteback:\n\t/*\n\t * time to start writing.  Make bios for everything from the\n\t * higher layers (the bio_list in our rbio) and our p/q.  Ignore\n\t * everything else.\n\t */\n\tfor_each_set_bit(pagenr, rbio->dbitmap, rbio->stripe_npages) {\n\t\tstruct page *page;\n\n\t\tpage = rbio_stripe_page(rbio, rbio->scrubp, pagenr);\n\t\tret = rbio_add_io_page(rbio, &bio_list,\n\t\t\t       page, rbio->scrubp, pagenr, rbio->stripe_len);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (!is_replace)\n\t\tgoto submit_write;\n\n\tfor_each_set_bit(pagenr, pbitmap, rbio->stripe_npages) {\n\t\tstruct page *page;\n\n\t\tpage = rbio_stripe_page(rbio, rbio->scrubp, pagenr);\n\t\tret = rbio_add_io_page(rbio, &bio_list, page,\n\t\t\t\t       bbio->tgtdev_map[rbio->scrubp],\n\t\t\t\t       pagenr, rbio->stripe_len);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\nsubmit_write:\n\tnr_data = bio_list_size(&bio_list);\n\tif (!nr_data) {\n\t\t/* Every parity is right */\n\t\trbio_orig_end_io(rbio, 0, 0);\n\t\treturn;\n\t}\n\n\tatomic_set(&rbio->stripes_pending, nr_data);\n\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid_write_parity_end_io;\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(WRITE, bio);\n\t}\n\treturn;\n\ncleanup:\n\trbio_orig_end_io(rbio, -EIO, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__raid_recover_end_io",
          "args": [
            "rbio"
          ],
          "line": 2528
        },
        "resolved": true,
        "details": {
          "function_name": "__raid_recover_end_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1800-1989",
          "snippet": "static void __raid_recover_end_io(struct btrfs_raid_bio *rbio)\n{\n\tint pagenr, stripe;\n\tvoid **pointers;\n\tint faila = -1, failb = -1;\n\tint nr_pages = DIV_ROUND_UP(rbio->stripe_len, PAGE_CACHE_SIZE);\n\tstruct page *page;\n\tint err;\n\tint i;\n\n\tpointers = kzalloc(rbio->real_stripes * sizeof(void *),\n\t\t\t   GFP_NOFS);\n\tif (!pointers) {\n\t\terr = -ENOMEM;\n\t\tgoto cleanup_io;\n\t}\n\n\tfaila = rbio->faila;\n\tfailb = rbio->failb;\n\n\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD) {\n\t\tspin_lock_irq(&rbio->bio_list_lock);\n\t\tset_bit(RBIO_RMW_LOCKED_BIT, &rbio->flags);\n\t\tspin_unlock_irq(&rbio->bio_list_lock);\n\t}\n\n\tindex_rbio_pages(rbio);\n\n\tfor (pagenr = 0; pagenr < nr_pages; pagenr++) {\n\t\t/*\n\t\t * Now we just use bitmap to mark the horizontal stripes in\n\t\t * which we have data when doing parity scrub.\n\t\t */\n\t\tif (rbio->operation == BTRFS_RBIO_PARITY_SCRUB &&\n\t\t    !test_bit(pagenr, rbio->dbitmap))\n\t\t\tcontinue;\n\n\t\t/* setup our array of pointers with pages\n\t\t * from each stripe\n\t\t */\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\t\t/*\n\t\t\t * if we're rebuilding a read, we have to use\n\t\t\t * pages from the bio list\n\t\t\t */\n\t\t\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD &&\n\t\t\t    (stripe == faila || stripe == failb)) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\t} else {\n\t\t\t\tpage = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\t\t\tpointers[stripe] = kmap(page);\n\t\t}\n\n\t\t/* all raid6 handling here */\n\t\tif (rbio->bbio->map_type & BTRFS_BLOCK_GROUP_RAID6) {\n\t\t\t/*\n\t\t\t * single failure, rebuild from parity raid5\n\t\t\t * style\n\t\t\t */\n\t\t\tif (failb < 0) {\n\t\t\t\tif (faila == rbio->nr_data) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Just the P stripe has failed, without\n\t\t\t\t\t * a bad data or Q stripe.\n\t\t\t\t\t * TODO, we should redo the xor here.\n\t\t\t\t\t */\n\t\t\t\t\terr = -EIO;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * a single failure in raid6 is rebuilt\n\t\t\t\t * in the pstripe code below\n\t\t\t\t */\n\t\t\t\tgoto pstripe;\n\t\t\t}\n\n\t\t\t/* make sure our ps and qs are in order */\n\t\t\tif (faila > failb) {\n\t\t\t\tint tmp = failb;\n\t\t\t\tfailb = faila;\n\t\t\t\tfaila = tmp;\n\t\t\t}\n\n\t\t\t/* if the q stripe is failed, do a pstripe reconstruction\n\t\t\t * from the xors.\n\t\t\t * If both the q stripe and the P stripe are failed, we're\n\t\t\t * here due to a crc mismatch and we can't give them the\n\t\t\t * data they want\n\t\t\t */\n\t\t\tif (rbio->bbio->raid_map[failb] == RAID6_Q_STRIPE) {\n\t\t\t\tif (rbio->bbio->raid_map[faila] ==\n\t\t\t\t    RAID5_P_STRIPE) {\n\t\t\t\t\terr = -EIO;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * otherwise we have one bad data stripe and\n\t\t\t\t * a good P stripe.  raid5!\n\t\t\t\t */\n\t\t\t\tgoto pstripe;\n\t\t\t}\n\n\t\t\tif (rbio->bbio->raid_map[failb] == RAID5_P_STRIPE) {\n\t\t\t\traid6_datap_recov(rbio->real_stripes,\n\t\t\t\t\t\t  PAGE_SIZE, faila, pointers);\n\t\t\t} else {\n\t\t\t\traid6_2data_recov(rbio->real_stripes,\n\t\t\t\t\t\t  PAGE_SIZE, faila, failb,\n\t\t\t\t\t\t  pointers);\n\t\t\t}\n\t\t} else {\n\t\t\tvoid *p;\n\n\t\t\t/* rebuild from P stripe here (raid5 or raid6) */\n\t\t\tBUG_ON(failb != -1);\npstripe:\n\t\t\t/* Copy parity block into failed block to start with */\n\t\t\tmemcpy(pointers[faila],\n\t\t\t       pointers[rbio->nr_data],\n\t\t\t       PAGE_CACHE_SIZE);\n\n\t\t\t/* rearrange the pointer array */\n\t\t\tp = pointers[faila];\n\t\t\tfor (stripe = faila; stripe < rbio->nr_data - 1; stripe++)\n\t\t\t\tpointers[stripe] = pointers[stripe + 1];\n\t\t\tpointers[rbio->nr_data - 1] = p;\n\n\t\t\t/* xor in the rest */\n\t\t\trun_xor(pointers, rbio->nr_data - 1, PAGE_CACHE_SIZE);\n\t\t}\n\t\t/* if we're doing this rebuild as part of an rmw, go through\n\t\t * and set all of our private rbio pages in the\n\t\t * failed stripes as uptodate.  This way finish_rmw will\n\t\t * know they can be trusted.  If this was a read reconstruction,\n\t\t * other endio functions will fiddle the uptodate bits\n\t\t */\n\t\tif (rbio->operation == BTRFS_RBIO_WRITE) {\n\t\t\tfor (i = 0;  i < nr_pages; i++) {\n\t\t\t\tif (faila != -1) {\n\t\t\t\t\tpage = rbio_stripe_page(rbio, faila, i);\n\t\t\t\t\tSetPageUptodate(page);\n\t\t\t\t}\n\t\t\t\tif (failb != -1) {\n\t\t\t\t\tpage = rbio_stripe_page(rbio, failb, i);\n\t\t\t\t\tSetPageUptodate(page);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\t\t/*\n\t\t\t * if we're rebuilding a read, we have to use\n\t\t\t * pages from the bio list\n\t\t\t */\n\t\t\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD &&\n\t\t\t    (stripe == faila || stripe == failb)) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\t} else {\n\t\t\t\tpage = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\t\t\tkunmap(page);\n\t\t}\n\t}\n\n\terr = 0;\ncleanup:\n\tkfree(pointers);\n\ncleanup_io:\n\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD) {\n\t\tif (err == 0)\n\t\t\tcache_rbio_pages(rbio);\n\t\telse\n\t\t\tclear_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n\n\t\trbio_orig_end_io(rbio, err, err == 0);\n\t} else if (err == 0) {\n\t\trbio->faila = -1;\n\t\trbio->failb = -1;\n\n\t\tif (rbio->operation == BTRFS_RBIO_WRITE)\n\t\t\tfinish_rmw(rbio);\n\t\telse if (rbio->operation == BTRFS_RBIO_PARITY_SCRUB)\n\t\t\tfinish_parity_scrub(rbio, 0);\n\t\telse\n\t\t\tBUG();\n\t} else {\n\t\trbio_orig_end_io(rbio, err, 0);\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RBIO_CACHE_READY_BIT\t3",
            "#define RBIO_RMW_LOCKED_BIT\t1"
          ],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_READY_BIT\t3\n#define RBIO_RMW_LOCKED_BIT\t1\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void __raid_recover_end_io(struct btrfs_raid_bio *rbio)\n{\n\tint pagenr, stripe;\n\tvoid **pointers;\n\tint faila = -1, failb = -1;\n\tint nr_pages = DIV_ROUND_UP(rbio->stripe_len, PAGE_CACHE_SIZE);\n\tstruct page *page;\n\tint err;\n\tint i;\n\n\tpointers = kzalloc(rbio->real_stripes * sizeof(void *),\n\t\t\t   GFP_NOFS);\n\tif (!pointers) {\n\t\terr = -ENOMEM;\n\t\tgoto cleanup_io;\n\t}\n\n\tfaila = rbio->faila;\n\tfailb = rbio->failb;\n\n\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD) {\n\t\tspin_lock_irq(&rbio->bio_list_lock);\n\t\tset_bit(RBIO_RMW_LOCKED_BIT, &rbio->flags);\n\t\tspin_unlock_irq(&rbio->bio_list_lock);\n\t}\n\n\tindex_rbio_pages(rbio);\n\n\tfor (pagenr = 0; pagenr < nr_pages; pagenr++) {\n\t\t/*\n\t\t * Now we just use bitmap to mark the horizontal stripes in\n\t\t * which we have data when doing parity scrub.\n\t\t */\n\t\tif (rbio->operation == BTRFS_RBIO_PARITY_SCRUB &&\n\t\t    !test_bit(pagenr, rbio->dbitmap))\n\t\t\tcontinue;\n\n\t\t/* setup our array of pointers with pages\n\t\t * from each stripe\n\t\t */\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\t\t/*\n\t\t\t * if we're rebuilding a read, we have to use\n\t\t\t * pages from the bio list\n\t\t\t */\n\t\t\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD &&\n\t\t\t    (stripe == faila || stripe == failb)) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\t} else {\n\t\t\t\tpage = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\t\t\tpointers[stripe] = kmap(page);\n\t\t}\n\n\t\t/* all raid6 handling here */\n\t\tif (rbio->bbio->map_type & BTRFS_BLOCK_GROUP_RAID6) {\n\t\t\t/*\n\t\t\t * single failure, rebuild from parity raid5\n\t\t\t * style\n\t\t\t */\n\t\t\tif (failb < 0) {\n\t\t\t\tif (faila == rbio->nr_data) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Just the P stripe has failed, without\n\t\t\t\t\t * a bad data or Q stripe.\n\t\t\t\t\t * TODO, we should redo the xor here.\n\t\t\t\t\t */\n\t\t\t\t\terr = -EIO;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * a single failure in raid6 is rebuilt\n\t\t\t\t * in the pstripe code below\n\t\t\t\t */\n\t\t\t\tgoto pstripe;\n\t\t\t}\n\n\t\t\t/* make sure our ps and qs are in order */\n\t\t\tif (faila > failb) {\n\t\t\t\tint tmp = failb;\n\t\t\t\tfailb = faila;\n\t\t\t\tfaila = tmp;\n\t\t\t}\n\n\t\t\t/* if the q stripe is failed, do a pstripe reconstruction\n\t\t\t * from the xors.\n\t\t\t * If both the q stripe and the P stripe are failed, we're\n\t\t\t * here due to a crc mismatch and we can't give them the\n\t\t\t * data they want\n\t\t\t */\n\t\t\tif (rbio->bbio->raid_map[failb] == RAID6_Q_STRIPE) {\n\t\t\t\tif (rbio->bbio->raid_map[faila] ==\n\t\t\t\t    RAID5_P_STRIPE) {\n\t\t\t\t\terr = -EIO;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * otherwise we have one bad data stripe and\n\t\t\t\t * a good P stripe.  raid5!\n\t\t\t\t */\n\t\t\t\tgoto pstripe;\n\t\t\t}\n\n\t\t\tif (rbio->bbio->raid_map[failb] == RAID5_P_STRIPE) {\n\t\t\t\traid6_datap_recov(rbio->real_stripes,\n\t\t\t\t\t\t  PAGE_SIZE, faila, pointers);\n\t\t\t} else {\n\t\t\t\traid6_2data_recov(rbio->real_stripes,\n\t\t\t\t\t\t  PAGE_SIZE, faila, failb,\n\t\t\t\t\t\t  pointers);\n\t\t\t}\n\t\t} else {\n\t\t\tvoid *p;\n\n\t\t\t/* rebuild from P stripe here (raid5 or raid6) */\n\t\t\tBUG_ON(failb != -1);\npstripe:\n\t\t\t/* Copy parity block into failed block to start with */\n\t\t\tmemcpy(pointers[faila],\n\t\t\t       pointers[rbio->nr_data],\n\t\t\t       PAGE_CACHE_SIZE);\n\n\t\t\t/* rearrange the pointer array */\n\t\t\tp = pointers[faila];\n\t\t\tfor (stripe = faila; stripe < rbio->nr_data - 1; stripe++)\n\t\t\t\tpointers[stripe] = pointers[stripe + 1];\n\t\t\tpointers[rbio->nr_data - 1] = p;\n\n\t\t\t/* xor in the rest */\n\t\t\trun_xor(pointers, rbio->nr_data - 1, PAGE_CACHE_SIZE);\n\t\t}\n\t\t/* if we're doing this rebuild as part of an rmw, go through\n\t\t * and set all of our private rbio pages in the\n\t\t * failed stripes as uptodate.  This way finish_rmw will\n\t\t * know they can be trusted.  If this was a read reconstruction,\n\t\t * other endio functions will fiddle the uptodate bits\n\t\t */\n\t\tif (rbio->operation == BTRFS_RBIO_WRITE) {\n\t\t\tfor (i = 0;  i < nr_pages; i++) {\n\t\t\t\tif (faila != -1) {\n\t\t\t\t\tpage = rbio_stripe_page(rbio, faila, i);\n\t\t\t\t\tSetPageUptodate(page);\n\t\t\t\t}\n\t\t\t\tif (failb != -1) {\n\t\t\t\t\tpage = rbio_stripe_page(rbio, failb, i);\n\t\t\t\t\tSetPageUptodate(page);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\t\t/*\n\t\t\t * if we're rebuilding a read, we have to use\n\t\t\t * pages from the bio list\n\t\t\t */\n\t\t\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD &&\n\t\t\t    (stripe == faila || stripe == failb)) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\t} else {\n\t\t\t\tpage = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\t\t\tkunmap(page);\n\t\t}\n\t}\n\n\terr = 0;\ncleanup:\n\tkfree(pointers);\n\ncleanup_io:\n\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD) {\n\t\tif (err == 0)\n\t\t\tcache_rbio_pages(rbio);\n\t\telse\n\t\t\tclear_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n\n\t\trbio_orig_end_io(rbio, err, err == 0);\n\t} else if (err == 0) {\n\t\trbio->faila = -1;\n\t\trbio->failb = -1;\n\n\t\tif (rbio->operation == BTRFS_RBIO_WRITE)\n\t\t\tfinish_rmw(rbio);\n\t\telse if (rbio->operation == BTRFS_RBIO_PARITY_SCRUB)\n\t\t\tfinish_parity_scrub(rbio, 0);\n\t\telse\n\t\t\tBUG();\n\t} else {\n\t\trbio_orig_end_io(rbio, err, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_parity_stripe",
          "args": [
            "rbio->failb"
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_data_stripe",
          "args": [
            "rbio",
            "rbio->failb"
          ],
          "line": 2497
        },
        "resolved": true,
        "details": {
          "function_name": "is_data_stripe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "2470-2475",
          "snippet": "static inline int is_data_stripe(struct btrfs_raid_bio *rbio, int stripe)\n{\n\tif (stripe >= 0 && stripe < rbio->nr_data)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic inline int is_data_stripe(struct btrfs_raid_bio *rbio, int stripe)\n{\n\tif (stripe >= 0 && stripe < rbio->nr_data)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_parity_stripe",
          "args": [
            "rbio->faila"
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rbio->error"
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void validate_rbio_for_parity_scrub(struct btrfs_raid_bio *rbio)\n{\n\tif (atomic_read(&rbio->error) > rbio->bbio->max_errors)\n\t\tgoto cleanup;\n\n\tif (rbio->faila >= 0 || rbio->failb >= 0) {\n\t\tint dfail = 0, failp = -1;\n\n\t\tif (is_data_stripe(rbio, rbio->faila))\n\t\t\tdfail++;\n\t\telse if (is_parity_stripe(rbio->faila))\n\t\t\tfailp = rbio->faila;\n\n\t\tif (is_data_stripe(rbio, rbio->failb))\n\t\t\tdfail++;\n\t\telse if (is_parity_stripe(rbio->failb))\n\t\t\tfailp = rbio->failb;\n\n\t\t/*\n\t\t * Because we can not use a scrubbing parity to repair\n\t\t * the data, so the capability of the repair is declined.\n\t\t * (In the case of RAID5, we can not repair anything)\n\t\t */\n\t\tif (dfail > rbio->bbio->max_errors - 1)\n\t\t\tgoto cleanup;\n\n\t\t/*\n\t\t * If all data is good, only parity is correctly, just\n\t\t * repair the parity.\n\t\t */\n\t\tif (dfail == 0) {\n\t\t\tfinish_parity_scrub(rbio, 0);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * Here means we got one corrupted data stripe and one\n\t\t * corrupted parity on RAID6, if the corrupted parity\n\t\t * is scrubbing parity, luckly, use the other one to repair\n\t\t * the data, or we can not repair the data stripe.\n\t\t */\n\t\tif (failp != rbio->scrubp)\n\t\t\tgoto cleanup;\n\n\t\t__raid_recover_end_io(rbio);\n\t} else {\n\t\tfinish_parity_scrub(rbio, 1);\n\t}\n\treturn;\n\ncleanup:\n\trbio_orig_end_io(rbio, -EIO, 0);\n}"
  },
  {
    "function_name": "is_data_stripe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "2470-2475",
    "snippet": "static inline int is_data_stripe(struct btrfs_raid_bio *rbio, int stripe)\n{\n\tif (stripe >= 0 && stripe < rbio->nr_data)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic inline int is_data_stripe(struct btrfs_raid_bio *rbio, int stripe)\n{\n\tif (stripe >= 0 && stripe < rbio->nr_data)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "finish_parity_scrub",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "2308-2468",
    "snippet": "static noinline void finish_parity_scrub(struct btrfs_raid_bio *rbio,\n\t\t\t\t\t int need_check)\n{\n\tstruct btrfs_bio *bbio = rbio->bbio;\n\tvoid *pointers[rbio->real_stripes];\n\tDECLARE_BITMAP(pbitmap, rbio->stripe_npages);\n\tint nr_data = rbio->nr_data;\n\tint stripe;\n\tint pagenr;\n\tint p_stripe = -1;\n\tint q_stripe = -1;\n\tstruct page *p_page = NULL;\n\tstruct page *q_page = NULL;\n\tstruct bio_list bio_list;\n\tstruct bio *bio;\n\tint is_replace = 0;\n\tint ret;\n\n\tbio_list_init(&bio_list);\n\n\tif (rbio->real_stripes - rbio->nr_data == 1) {\n\t\tp_stripe = rbio->real_stripes - 1;\n\t} else if (rbio->real_stripes - rbio->nr_data == 2) {\n\t\tp_stripe = rbio->real_stripes - 2;\n\t\tq_stripe = rbio->real_stripes - 1;\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (bbio->num_tgtdevs && bbio->tgtdev_map[rbio->scrubp]) {\n\t\tis_replace = 1;\n\t\tbitmap_copy(pbitmap, rbio->dbitmap, rbio->stripe_npages);\n\t}\n\n\t/*\n\t * Because the higher layers(scrubber) are unlikely to\n\t * use this area of the disk again soon, so don't cache\n\t * it.\n\t */\n\tclear_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n\n\tif (!need_check)\n\t\tgoto writeback;\n\n\tp_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\tif (!p_page)\n\t\tgoto cleanup;\n\tSetPageUptodate(p_page);\n\n\tif (q_stripe != -1) {\n\t\tq_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\t\tif (!q_page) {\n\t\t\t__free_page(p_page);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tSetPageUptodate(q_page);\n\t}\n\n\tatomic_set(&rbio->error, 0);\n\n\tfor_each_set_bit(pagenr, rbio->dbitmap, rbio->stripe_npages) {\n\t\tstruct page *p;\n\t\tvoid *parity;\n\t\t/* first collect one page from each data stripe */\n\t\tfor (stripe = 0; stripe < nr_data; stripe++) {\n\t\t\tp = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\tpointers[stripe] = kmap(p);\n\t\t}\n\n\t\t/* then add the parity stripe */\n\t\tpointers[stripe++] = kmap(p_page);\n\n\t\tif (q_stripe != -1) {\n\n\t\t\t/*\n\t\t\t * raid6, add the qstripe and call the\n\t\t\t * library function to fill in our p/q\n\t\t\t */\n\t\t\tpointers[stripe++] = kmap(q_page);\n\n\t\t\traid6_call.gen_syndrome(rbio->real_stripes, PAGE_SIZE,\n\t\t\t\t\t\tpointers);\n\t\t} else {\n\t\t\t/* raid5 */\n\t\t\tmemcpy(pointers[nr_data], pointers[0], PAGE_SIZE);\n\t\t\trun_xor(pointers + 1, nr_data - 1, PAGE_CACHE_SIZE);\n\t\t}\n\n\t\t/* Check scrubbing pairty and repair it */\n\t\tp = rbio_stripe_page(rbio, rbio->scrubp, pagenr);\n\t\tparity = kmap(p);\n\t\tif (memcmp(parity, pointers[rbio->scrubp], PAGE_CACHE_SIZE))\n\t\t\tmemcpy(parity, pointers[rbio->scrubp], PAGE_CACHE_SIZE);\n\t\telse\n\t\t\t/* Parity is right, needn't writeback */\n\t\t\tbitmap_clear(rbio->dbitmap, pagenr, 1);\n\t\tkunmap(p);\n\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++)\n\t\t\tkunmap(page_in_rbio(rbio, stripe, pagenr, 0));\n\t}\n\n\t__free_page(p_page);\n\tif (q_page)\n\t\t__free_page(q_page);\n\nwriteback:\n\t/*\n\t * time to start writing.  Make bios for everything from the\n\t * higher layers (the bio_list in our rbio) and our p/q.  Ignore\n\t * everything else.\n\t */\n\tfor_each_set_bit(pagenr, rbio->dbitmap, rbio->stripe_npages) {\n\t\tstruct page *page;\n\n\t\tpage = rbio_stripe_page(rbio, rbio->scrubp, pagenr);\n\t\tret = rbio_add_io_page(rbio, &bio_list,\n\t\t\t       page, rbio->scrubp, pagenr, rbio->stripe_len);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (!is_replace)\n\t\tgoto submit_write;\n\n\tfor_each_set_bit(pagenr, pbitmap, rbio->stripe_npages) {\n\t\tstruct page *page;\n\n\t\tpage = rbio_stripe_page(rbio, rbio->scrubp, pagenr);\n\t\tret = rbio_add_io_page(rbio, &bio_list, page,\n\t\t\t\t       bbio->tgtdev_map[rbio->scrubp],\n\t\t\t\t       pagenr, rbio->stripe_len);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\nsubmit_write:\n\tnr_data = bio_list_size(&bio_list);\n\tif (!nr_data) {\n\t\t/* Every parity is right */\n\t\trbio_orig_end_io(rbio, 0, 0);\n\t\treturn;\n\t}\n\n\tatomic_set(&rbio->stripes_pending, nr_data);\n\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid_write_parity_end_io;\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(WRITE, bio);\n\t}\n\treturn;\n\ncleanup:\n\trbio_orig_end_io(rbio, -EIO, 0);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define RBIO_CACHE_READY_BIT\t3"
    ],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_parity_scrub(struct btrfs_raid_bio *rbio,\n\t\t\t\t\t int need_check);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rbio_orig_end_io",
          "args": [
            "rbio",
            "-EIO",
            "0"
          ],
          "line": 2467
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_orig_end_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "861-879",
          "snippet": "static void rbio_orig_end_io(struct btrfs_raid_bio *rbio, int err, int uptodate)\n{\n\tstruct bio *cur = bio_list_get(&rbio->bio_list);\n\tstruct bio *next;\n\n\tif (rbio->generic_bio_cnt)\n\t\tbtrfs_bio_counter_sub(rbio->fs_info, rbio->generic_bio_cnt);\n\n\tfree_raid_bio(rbio);\n\n\twhile (cur) {\n\t\tnext = cur->bi_next;\n\t\tcur->bi_next = NULL;\n\t\tif (uptodate)\n\t\t\tset_bit(BIO_UPTODATE, &cur->bi_flags);\n\t\tbio_endio(cur, err);\n\t\tcur = next;\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void rbio_orig_end_io(struct btrfs_raid_bio *rbio, int err, int uptodate)\n{\n\tstruct bio *cur = bio_list_get(&rbio->bio_list);\n\tstruct bio *next;\n\n\tif (rbio->generic_bio_cnt)\n\t\tbtrfs_bio_counter_sub(rbio->fs_info, rbio->generic_bio_cnt);\n\n\tfree_raid_bio(rbio);\n\n\twhile (cur) {\n\t\tnext = cur->bi_next;\n\t\tcur->bi_next = NULL;\n\t\tif (uptodate)\n\t\t\tset_bit(BIO_UPTODATE, &cur->bi_flags);\n\t\tbio_endio(cur, err);\n\t\tcur = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "WRITE",
            "bio"
          ],
          "line": 2462
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_submit_bio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "3067-3071",
          "snippet": "int btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!test_bit(BIO_UPTODATE, &bio->bi_flags)"
          ],
          "line": 2461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BIO_UPTODATE",
            "&bio->bi_flags"
          ],
          "line": 2461
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_list_pop",
          "args": [
            "&bio_list"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&rbio->stripes_pending",
            "nr_data"
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_list_size",
          "args": [
            "&bio_list"
          ],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rbio_add_io_page",
          "args": [
            "rbio",
            "&bio_list",
            "page",
            "bbio->tgtdev_map[rbio->scrubp]",
            "pagenr",
            "rbio->stripe_len"
          ],
          "line": 2437
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_add_io_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1050-1102",
          "snippet": "static int rbio_add_io_page(struct btrfs_raid_bio *rbio,\n\t\t\t    struct bio_list *bio_list,\n\t\t\t    struct page *page,\n\t\t\t    int stripe_nr,\n\t\t\t    unsigned long page_index,\n\t\t\t    unsigned long bio_max_len)\n{\n\tstruct bio *last = bio_list->tail;\n\tu64 last_end = 0;\n\tint ret;\n\tstruct bio *bio;\n\tstruct btrfs_bio_stripe *stripe;\n\tu64 disk_start;\n\n\tstripe = &rbio->bbio->stripes[stripe_nr];\n\tdisk_start = stripe->physical + (page_index << PAGE_CACHE_SHIFT);\n\n\t/* if the device is missing, just fail this stripe */\n\tif (!stripe->dev->bdev)\n\t\treturn fail_rbio_index(rbio, stripe_nr);\n\n\t/* see if we can add this page onto our existing bio */\n\tif (last) {\n\t\tlast_end = (u64)last->bi_iter.bi_sector << 9;\n\t\tlast_end += last->bi_iter.bi_size;\n\n\t\t/*\n\t\t * we can't merge these if they are from different\n\t\t * devices or if they are not contiguous\n\t\t */\n\t\tif (last_end == disk_start && stripe->dev->bdev &&\n\t\t    test_bit(BIO_UPTODATE, &last->bi_flags) &&\n\t\t    last->bi_bdev == stripe->dev->bdev) {\n\t\t\tret = bio_add_page(last, page, PAGE_CACHE_SIZE, 0);\n\t\t\tif (ret == PAGE_CACHE_SIZE)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* put a new bio on the list */\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, bio_max_len >> PAGE_SHIFT?:1);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\n\tbio->bi_iter.bi_size = 0;\n\tbio->bi_bdev = stripe->dev->bdev;\n\tbio->bi_iter.bi_sector = disk_start >> 9;\n\tset_bit(BIO_UPTODATE, &bio->bi_flags);\n\n\tbio_add_page(bio, page, PAGE_CACHE_SIZE, 0);\n\tbio_list_add(bio_list, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int rbio_add_io_page(struct btrfs_raid_bio *rbio,\n\t\t\t    struct bio_list *bio_list,\n\t\t\t    struct page *page,\n\t\t\t    int stripe_nr,\n\t\t\t    unsigned long page_index,\n\t\t\t    unsigned long bio_max_len)\n{\n\tstruct bio *last = bio_list->tail;\n\tu64 last_end = 0;\n\tint ret;\n\tstruct bio *bio;\n\tstruct btrfs_bio_stripe *stripe;\n\tu64 disk_start;\n\n\tstripe = &rbio->bbio->stripes[stripe_nr];\n\tdisk_start = stripe->physical + (page_index << PAGE_CACHE_SHIFT);\n\n\t/* if the device is missing, just fail this stripe */\n\tif (!stripe->dev->bdev)\n\t\treturn fail_rbio_index(rbio, stripe_nr);\n\n\t/* see if we can add this page onto our existing bio */\n\tif (last) {\n\t\tlast_end = (u64)last->bi_iter.bi_sector << 9;\n\t\tlast_end += last->bi_iter.bi_size;\n\n\t\t/*\n\t\t * we can't merge these if they are from different\n\t\t * devices or if they are not contiguous\n\t\t */\n\t\tif (last_end == disk_start && stripe->dev->bdev &&\n\t\t    test_bit(BIO_UPTODATE, &last->bi_flags) &&\n\t\t    last->bi_bdev == stripe->dev->bdev) {\n\t\t\tret = bio_add_page(last, page, PAGE_CACHE_SIZE, 0);\n\t\t\tif (ret == PAGE_CACHE_SIZE)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* put a new bio on the list */\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, bio_max_len >> PAGE_SHIFT?:1);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\n\tbio->bi_iter.bi_size = 0;\n\tbio->bi_bdev = stripe->dev->bdev;\n\tbio->bi_iter.bi_sector = disk_start >> 9;\n\tset_bit(BIO_UPTODATE, &bio->bi_flags);\n\n\tbio_add_page(bio, page, PAGE_CACHE_SIZE, 0);\n\tbio_list_add(bio_list, bio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rbio_stripe_page",
          "args": [
            "rbio",
            "rbio->scrubp",
            "pagenr"
          ],
          "line": 2436
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_stripe_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1125-1131",
          "snippet": "static struct page *rbio_stripe_page(struct btrfs_raid_bio *rbio, int stripe, int page)\n{\n\tint index;\n\tindex = stripe * (rbio->stripe_len >> PAGE_CACHE_SHIFT);\n\tindex += page;\n\treturn rbio->stripe_pages[index];\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic struct page *rbio_stripe_page(struct btrfs_raid_bio *rbio, int stripe, int page)\n{\n\tint index;\n\tindex = stripe * (rbio->stripe_len >> PAGE_CACHE_SHIFT);\n\tindex += page;\n\treturn rbio->stripe_pages[index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "pagenr",
            "pbitmap",
            "rbio->stripe_npages"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "pagenr",
            "rbio->dbitmap",
            "rbio->stripe_npages"
          ],
          "line": 2420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "q_page"
          ],
          "line": 2412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "p_page"
          ],
          "line": 2410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page_in_rbio(rbio, stripe, pagenr, 0)"
          ],
          "line": 2407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_in_rbio",
          "args": [
            "rbio",
            "stripe",
            "pagenr",
            "0"
          ],
          "line": 2407
        },
        "resolved": true,
        "details": {
          "function_name": "page_in_rbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "923-939",
          "snippet": "static struct page *page_in_rbio(struct btrfs_raid_bio *rbio,\n\t\t\t\t int index, int pagenr, int bio_list_only)\n{\n\tint chunk_page;\n\tstruct page *p = NULL;\n\n\tchunk_page = index * (rbio->stripe_len >> PAGE_SHIFT) + pagenr;\n\n\tspin_lock_irq(&rbio->bio_list_lock);\n\tp = rbio->bio_pages[chunk_page];\n\tspin_unlock_irq(&rbio->bio_list_lock);\n\n\tif (p || bio_list_only)\n\t\treturn p;\n\n\treturn rbio->stripe_pages[chunk_page];\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic struct page *page_in_rbio(struct btrfs_raid_bio *rbio,\n\t\t\t\t int index, int pagenr, int bio_list_only)\n{\n\tint chunk_page;\n\tstruct page *p = NULL;\n\n\tchunk_page = index * (rbio->stripe_len >> PAGE_SHIFT) + pagenr;\n\n\tspin_lock_irq(&rbio->bio_list_lock);\n\tp = rbio->bio_pages[chunk_page];\n\tspin_unlock_irq(&rbio->bio_list_lock);\n\n\tif (p || bio_list_only)\n\t\treturn p;\n\n\treturn rbio->stripe_pages[chunk_page];\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "p"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_clear",
          "args": [
            "rbio->dbitmap",
            "pagenr",
            "1"
          ],
          "line": 2403
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_bitmap_clear_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/bitmap.h",
          "lines": "82-86",
          "snippet": "static inline int ntfs_bitmap_clear_run(struct inode *vi, const s64 start_bit,\n\t\tconst s64 count)\n{\n\treturn ntfs_bitmap_set_bits_in_run(vi, start_bit, count, 0);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline int ntfs_bitmap_clear_run(struct inode *vi, const s64 start_bit,\n\t\tconst s64 count)\n{\n\treturn ntfs_bitmap_set_bits_in_run(vi, start_bit, count, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "parity",
            "pointers[rbio->scrubp]",
            "PAGE_CACHE_SIZE"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "parity",
            "pointers[rbio->scrubp]",
            "PAGE_CACHE_SIZE"
          ],
          "line": 2399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "p"
          ],
          "line": 2398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_xor",
          "args": [
            "pointers + 1",
            "nr_data - 1",
            "PAGE_CACHE_SIZE"
          ],
          "line": 2393
        },
        "resolved": true,
        "details": {
          "function_name": "run_xor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "520-533",
          "snippet": "static void run_xor(void **pages, int src_cnt, ssize_t len)\n{\n\tint src_off = 0;\n\tint xor_src_cnt = 0;\n\tvoid *dest = pages[src_cnt];\n\n\twhile(src_cnt > 0) {\n\t\txor_src_cnt = min(src_cnt, MAX_XOR_BLOCKS);\n\t\txor_blocks(xor_src_cnt, len, dest, pages + src_off);\n\n\t\tsrc_cnt -= xor_src_cnt;\n\t\tsrc_off += xor_src_cnt;\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic void run_xor(void **pages, int src_cnt, ssize_t len)\n{\n\tint src_off = 0;\n\tint xor_src_cnt = 0;\n\tvoid *dest = pages[src_cnt];\n\n\twhile(src_cnt > 0) {\n\t\txor_src_cnt = min(src_cnt, MAX_XOR_BLOCKS);\n\t\txor_blocks(xor_src_cnt, len, dest, pages + src_off);\n\n\t\tsrc_cnt -= xor_src_cnt;\n\t\tsrc_off += xor_src_cnt;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pointers[nr_data]",
            "pointers[0]",
            "PAGE_SIZE"
          ],
          "line": 2392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raid6_call.gen_syndrome",
          "args": [
            "rbio->real_stripes",
            "PAGE_SIZE",
            "pointers"
          ],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "q_page"
          ],
          "line": 2386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "p_page"
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "p"
          ],
          "line": 2374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "pagenr",
            "rbio->dbitmap",
            "rbio->stripe_npages"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&rbio->error",
            "0"
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "q_page"
          ],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "p_page"
          ],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_NOFS | __GFP_HIGHMEM"
          ],
          "line": 2358
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "p_page"
          ],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "RBIO_CACHE_READY_BIT",
            "&rbio->flags"
          ],
          "line": 2347
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_copy",
          "args": [
            "pbitmap",
            "rbio->dbitmap",
            "rbio->stripe_npages"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_list_init",
          "args": [
            "&bio_list"
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_BITMAP",
          "args": [
            "pbitmap",
            "rbio->stripe_npages"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_READY_BIT\t3\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_parity_scrub(struct btrfs_raid_bio *rbio,\n\t\t\t\t\t int need_check);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic noinline void finish_parity_scrub(struct btrfs_raid_bio *rbio,\n\t\t\t\t\t int need_check)\n{\n\tstruct btrfs_bio *bbio = rbio->bbio;\n\tvoid *pointers[rbio->real_stripes];\n\tDECLARE_BITMAP(pbitmap, rbio->stripe_npages);\n\tint nr_data = rbio->nr_data;\n\tint stripe;\n\tint pagenr;\n\tint p_stripe = -1;\n\tint q_stripe = -1;\n\tstruct page *p_page = NULL;\n\tstruct page *q_page = NULL;\n\tstruct bio_list bio_list;\n\tstruct bio *bio;\n\tint is_replace = 0;\n\tint ret;\n\n\tbio_list_init(&bio_list);\n\n\tif (rbio->real_stripes - rbio->nr_data == 1) {\n\t\tp_stripe = rbio->real_stripes - 1;\n\t} else if (rbio->real_stripes - rbio->nr_data == 2) {\n\t\tp_stripe = rbio->real_stripes - 2;\n\t\tq_stripe = rbio->real_stripes - 1;\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (bbio->num_tgtdevs && bbio->tgtdev_map[rbio->scrubp]) {\n\t\tis_replace = 1;\n\t\tbitmap_copy(pbitmap, rbio->dbitmap, rbio->stripe_npages);\n\t}\n\n\t/*\n\t * Because the higher layers(scrubber) are unlikely to\n\t * use this area of the disk again soon, so don't cache\n\t * it.\n\t */\n\tclear_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n\n\tif (!need_check)\n\t\tgoto writeback;\n\n\tp_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\tif (!p_page)\n\t\tgoto cleanup;\n\tSetPageUptodate(p_page);\n\n\tif (q_stripe != -1) {\n\t\tq_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\t\tif (!q_page) {\n\t\t\t__free_page(p_page);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tSetPageUptodate(q_page);\n\t}\n\n\tatomic_set(&rbio->error, 0);\n\n\tfor_each_set_bit(pagenr, rbio->dbitmap, rbio->stripe_npages) {\n\t\tstruct page *p;\n\t\tvoid *parity;\n\t\t/* first collect one page from each data stripe */\n\t\tfor (stripe = 0; stripe < nr_data; stripe++) {\n\t\t\tp = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\tpointers[stripe] = kmap(p);\n\t\t}\n\n\t\t/* then add the parity stripe */\n\t\tpointers[stripe++] = kmap(p_page);\n\n\t\tif (q_stripe != -1) {\n\n\t\t\t/*\n\t\t\t * raid6, add the qstripe and call the\n\t\t\t * library function to fill in our p/q\n\t\t\t */\n\t\t\tpointers[stripe++] = kmap(q_page);\n\n\t\t\traid6_call.gen_syndrome(rbio->real_stripes, PAGE_SIZE,\n\t\t\t\t\t\tpointers);\n\t\t} else {\n\t\t\t/* raid5 */\n\t\t\tmemcpy(pointers[nr_data], pointers[0], PAGE_SIZE);\n\t\t\trun_xor(pointers + 1, nr_data - 1, PAGE_CACHE_SIZE);\n\t\t}\n\n\t\t/* Check scrubbing pairty and repair it */\n\t\tp = rbio_stripe_page(rbio, rbio->scrubp, pagenr);\n\t\tparity = kmap(p);\n\t\tif (memcmp(parity, pointers[rbio->scrubp], PAGE_CACHE_SIZE))\n\t\t\tmemcpy(parity, pointers[rbio->scrubp], PAGE_CACHE_SIZE);\n\t\telse\n\t\t\t/* Parity is right, needn't writeback */\n\t\t\tbitmap_clear(rbio->dbitmap, pagenr, 1);\n\t\tkunmap(p);\n\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++)\n\t\t\tkunmap(page_in_rbio(rbio, stripe, pagenr, 0));\n\t}\n\n\t__free_page(p_page);\n\tif (q_page)\n\t\t__free_page(q_page);\n\nwriteback:\n\t/*\n\t * time to start writing.  Make bios for everything from the\n\t * higher layers (the bio_list in our rbio) and our p/q.  Ignore\n\t * everything else.\n\t */\n\tfor_each_set_bit(pagenr, rbio->dbitmap, rbio->stripe_npages) {\n\t\tstruct page *page;\n\n\t\tpage = rbio_stripe_page(rbio, rbio->scrubp, pagenr);\n\t\tret = rbio_add_io_page(rbio, &bio_list,\n\t\t\t       page, rbio->scrubp, pagenr, rbio->stripe_len);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (!is_replace)\n\t\tgoto submit_write;\n\n\tfor_each_set_bit(pagenr, pbitmap, rbio->stripe_npages) {\n\t\tstruct page *page;\n\n\t\tpage = rbio_stripe_page(rbio, rbio->scrubp, pagenr);\n\t\tret = rbio_add_io_page(rbio, &bio_list, page,\n\t\t\t\t       bbio->tgtdev_map[rbio->scrubp],\n\t\t\t\t       pagenr, rbio->stripe_len);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\nsubmit_write:\n\tnr_data = bio_list_size(&bio_list);\n\tif (!nr_data) {\n\t\t/* Every parity is right */\n\t\trbio_orig_end_io(rbio, 0, 0);\n\t\treturn;\n\t}\n\n\tatomic_set(&rbio->stripes_pending, nr_data);\n\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid_write_parity_end_io;\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(WRITE, bio);\n\t}\n\treturn;\n\ncleanup:\n\trbio_orig_end_io(rbio, -EIO, 0);\n}"
  },
  {
    "function_name": "raid_write_parity_end_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "2288-2306",
    "snippet": "static void raid_write_parity_end_io(struct bio *bio, int err)\n{\n\tstruct btrfs_raid_bio *rbio = bio->bi_private;\n\n\tif (err)\n\t\tfail_bio_stripe(rbio, bio);\n\n\tbio_put(bio);\n\n\tif (!atomic_dec_and_test(&rbio->stripes_pending))\n\t\treturn;\n\n\terr = 0;\n\n\tif (atomic_read(&rbio->error))\n\t\terr = -EIO;\n\n\trbio_orig_end_io(rbio, err, 0);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rbio_orig_end_io",
          "args": [
            "rbio",
            "err",
            "0"
          ],
          "line": 2305
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_orig_end_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "861-879",
          "snippet": "static void rbio_orig_end_io(struct btrfs_raid_bio *rbio, int err, int uptodate)\n{\n\tstruct bio *cur = bio_list_get(&rbio->bio_list);\n\tstruct bio *next;\n\n\tif (rbio->generic_bio_cnt)\n\t\tbtrfs_bio_counter_sub(rbio->fs_info, rbio->generic_bio_cnt);\n\n\tfree_raid_bio(rbio);\n\n\twhile (cur) {\n\t\tnext = cur->bi_next;\n\t\tcur->bi_next = NULL;\n\t\tif (uptodate)\n\t\t\tset_bit(BIO_UPTODATE, &cur->bi_flags);\n\t\tbio_endio(cur, err);\n\t\tcur = next;\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void rbio_orig_end_io(struct btrfs_raid_bio *rbio, int err, int uptodate)\n{\n\tstruct bio *cur = bio_list_get(&rbio->bio_list);\n\tstruct bio *next;\n\n\tif (rbio->generic_bio_cnt)\n\t\tbtrfs_bio_counter_sub(rbio->fs_info, rbio->generic_bio_cnt);\n\n\tfree_raid_bio(rbio);\n\n\twhile (cur) {\n\t\tnext = cur->bi_next;\n\t\tcur->bi_next = NULL;\n\t\tif (uptodate)\n\t\t\tset_bit(BIO_UPTODATE, &cur->bi_flags);\n\t\tbio_endio(cur, err);\n\t\tcur = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rbio->error"
          ],
          "line": 2302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&rbio->stripes_pending"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fail_bio_stripe",
          "args": [
            "rbio",
            "bio"
          ],
          "line": 2293
        },
        "resolved": true,
        "details": {
          "function_name": "fail_bio_stripe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1417-1426",
          "snippet": "static int fail_bio_stripe(struct btrfs_raid_bio *rbio,\n\t\t\t   struct bio *bio)\n{\n\tint failed = find_bio_stripe(rbio, bio);\n\n\tif (failed < 0)\n\t\treturn -EIO;\n\n\treturn fail_rbio_index(rbio, failed);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio,\n\t\t\t   struct bio *bio)\n{\n\tint failed = find_bio_stripe(rbio, bio);\n\n\tif (failed < 0)\n\t\treturn -EIO;\n\n\treturn fail_rbio_index(rbio, failed);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void raid_write_parity_end_io(struct bio *bio, int err)\n{\n\tstruct btrfs_raid_bio *rbio = bio->bi_private;\n\n\tif (err)\n\t\tfail_bio_stripe(rbio, bio);\n\n\tbio_put(bio);\n\n\tif (!atomic_dec_and_test(&rbio->stripes_pending))\n\t\treturn;\n\n\terr = 0;\n\n\tif (atomic_read(&rbio->error))\n\t\terr = -EIO;\n\n\trbio_orig_end_io(rbio, err, 0);\n}"
  },
  {
    "function_name": "alloc_rbio_essential_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "2261-2282",
    "snippet": "static int alloc_rbio_essential_pages(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\tint bit;\n\tint index;\n\tstruct page *page;\n\n\tfor_each_set_bit(bit, rbio->dbitmap, rbio->stripe_npages) {\n\t\tfor (i = 0; i < rbio->real_stripes; i++) {\n\t\t\tindex = i * rbio->stripe_npages + bit;\n\t\t\tif (rbio->stripe_pages[index])\n\t\t\t\tcontinue;\n\n\t\t\tpage = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\t\t\tif (!page)\n\t\t\t\treturn -ENOMEM;\n\t\t\trbio->stripe_pages[index] = page;\n\t\t\tClearPageUptodate(page);\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 2278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_NOFS | __GFP_HIGHMEM"
          ],
          "line": 2274
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "bit",
            "rbio->dbitmap",
            "rbio->stripe_npages"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int alloc_rbio_essential_pages(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\tint bit;\n\tint index;\n\tstruct page *page;\n\n\tfor_each_set_bit(bit, rbio->dbitmap, rbio->stripe_npages) {\n\t\tfor (i = 0; i < rbio->real_stripes; i++) {\n\t\t\tindex = i * rbio->stripe_npages + bit;\n\t\t\tif (rbio->stripe_pages[index])\n\t\t\t\tcontinue;\n\n\t\t\tpage = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\t\t\tif (!page)\n\t\t\t\treturn -ENOMEM;\n\t\t\trbio->stripe_pages[index] = page;\n\t\t\tClearPageUptodate(page);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "raid56_parity_add_scrub_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "2243-2255",
    "snippet": "void raid56_parity_add_scrub_pages(struct btrfs_raid_bio *rbio,\n\t\t\t\t   struct page *page, u64 logical)\n{\n\tint stripe_offset;\n\tint index;\n\n\tASSERT(logical >= rbio->bbio->raid_map[0]);\n\tASSERT(logical + PAGE_SIZE <= rbio->bbio->raid_map[0] +\n\t\t\t\trbio->stripe_len * rbio->nr_data);\n\tstripe_offset = (int)(logical - rbio->bbio->raid_map[0]);\n\tindex = stripe_offset >> PAGE_CACHE_SHIFT;\n\trbio->bio_pages[index] = page;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "logical + PAGE_SIZE <= rbio->bbio->raid_map[0] +\n\t\t\t\trbio->stripe_len * rbio->nr_data"
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "logical >= rbio->bbio->raid_map[0]"
          ],
          "line": 2249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nvoid raid56_parity_add_scrub_pages(struct btrfs_raid_bio *rbio,\n\t\t\t\t   struct page *page, u64 logical)\n{\n\tint stripe_offset;\n\tint index;\n\n\tASSERT(logical >= rbio->bbio->raid_map[0]);\n\tASSERT(logical + PAGE_SIZE <= rbio->bbio->raid_map[0] +\n\t\t\t\trbio->stripe_len * rbio->nr_data);\n\tstripe_offset = (int)(logical - rbio->bbio->raid_map[0]);\n\tindex = stripe_offset >> PAGE_CACHE_SHIFT;\n\trbio->bio_pages[index] = page;\n}"
  },
  {
    "function_name": "raid56_parity_alloc_scrub_rbio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "2208-2241",
    "snippet": "struct btrfs_raid_bio *\nraid56_parity_alloc_scrub_rbio(struct btrfs_root *root, struct bio *bio,\n\t\t\t       struct btrfs_bio *bbio, u64 stripe_len,\n\t\t\t       struct btrfs_device *scrub_dev,\n\t\t\t       unsigned long *dbitmap, int stripe_nsectors)\n{\n\tstruct btrfs_raid_bio *rbio;\n\tint i;\n\n\trbio = alloc_rbio(root, bbio, stripe_len);\n\tif (IS_ERR(rbio))\n\t\treturn NULL;\n\tbio_list_add(&rbio->bio_list, bio);\n\t/*\n\t * This is a special bio which is used to hold the completion handler\n\t * and make the scrub rbio is similar to the other types\n\t */\n\tASSERT(!bio->bi_iter.bi_size);\n\trbio->operation = BTRFS_RBIO_PARITY_SCRUB;\n\n\tfor (i = 0; i < rbio->real_stripes; i++) {\n\t\tif (bbio->stripes[i].dev == scrub_dev) {\n\t\t\trbio->scrubp = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Now we just support the sectorsize equals to page size */\n\tASSERT(root->sectorsize == PAGE_SIZE);\n\tASSERT(rbio->stripe_npages == stripe_nsectors);\n\tbitmap_copy(rbio->dbitmap, dbitmap, stripe_nsectors);\n\n\treturn rbio;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bitmap_copy",
          "args": [
            "rbio->dbitmap",
            "dbitmap",
            "stripe_nsectors"
          ],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "rbio->stripe_npages == stripe_nsectors"
          ],
          "line": 2237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "root->sectorsize == PAGE_SIZE"
          ],
          "line": 2236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!bio->bi_iter.bi_size"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_list_add",
          "args": [
            "&rbio->bio_list",
            "bio"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rbio"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_rbio",
          "args": [
            "root",
            "bbio",
            "stripe_len"
          ],
          "line": 2217
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_rbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "955-1006",
          "snippet": "static struct btrfs_raid_bio *alloc_rbio(struct btrfs_root *root,\n\t\t\t  struct btrfs_bio *bbio, u64 stripe_len)\n{\n\tstruct btrfs_raid_bio *rbio;\n\tint nr_data = 0;\n\tint real_stripes = bbio->num_stripes - bbio->num_tgtdevs;\n\tint num_pages = rbio_nr_pages(stripe_len, real_stripes);\n\tint stripe_npages = DIV_ROUND_UP(stripe_len, PAGE_SIZE);\n\tvoid *p;\n\n\trbio = kzalloc(sizeof(*rbio) + num_pages * sizeof(struct page *) * 2 +\n\t\t       DIV_ROUND_UP(stripe_npages, BITS_PER_LONG / 8),\n\t\t\tGFP_NOFS);\n\tif (!rbio)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbio_list_init(&rbio->bio_list);\n\tINIT_LIST_HEAD(&rbio->plug_list);\n\tspin_lock_init(&rbio->bio_list_lock);\n\tINIT_LIST_HEAD(&rbio->stripe_cache);\n\tINIT_LIST_HEAD(&rbio->hash_list);\n\trbio->bbio = bbio;\n\trbio->fs_info = root->fs_info;\n\trbio->stripe_len = stripe_len;\n\trbio->nr_pages = num_pages;\n\trbio->real_stripes = real_stripes;\n\trbio->stripe_npages = stripe_npages;\n\trbio->faila = -1;\n\trbio->failb = -1;\n\tatomic_set(&rbio->refs, 1);\n\tatomic_set(&rbio->error, 0);\n\tatomic_set(&rbio->stripes_pending, 0);\n\n\t/*\n\t * the stripe_pages and bio_pages array point to the extra\n\t * memory we allocated past the end of the rbio\n\t */\n\tp = rbio + 1;\n\trbio->stripe_pages = p;\n\trbio->bio_pages = p + sizeof(struct page *) * num_pages;\n\trbio->dbitmap = p + sizeof(struct page *) * num_pages * 2;\n\n\tif (bbio->map_type & BTRFS_BLOCK_GROUP_RAID5)\n\t\tnr_data = real_stripes - 1;\n\telse if (bbio->map_type & BTRFS_BLOCK_GROUP_RAID6)\n\t\tnr_data = real_stripes - 2;\n\telse\n\t\tBUG();\n\n\trbio->nr_data = nr_data;\n\treturn rbio;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic struct btrfs_raid_bio *alloc_rbio(struct btrfs_root *root,\n\t\t\t  struct btrfs_bio *bbio, u64 stripe_len)\n{\n\tstruct btrfs_raid_bio *rbio;\n\tint nr_data = 0;\n\tint real_stripes = bbio->num_stripes - bbio->num_tgtdevs;\n\tint num_pages = rbio_nr_pages(stripe_len, real_stripes);\n\tint stripe_npages = DIV_ROUND_UP(stripe_len, PAGE_SIZE);\n\tvoid *p;\n\n\trbio = kzalloc(sizeof(*rbio) + num_pages * sizeof(struct page *) * 2 +\n\t\t       DIV_ROUND_UP(stripe_npages, BITS_PER_LONG / 8),\n\t\t\tGFP_NOFS);\n\tif (!rbio)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbio_list_init(&rbio->bio_list);\n\tINIT_LIST_HEAD(&rbio->plug_list);\n\tspin_lock_init(&rbio->bio_list_lock);\n\tINIT_LIST_HEAD(&rbio->stripe_cache);\n\tINIT_LIST_HEAD(&rbio->hash_list);\n\trbio->bbio = bbio;\n\trbio->fs_info = root->fs_info;\n\trbio->stripe_len = stripe_len;\n\trbio->nr_pages = num_pages;\n\trbio->real_stripes = real_stripes;\n\trbio->stripe_npages = stripe_npages;\n\trbio->faila = -1;\n\trbio->failb = -1;\n\tatomic_set(&rbio->refs, 1);\n\tatomic_set(&rbio->error, 0);\n\tatomic_set(&rbio->stripes_pending, 0);\n\n\t/*\n\t * the stripe_pages and bio_pages array point to the extra\n\t * memory we allocated past the end of the rbio\n\t */\n\tp = rbio + 1;\n\trbio->stripe_pages = p;\n\trbio->bio_pages = p + sizeof(struct page *) * num_pages;\n\trbio->dbitmap = p + sizeof(struct page *) * num_pages * 2;\n\n\tif (bbio->map_type & BTRFS_BLOCK_GROUP_RAID5)\n\t\tnr_data = real_stripes - 1;\n\telse if (bbio->map_type & BTRFS_BLOCK_GROUP_RAID6)\n\t\tnr_data = real_stripes - 2;\n\telse\n\t\tBUG();\n\n\trbio->nr_data = nr_data;\n\treturn rbio;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstruct btrfs_raid_bio *\nraid56_parity_alloc_scrub_rbio(struct btrfs_root *root, struct bio *bio,\n\t\t\t       struct btrfs_bio *bbio, u64 stripe_len,\n\t\t\t       struct btrfs_device *scrub_dev,\n\t\t\t       unsigned long *dbitmap, int stripe_nsectors)\n{\n\tstruct btrfs_raid_bio *rbio;\n\tint i;\n\n\trbio = alloc_rbio(root, bbio, stripe_len);\n\tif (IS_ERR(rbio))\n\t\treturn NULL;\n\tbio_list_add(&rbio->bio_list, bio);\n\t/*\n\t * This is a special bio which is used to hold the completion handler\n\t * and make the scrub rbio is similar to the other types\n\t */\n\tASSERT(!bio->bi_iter.bi_size);\n\trbio->operation = BTRFS_RBIO_PARITY_SCRUB;\n\n\tfor (i = 0; i < rbio->real_stripes; i++) {\n\t\tif (bbio->stripes[i].dev == scrub_dev) {\n\t\t\trbio->scrubp = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Now we just support the sectorsize equals to page size */\n\tASSERT(root->sectorsize == PAGE_SIZE);\n\tASSERT(rbio->stripe_npages == stripe_nsectors);\n\tbitmap_copy(rbio->dbitmap, dbitmap, stripe_nsectors);\n\n\treturn rbio;\n}"
  },
  {
    "function_name": "read_rebuild_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "2192-2198",
    "snippet": "static void read_rebuild_work(struct btrfs_work *work)\n{\n\tstruct btrfs_raid_bio *rbio;\n\n\trbio = container_of(work, struct btrfs_raid_bio, work);\n\t__raid56_parity_recover(rbio);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void rmw_work(struct btrfs_work *work);",
      "static void read_rebuild_work(struct btrfs_work *work);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__raid56_parity_recover",
          "args": [
            "rbio"
          ],
          "line": 2197
        },
        "resolved": true,
        "details": {
          "function_name": "__raid56_parity_recover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "2026-2115",
          "snippet": "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio)\n{\n\tint bios_to_read = 0;\n\tstruct bio_list bio_list;\n\tint ret;\n\tint nr_pages = DIV_ROUND_UP(rbio->stripe_len, PAGE_CACHE_SIZE);\n\tint pagenr;\n\tint stripe;\n\tstruct bio *bio;\n\n\tbio_list_init(&bio_list);\n\n\tret = alloc_rbio_pages(rbio);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tatomic_set(&rbio->error, 0);\n\n\t/*\n\t * read everything that hasn't failed.  Thanks to the\n\t * stripe cache, it is possible that some or all of these\n\t * pages are going to be uptodate.\n\t */\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tif (rbio->faila == stripe || rbio->failb == stripe) {\n\t\t\tatomic_inc(&rbio->error);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (pagenr = 0; pagenr < nr_pages; pagenr++) {\n\t\t\tstruct page *p;\n\n\t\t\t/*\n\t\t\t * the rmw code may have already read this\n\t\t\t * page in\n\t\t\t */\n\t\t\tp = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\tif (PageUptodate(p))\n\t\t\t\tcontinue;\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list,\n\t\t\t\t       rbio_stripe_page(rbio, stripe, pagenr),\n\t\t\t\t       stripe, pagenr, rbio->stripe_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tbios_to_read = bio_list_size(&bio_list);\n\tif (!bios_to_read) {\n\t\t/*\n\t\t * we might have no bios to read just because the pages\n\t\t * were up to date, or we might have no bios to read because\n\t\t * the devices were gone.\n\t\t */\n\t\tif (atomic_read(&rbio->error) <= rbio->bbio->max_errors) {\n\t\t\t__raid_recover_end_io(rbio);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/*\n\t * the bbio may be freed once we submit the last bio.  Make sure\n\t * not to touch it after that\n\t */\n\tatomic_set(&rbio->stripes_pending, bios_to_read);\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid_recover_end_io;\n\n\t\tbtrfs_bio_wq_end_io(rbio->fs_info, bio,\n\t\t\t\t    BTRFS_WQ_ENDIO_RAID56);\n\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(READ, bio);\n\t}\nout:\n\treturn 0;\n\ncleanup:\n\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD)\n\t\trbio_orig_end_io(rbio, -EIO, 0);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio)\n{\n\tint bios_to_read = 0;\n\tstruct bio_list bio_list;\n\tint ret;\n\tint nr_pages = DIV_ROUND_UP(rbio->stripe_len, PAGE_CACHE_SIZE);\n\tint pagenr;\n\tint stripe;\n\tstruct bio *bio;\n\n\tbio_list_init(&bio_list);\n\n\tret = alloc_rbio_pages(rbio);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tatomic_set(&rbio->error, 0);\n\n\t/*\n\t * read everything that hasn't failed.  Thanks to the\n\t * stripe cache, it is possible that some or all of these\n\t * pages are going to be uptodate.\n\t */\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tif (rbio->faila == stripe || rbio->failb == stripe) {\n\t\t\tatomic_inc(&rbio->error);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (pagenr = 0; pagenr < nr_pages; pagenr++) {\n\t\t\tstruct page *p;\n\n\t\t\t/*\n\t\t\t * the rmw code may have already read this\n\t\t\t * page in\n\t\t\t */\n\t\t\tp = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\tif (PageUptodate(p))\n\t\t\t\tcontinue;\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list,\n\t\t\t\t       rbio_stripe_page(rbio, stripe, pagenr),\n\t\t\t\t       stripe, pagenr, rbio->stripe_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tbios_to_read = bio_list_size(&bio_list);\n\tif (!bios_to_read) {\n\t\t/*\n\t\t * we might have no bios to read just because the pages\n\t\t * were up to date, or we might have no bios to read because\n\t\t * the devices were gone.\n\t\t */\n\t\tif (atomic_read(&rbio->error) <= rbio->bbio->max_errors) {\n\t\t\t__raid_recover_end_io(rbio);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/*\n\t * the bbio may be freed once we submit the last bio.  Make sure\n\t * not to touch it after that\n\t */\n\tatomic_set(&rbio->stripes_pending, bios_to_read);\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid_recover_end_io;\n\n\t\tbtrfs_bio_wq_end_io(rbio->fs_info, bio,\n\t\t\t\t    BTRFS_WQ_ENDIO_RAID56);\n\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(READ, bio);\n\t}\nout:\n\treturn 0;\n\ncleanup:\n\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD)\n\t\trbio_orig_end_io(rbio, -EIO, 0);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structbtrfs_raid_bio",
            "work"
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void rmw_work(struct btrfs_work *work);\nstatic void read_rebuild_work(struct btrfs_work *work);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void read_rebuild_work(struct btrfs_work *work)\n{\n\tstruct btrfs_raid_bio *rbio;\n\n\trbio = container_of(work, struct btrfs_raid_bio, work);\n\t__raid56_parity_recover(rbio);\n}"
  },
  {
    "function_name": "rmw_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "2184-2190",
    "snippet": "static void rmw_work(struct btrfs_work *work)\n{\n\tstruct btrfs_raid_bio *rbio;\n\n\trbio = container_of(work, struct btrfs_raid_bio, work);\n\traid56_rmw_stripe(rbio);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void rmw_work(struct btrfs_work *work);",
      "static void read_rebuild_work(struct btrfs_work *work);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raid56_rmw_stripe",
          "args": [
            "rbio"
          ],
          "line": 2189
        },
        "resolved": true,
        "details": {
          "function_name": "raid56_rmw_stripe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1504-1595",
          "snippet": "static int raid56_rmw_stripe(struct btrfs_raid_bio *rbio)\n{\n\tint bios_to_read = 0;\n\tstruct bio_list bio_list;\n\tint ret;\n\tint nr_pages = DIV_ROUND_UP(rbio->stripe_len, PAGE_CACHE_SIZE);\n\tint pagenr;\n\tint stripe;\n\tstruct bio *bio;\n\n\tbio_list_init(&bio_list);\n\n\tret = alloc_rbio_pages(rbio);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tindex_rbio_pages(rbio);\n\n\tatomic_set(&rbio->error, 0);\n\t/*\n\t * build a list of bios to read all the missing parts of this\n\t * stripe\n\t */\n\tfor (stripe = 0; stripe < rbio->nr_data; stripe++) {\n\t\tfor (pagenr = 0; pagenr < nr_pages; pagenr++) {\n\t\t\tstruct page *page;\n\t\t\t/*\n\t\t\t * we want to find all the pages missing from\n\t\t\t * the rbio and read them from the disk.  If\n\t\t\t * page_in_rbio finds a page in the bio list\n\t\t\t * we don't need to read it off the stripe.\n\t\t\t */\n\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 1);\n\t\t\tif (page)\n\t\t\t\tcontinue;\n\n\t\t\tpage = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t/*\n\t\t\t * the bio cache may have handed us an uptodate\n\t\t\t * page.  If so, be happy and use it\n\t\t\t */\n\t\t\tif (PageUptodate(page))\n\t\t\t\tcontinue;\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list, page,\n\t\t\t\t       stripe, pagenr, rbio->stripe_len);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tbios_to_read = bio_list_size(&bio_list);\n\tif (!bios_to_read) {\n\t\t/*\n\t\t * this can happen if others have merged with\n\t\t * us, it means there is nothing left to read.\n\t\t * But if there are missing devices it may not be\n\t\t * safe to do the full stripe write yet.\n\t\t */\n\t\tgoto finish;\n\t}\n\n\t/*\n\t * the bbio may be freed once we submit the last bio.  Make sure\n\t * not to touch it after that\n\t */\n\tatomic_set(&rbio->stripes_pending, bios_to_read);\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid_rmw_end_io;\n\n\t\tbtrfs_bio_wq_end_io(rbio->fs_info, bio,\n\t\t\t\t    BTRFS_WQ_ENDIO_RAID56);\n\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(READ, bio);\n\t}\n\t/* the actual write will happen once the reads are done */\n\treturn 0;\n\ncleanup:\n\trbio_orig_end_io(rbio, -EIO, 0);\n\treturn -EIO;\n\nfinish:\n\tvalidate_rbio_for_rmw(rbio);\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int raid56_rmw_stripe(struct btrfs_raid_bio *rbio)\n{\n\tint bios_to_read = 0;\n\tstruct bio_list bio_list;\n\tint ret;\n\tint nr_pages = DIV_ROUND_UP(rbio->stripe_len, PAGE_CACHE_SIZE);\n\tint pagenr;\n\tint stripe;\n\tstruct bio *bio;\n\n\tbio_list_init(&bio_list);\n\n\tret = alloc_rbio_pages(rbio);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tindex_rbio_pages(rbio);\n\n\tatomic_set(&rbio->error, 0);\n\t/*\n\t * build a list of bios to read all the missing parts of this\n\t * stripe\n\t */\n\tfor (stripe = 0; stripe < rbio->nr_data; stripe++) {\n\t\tfor (pagenr = 0; pagenr < nr_pages; pagenr++) {\n\t\t\tstruct page *page;\n\t\t\t/*\n\t\t\t * we want to find all the pages missing from\n\t\t\t * the rbio and read them from the disk.  If\n\t\t\t * page_in_rbio finds a page in the bio list\n\t\t\t * we don't need to read it off the stripe.\n\t\t\t */\n\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 1);\n\t\t\tif (page)\n\t\t\t\tcontinue;\n\n\t\t\tpage = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t/*\n\t\t\t * the bio cache may have handed us an uptodate\n\t\t\t * page.  If so, be happy and use it\n\t\t\t */\n\t\t\tif (PageUptodate(page))\n\t\t\t\tcontinue;\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list, page,\n\t\t\t\t       stripe, pagenr, rbio->stripe_len);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tbios_to_read = bio_list_size(&bio_list);\n\tif (!bios_to_read) {\n\t\t/*\n\t\t * this can happen if others have merged with\n\t\t * us, it means there is nothing left to read.\n\t\t * But if there are missing devices it may not be\n\t\t * safe to do the full stripe write yet.\n\t\t */\n\t\tgoto finish;\n\t}\n\n\t/*\n\t * the bbio may be freed once we submit the last bio.  Make sure\n\t * not to touch it after that\n\t */\n\tatomic_set(&rbio->stripes_pending, bios_to_read);\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid_rmw_end_io;\n\n\t\tbtrfs_bio_wq_end_io(rbio->fs_info, bio,\n\t\t\t\t    BTRFS_WQ_ENDIO_RAID56);\n\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(READ, bio);\n\t}\n\t/* the actual write will happen once the reads are done */\n\treturn 0;\n\ncleanup:\n\trbio_orig_end_io(rbio, -EIO, 0);\n\treturn -EIO;\n\nfinish:\n\tvalidate_rbio_for_rmw(rbio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structbtrfs_raid_bio",
            "work"
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void rmw_work(struct btrfs_work *work);\nstatic void read_rebuild_work(struct btrfs_work *work);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void rmw_work(struct btrfs_work *work)\n{\n\tstruct btrfs_raid_bio *rbio;\n\n\trbio = container_of(work, struct btrfs_raid_bio, work);\n\traid56_rmw_stripe(rbio);\n}"
  },
  {
    "function_name": "raid56_parity_recover",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "2123-2182",
    "snippet": "int raid56_parity_recover(struct btrfs_root *root, struct bio *bio,\n\t\t\t  struct btrfs_bio *bbio, u64 stripe_len,\n\t\t\t  int mirror_num, int generic_io)\n{\n\tstruct btrfs_raid_bio *rbio;\n\tint ret;\n\n\trbio = alloc_rbio(root, bbio, stripe_len);\n\tif (IS_ERR(rbio)) {\n\t\tif (generic_io)\n\t\t\tbtrfs_put_bbio(bbio);\n\t\treturn PTR_ERR(rbio);\n\t}\n\n\trbio->operation = BTRFS_RBIO_READ_REBUILD;\n\tbio_list_add(&rbio->bio_list, bio);\n\trbio->bio_list_bytes = bio->bi_iter.bi_size;\n\n\trbio->faila = find_logical_bio_stripe(rbio, bio);\n\tif (rbio->faila == -1) {\n\t\tBUG();\n\t\tif (generic_io)\n\t\t\tbtrfs_put_bbio(bbio);\n\t\tkfree(rbio);\n\t\treturn -EIO;\n\t}\n\n\tif (generic_io) {\n\t\tbtrfs_bio_counter_inc_noblocked(root->fs_info);\n\t\trbio->generic_bio_cnt = 1;\n\t} else {\n\t\tbtrfs_get_bbio(bbio);\n\t}\n\n\t/*\n\t * reconstruct from the q stripe if they are\n\t * asking for mirror 3\n\t */\n\tif (mirror_num == 3)\n\t\trbio->failb = rbio->real_stripes - 2;\n\n\tret = lock_stripe_add(rbio);\n\n\t/*\n\t * __raid56_parity_recover will end the bio with\n\t * any errors it hits.  We don't want to return\n\t * its error value up the stack because our caller\n\t * will end up calling bio_endio with any nonzero\n\t * return\n\t */\n\tif (ret == 0)\n\t\t__raid56_parity_recover(rbio);\n\t/*\n\t * our rbio has been added to the list of\n\t * rbios that will be handled after the\n\t * currently lock owner is done\n\t */\n\treturn 0;\n\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__raid56_parity_recover",
          "args": [
            "rbio"
          ],
          "line": 2174
        },
        "resolved": true,
        "details": {
          "function_name": "__raid56_parity_recover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "2026-2115",
          "snippet": "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio)\n{\n\tint bios_to_read = 0;\n\tstruct bio_list bio_list;\n\tint ret;\n\tint nr_pages = DIV_ROUND_UP(rbio->stripe_len, PAGE_CACHE_SIZE);\n\tint pagenr;\n\tint stripe;\n\tstruct bio *bio;\n\n\tbio_list_init(&bio_list);\n\n\tret = alloc_rbio_pages(rbio);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tatomic_set(&rbio->error, 0);\n\n\t/*\n\t * read everything that hasn't failed.  Thanks to the\n\t * stripe cache, it is possible that some or all of these\n\t * pages are going to be uptodate.\n\t */\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tif (rbio->faila == stripe || rbio->failb == stripe) {\n\t\t\tatomic_inc(&rbio->error);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (pagenr = 0; pagenr < nr_pages; pagenr++) {\n\t\t\tstruct page *p;\n\n\t\t\t/*\n\t\t\t * the rmw code may have already read this\n\t\t\t * page in\n\t\t\t */\n\t\t\tp = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\tif (PageUptodate(p))\n\t\t\t\tcontinue;\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list,\n\t\t\t\t       rbio_stripe_page(rbio, stripe, pagenr),\n\t\t\t\t       stripe, pagenr, rbio->stripe_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tbios_to_read = bio_list_size(&bio_list);\n\tif (!bios_to_read) {\n\t\t/*\n\t\t * we might have no bios to read just because the pages\n\t\t * were up to date, or we might have no bios to read because\n\t\t * the devices were gone.\n\t\t */\n\t\tif (atomic_read(&rbio->error) <= rbio->bbio->max_errors) {\n\t\t\t__raid_recover_end_io(rbio);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/*\n\t * the bbio may be freed once we submit the last bio.  Make sure\n\t * not to touch it after that\n\t */\n\tatomic_set(&rbio->stripes_pending, bios_to_read);\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid_recover_end_io;\n\n\t\tbtrfs_bio_wq_end_io(rbio->fs_info, bio,\n\t\t\t\t    BTRFS_WQ_ENDIO_RAID56);\n\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(READ, bio);\n\t}\nout:\n\treturn 0;\n\ncleanup:\n\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD)\n\t\trbio_orig_end_io(rbio, -EIO, 0);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio)\n{\n\tint bios_to_read = 0;\n\tstruct bio_list bio_list;\n\tint ret;\n\tint nr_pages = DIV_ROUND_UP(rbio->stripe_len, PAGE_CACHE_SIZE);\n\tint pagenr;\n\tint stripe;\n\tstruct bio *bio;\n\n\tbio_list_init(&bio_list);\n\n\tret = alloc_rbio_pages(rbio);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tatomic_set(&rbio->error, 0);\n\n\t/*\n\t * read everything that hasn't failed.  Thanks to the\n\t * stripe cache, it is possible that some or all of these\n\t * pages are going to be uptodate.\n\t */\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tif (rbio->faila == stripe || rbio->failb == stripe) {\n\t\t\tatomic_inc(&rbio->error);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (pagenr = 0; pagenr < nr_pages; pagenr++) {\n\t\t\tstruct page *p;\n\n\t\t\t/*\n\t\t\t * the rmw code may have already read this\n\t\t\t * page in\n\t\t\t */\n\t\t\tp = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\tif (PageUptodate(p))\n\t\t\t\tcontinue;\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list,\n\t\t\t\t       rbio_stripe_page(rbio, stripe, pagenr),\n\t\t\t\t       stripe, pagenr, rbio->stripe_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tbios_to_read = bio_list_size(&bio_list);\n\tif (!bios_to_read) {\n\t\t/*\n\t\t * we might have no bios to read just because the pages\n\t\t * were up to date, or we might have no bios to read because\n\t\t * the devices were gone.\n\t\t */\n\t\tif (atomic_read(&rbio->error) <= rbio->bbio->max_errors) {\n\t\t\t__raid_recover_end_io(rbio);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/*\n\t * the bbio may be freed once we submit the last bio.  Make sure\n\t * not to touch it after that\n\t */\n\tatomic_set(&rbio->stripes_pending, bios_to_read);\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid_recover_end_io;\n\n\t\tbtrfs_bio_wq_end_io(rbio->fs_info, bio,\n\t\t\t\t    BTRFS_WQ_ENDIO_RAID56);\n\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(READ, bio);\n\t}\nout:\n\treturn 0;\n\ncleanup:\n\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD)\n\t\trbio_orig_end_io(rbio, -EIO, 0);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_stripe_add",
          "args": [
            "rbio"
          ],
          "line": 2164
        },
        "resolved": true,
        "details": {
          "function_name": "lock_stripe_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "660-743",
          "snippet": "static noinline int lock_stripe_add(struct btrfs_raid_bio *rbio)\n{\n\tint bucket = rbio_bucket(rbio);\n\tstruct btrfs_stripe_hash *h = rbio->fs_info->stripe_hash_table->table + bucket;\n\tstruct btrfs_raid_bio *cur;\n\tstruct btrfs_raid_bio *pending;\n\tunsigned long flags;\n\tDEFINE_WAIT(wait);\n\tstruct btrfs_raid_bio *freeit = NULL;\n\tstruct btrfs_raid_bio *cache_drop = NULL;\n\tint ret = 0;\n\tint walk = 0;\n\n\tspin_lock_irqsave(&h->lock, flags);\n\tlist_for_each_entry(cur, &h->hash_list, hash_list) {\n\t\twalk++;\n\t\tif (cur->bbio->raid_map[0] == rbio->bbio->raid_map[0]) {\n\t\t\tspin_lock(&cur->bio_list_lock);\n\n\t\t\t/* can we steal this cached rbio's pages? */\n\t\t\tif (bio_list_empty(&cur->bio_list) &&\n\t\t\t    list_empty(&cur->plug_list) &&\n\t\t\t    test_bit(RBIO_CACHE_BIT, &cur->flags) &&\n\t\t\t    !test_bit(RBIO_RMW_LOCKED_BIT, &cur->flags)) {\n\t\t\t\tlist_del_init(&cur->hash_list);\n\t\t\t\tatomic_dec(&cur->refs);\n\n\t\t\t\tsteal_rbio(cur, rbio);\n\t\t\t\tcache_drop = cur;\n\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\n\t\t\t\tgoto lockit;\n\t\t\t}\n\n\t\t\t/* can we merge into the lock owner? */\n\t\t\tif (rbio_can_merge(cur, rbio)) {\n\t\t\t\tmerge_rbio(cur, rbio);\n\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\t\tfreeit = rbio;\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\n\t\t\t/*\n\t\t\t * we couldn't merge with the running\n\t\t\t * rbio, see if we can merge with the\n\t\t\t * pending ones.  We don't have to\n\t\t\t * check for rmw_locked because there\n\t\t\t * is no way they are inside finish_rmw\n\t\t\t * right now\n\t\t\t */\n\t\t\tlist_for_each_entry(pending, &cur->plug_list,\n\t\t\t\t\t    plug_list) {\n\t\t\t\tif (rbio_can_merge(pending, rbio)) {\n\t\t\t\t\tmerge_rbio(pending, rbio);\n\t\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\t\t\tfreeit = rbio;\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* no merging, put us on the tail of the plug list,\n\t\t\t * our rbio will be started with the currently\n\t\t\t * running rbio unlocks\n\t\t\t */\n\t\t\tlist_add_tail(&rbio->plug_list, &cur->plug_list);\n\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\nlockit:\n\tatomic_inc(&rbio->refs);\n\tlist_add(&rbio->hash_list, &h->hash_list);\nout:\n\tspin_unlock_irqrestore(&h->lock, flags);\n\tif (cache_drop)\n\t\tremove_rbio_from_cache(cache_drop);\n\tif (freeit)\n\t\t__free_raid_bio(freeit);\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RBIO_CACHE_BIT\t\t2",
            "#define RBIO_RMW_LOCKED_BIT\t1"
          ],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_BIT\t\t2\n#define RBIO_RMW_LOCKED_BIT\t1\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic noinline int lock_stripe_add(struct btrfs_raid_bio *rbio)\n{\n\tint bucket = rbio_bucket(rbio);\n\tstruct btrfs_stripe_hash *h = rbio->fs_info->stripe_hash_table->table + bucket;\n\tstruct btrfs_raid_bio *cur;\n\tstruct btrfs_raid_bio *pending;\n\tunsigned long flags;\n\tDEFINE_WAIT(wait);\n\tstruct btrfs_raid_bio *freeit = NULL;\n\tstruct btrfs_raid_bio *cache_drop = NULL;\n\tint ret = 0;\n\tint walk = 0;\n\n\tspin_lock_irqsave(&h->lock, flags);\n\tlist_for_each_entry(cur, &h->hash_list, hash_list) {\n\t\twalk++;\n\t\tif (cur->bbio->raid_map[0] == rbio->bbio->raid_map[0]) {\n\t\t\tspin_lock(&cur->bio_list_lock);\n\n\t\t\t/* can we steal this cached rbio's pages? */\n\t\t\tif (bio_list_empty(&cur->bio_list) &&\n\t\t\t    list_empty(&cur->plug_list) &&\n\t\t\t    test_bit(RBIO_CACHE_BIT, &cur->flags) &&\n\t\t\t    !test_bit(RBIO_RMW_LOCKED_BIT, &cur->flags)) {\n\t\t\t\tlist_del_init(&cur->hash_list);\n\t\t\t\tatomic_dec(&cur->refs);\n\n\t\t\t\tsteal_rbio(cur, rbio);\n\t\t\t\tcache_drop = cur;\n\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\n\t\t\t\tgoto lockit;\n\t\t\t}\n\n\t\t\t/* can we merge into the lock owner? */\n\t\t\tif (rbio_can_merge(cur, rbio)) {\n\t\t\t\tmerge_rbio(cur, rbio);\n\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\t\tfreeit = rbio;\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\n\t\t\t/*\n\t\t\t * we couldn't merge with the running\n\t\t\t * rbio, see if we can merge with the\n\t\t\t * pending ones.  We don't have to\n\t\t\t * check for rmw_locked because there\n\t\t\t * is no way they are inside finish_rmw\n\t\t\t * right now\n\t\t\t */\n\t\t\tlist_for_each_entry(pending, &cur->plug_list,\n\t\t\t\t\t    plug_list) {\n\t\t\t\tif (rbio_can_merge(pending, rbio)) {\n\t\t\t\t\tmerge_rbio(pending, rbio);\n\t\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\t\t\tfreeit = rbio;\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* no merging, put us on the tail of the plug list,\n\t\t\t * our rbio will be started with the currently\n\t\t\t * running rbio unlocks\n\t\t\t */\n\t\t\tlist_add_tail(&rbio->plug_list, &cur->plug_list);\n\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\nlockit:\n\tatomic_inc(&rbio->refs);\n\tlist_add(&rbio->hash_list, &h->hash_list);\nout:\n\tspin_unlock_irqrestore(&h->lock, flags);\n\tif (cache_drop)\n\t\tremove_rbio_from_cache(cache_drop);\n\tif (freeit)\n\t\t__free_raid_bio(freeit);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_get_bbio",
          "args": [
            "bbio"
          ],
          "line": 2154
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_bbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4927-4931",
          "snippet": "void btrfs_get_bbio(struct btrfs_bio *bbio)\n{\n\tWARN_ON(!atomic_read(&bbio->refs));\n\tatomic_inc(&bbio->refs);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_get_bbio(struct btrfs_bio *bbio)\n{\n\tWARN_ON(!atomic_read(&bbio->refs));\n\tatomic_inc(&bbio->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_bio_counter_inc_noblocked",
          "args": [
            "root->fs_info"
          ],
          "line": 2151
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bio_counter_inc_noblocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "911-914",
          "snippet": "void btrfs_bio_counter_inc_noblocked(struct btrfs_fs_info *fs_info)\n{\n\tpercpu_counter_inc(&fs_info->bio_counter);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
            "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nvoid btrfs_bio_counter_inc_noblocked(struct btrfs_fs_info *fs_info)\n{\n\tpercpu_counter_inc(&fs_info->bio_counter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rbio"
          ],
          "line": 2146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_put_bbio",
          "args": [
            "bbio"
          ],
          "line": 2145
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_bbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4933-4939",
          "snippet": "void btrfs_put_bbio(struct btrfs_bio *bbio)\n{\n\tif (!bbio)\n\t\treturn;\n\tif (atomic_dec_and_test(&bbio->refs))\n\t\tkfree(bbio);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_put_bbio(struct btrfs_bio *bbio)\n{\n\tif (!bbio)\n\t\treturn;\n\tif (atomic_dec_and_test(&bbio->refs))\n\t\tkfree(bbio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_logical_bio_stripe",
          "args": [
            "rbio",
            "bio"
          ],
          "line": 2141
        },
        "resolved": true,
        "details": {
          "function_name": "find_logical_bio_stripe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1363-1380",
          "snippet": "static int find_logical_bio_stripe(struct btrfs_raid_bio *rbio,\n\t\t\t\t   struct bio *bio)\n{\n\tu64 logical = bio->bi_iter.bi_sector;\n\tu64 stripe_start;\n\tint i;\n\n\tlogical <<= 9;\n\n\tfor (i = 0; i < rbio->nr_data; i++) {\n\t\tstripe_start = rbio->bbio->raid_map[i];\n\t\tif (logical >= stripe_start &&\n\t\t    logical < stripe_start + rbio->stripe_len) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int find_logical_bio_stripe(struct btrfs_raid_bio *rbio,\n\t\t\t\t   struct bio *bio)\n{\n\tu64 logical = bio->bi_iter.bi_sector;\n\tu64 stripe_start;\n\tint i;\n\n\tlogical <<= 9;\n\n\tfor (i = 0; i < rbio->nr_data; i++) {\n\t\tstripe_start = rbio->bbio->raid_map[i];\n\t\tif (logical >= stripe_start &&\n\t\t    logical < stripe_start + rbio->stripe_len) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_list_add",
          "args": [
            "&rbio->bio_list",
            "bio"
          ],
          "line": 2138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rbio"
          ],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rbio"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_rbio",
          "args": [
            "root",
            "bbio",
            "stripe_len"
          ],
          "line": 2130
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_rbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "955-1006",
          "snippet": "static struct btrfs_raid_bio *alloc_rbio(struct btrfs_root *root,\n\t\t\t  struct btrfs_bio *bbio, u64 stripe_len)\n{\n\tstruct btrfs_raid_bio *rbio;\n\tint nr_data = 0;\n\tint real_stripes = bbio->num_stripes - bbio->num_tgtdevs;\n\tint num_pages = rbio_nr_pages(stripe_len, real_stripes);\n\tint stripe_npages = DIV_ROUND_UP(stripe_len, PAGE_SIZE);\n\tvoid *p;\n\n\trbio = kzalloc(sizeof(*rbio) + num_pages * sizeof(struct page *) * 2 +\n\t\t       DIV_ROUND_UP(stripe_npages, BITS_PER_LONG / 8),\n\t\t\tGFP_NOFS);\n\tif (!rbio)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbio_list_init(&rbio->bio_list);\n\tINIT_LIST_HEAD(&rbio->plug_list);\n\tspin_lock_init(&rbio->bio_list_lock);\n\tINIT_LIST_HEAD(&rbio->stripe_cache);\n\tINIT_LIST_HEAD(&rbio->hash_list);\n\trbio->bbio = bbio;\n\trbio->fs_info = root->fs_info;\n\trbio->stripe_len = stripe_len;\n\trbio->nr_pages = num_pages;\n\trbio->real_stripes = real_stripes;\n\trbio->stripe_npages = stripe_npages;\n\trbio->faila = -1;\n\trbio->failb = -1;\n\tatomic_set(&rbio->refs, 1);\n\tatomic_set(&rbio->error, 0);\n\tatomic_set(&rbio->stripes_pending, 0);\n\n\t/*\n\t * the stripe_pages and bio_pages array point to the extra\n\t * memory we allocated past the end of the rbio\n\t */\n\tp = rbio + 1;\n\trbio->stripe_pages = p;\n\trbio->bio_pages = p + sizeof(struct page *) * num_pages;\n\trbio->dbitmap = p + sizeof(struct page *) * num_pages * 2;\n\n\tif (bbio->map_type & BTRFS_BLOCK_GROUP_RAID5)\n\t\tnr_data = real_stripes - 1;\n\telse if (bbio->map_type & BTRFS_BLOCK_GROUP_RAID6)\n\t\tnr_data = real_stripes - 2;\n\telse\n\t\tBUG();\n\n\trbio->nr_data = nr_data;\n\treturn rbio;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic struct btrfs_raid_bio *alloc_rbio(struct btrfs_root *root,\n\t\t\t  struct btrfs_bio *bbio, u64 stripe_len)\n{\n\tstruct btrfs_raid_bio *rbio;\n\tint nr_data = 0;\n\tint real_stripes = bbio->num_stripes - bbio->num_tgtdevs;\n\tint num_pages = rbio_nr_pages(stripe_len, real_stripes);\n\tint stripe_npages = DIV_ROUND_UP(stripe_len, PAGE_SIZE);\n\tvoid *p;\n\n\trbio = kzalloc(sizeof(*rbio) + num_pages * sizeof(struct page *) * 2 +\n\t\t       DIV_ROUND_UP(stripe_npages, BITS_PER_LONG / 8),\n\t\t\tGFP_NOFS);\n\tif (!rbio)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbio_list_init(&rbio->bio_list);\n\tINIT_LIST_HEAD(&rbio->plug_list);\n\tspin_lock_init(&rbio->bio_list_lock);\n\tINIT_LIST_HEAD(&rbio->stripe_cache);\n\tINIT_LIST_HEAD(&rbio->hash_list);\n\trbio->bbio = bbio;\n\trbio->fs_info = root->fs_info;\n\trbio->stripe_len = stripe_len;\n\trbio->nr_pages = num_pages;\n\trbio->real_stripes = real_stripes;\n\trbio->stripe_npages = stripe_npages;\n\trbio->faila = -1;\n\trbio->failb = -1;\n\tatomic_set(&rbio->refs, 1);\n\tatomic_set(&rbio->error, 0);\n\tatomic_set(&rbio->stripes_pending, 0);\n\n\t/*\n\t * the stripe_pages and bio_pages array point to the extra\n\t * memory we allocated past the end of the rbio\n\t */\n\tp = rbio + 1;\n\trbio->stripe_pages = p;\n\trbio->bio_pages = p + sizeof(struct page *) * num_pages;\n\trbio->dbitmap = p + sizeof(struct page *) * num_pages * 2;\n\n\tif (bbio->map_type & BTRFS_BLOCK_GROUP_RAID5)\n\t\tnr_data = real_stripes - 1;\n\telse if (bbio->map_type & BTRFS_BLOCK_GROUP_RAID6)\n\t\tnr_data = real_stripes - 2;\n\telse\n\t\tBUG();\n\n\trbio->nr_data = nr_data;\n\treturn rbio;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nint raid56_parity_recover(struct btrfs_root *root, struct bio *bio,\n\t\t\t  struct btrfs_bio *bbio, u64 stripe_len,\n\t\t\t  int mirror_num, int generic_io)\n{\n\tstruct btrfs_raid_bio *rbio;\n\tint ret;\n\n\trbio = alloc_rbio(root, bbio, stripe_len);\n\tif (IS_ERR(rbio)) {\n\t\tif (generic_io)\n\t\t\tbtrfs_put_bbio(bbio);\n\t\treturn PTR_ERR(rbio);\n\t}\n\n\trbio->operation = BTRFS_RBIO_READ_REBUILD;\n\tbio_list_add(&rbio->bio_list, bio);\n\trbio->bio_list_bytes = bio->bi_iter.bi_size;\n\n\trbio->faila = find_logical_bio_stripe(rbio, bio);\n\tif (rbio->faila == -1) {\n\t\tBUG();\n\t\tif (generic_io)\n\t\t\tbtrfs_put_bbio(bbio);\n\t\tkfree(rbio);\n\t\treturn -EIO;\n\t}\n\n\tif (generic_io) {\n\t\tbtrfs_bio_counter_inc_noblocked(root->fs_info);\n\t\trbio->generic_bio_cnt = 1;\n\t} else {\n\t\tbtrfs_get_bbio(bbio);\n\t}\n\n\t/*\n\t * reconstruct from the q stripe if they are\n\t * asking for mirror 3\n\t */\n\tif (mirror_num == 3)\n\t\trbio->failb = rbio->real_stripes - 2;\n\n\tret = lock_stripe_add(rbio);\n\n\t/*\n\t * __raid56_parity_recover will end the bio with\n\t * any errors it hits.  We don't want to return\n\t * its error value up the stack because our caller\n\t * will end up calling bio_endio with any nonzero\n\t * return\n\t */\n\tif (ret == 0)\n\t\t__raid56_parity_recover(rbio);\n\t/*\n\t * our rbio has been added to the list of\n\t * rbios that will be handled after the\n\t * currently lock owner is done\n\t */\n\treturn 0;\n\n}"
  },
  {
    "function_name": "__raid56_parity_recover",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "2026-2115",
    "snippet": "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio)\n{\n\tint bios_to_read = 0;\n\tstruct bio_list bio_list;\n\tint ret;\n\tint nr_pages = DIV_ROUND_UP(rbio->stripe_len, PAGE_CACHE_SIZE);\n\tint pagenr;\n\tint stripe;\n\tstruct bio *bio;\n\n\tbio_list_init(&bio_list);\n\n\tret = alloc_rbio_pages(rbio);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tatomic_set(&rbio->error, 0);\n\n\t/*\n\t * read everything that hasn't failed.  Thanks to the\n\t * stripe cache, it is possible that some or all of these\n\t * pages are going to be uptodate.\n\t */\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tif (rbio->faila == stripe || rbio->failb == stripe) {\n\t\t\tatomic_inc(&rbio->error);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (pagenr = 0; pagenr < nr_pages; pagenr++) {\n\t\t\tstruct page *p;\n\n\t\t\t/*\n\t\t\t * the rmw code may have already read this\n\t\t\t * page in\n\t\t\t */\n\t\t\tp = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\tif (PageUptodate(p))\n\t\t\t\tcontinue;\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list,\n\t\t\t\t       rbio_stripe_page(rbio, stripe, pagenr),\n\t\t\t\t       stripe, pagenr, rbio->stripe_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tbios_to_read = bio_list_size(&bio_list);\n\tif (!bios_to_read) {\n\t\t/*\n\t\t * we might have no bios to read just because the pages\n\t\t * were up to date, or we might have no bios to read because\n\t\t * the devices were gone.\n\t\t */\n\t\tif (atomic_read(&rbio->error) <= rbio->bbio->max_errors) {\n\t\t\t__raid_recover_end_io(rbio);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/*\n\t * the bbio may be freed once we submit the last bio.  Make sure\n\t * not to touch it after that\n\t */\n\tatomic_set(&rbio->stripes_pending, bios_to_read);\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid_recover_end_io;\n\n\t\tbtrfs_bio_wq_end_io(rbio->fs_info, bio,\n\t\t\t\t    BTRFS_WQ_ENDIO_RAID56);\n\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(READ, bio);\n\t}\nout:\n\treturn 0;\n\ncleanup:\n\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD)\n\t\trbio_orig_end_io(rbio, -EIO, 0);\n\treturn -EIO;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
      "static int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rbio_orig_end_io",
          "args": [
            "rbio",
            "-EIO",
            "0"
          ],
          "line": 2113
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_orig_end_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "861-879",
          "snippet": "static void rbio_orig_end_io(struct btrfs_raid_bio *rbio, int err, int uptodate)\n{\n\tstruct bio *cur = bio_list_get(&rbio->bio_list);\n\tstruct bio *next;\n\n\tif (rbio->generic_bio_cnt)\n\t\tbtrfs_bio_counter_sub(rbio->fs_info, rbio->generic_bio_cnt);\n\n\tfree_raid_bio(rbio);\n\n\twhile (cur) {\n\t\tnext = cur->bi_next;\n\t\tcur->bi_next = NULL;\n\t\tif (uptodate)\n\t\t\tset_bit(BIO_UPTODATE, &cur->bi_flags);\n\t\tbio_endio(cur, err);\n\t\tcur = next;\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void rbio_orig_end_io(struct btrfs_raid_bio *rbio, int err, int uptodate)\n{\n\tstruct bio *cur = bio_list_get(&rbio->bio_list);\n\tstruct bio *next;\n\n\tif (rbio->generic_bio_cnt)\n\t\tbtrfs_bio_counter_sub(rbio->fs_info, rbio->generic_bio_cnt);\n\n\tfree_raid_bio(rbio);\n\n\twhile (cur) {\n\t\tnext = cur->bi_next;\n\t\tcur->bi_next = NULL;\n\t\tif (uptodate)\n\t\t\tset_bit(BIO_UPTODATE, &cur->bi_flags);\n\t\tbio_endio(cur, err);\n\t\tcur = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "READ",
            "bio"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_submit_bio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "3067-3071",
          "snippet": "int btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!test_bit(BIO_UPTODATE, &bio->bi_flags)"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BIO_UPTODATE",
            "&bio->bi_flags"
          ],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_bio_wq_end_io",
          "args": [
            "rbio->fs_info",
            "bio",
            "BTRFS_WQ_ENDIO_RAID56"
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bio_wq_end_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "756-775",
          "snippet": "int btrfs_bio_wq_end_io(struct btrfs_fs_info *info, struct bio *bio,\n\t\t\tenum btrfs_wq_endio_type metadata)\n{\n\tstruct btrfs_end_io_wq *end_io_wq;\n\n\tend_io_wq = kmem_cache_alloc(btrfs_end_io_wq_cache, GFP_NOFS);\n\tif (!end_io_wq)\n\t\treturn -ENOMEM;\n\n\tend_io_wq->private = bio->bi_private;\n\tend_io_wq->end_io = bio->bi_end_io;\n\tend_io_wq->info = info;\n\tend_io_wq->error = 0;\n\tend_io_wq->bio = bio;\n\tend_io_wq->metadata = metadata;\n\n\tbio->bi_private = end_io_wq;\n\tbio->bi_end_io = end_workqueue_bio;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_end_io_wq_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *btrfs_end_io_wq_cache;\n\nint btrfs_bio_wq_end_io(struct btrfs_fs_info *info, struct bio *bio,\n\t\t\tenum btrfs_wq_endio_type metadata)\n{\n\tstruct btrfs_end_io_wq *end_io_wq;\n\n\tend_io_wq = kmem_cache_alloc(btrfs_end_io_wq_cache, GFP_NOFS);\n\tif (!end_io_wq)\n\t\treturn -ENOMEM;\n\n\tend_io_wq->private = bio->bi_private;\n\tend_io_wq->end_io = bio->bi_end_io;\n\tend_io_wq->info = info;\n\tend_io_wq->error = 0;\n\tend_io_wq->bio = bio;\n\tend_io_wq->metadata = metadata;\n\n\tbio->bi_private = end_io_wq;\n\tbio->bi_end_io = end_workqueue_bio;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_list_pop",
          "args": [
            "&bio_list"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&rbio->stripes_pending",
            "bios_to_read"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__raid_recover_end_io",
          "args": [
            "rbio"
          ],
          "line": 2082
        },
        "resolved": true,
        "details": {
          "function_name": "__raid_recover_end_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1800-1989",
          "snippet": "static void __raid_recover_end_io(struct btrfs_raid_bio *rbio)\n{\n\tint pagenr, stripe;\n\tvoid **pointers;\n\tint faila = -1, failb = -1;\n\tint nr_pages = DIV_ROUND_UP(rbio->stripe_len, PAGE_CACHE_SIZE);\n\tstruct page *page;\n\tint err;\n\tint i;\n\n\tpointers = kzalloc(rbio->real_stripes * sizeof(void *),\n\t\t\t   GFP_NOFS);\n\tif (!pointers) {\n\t\terr = -ENOMEM;\n\t\tgoto cleanup_io;\n\t}\n\n\tfaila = rbio->faila;\n\tfailb = rbio->failb;\n\n\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD) {\n\t\tspin_lock_irq(&rbio->bio_list_lock);\n\t\tset_bit(RBIO_RMW_LOCKED_BIT, &rbio->flags);\n\t\tspin_unlock_irq(&rbio->bio_list_lock);\n\t}\n\n\tindex_rbio_pages(rbio);\n\n\tfor (pagenr = 0; pagenr < nr_pages; pagenr++) {\n\t\t/*\n\t\t * Now we just use bitmap to mark the horizontal stripes in\n\t\t * which we have data when doing parity scrub.\n\t\t */\n\t\tif (rbio->operation == BTRFS_RBIO_PARITY_SCRUB &&\n\t\t    !test_bit(pagenr, rbio->dbitmap))\n\t\t\tcontinue;\n\n\t\t/* setup our array of pointers with pages\n\t\t * from each stripe\n\t\t */\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\t\t/*\n\t\t\t * if we're rebuilding a read, we have to use\n\t\t\t * pages from the bio list\n\t\t\t */\n\t\t\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD &&\n\t\t\t    (stripe == faila || stripe == failb)) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\t} else {\n\t\t\t\tpage = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\t\t\tpointers[stripe] = kmap(page);\n\t\t}\n\n\t\t/* all raid6 handling here */\n\t\tif (rbio->bbio->map_type & BTRFS_BLOCK_GROUP_RAID6) {\n\t\t\t/*\n\t\t\t * single failure, rebuild from parity raid5\n\t\t\t * style\n\t\t\t */\n\t\t\tif (failb < 0) {\n\t\t\t\tif (faila == rbio->nr_data) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Just the P stripe has failed, without\n\t\t\t\t\t * a bad data or Q stripe.\n\t\t\t\t\t * TODO, we should redo the xor here.\n\t\t\t\t\t */\n\t\t\t\t\terr = -EIO;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * a single failure in raid6 is rebuilt\n\t\t\t\t * in the pstripe code below\n\t\t\t\t */\n\t\t\t\tgoto pstripe;\n\t\t\t}\n\n\t\t\t/* make sure our ps and qs are in order */\n\t\t\tif (faila > failb) {\n\t\t\t\tint tmp = failb;\n\t\t\t\tfailb = faila;\n\t\t\t\tfaila = tmp;\n\t\t\t}\n\n\t\t\t/* if the q stripe is failed, do a pstripe reconstruction\n\t\t\t * from the xors.\n\t\t\t * If both the q stripe and the P stripe are failed, we're\n\t\t\t * here due to a crc mismatch and we can't give them the\n\t\t\t * data they want\n\t\t\t */\n\t\t\tif (rbio->bbio->raid_map[failb] == RAID6_Q_STRIPE) {\n\t\t\t\tif (rbio->bbio->raid_map[faila] ==\n\t\t\t\t    RAID5_P_STRIPE) {\n\t\t\t\t\terr = -EIO;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * otherwise we have one bad data stripe and\n\t\t\t\t * a good P stripe.  raid5!\n\t\t\t\t */\n\t\t\t\tgoto pstripe;\n\t\t\t}\n\n\t\t\tif (rbio->bbio->raid_map[failb] == RAID5_P_STRIPE) {\n\t\t\t\traid6_datap_recov(rbio->real_stripes,\n\t\t\t\t\t\t  PAGE_SIZE, faila, pointers);\n\t\t\t} else {\n\t\t\t\traid6_2data_recov(rbio->real_stripes,\n\t\t\t\t\t\t  PAGE_SIZE, faila, failb,\n\t\t\t\t\t\t  pointers);\n\t\t\t}\n\t\t} else {\n\t\t\tvoid *p;\n\n\t\t\t/* rebuild from P stripe here (raid5 or raid6) */\n\t\t\tBUG_ON(failb != -1);\npstripe:\n\t\t\t/* Copy parity block into failed block to start with */\n\t\t\tmemcpy(pointers[faila],\n\t\t\t       pointers[rbio->nr_data],\n\t\t\t       PAGE_CACHE_SIZE);\n\n\t\t\t/* rearrange the pointer array */\n\t\t\tp = pointers[faila];\n\t\t\tfor (stripe = faila; stripe < rbio->nr_data - 1; stripe++)\n\t\t\t\tpointers[stripe] = pointers[stripe + 1];\n\t\t\tpointers[rbio->nr_data - 1] = p;\n\n\t\t\t/* xor in the rest */\n\t\t\trun_xor(pointers, rbio->nr_data - 1, PAGE_CACHE_SIZE);\n\t\t}\n\t\t/* if we're doing this rebuild as part of an rmw, go through\n\t\t * and set all of our private rbio pages in the\n\t\t * failed stripes as uptodate.  This way finish_rmw will\n\t\t * know they can be trusted.  If this was a read reconstruction,\n\t\t * other endio functions will fiddle the uptodate bits\n\t\t */\n\t\tif (rbio->operation == BTRFS_RBIO_WRITE) {\n\t\t\tfor (i = 0;  i < nr_pages; i++) {\n\t\t\t\tif (faila != -1) {\n\t\t\t\t\tpage = rbio_stripe_page(rbio, faila, i);\n\t\t\t\t\tSetPageUptodate(page);\n\t\t\t\t}\n\t\t\t\tif (failb != -1) {\n\t\t\t\t\tpage = rbio_stripe_page(rbio, failb, i);\n\t\t\t\t\tSetPageUptodate(page);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\t\t/*\n\t\t\t * if we're rebuilding a read, we have to use\n\t\t\t * pages from the bio list\n\t\t\t */\n\t\t\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD &&\n\t\t\t    (stripe == faila || stripe == failb)) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\t} else {\n\t\t\t\tpage = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\t\t\tkunmap(page);\n\t\t}\n\t}\n\n\terr = 0;\ncleanup:\n\tkfree(pointers);\n\ncleanup_io:\n\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD) {\n\t\tif (err == 0)\n\t\t\tcache_rbio_pages(rbio);\n\t\telse\n\t\t\tclear_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n\n\t\trbio_orig_end_io(rbio, err, err == 0);\n\t} else if (err == 0) {\n\t\trbio->faila = -1;\n\t\trbio->failb = -1;\n\n\t\tif (rbio->operation == BTRFS_RBIO_WRITE)\n\t\t\tfinish_rmw(rbio);\n\t\telse if (rbio->operation == BTRFS_RBIO_PARITY_SCRUB)\n\t\t\tfinish_parity_scrub(rbio, 0);\n\t\telse\n\t\t\tBUG();\n\t} else {\n\t\trbio_orig_end_io(rbio, err, 0);\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RBIO_CACHE_READY_BIT\t3",
            "#define RBIO_RMW_LOCKED_BIT\t1"
          ],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_READY_BIT\t3\n#define RBIO_RMW_LOCKED_BIT\t1\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void __raid_recover_end_io(struct btrfs_raid_bio *rbio)\n{\n\tint pagenr, stripe;\n\tvoid **pointers;\n\tint faila = -1, failb = -1;\n\tint nr_pages = DIV_ROUND_UP(rbio->stripe_len, PAGE_CACHE_SIZE);\n\tstruct page *page;\n\tint err;\n\tint i;\n\n\tpointers = kzalloc(rbio->real_stripes * sizeof(void *),\n\t\t\t   GFP_NOFS);\n\tif (!pointers) {\n\t\terr = -ENOMEM;\n\t\tgoto cleanup_io;\n\t}\n\n\tfaila = rbio->faila;\n\tfailb = rbio->failb;\n\n\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD) {\n\t\tspin_lock_irq(&rbio->bio_list_lock);\n\t\tset_bit(RBIO_RMW_LOCKED_BIT, &rbio->flags);\n\t\tspin_unlock_irq(&rbio->bio_list_lock);\n\t}\n\n\tindex_rbio_pages(rbio);\n\n\tfor (pagenr = 0; pagenr < nr_pages; pagenr++) {\n\t\t/*\n\t\t * Now we just use bitmap to mark the horizontal stripes in\n\t\t * which we have data when doing parity scrub.\n\t\t */\n\t\tif (rbio->operation == BTRFS_RBIO_PARITY_SCRUB &&\n\t\t    !test_bit(pagenr, rbio->dbitmap))\n\t\t\tcontinue;\n\n\t\t/* setup our array of pointers with pages\n\t\t * from each stripe\n\t\t */\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\t\t/*\n\t\t\t * if we're rebuilding a read, we have to use\n\t\t\t * pages from the bio list\n\t\t\t */\n\t\t\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD &&\n\t\t\t    (stripe == faila || stripe == failb)) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\t} else {\n\t\t\t\tpage = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\t\t\tpointers[stripe] = kmap(page);\n\t\t}\n\n\t\t/* all raid6 handling here */\n\t\tif (rbio->bbio->map_type & BTRFS_BLOCK_GROUP_RAID6) {\n\t\t\t/*\n\t\t\t * single failure, rebuild from parity raid5\n\t\t\t * style\n\t\t\t */\n\t\t\tif (failb < 0) {\n\t\t\t\tif (faila == rbio->nr_data) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Just the P stripe has failed, without\n\t\t\t\t\t * a bad data or Q stripe.\n\t\t\t\t\t * TODO, we should redo the xor here.\n\t\t\t\t\t */\n\t\t\t\t\terr = -EIO;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * a single failure in raid6 is rebuilt\n\t\t\t\t * in the pstripe code below\n\t\t\t\t */\n\t\t\t\tgoto pstripe;\n\t\t\t}\n\n\t\t\t/* make sure our ps and qs are in order */\n\t\t\tif (faila > failb) {\n\t\t\t\tint tmp = failb;\n\t\t\t\tfailb = faila;\n\t\t\t\tfaila = tmp;\n\t\t\t}\n\n\t\t\t/* if the q stripe is failed, do a pstripe reconstruction\n\t\t\t * from the xors.\n\t\t\t * If both the q stripe and the P stripe are failed, we're\n\t\t\t * here due to a crc mismatch and we can't give them the\n\t\t\t * data they want\n\t\t\t */\n\t\t\tif (rbio->bbio->raid_map[failb] == RAID6_Q_STRIPE) {\n\t\t\t\tif (rbio->bbio->raid_map[faila] ==\n\t\t\t\t    RAID5_P_STRIPE) {\n\t\t\t\t\terr = -EIO;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * otherwise we have one bad data stripe and\n\t\t\t\t * a good P stripe.  raid5!\n\t\t\t\t */\n\t\t\t\tgoto pstripe;\n\t\t\t}\n\n\t\t\tif (rbio->bbio->raid_map[failb] == RAID5_P_STRIPE) {\n\t\t\t\traid6_datap_recov(rbio->real_stripes,\n\t\t\t\t\t\t  PAGE_SIZE, faila, pointers);\n\t\t\t} else {\n\t\t\t\traid6_2data_recov(rbio->real_stripes,\n\t\t\t\t\t\t  PAGE_SIZE, faila, failb,\n\t\t\t\t\t\t  pointers);\n\t\t\t}\n\t\t} else {\n\t\t\tvoid *p;\n\n\t\t\t/* rebuild from P stripe here (raid5 or raid6) */\n\t\t\tBUG_ON(failb != -1);\npstripe:\n\t\t\t/* Copy parity block into failed block to start with */\n\t\t\tmemcpy(pointers[faila],\n\t\t\t       pointers[rbio->nr_data],\n\t\t\t       PAGE_CACHE_SIZE);\n\n\t\t\t/* rearrange the pointer array */\n\t\t\tp = pointers[faila];\n\t\t\tfor (stripe = faila; stripe < rbio->nr_data - 1; stripe++)\n\t\t\t\tpointers[stripe] = pointers[stripe + 1];\n\t\t\tpointers[rbio->nr_data - 1] = p;\n\n\t\t\t/* xor in the rest */\n\t\t\trun_xor(pointers, rbio->nr_data - 1, PAGE_CACHE_SIZE);\n\t\t}\n\t\t/* if we're doing this rebuild as part of an rmw, go through\n\t\t * and set all of our private rbio pages in the\n\t\t * failed stripes as uptodate.  This way finish_rmw will\n\t\t * know they can be trusted.  If this was a read reconstruction,\n\t\t * other endio functions will fiddle the uptodate bits\n\t\t */\n\t\tif (rbio->operation == BTRFS_RBIO_WRITE) {\n\t\t\tfor (i = 0;  i < nr_pages; i++) {\n\t\t\t\tif (faila != -1) {\n\t\t\t\t\tpage = rbio_stripe_page(rbio, faila, i);\n\t\t\t\t\tSetPageUptodate(page);\n\t\t\t\t}\n\t\t\t\tif (failb != -1) {\n\t\t\t\t\tpage = rbio_stripe_page(rbio, failb, i);\n\t\t\t\t\tSetPageUptodate(page);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\t\t/*\n\t\t\t * if we're rebuilding a read, we have to use\n\t\t\t * pages from the bio list\n\t\t\t */\n\t\t\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD &&\n\t\t\t    (stripe == faila || stripe == failb)) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\t} else {\n\t\t\t\tpage = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\t\t\tkunmap(page);\n\t\t}\n\t}\n\n\terr = 0;\ncleanup:\n\tkfree(pointers);\n\ncleanup_io:\n\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD) {\n\t\tif (err == 0)\n\t\t\tcache_rbio_pages(rbio);\n\t\telse\n\t\t\tclear_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n\n\t\trbio_orig_end_io(rbio, err, err == 0);\n\t} else if (err == 0) {\n\t\trbio->faila = -1;\n\t\trbio->failb = -1;\n\n\t\tif (rbio->operation == BTRFS_RBIO_WRITE)\n\t\t\tfinish_rmw(rbio);\n\t\telse if (rbio->operation == BTRFS_RBIO_PARITY_SCRUB)\n\t\t\tfinish_parity_scrub(rbio, 0);\n\t\telse\n\t\t\tBUG();\n\t} else {\n\t\trbio_orig_end_io(rbio, err, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rbio->error"
          ],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_list_size",
          "args": [
            "&bio_list"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rbio_add_io_page",
          "args": [
            "rbio",
            "&bio_list",
            "rbio_stripe_page(rbio, stripe, pagenr)",
            "stripe",
            "pagenr",
            "rbio->stripe_len"
          ],
          "line": 2066
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_add_io_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1050-1102",
          "snippet": "static int rbio_add_io_page(struct btrfs_raid_bio *rbio,\n\t\t\t    struct bio_list *bio_list,\n\t\t\t    struct page *page,\n\t\t\t    int stripe_nr,\n\t\t\t    unsigned long page_index,\n\t\t\t    unsigned long bio_max_len)\n{\n\tstruct bio *last = bio_list->tail;\n\tu64 last_end = 0;\n\tint ret;\n\tstruct bio *bio;\n\tstruct btrfs_bio_stripe *stripe;\n\tu64 disk_start;\n\n\tstripe = &rbio->bbio->stripes[stripe_nr];\n\tdisk_start = stripe->physical + (page_index << PAGE_CACHE_SHIFT);\n\n\t/* if the device is missing, just fail this stripe */\n\tif (!stripe->dev->bdev)\n\t\treturn fail_rbio_index(rbio, stripe_nr);\n\n\t/* see if we can add this page onto our existing bio */\n\tif (last) {\n\t\tlast_end = (u64)last->bi_iter.bi_sector << 9;\n\t\tlast_end += last->bi_iter.bi_size;\n\n\t\t/*\n\t\t * we can't merge these if they are from different\n\t\t * devices or if they are not contiguous\n\t\t */\n\t\tif (last_end == disk_start && stripe->dev->bdev &&\n\t\t    test_bit(BIO_UPTODATE, &last->bi_flags) &&\n\t\t    last->bi_bdev == stripe->dev->bdev) {\n\t\t\tret = bio_add_page(last, page, PAGE_CACHE_SIZE, 0);\n\t\t\tif (ret == PAGE_CACHE_SIZE)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* put a new bio on the list */\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, bio_max_len >> PAGE_SHIFT?:1);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\n\tbio->bi_iter.bi_size = 0;\n\tbio->bi_bdev = stripe->dev->bdev;\n\tbio->bi_iter.bi_sector = disk_start >> 9;\n\tset_bit(BIO_UPTODATE, &bio->bi_flags);\n\n\tbio_add_page(bio, page, PAGE_CACHE_SIZE, 0);\n\tbio_list_add(bio_list, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int rbio_add_io_page(struct btrfs_raid_bio *rbio,\n\t\t\t    struct bio_list *bio_list,\n\t\t\t    struct page *page,\n\t\t\t    int stripe_nr,\n\t\t\t    unsigned long page_index,\n\t\t\t    unsigned long bio_max_len)\n{\n\tstruct bio *last = bio_list->tail;\n\tu64 last_end = 0;\n\tint ret;\n\tstruct bio *bio;\n\tstruct btrfs_bio_stripe *stripe;\n\tu64 disk_start;\n\n\tstripe = &rbio->bbio->stripes[stripe_nr];\n\tdisk_start = stripe->physical + (page_index << PAGE_CACHE_SHIFT);\n\n\t/* if the device is missing, just fail this stripe */\n\tif (!stripe->dev->bdev)\n\t\treturn fail_rbio_index(rbio, stripe_nr);\n\n\t/* see if we can add this page onto our existing bio */\n\tif (last) {\n\t\tlast_end = (u64)last->bi_iter.bi_sector << 9;\n\t\tlast_end += last->bi_iter.bi_size;\n\n\t\t/*\n\t\t * we can't merge these if they are from different\n\t\t * devices or if they are not contiguous\n\t\t */\n\t\tif (last_end == disk_start && stripe->dev->bdev &&\n\t\t    test_bit(BIO_UPTODATE, &last->bi_flags) &&\n\t\t    last->bi_bdev == stripe->dev->bdev) {\n\t\t\tret = bio_add_page(last, page, PAGE_CACHE_SIZE, 0);\n\t\t\tif (ret == PAGE_CACHE_SIZE)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* put a new bio on the list */\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, bio_max_len >> PAGE_SHIFT?:1);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\n\tbio->bi_iter.bi_size = 0;\n\tbio->bi_bdev = stripe->dev->bdev;\n\tbio->bi_iter.bi_sector = disk_start >> 9;\n\tset_bit(BIO_UPTODATE, &bio->bi_flags);\n\n\tbio_add_page(bio, page, PAGE_CACHE_SIZE, 0);\n\tbio_list_add(bio_list, bio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rbio_stripe_page",
          "args": [
            "rbio",
            "stripe",
            "pagenr"
          ],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_stripe_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1125-1131",
          "snippet": "static struct page *rbio_stripe_page(struct btrfs_raid_bio *rbio, int stripe, int page)\n{\n\tint index;\n\tindex = stripe * (rbio->stripe_len >> PAGE_CACHE_SHIFT);\n\tindex += page;\n\treturn rbio->stripe_pages[index];\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic struct page *rbio_stripe_page(struct btrfs_raid_bio *rbio, int stripe, int page)\n{\n\tint index;\n\tindex = stripe * (rbio->stripe_len >> PAGE_CACHE_SHIFT);\n\tindex += page;\n\treturn rbio->stripe_pages[index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "p"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&rbio->error"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&rbio->error",
            "0"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_rbio_pages",
          "args": [
            "rbio"
          ],
          "line": 2038
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_rbio_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1009-1024",
          "snippet": "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\tstruct page *page;\n\n\tfor (i = 0; i < rbio->nr_pages; i++) {\n\t\tif (rbio->stripe_pages[i])\n\t\t\tcontinue;\n\t\tpage = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\trbio->stripe_pages[i] = page;\n\t\tClearPageUptodate(page);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\tstruct page *page;\n\n\tfor (i = 0; i < rbio->nr_pages; i++) {\n\t\tif (rbio->stripe_pages[i])\n\t\t\tcontinue;\n\t\tpage = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\trbio->stripe_pages[i] = page;\n\t\tClearPageUptodate(page);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_list_init",
          "args": [
            "&bio_list"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "rbio->stripe_len",
            "PAGE_CACHE_SIZE"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio)\n{\n\tint bios_to_read = 0;\n\tstruct bio_list bio_list;\n\tint ret;\n\tint nr_pages = DIV_ROUND_UP(rbio->stripe_len, PAGE_CACHE_SIZE);\n\tint pagenr;\n\tint stripe;\n\tstruct bio *bio;\n\n\tbio_list_init(&bio_list);\n\n\tret = alloc_rbio_pages(rbio);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tatomic_set(&rbio->error, 0);\n\n\t/*\n\t * read everything that hasn't failed.  Thanks to the\n\t * stripe cache, it is possible that some or all of these\n\t * pages are going to be uptodate.\n\t */\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tif (rbio->faila == stripe || rbio->failb == stripe) {\n\t\t\tatomic_inc(&rbio->error);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (pagenr = 0; pagenr < nr_pages; pagenr++) {\n\t\t\tstruct page *p;\n\n\t\t\t/*\n\t\t\t * the rmw code may have already read this\n\t\t\t * page in\n\t\t\t */\n\t\t\tp = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\tif (PageUptodate(p))\n\t\t\t\tcontinue;\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list,\n\t\t\t\t       rbio_stripe_page(rbio, stripe, pagenr),\n\t\t\t\t       stripe, pagenr, rbio->stripe_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tbios_to_read = bio_list_size(&bio_list);\n\tif (!bios_to_read) {\n\t\t/*\n\t\t * we might have no bios to read just because the pages\n\t\t * were up to date, or we might have no bios to read because\n\t\t * the devices were gone.\n\t\t */\n\t\tif (atomic_read(&rbio->error) <= rbio->bbio->max_errors) {\n\t\t\t__raid_recover_end_io(rbio);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/*\n\t * the bbio may be freed once we submit the last bio.  Make sure\n\t * not to touch it after that\n\t */\n\tatomic_set(&rbio->stripes_pending, bios_to_read);\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid_recover_end_io;\n\n\t\tbtrfs_bio_wq_end_io(rbio->fs_info, bio,\n\t\t\t\t    BTRFS_WQ_ENDIO_RAID56);\n\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(READ, bio);\n\t}\nout:\n\treturn 0;\n\ncleanup:\n\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD)\n\t\trbio_orig_end_io(rbio, -EIO, 0);\n\treturn -EIO;\n}"
  },
  {
    "function_name": "raid_recover_end_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "1995-2016",
    "snippet": "static void raid_recover_end_io(struct bio *bio, int err)\n{\n\tstruct btrfs_raid_bio *rbio = bio->bi_private;\n\n\t/*\n\t * we only read stripe pages off the disk, set them\n\t * up to date if there were no errors\n\t */\n\tif (err)\n\t\tfail_bio_stripe(rbio, bio);\n\telse\n\t\tset_bio_pages_uptodate(bio);\n\tbio_put(bio);\n\n\tif (!atomic_dec_and_test(&rbio->stripes_pending))\n\t\treturn;\n\n\tif (atomic_read(&rbio->error) > rbio->bbio->max_errors)\n\t\trbio_orig_end_io(rbio, -EIO, 0);\n\telse\n\t\t__raid_recover_end_io(rbio);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__raid_recover_end_io",
          "args": [
            "rbio"
          ],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "__raid_recover_end_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1800-1989",
          "snippet": "static void __raid_recover_end_io(struct btrfs_raid_bio *rbio)\n{\n\tint pagenr, stripe;\n\tvoid **pointers;\n\tint faila = -1, failb = -1;\n\tint nr_pages = DIV_ROUND_UP(rbio->stripe_len, PAGE_CACHE_SIZE);\n\tstruct page *page;\n\tint err;\n\tint i;\n\n\tpointers = kzalloc(rbio->real_stripes * sizeof(void *),\n\t\t\t   GFP_NOFS);\n\tif (!pointers) {\n\t\terr = -ENOMEM;\n\t\tgoto cleanup_io;\n\t}\n\n\tfaila = rbio->faila;\n\tfailb = rbio->failb;\n\n\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD) {\n\t\tspin_lock_irq(&rbio->bio_list_lock);\n\t\tset_bit(RBIO_RMW_LOCKED_BIT, &rbio->flags);\n\t\tspin_unlock_irq(&rbio->bio_list_lock);\n\t}\n\n\tindex_rbio_pages(rbio);\n\n\tfor (pagenr = 0; pagenr < nr_pages; pagenr++) {\n\t\t/*\n\t\t * Now we just use bitmap to mark the horizontal stripes in\n\t\t * which we have data when doing parity scrub.\n\t\t */\n\t\tif (rbio->operation == BTRFS_RBIO_PARITY_SCRUB &&\n\t\t    !test_bit(pagenr, rbio->dbitmap))\n\t\t\tcontinue;\n\n\t\t/* setup our array of pointers with pages\n\t\t * from each stripe\n\t\t */\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\t\t/*\n\t\t\t * if we're rebuilding a read, we have to use\n\t\t\t * pages from the bio list\n\t\t\t */\n\t\t\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD &&\n\t\t\t    (stripe == faila || stripe == failb)) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\t} else {\n\t\t\t\tpage = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\t\t\tpointers[stripe] = kmap(page);\n\t\t}\n\n\t\t/* all raid6 handling here */\n\t\tif (rbio->bbio->map_type & BTRFS_BLOCK_GROUP_RAID6) {\n\t\t\t/*\n\t\t\t * single failure, rebuild from parity raid5\n\t\t\t * style\n\t\t\t */\n\t\t\tif (failb < 0) {\n\t\t\t\tif (faila == rbio->nr_data) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Just the P stripe has failed, without\n\t\t\t\t\t * a bad data or Q stripe.\n\t\t\t\t\t * TODO, we should redo the xor here.\n\t\t\t\t\t */\n\t\t\t\t\terr = -EIO;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * a single failure in raid6 is rebuilt\n\t\t\t\t * in the pstripe code below\n\t\t\t\t */\n\t\t\t\tgoto pstripe;\n\t\t\t}\n\n\t\t\t/* make sure our ps and qs are in order */\n\t\t\tif (faila > failb) {\n\t\t\t\tint tmp = failb;\n\t\t\t\tfailb = faila;\n\t\t\t\tfaila = tmp;\n\t\t\t}\n\n\t\t\t/* if the q stripe is failed, do a pstripe reconstruction\n\t\t\t * from the xors.\n\t\t\t * If both the q stripe and the P stripe are failed, we're\n\t\t\t * here due to a crc mismatch and we can't give them the\n\t\t\t * data they want\n\t\t\t */\n\t\t\tif (rbio->bbio->raid_map[failb] == RAID6_Q_STRIPE) {\n\t\t\t\tif (rbio->bbio->raid_map[faila] ==\n\t\t\t\t    RAID5_P_STRIPE) {\n\t\t\t\t\terr = -EIO;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * otherwise we have one bad data stripe and\n\t\t\t\t * a good P stripe.  raid5!\n\t\t\t\t */\n\t\t\t\tgoto pstripe;\n\t\t\t}\n\n\t\t\tif (rbio->bbio->raid_map[failb] == RAID5_P_STRIPE) {\n\t\t\t\traid6_datap_recov(rbio->real_stripes,\n\t\t\t\t\t\t  PAGE_SIZE, faila, pointers);\n\t\t\t} else {\n\t\t\t\traid6_2data_recov(rbio->real_stripes,\n\t\t\t\t\t\t  PAGE_SIZE, faila, failb,\n\t\t\t\t\t\t  pointers);\n\t\t\t}\n\t\t} else {\n\t\t\tvoid *p;\n\n\t\t\t/* rebuild from P stripe here (raid5 or raid6) */\n\t\t\tBUG_ON(failb != -1);\npstripe:\n\t\t\t/* Copy parity block into failed block to start with */\n\t\t\tmemcpy(pointers[faila],\n\t\t\t       pointers[rbio->nr_data],\n\t\t\t       PAGE_CACHE_SIZE);\n\n\t\t\t/* rearrange the pointer array */\n\t\t\tp = pointers[faila];\n\t\t\tfor (stripe = faila; stripe < rbio->nr_data - 1; stripe++)\n\t\t\t\tpointers[stripe] = pointers[stripe + 1];\n\t\t\tpointers[rbio->nr_data - 1] = p;\n\n\t\t\t/* xor in the rest */\n\t\t\trun_xor(pointers, rbio->nr_data - 1, PAGE_CACHE_SIZE);\n\t\t}\n\t\t/* if we're doing this rebuild as part of an rmw, go through\n\t\t * and set all of our private rbio pages in the\n\t\t * failed stripes as uptodate.  This way finish_rmw will\n\t\t * know they can be trusted.  If this was a read reconstruction,\n\t\t * other endio functions will fiddle the uptodate bits\n\t\t */\n\t\tif (rbio->operation == BTRFS_RBIO_WRITE) {\n\t\t\tfor (i = 0;  i < nr_pages; i++) {\n\t\t\t\tif (faila != -1) {\n\t\t\t\t\tpage = rbio_stripe_page(rbio, faila, i);\n\t\t\t\t\tSetPageUptodate(page);\n\t\t\t\t}\n\t\t\t\tif (failb != -1) {\n\t\t\t\t\tpage = rbio_stripe_page(rbio, failb, i);\n\t\t\t\t\tSetPageUptodate(page);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\t\t/*\n\t\t\t * if we're rebuilding a read, we have to use\n\t\t\t * pages from the bio list\n\t\t\t */\n\t\t\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD &&\n\t\t\t    (stripe == faila || stripe == failb)) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\t} else {\n\t\t\t\tpage = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\t\t\tkunmap(page);\n\t\t}\n\t}\n\n\terr = 0;\ncleanup:\n\tkfree(pointers);\n\ncleanup_io:\n\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD) {\n\t\tif (err == 0)\n\t\t\tcache_rbio_pages(rbio);\n\t\telse\n\t\t\tclear_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n\n\t\trbio_orig_end_io(rbio, err, err == 0);\n\t} else if (err == 0) {\n\t\trbio->faila = -1;\n\t\trbio->failb = -1;\n\n\t\tif (rbio->operation == BTRFS_RBIO_WRITE)\n\t\t\tfinish_rmw(rbio);\n\t\telse if (rbio->operation == BTRFS_RBIO_PARITY_SCRUB)\n\t\t\tfinish_parity_scrub(rbio, 0);\n\t\telse\n\t\t\tBUG();\n\t} else {\n\t\trbio_orig_end_io(rbio, err, 0);\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RBIO_CACHE_READY_BIT\t3",
            "#define RBIO_RMW_LOCKED_BIT\t1"
          ],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_READY_BIT\t3\n#define RBIO_RMW_LOCKED_BIT\t1\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void __raid_recover_end_io(struct btrfs_raid_bio *rbio)\n{\n\tint pagenr, stripe;\n\tvoid **pointers;\n\tint faila = -1, failb = -1;\n\tint nr_pages = DIV_ROUND_UP(rbio->stripe_len, PAGE_CACHE_SIZE);\n\tstruct page *page;\n\tint err;\n\tint i;\n\n\tpointers = kzalloc(rbio->real_stripes * sizeof(void *),\n\t\t\t   GFP_NOFS);\n\tif (!pointers) {\n\t\terr = -ENOMEM;\n\t\tgoto cleanup_io;\n\t}\n\n\tfaila = rbio->faila;\n\tfailb = rbio->failb;\n\n\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD) {\n\t\tspin_lock_irq(&rbio->bio_list_lock);\n\t\tset_bit(RBIO_RMW_LOCKED_BIT, &rbio->flags);\n\t\tspin_unlock_irq(&rbio->bio_list_lock);\n\t}\n\n\tindex_rbio_pages(rbio);\n\n\tfor (pagenr = 0; pagenr < nr_pages; pagenr++) {\n\t\t/*\n\t\t * Now we just use bitmap to mark the horizontal stripes in\n\t\t * which we have data when doing parity scrub.\n\t\t */\n\t\tif (rbio->operation == BTRFS_RBIO_PARITY_SCRUB &&\n\t\t    !test_bit(pagenr, rbio->dbitmap))\n\t\t\tcontinue;\n\n\t\t/* setup our array of pointers with pages\n\t\t * from each stripe\n\t\t */\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\t\t/*\n\t\t\t * if we're rebuilding a read, we have to use\n\t\t\t * pages from the bio list\n\t\t\t */\n\t\t\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD &&\n\t\t\t    (stripe == faila || stripe == failb)) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\t} else {\n\t\t\t\tpage = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\t\t\tpointers[stripe] = kmap(page);\n\t\t}\n\n\t\t/* all raid6 handling here */\n\t\tif (rbio->bbio->map_type & BTRFS_BLOCK_GROUP_RAID6) {\n\t\t\t/*\n\t\t\t * single failure, rebuild from parity raid5\n\t\t\t * style\n\t\t\t */\n\t\t\tif (failb < 0) {\n\t\t\t\tif (faila == rbio->nr_data) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Just the P stripe has failed, without\n\t\t\t\t\t * a bad data or Q stripe.\n\t\t\t\t\t * TODO, we should redo the xor here.\n\t\t\t\t\t */\n\t\t\t\t\terr = -EIO;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * a single failure in raid6 is rebuilt\n\t\t\t\t * in the pstripe code below\n\t\t\t\t */\n\t\t\t\tgoto pstripe;\n\t\t\t}\n\n\t\t\t/* make sure our ps and qs are in order */\n\t\t\tif (faila > failb) {\n\t\t\t\tint tmp = failb;\n\t\t\t\tfailb = faila;\n\t\t\t\tfaila = tmp;\n\t\t\t}\n\n\t\t\t/* if the q stripe is failed, do a pstripe reconstruction\n\t\t\t * from the xors.\n\t\t\t * If both the q stripe and the P stripe are failed, we're\n\t\t\t * here due to a crc mismatch and we can't give them the\n\t\t\t * data they want\n\t\t\t */\n\t\t\tif (rbio->bbio->raid_map[failb] == RAID6_Q_STRIPE) {\n\t\t\t\tif (rbio->bbio->raid_map[faila] ==\n\t\t\t\t    RAID5_P_STRIPE) {\n\t\t\t\t\terr = -EIO;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * otherwise we have one bad data stripe and\n\t\t\t\t * a good P stripe.  raid5!\n\t\t\t\t */\n\t\t\t\tgoto pstripe;\n\t\t\t}\n\n\t\t\tif (rbio->bbio->raid_map[failb] == RAID5_P_STRIPE) {\n\t\t\t\traid6_datap_recov(rbio->real_stripes,\n\t\t\t\t\t\t  PAGE_SIZE, faila, pointers);\n\t\t\t} else {\n\t\t\t\traid6_2data_recov(rbio->real_stripes,\n\t\t\t\t\t\t  PAGE_SIZE, faila, failb,\n\t\t\t\t\t\t  pointers);\n\t\t\t}\n\t\t} else {\n\t\t\tvoid *p;\n\n\t\t\t/* rebuild from P stripe here (raid5 or raid6) */\n\t\t\tBUG_ON(failb != -1);\npstripe:\n\t\t\t/* Copy parity block into failed block to start with */\n\t\t\tmemcpy(pointers[faila],\n\t\t\t       pointers[rbio->nr_data],\n\t\t\t       PAGE_CACHE_SIZE);\n\n\t\t\t/* rearrange the pointer array */\n\t\t\tp = pointers[faila];\n\t\t\tfor (stripe = faila; stripe < rbio->nr_data - 1; stripe++)\n\t\t\t\tpointers[stripe] = pointers[stripe + 1];\n\t\t\tpointers[rbio->nr_data - 1] = p;\n\n\t\t\t/* xor in the rest */\n\t\t\trun_xor(pointers, rbio->nr_data - 1, PAGE_CACHE_SIZE);\n\t\t}\n\t\t/* if we're doing this rebuild as part of an rmw, go through\n\t\t * and set all of our private rbio pages in the\n\t\t * failed stripes as uptodate.  This way finish_rmw will\n\t\t * know they can be trusted.  If this was a read reconstruction,\n\t\t * other endio functions will fiddle the uptodate bits\n\t\t */\n\t\tif (rbio->operation == BTRFS_RBIO_WRITE) {\n\t\t\tfor (i = 0;  i < nr_pages; i++) {\n\t\t\t\tif (faila != -1) {\n\t\t\t\t\tpage = rbio_stripe_page(rbio, faila, i);\n\t\t\t\t\tSetPageUptodate(page);\n\t\t\t\t}\n\t\t\t\tif (failb != -1) {\n\t\t\t\t\tpage = rbio_stripe_page(rbio, failb, i);\n\t\t\t\t\tSetPageUptodate(page);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\t\t/*\n\t\t\t * if we're rebuilding a read, we have to use\n\t\t\t * pages from the bio list\n\t\t\t */\n\t\t\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD &&\n\t\t\t    (stripe == faila || stripe == failb)) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\t} else {\n\t\t\t\tpage = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\t\t\tkunmap(page);\n\t\t}\n\t}\n\n\terr = 0;\ncleanup:\n\tkfree(pointers);\n\ncleanup_io:\n\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD) {\n\t\tif (err == 0)\n\t\t\tcache_rbio_pages(rbio);\n\t\telse\n\t\t\tclear_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n\n\t\trbio_orig_end_io(rbio, err, err == 0);\n\t} else if (err == 0) {\n\t\trbio->faila = -1;\n\t\trbio->failb = -1;\n\n\t\tif (rbio->operation == BTRFS_RBIO_WRITE)\n\t\t\tfinish_rmw(rbio);\n\t\telse if (rbio->operation == BTRFS_RBIO_PARITY_SCRUB)\n\t\t\tfinish_parity_scrub(rbio, 0);\n\t\telse\n\t\t\tBUG();\n\t} else {\n\t\trbio_orig_end_io(rbio, err, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rbio_orig_end_io",
          "args": [
            "rbio",
            "-EIO",
            "0"
          ],
          "line": 2013
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_orig_end_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "861-879",
          "snippet": "static void rbio_orig_end_io(struct btrfs_raid_bio *rbio, int err, int uptodate)\n{\n\tstruct bio *cur = bio_list_get(&rbio->bio_list);\n\tstruct bio *next;\n\n\tif (rbio->generic_bio_cnt)\n\t\tbtrfs_bio_counter_sub(rbio->fs_info, rbio->generic_bio_cnt);\n\n\tfree_raid_bio(rbio);\n\n\twhile (cur) {\n\t\tnext = cur->bi_next;\n\t\tcur->bi_next = NULL;\n\t\tif (uptodate)\n\t\t\tset_bit(BIO_UPTODATE, &cur->bi_flags);\n\t\tbio_endio(cur, err);\n\t\tcur = next;\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void rbio_orig_end_io(struct btrfs_raid_bio *rbio, int err, int uptodate)\n{\n\tstruct bio *cur = bio_list_get(&rbio->bio_list);\n\tstruct bio *next;\n\n\tif (rbio->generic_bio_cnt)\n\t\tbtrfs_bio_counter_sub(rbio->fs_info, rbio->generic_bio_cnt);\n\n\tfree_raid_bio(rbio);\n\n\twhile (cur) {\n\t\tnext = cur->bi_next;\n\t\tcur->bi_next = NULL;\n\t\tif (uptodate)\n\t\t\tset_bit(BIO_UPTODATE, &cur->bi_flags);\n\t\tbio_endio(cur, err);\n\t\tcur = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rbio->error"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&rbio->stripes_pending"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bio_pages_uptodate",
          "args": [
            "bio"
          ],
          "line": 2006
        },
        "resolved": true,
        "details": {
          "function_name": "set_bio_pages_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1432-1441",
          "snippet": "static void set_bio_pages_uptodate(struct bio *bio)\n{\n\tint i;\n\tstruct page *p;\n\n\tfor (i = 0; i < bio->bi_vcnt; i++) {\n\t\tp = bio->bi_io_vec[i].bv_page;\n\t\tSetPageUptodate(p);\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\n\nstatic void set_bio_pages_uptodate(struct bio *bio)\n{\n\tint i;\n\tstruct page *p;\n\n\tfor (i = 0; i < bio->bi_vcnt; i++) {\n\t\tp = bio->bi_io_vec[i].bv_page;\n\t\tSetPageUptodate(p);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fail_bio_stripe",
          "args": [
            "rbio",
            "bio"
          ],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "fail_bio_stripe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1417-1426",
          "snippet": "static int fail_bio_stripe(struct btrfs_raid_bio *rbio,\n\t\t\t   struct bio *bio)\n{\n\tint failed = find_bio_stripe(rbio, bio);\n\n\tif (failed < 0)\n\t\treturn -EIO;\n\n\treturn fail_rbio_index(rbio, failed);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio,\n\t\t\t   struct bio *bio)\n{\n\tint failed = find_bio_stripe(rbio, bio);\n\n\tif (failed < 0)\n\t\treturn -EIO;\n\n\treturn fail_rbio_index(rbio, failed);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void raid_recover_end_io(struct bio *bio, int err)\n{\n\tstruct btrfs_raid_bio *rbio = bio->bi_private;\n\n\t/*\n\t * we only read stripe pages off the disk, set them\n\t * up to date if there were no errors\n\t */\n\tif (err)\n\t\tfail_bio_stripe(rbio, bio);\n\telse\n\t\tset_bio_pages_uptodate(bio);\n\tbio_put(bio);\n\n\tif (!atomic_dec_and_test(&rbio->stripes_pending))\n\t\treturn;\n\n\tif (atomic_read(&rbio->error) > rbio->bbio->max_errors)\n\t\trbio_orig_end_io(rbio, -EIO, 0);\n\telse\n\t\t__raid_recover_end_io(rbio);\n}"
  },
  {
    "function_name": "__raid_recover_end_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "1800-1989",
    "snippet": "static void __raid_recover_end_io(struct btrfs_raid_bio *rbio)\n{\n\tint pagenr, stripe;\n\tvoid **pointers;\n\tint faila = -1, failb = -1;\n\tint nr_pages = DIV_ROUND_UP(rbio->stripe_len, PAGE_CACHE_SIZE);\n\tstruct page *page;\n\tint err;\n\tint i;\n\n\tpointers = kzalloc(rbio->real_stripes * sizeof(void *),\n\t\t\t   GFP_NOFS);\n\tif (!pointers) {\n\t\terr = -ENOMEM;\n\t\tgoto cleanup_io;\n\t}\n\n\tfaila = rbio->faila;\n\tfailb = rbio->failb;\n\n\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD) {\n\t\tspin_lock_irq(&rbio->bio_list_lock);\n\t\tset_bit(RBIO_RMW_LOCKED_BIT, &rbio->flags);\n\t\tspin_unlock_irq(&rbio->bio_list_lock);\n\t}\n\n\tindex_rbio_pages(rbio);\n\n\tfor (pagenr = 0; pagenr < nr_pages; pagenr++) {\n\t\t/*\n\t\t * Now we just use bitmap to mark the horizontal stripes in\n\t\t * which we have data when doing parity scrub.\n\t\t */\n\t\tif (rbio->operation == BTRFS_RBIO_PARITY_SCRUB &&\n\t\t    !test_bit(pagenr, rbio->dbitmap))\n\t\t\tcontinue;\n\n\t\t/* setup our array of pointers with pages\n\t\t * from each stripe\n\t\t */\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\t\t/*\n\t\t\t * if we're rebuilding a read, we have to use\n\t\t\t * pages from the bio list\n\t\t\t */\n\t\t\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD &&\n\t\t\t    (stripe == faila || stripe == failb)) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\t} else {\n\t\t\t\tpage = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\t\t\tpointers[stripe] = kmap(page);\n\t\t}\n\n\t\t/* all raid6 handling here */\n\t\tif (rbio->bbio->map_type & BTRFS_BLOCK_GROUP_RAID6) {\n\t\t\t/*\n\t\t\t * single failure, rebuild from parity raid5\n\t\t\t * style\n\t\t\t */\n\t\t\tif (failb < 0) {\n\t\t\t\tif (faila == rbio->nr_data) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Just the P stripe has failed, without\n\t\t\t\t\t * a bad data or Q stripe.\n\t\t\t\t\t * TODO, we should redo the xor here.\n\t\t\t\t\t */\n\t\t\t\t\terr = -EIO;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * a single failure in raid6 is rebuilt\n\t\t\t\t * in the pstripe code below\n\t\t\t\t */\n\t\t\t\tgoto pstripe;\n\t\t\t}\n\n\t\t\t/* make sure our ps and qs are in order */\n\t\t\tif (faila > failb) {\n\t\t\t\tint tmp = failb;\n\t\t\t\tfailb = faila;\n\t\t\t\tfaila = tmp;\n\t\t\t}\n\n\t\t\t/* if the q stripe is failed, do a pstripe reconstruction\n\t\t\t * from the xors.\n\t\t\t * If both the q stripe and the P stripe are failed, we're\n\t\t\t * here due to a crc mismatch and we can't give them the\n\t\t\t * data they want\n\t\t\t */\n\t\t\tif (rbio->bbio->raid_map[failb] == RAID6_Q_STRIPE) {\n\t\t\t\tif (rbio->bbio->raid_map[faila] ==\n\t\t\t\t    RAID5_P_STRIPE) {\n\t\t\t\t\terr = -EIO;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * otherwise we have one bad data stripe and\n\t\t\t\t * a good P stripe.  raid5!\n\t\t\t\t */\n\t\t\t\tgoto pstripe;\n\t\t\t}\n\n\t\t\tif (rbio->bbio->raid_map[failb] == RAID5_P_STRIPE) {\n\t\t\t\traid6_datap_recov(rbio->real_stripes,\n\t\t\t\t\t\t  PAGE_SIZE, faila, pointers);\n\t\t\t} else {\n\t\t\t\traid6_2data_recov(rbio->real_stripes,\n\t\t\t\t\t\t  PAGE_SIZE, faila, failb,\n\t\t\t\t\t\t  pointers);\n\t\t\t}\n\t\t} else {\n\t\t\tvoid *p;\n\n\t\t\t/* rebuild from P stripe here (raid5 or raid6) */\n\t\t\tBUG_ON(failb != -1);\npstripe:\n\t\t\t/* Copy parity block into failed block to start with */\n\t\t\tmemcpy(pointers[faila],\n\t\t\t       pointers[rbio->nr_data],\n\t\t\t       PAGE_CACHE_SIZE);\n\n\t\t\t/* rearrange the pointer array */\n\t\t\tp = pointers[faila];\n\t\t\tfor (stripe = faila; stripe < rbio->nr_data - 1; stripe++)\n\t\t\t\tpointers[stripe] = pointers[stripe + 1];\n\t\t\tpointers[rbio->nr_data - 1] = p;\n\n\t\t\t/* xor in the rest */\n\t\t\trun_xor(pointers, rbio->nr_data - 1, PAGE_CACHE_SIZE);\n\t\t}\n\t\t/* if we're doing this rebuild as part of an rmw, go through\n\t\t * and set all of our private rbio pages in the\n\t\t * failed stripes as uptodate.  This way finish_rmw will\n\t\t * know they can be trusted.  If this was a read reconstruction,\n\t\t * other endio functions will fiddle the uptodate bits\n\t\t */\n\t\tif (rbio->operation == BTRFS_RBIO_WRITE) {\n\t\t\tfor (i = 0;  i < nr_pages; i++) {\n\t\t\t\tif (faila != -1) {\n\t\t\t\t\tpage = rbio_stripe_page(rbio, faila, i);\n\t\t\t\t\tSetPageUptodate(page);\n\t\t\t\t}\n\t\t\t\tif (failb != -1) {\n\t\t\t\t\tpage = rbio_stripe_page(rbio, failb, i);\n\t\t\t\t\tSetPageUptodate(page);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\t\t/*\n\t\t\t * if we're rebuilding a read, we have to use\n\t\t\t * pages from the bio list\n\t\t\t */\n\t\t\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD &&\n\t\t\t    (stripe == faila || stripe == failb)) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\t} else {\n\t\t\t\tpage = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\t\t\tkunmap(page);\n\t\t}\n\t}\n\n\terr = 0;\ncleanup:\n\tkfree(pointers);\n\ncleanup_io:\n\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD) {\n\t\tif (err == 0)\n\t\t\tcache_rbio_pages(rbio);\n\t\telse\n\t\t\tclear_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n\n\t\trbio_orig_end_io(rbio, err, err == 0);\n\t} else if (err == 0) {\n\t\trbio->faila = -1;\n\t\trbio->failb = -1;\n\n\t\tif (rbio->operation == BTRFS_RBIO_WRITE)\n\t\t\tfinish_rmw(rbio);\n\t\telse if (rbio->operation == BTRFS_RBIO_PARITY_SCRUB)\n\t\t\tfinish_parity_scrub(rbio, 0);\n\t\telse\n\t\t\tBUG();\n\t} else {\n\t\trbio_orig_end_io(rbio, err, 0);\n\t}\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define RBIO_CACHE_READY_BIT\t3",
      "#define RBIO_RMW_LOCKED_BIT\t1"
    ],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
      "static int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rbio_orig_end_io",
          "args": [
            "rbio",
            "err",
            "0"
          ],
          "line": 1987
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_orig_end_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "861-879",
          "snippet": "static void rbio_orig_end_io(struct btrfs_raid_bio *rbio, int err, int uptodate)\n{\n\tstruct bio *cur = bio_list_get(&rbio->bio_list);\n\tstruct bio *next;\n\n\tif (rbio->generic_bio_cnt)\n\t\tbtrfs_bio_counter_sub(rbio->fs_info, rbio->generic_bio_cnt);\n\n\tfree_raid_bio(rbio);\n\n\twhile (cur) {\n\t\tnext = cur->bi_next;\n\t\tcur->bi_next = NULL;\n\t\tif (uptodate)\n\t\t\tset_bit(BIO_UPTODATE, &cur->bi_flags);\n\t\tbio_endio(cur, err);\n\t\tcur = next;\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void rbio_orig_end_io(struct btrfs_raid_bio *rbio, int err, int uptodate)\n{\n\tstruct bio *cur = bio_list_get(&rbio->bio_list);\n\tstruct bio *next;\n\n\tif (rbio->generic_bio_cnt)\n\t\tbtrfs_bio_counter_sub(rbio->fs_info, rbio->generic_bio_cnt);\n\n\tfree_raid_bio(rbio);\n\n\twhile (cur) {\n\t\tnext = cur->bi_next;\n\t\tcur->bi_next = NULL;\n\t\tif (uptodate)\n\t\t\tset_bit(BIO_UPTODATE, &cur->bi_flags);\n\t\tbio_endio(cur, err);\n\t\tcur = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_parity_scrub",
          "args": [
            "rbio",
            "0"
          ],
          "line": 1983
        },
        "resolved": true,
        "details": {
          "function_name": "finish_parity_scrub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "2308-2468",
          "snippet": "static noinline void finish_parity_scrub(struct btrfs_raid_bio *rbio,\n\t\t\t\t\t int need_check)\n{\n\tstruct btrfs_bio *bbio = rbio->bbio;\n\tvoid *pointers[rbio->real_stripes];\n\tDECLARE_BITMAP(pbitmap, rbio->stripe_npages);\n\tint nr_data = rbio->nr_data;\n\tint stripe;\n\tint pagenr;\n\tint p_stripe = -1;\n\tint q_stripe = -1;\n\tstruct page *p_page = NULL;\n\tstruct page *q_page = NULL;\n\tstruct bio_list bio_list;\n\tstruct bio *bio;\n\tint is_replace = 0;\n\tint ret;\n\n\tbio_list_init(&bio_list);\n\n\tif (rbio->real_stripes - rbio->nr_data == 1) {\n\t\tp_stripe = rbio->real_stripes - 1;\n\t} else if (rbio->real_stripes - rbio->nr_data == 2) {\n\t\tp_stripe = rbio->real_stripes - 2;\n\t\tq_stripe = rbio->real_stripes - 1;\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (bbio->num_tgtdevs && bbio->tgtdev_map[rbio->scrubp]) {\n\t\tis_replace = 1;\n\t\tbitmap_copy(pbitmap, rbio->dbitmap, rbio->stripe_npages);\n\t}\n\n\t/*\n\t * Because the higher layers(scrubber) are unlikely to\n\t * use this area of the disk again soon, so don't cache\n\t * it.\n\t */\n\tclear_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n\n\tif (!need_check)\n\t\tgoto writeback;\n\n\tp_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\tif (!p_page)\n\t\tgoto cleanup;\n\tSetPageUptodate(p_page);\n\n\tif (q_stripe != -1) {\n\t\tq_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\t\tif (!q_page) {\n\t\t\t__free_page(p_page);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tSetPageUptodate(q_page);\n\t}\n\n\tatomic_set(&rbio->error, 0);\n\n\tfor_each_set_bit(pagenr, rbio->dbitmap, rbio->stripe_npages) {\n\t\tstruct page *p;\n\t\tvoid *parity;\n\t\t/* first collect one page from each data stripe */\n\t\tfor (stripe = 0; stripe < nr_data; stripe++) {\n\t\t\tp = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\tpointers[stripe] = kmap(p);\n\t\t}\n\n\t\t/* then add the parity stripe */\n\t\tpointers[stripe++] = kmap(p_page);\n\n\t\tif (q_stripe != -1) {\n\n\t\t\t/*\n\t\t\t * raid6, add the qstripe and call the\n\t\t\t * library function to fill in our p/q\n\t\t\t */\n\t\t\tpointers[stripe++] = kmap(q_page);\n\n\t\t\traid6_call.gen_syndrome(rbio->real_stripes, PAGE_SIZE,\n\t\t\t\t\t\tpointers);\n\t\t} else {\n\t\t\t/* raid5 */\n\t\t\tmemcpy(pointers[nr_data], pointers[0], PAGE_SIZE);\n\t\t\trun_xor(pointers + 1, nr_data - 1, PAGE_CACHE_SIZE);\n\t\t}\n\n\t\t/* Check scrubbing pairty and repair it */\n\t\tp = rbio_stripe_page(rbio, rbio->scrubp, pagenr);\n\t\tparity = kmap(p);\n\t\tif (memcmp(parity, pointers[rbio->scrubp], PAGE_CACHE_SIZE))\n\t\t\tmemcpy(parity, pointers[rbio->scrubp], PAGE_CACHE_SIZE);\n\t\telse\n\t\t\t/* Parity is right, needn't writeback */\n\t\t\tbitmap_clear(rbio->dbitmap, pagenr, 1);\n\t\tkunmap(p);\n\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++)\n\t\t\tkunmap(page_in_rbio(rbio, stripe, pagenr, 0));\n\t}\n\n\t__free_page(p_page);\n\tif (q_page)\n\t\t__free_page(q_page);\n\nwriteback:\n\t/*\n\t * time to start writing.  Make bios for everything from the\n\t * higher layers (the bio_list in our rbio) and our p/q.  Ignore\n\t * everything else.\n\t */\n\tfor_each_set_bit(pagenr, rbio->dbitmap, rbio->stripe_npages) {\n\t\tstruct page *page;\n\n\t\tpage = rbio_stripe_page(rbio, rbio->scrubp, pagenr);\n\t\tret = rbio_add_io_page(rbio, &bio_list,\n\t\t\t       page, rbio->scrubp, pagenr, rbio->stripe_len);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (!is_replace)\n\t\tgoto submit_write;\n\n\tfor_each_set_bit(pagenr, pbitmap, rbio->stripe_npages) {\n\t\tstruct page *page;\n\n\t\tpage = rbio_stripe_page(rbio, rbio->scrubp, pagenr);\n\t\tret = rbio_add_io_page(rbio, &bio_list, page,\n\t\t\t\t       bbio->tgtdev_map[rbio->scrubp],\n\t\t\t\t       pagenr, rbio->stripe_len);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\nsubmit_write:\n\tnr_data = bio_list_size(&bio_list);\n\tif (!nr_data) {\n\t\t/* Every parity is right */\n\t\trbio_orig_end_io(rbio, 0, 0);\n\t\treturn;\n\t}\n\n\tatomic_set(&rbio->stripes_pending, nr_data);\n\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid_write_parity_end_io;\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(WRITE, bio);\n\t}\n\treturn;\n\ncleanup:\n\trbio_orig_end_io(rbio, -EIO, 0);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RBIO_CACHE_READY_BIT\t3"
          ],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_parity_scrub(struct btrfs_raid_bio *rbio,\n\t\t\t\t\t int need_check);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_READY_BIT\t3\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_parity_scrub(struct btrfs_raid_bio *rbio,\n\t\t\t\t\t int need_check);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic noinline void finish_parity_scrub(struct btrfs_raid_bio *rbio,\n\t\t\t\t\t int need_check)\n{\n\tstruct btrfs_bio *bbio = rbio->bbio;\n\tvoid *pointers[rbio->real_stripes];\n\tDECLARE_BITMAP(pbitmap, rbio->stripe_npages);\n\tint nr_data = rbio->nr_data;\n\tint stripe;\n\tint pagenr;\n\tint p_stripe = -1;\n\tint q_stripe = -1;\n\tstruct page *p_page = NULL;\n\tstruct page *q_page = NULL;\n\tstruct bio_list bio_list;\n\tstruct bio *bio;\n\tint is_replace = 0;\n\tint ret;\n\n\tbio_list_init(&bio_list);\n\n\tif (rbio->real_stripes - rbio->nr_data == 1) {\n\t\tp_stripe = rbio->real_stripes - 1;\n\t} else if (rbio->real_stripes - rbio->nr_data == 2) {\n\t\tp_stripe = rbio->real_stripes - 2;\n\t\tq_stripe = rbio->real_stripes - 1;\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (bbio->num_tgtdevs && bbio->tgtdev_map[rbio->scrubp]) {\n\t\tis_replace = 1;\n\t\tbitmap_copy(pbitmap, rbio->dbitmap, rbio->stripe_npages);\n\t}\n\n\t/*\n\t * Because the higher layers(scrubber) are unlikely to\n\t * use this area of the disk again soon, so don't cache\n\t * it.\n\t */\n\tclear_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n\n\tif (!need_check)\n\t\tgoto writeback;\n\n\tp_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\tif (!p_page)\n\t\tgoto cleanup;\n\tSetPageUptodate(p_page);\n\n\tif (q_stripe != -1) {\n\t\tq_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\t\tif (!q_page) {\n\t\t\t__free_page(p_page);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tSetPageUptodate(q_page);\n\t}\n\n\tatomic_set(&rbio->error, 0);\n\n\tfor_each_set_bit(pagenr, rbio->dbitmap, rbio->stripe_npages) {\n\t\tstruct page *p;\n\t\tvoid *parity;\n\t\t/* first collect one page from each data stripe */\n\t\tfor (stripe = 0; stripe < nr_data; stripe++) {\n\t\t\tp = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\tpointers[stripe] = kmap(p);\n\t\t}\n\n\t\t/* then add the parity stripe */\n\t\tpointers[stripe++] = kmap(p_page);\n\n\t\tif (q_stripe != -1) {\n\n\t\t\t/*\n\t\t\t * raid6, add the qstripe and call the\n\t\t\t * library function to fill in our p/q\n\t\t\t */\n\t\t\tpointers[stripe++] = kmap(q_page);\n\n\t\t\traid6_call.gen_syndrome(rbio->real_stripes, PAGE_SIZE,\n\t\t\t\t\t\tpointers);\n\t\t} else {\n\t\t\t/* raid5 */\n\t\t\tmemcpy(pointers[nr_data], pointers[0], PAGE_SIZE);\n\t\t\trun_xor(pointers + 1, nr_data - 1, PAGE_CACHE_SIZE);\n\t\t}\n\n\t\t/* Check scrubbing pairty and repair it */\n\t\tp = rbio_stripe_page(rbio, rbio->scrubp, pagenr);\n\t\tparity = kmap(p);\n\t\tif (memcmp(parity, pointers[rbio->scrubp], PAGE_CACHE_SIZE))\n\t\t\tmemcpy(parity, pointers[rbio->scrubp], PAGE_CACHE_SIZE);\n\t\telse\n\t\t\t/* Parity is right, needn't writeback */\n\t\t\tbitmap_clear(rbio->dbitmap, pagenr, 1);\n\t\tkunmap(p);\n\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++)\n\t\t\tkunmap(page_in_rbio(rbio, stripe, pagenr, 0));\n\t}\n\n\t__free_page(p_page);\n\tif (q_page)\n\t\t__free_page(q_page);\n\nwriteback:\n\t/*\n\t * time to start writing.  Make bios for everything from the\n\t * higher layers (the bio_list in our rbio) and our p/q.  Ignore\n\t * everything else.\n\t */\n\tfor_each_set_bit(pagenr, rbio->dbitmap, rbio->stripe_npages) {\n\t\tstruct page *page;\n\n\t\tpage = rbio_stripe_page(rbio, rbio->scrubp, pagenr);\n\t\tret = rbio_add_io_page(rbio, &bio_list,\n\t\t\t       page, rbio->scrubp, pagenr, rbio->stripe_len);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (!is_replace)\n\t\tgoto submit_write;\n\n\tfor_each_set_bit(pagenr, pbitmap, rbio->stripe_npages) {\n\t\tstruct page *page;\n\n\t\tpage = rbio_stripe_page(rbio, rbio->scrubp, pagenr);\n\t\tret = rbio_add_io_page(rbio, &bio_list, page,\n\t\t\t\t       bbio->tgtdev_map[rbio->scrubp],\n\t\t\t\t       pagenr, rbio->stripe_len);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\nsubmit_write:\n\tnr_data = bio_list_size(&bio_list);\n\tif (!nr_data) {\n\t\t/* Every parity is right */\n\t\trbio_orig_end_io(rbio, 0, 0);\n\t\treturn;\n\t}\n\n\tatomic_set(&rbio->stripes_pending, nr_data);\n\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid_write_parity_end_io;\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(WRITE, bio);\n\t}\n\treturn;\n\ncleanup:\n\trbio_orig_end_io(rbio, -EIO, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_rmw",
          "args": [
            "rbio"
          ],
          "line": 1981
        },
        "resolved": true,
        "details": {
          "function_name": "finish_rmw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1172-1329",
          "snippet": "static noinline void finish_rmw(struct btrfs_raid_bio *rbio)\n{\n\tstruct btrfs_bio *bbio = rbio->bbio;\n\tvoid *pointers[rbio->real_stripes];\n\tint stripe_len = rbio->stripe_len;\n\tint nr_data = rbio->nr_data;\n\tint stripe;\n\tint pagenr;\n\tint p_stripe = -1;\n\tint q_stripe = -1;\n\tstruct bio_list bio_list;\n\tstruct bio *bio;\n\tint pages_per_stripe = stripe_len >> PAGE_CACHE_SHIFT;\n\tint ret;\n\n\tbio_list_init(&bio_list);\n\n\tif (rbio->real_stripes - rbio->nr_data == 1) {\n\t\tp_stripe = rbio->real_stripes - 1;\n\t} else if (rbio->real_stripes - rbio->nr_data == 2) {\n\t\tp_stripe = rbio->real_stripes - 2;\n\t\tq_stripe = rbio->real_stripes - 1;\n\t} else {\n\t\tBUG();\n\t}\n\n\t/* at this point we either have a full stripe,\n\t * or we've read the full stripe from the drive.\n\t * recalculate the parity and write the new results.\n\t *\n\t * We're not allowed to add any new bios to the\n\t * bio list here, anyone else that wants to\n\t * change this stripe needs to do their own rmw.\n\t */\n\tspin_lock_irq(&rbio->bio_list_lock);\n\tset_bit(RBIO_RMW_LOCKED_BIT, &rbio->flags);\n\tspin_unlock_irq(&rbio->bio_list_lock);\n\n\tatomic_set(&rbio->error, 0);\n\n\t/*\n\t * now that we've set rmw_locked, run through the\n\t * bio list one last time and map the page pointers\n\t *\n\t * We don't cache full rbios because we're assuming\n\t * the higher layers are unlikely to use this area of\n\t * the disk again soon.  If they do use it again,\n\t * hopefully they will send another full bio.\n\t */\n\tindex_rbio_pages(rbio);\n\tif (!rbio_is_full(rbio))\n\t\tcache_rbio_pages(rbio);\n\telse\n\t\tclear_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n\n\tfor (pagenr = 0; pagenr < pages_per_stripe; pagenr++) {\n\t\tstruct page *p;\n\t\t/* first collect one page from each data stripe */\n\t\tfor (stripe = 0; stripe < nr_data; stripe++) {\n\t\t\tp = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\tpointers[stripe] = kmap(p);\n\t\t}\n\n\t\t/* then add the parity stripe */\n\t\tp = rbio_pstripe_page(rbio, pagenr);\n\t\tSetPageUptodate(p);\n\t\tpointers[stripe++] = kmap(p);\n\n\t\tif (q_stripe != -1) {\n\n\t\t\t/*\n\t\t\t * raid6, add the qstripe and call the\n\t\t\t * library function to fill in our p/q\n\t\t\t */\n\t\t\tp = rbio_qstripe_page(rbio, pagenr);\n\t\t\tSetPageUptodate(p);\n\t\t\tpointers[stripe++] = kmap(p);\n\n\t\t\traid6_call.gen_syndrome(rbio->real_stripes, PAGE_SIZE,\n\t\t\t\t\t\tpointers);\n\t\t} else {\n\t\t\t/* raid5 */\n\t\t\tmemcpy(pointers[nr_data], pointers[0], PAGE_SIZE);\n\t\t\trun_xor(pointers + 1, nr_data - 1, PAGE_CACHE_SIZE);\n\t\t}\n\n\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++)\n\t\t\tkunmap(page_in_rbio(rbio, stripe, pagenr, 0));\n\t}\n\n\t/*\n\t * time to start writing.  Make bios for everything from the\n\t * higher layers (the bio_list in our rbio) and our p/q.  Ignore\n\t * everything else.\n\t */\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tfor (pagenr = 0; pagenr < pages_per_stripe; pagenr++) {\n\t\t\tstruct page *page;\n\t\t\tif (stripe < rbio->nr_data) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 1);\n\t\t\t\tif (!page)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t       page = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list,\n\t\t\t\t       page, stripe, pagenr, rbio->stripe_len);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (likely(!bbio->num_tgtdevs))\n\t\tgoto write_data;\n\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tif (!bbio->tgtdev_map[stripe])\n\t\t\tcontinue;\n\n\t\tfor (pagenr = 0; pagenr < pages_per_stripe; pagenr++) {\n\t\t\tstruct page *page;\n\t\t\tif (stripe < rbio->nr_data) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 1);\n\t\t\t\tif (!page)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t       page = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list, page,\n\t\t\t\t\t       rbio->bbio->tgtdev_map[stripe],\n\t\t\t\t\t       pagenr, rbio->stripe_len);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\nwrite_data:\n\tatomic_set(&rbio->stripes_pending, bio_list_size(&bio_list));\n\tBUG_ON(atomic_read(&rbio->stripes_pending) == 0);\n\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid_write_end_io;\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(WRITE, bio);\n\t}\n\treturn;\n\ncleanup:\n\trbio_orig_end_io(rbio, -EIO, 0);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RBIO_CACHE_READY_BIT\t3",
            "#define RBIO_RMW_LOCKED_BIT\t1"
          ],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_READY_BIT\t3\n#define RBIO_RMW_LOCKED_BIT\t1\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio)\n{\n\tstruct btrfs_bio *bbio = rbio->bbio;\n\tvoid *pointers[rbio->real_stripes];\n\tint stripe_len = rbio->stripe_len;\n\tint nr_data = rbio->nr_data;\n\tint stripe;\n\tint pagenr;\n\tint p_stripe = -1;\n\tint q_stripe = -1;\n\tstruct bio_list bio_list;\n\tstruct bio *bio;\n\tint pages_per_stripe = stripe_len >> PAGE_CACHE_SHIFT;\n\tint ret;\n\n\tbio_list_init(&bio_list);\n\n\tif (rbio->real_stripes - rbio->nr_data == 1) {\n\t\tp_stripe = rbio->real_stripes - 1;\n\t} else if (rbio->real_stripes - rbio->nr_data == 2) {\n\t\tp_stripe = rbio->real_stripes - 2;\n\t\tq_stripe = rbio->real_stripes - 1;\n\t} else {\n\t\tBUG();\n\t}\n\n\t/* at this point we either have a full stripe,\n\t * or we've read the full stripe from the drive.\n\t * recalculate the parity and write the new results.\n\t *\n\t * We're not allowed to add any new bios to the\n\t * bio list here, anyone else that wants to\n\t * change this stripe needs to do their own rmw.\n\t */\n\tspin_lock_irq(&rbio->bio_list_lock);\n\tset_bit(RBIO_RMW_LOCKED_BIT, &rbio->flags);\n\tspin_unlock_irq(&rbio->bio_list_lock);\n\n\tatomic_set(&rbio->error, 0);\n\n\t/*\n\t * now that we've set rmw_locked, run through the\n\t * bio list one last time and map the page pointers\n\t *\n\t * We don't cache full rbios because we're assuming\n\t * the higher layers are unlikely to use this area of\n\t * the disk again soon.  If they do use it again,\n\t * hopefully they will send another full bio.\n\t */\n\tindex_rbio_pages(rbio);\n\tif (!rbio_is_full(rbio))\n\t\tcache_rbio_pages(rbio);\n\telse\n\t\tclear_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n\n\tfor (pagenr = 0; pagenr < pages_per_stripe; pagenr++) {\n\t\tstruct page *p;\n\t\t/* first collect one page from each data stripe */\n\t\tfor (stripe = 0; stripe < nr_data; stripe++) {\n\t\t\tp = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\tpointers[stripe] = kmap(p);\n\t\t}\n\n\t\t/* then add the parity stripe */\n\t\tp = rbio_pstripe_page(rbio, pagenr);\n\t\tSetPageUptodate(p);\n\t\tpointers[stripe++] = kmap(p);\n\n\t\tif (q_stripe != -1) {\n\n\t\t\t/*\n\t\t\t * raid6, add the qstripe and call the\n\t\t\t * library function to fill in our p/q\n\t\t\t */\n\t\t\tp = rbio_qstripe_page(rbio, pagenr);\n\t\t\tSetPageUptodate(p);\n\t\t\tpointers[stripe++] = kmap(p);\n\n\t\t\traid6_call.gen_syndrome(rbio->real_stripes, PAGE_SIZE,\n\t\t\t\t\t\tpointers);\n\t\t} else {\n\t\t\t/* raid5 */\n\t\t\tmemcpy(pointers[nr_data], pointers[0], PAGE_SIZE);\n\t\t\trun_xor(pointers + 1, nr_data - 1, PAGE_CACHE_SIZE);\n\t\t}\n\n\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++)\n\t\t\tkunmap(page_in_rbio(rbio, stripe, pagenr, 0));\n\t}\n\n\t/*\n\t * time to start writing.  Make bios for everything from the\n\t * higher layers (the bio_list in our rbio) and our p/q.  Ignore\n\t * everything else.\n\t */\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tfor (pagenr = 0; pagenr < pages_per_stripe; pagenr++) {\n\t\t\tstruct page *page;\n\t\t\tif (stripe < rbio->nr_data) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 1);\n\t\t\t\tif (!page)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t       page = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list,\n\t\t\t\t       page, stripe, pagenr, rbio->stripe_len);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (likely(!bbio->num_tgtdevs))\n\t\tgoto write_data;\n\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tif (!bbio->tgtdev_map[stripe])\n\t\t\tcontinue;\n\n\t\tfor (pagenr = 0; pagenr < pages_per_stripe; pagenr++) {\n\t\t\tstruct page *page;\n\t\t\tif (stripe < rbio->nr_data) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 1);\n\t\t\t\tif (!page)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t       page = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list, page,\n\t\t\t\t\t       rbio->bbio->tgtdev_map[stripe],\n\t\t\t\t\t       pagenr, rbio->stripe_len);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\nwrite_data:\n\tatomic_set(&rbio->stripes_pending, bio_list_size(&bio_list));\n\tBUG_ON(atomic_read(&rbio->stripes_pending) == 0);\n\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid_write_end_io;\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(WRITE, bio);\n\t}\n\treturn;\n\ncleanup:\n\trbio_orig_end_io(rbio, -EIO, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "RBIO_CACHE_READY_BIT",
            "&rbio->flags"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_rbio_pages",
          "args": [
            "rbio"
          ],
          "line": 1971
        },
        "resolved": true,
        "details": {
          "function_name": "cache_rbio_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "258-283",
          "snippet": "static void cache_rbio_pages(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\tchar *s;\n\tchar *d;\n\tint ret;\n\n\tret = alloc_rbio_pages(rbio);\n\tif (ret)\n\t\treturn;\n\n\tfor (i = 0; i < rbio->nr_pages; i++) {\n\t\tif (!rbio->bio_pages[i])\n\t\t\tcontinue;\n\n\t\ts = kmap(rbio->bio_pages[i]);\n\t\td = kmap(rbio->stripe_pages[i]);\n\n\t\tmemcpy(d, s, PAGE_CACHE_SIZE);\n\n\t\tkunmap(rbio->bio_pages[i]);\n\t\tkunmap(rbio->stripe_pages[i]);\n\t\tSetPageUptodate(rbio->stripe_pages[i]);\n\t}\n\tset_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RBIO_CACHE_READY_BIT\t3"
          ],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_READY_BIT\t3\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void cache_rbio_pages(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\tchar *s;\n\tchar *d;\n\tint ret;\n\n\tret = alloc_rbio_pages(rbio);\n\tif (ret)\n\t\treturn;\n\n\tfor (i = 0; i < rbio->nr_pages; i++) {\n\t\tif (!rbio->bio_pages[i])\n\t\t\tcontinue;\n\n\t\ts = kmap(rbio->bio_pages[i]);\n\t\td = kmap(rbio->stripe_pages[i]);\n\n\t\tmemcpy(d, s, PAGE_CACHE_SIZE);\n\n\t\tkunmap(rbio->bio_pages[i]);\n\t\tkunmap(rbio->stripe_pages[i]);\n\t\tSetPageUptodate(rbio->stripe_pages[i]);\n\t}\n\tset_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pointers"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rbio_stripe_page",
          "args": [
            "rbio",
            "stripe",
            "pagenr"
          ],
          "line": 1958
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_stripe_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1125-1131",
          "snippet": "static struct page *rbio_stripe_page(struct btrfs_raid_bio *rbio, int stripe, int page)\n{\n\tint index;\n\tindex = stripe * (rbio->stripe_len >> PAGE_CACHE_SHIFT);\n\tindex += page;\n\treturn rbio->stripe_pages[index];\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic struct page *rbio_stripe_page(struct btrfs_raid_bio *rbio, int stripe, int page)\n{\n\tint index;\n\tindex = stripe * (rbio->stripe_len >> PAGE_CACHE_SHIFT);\n\tindex += page;\n\treturn rbio->stripe_pages[index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_in_rbio",
          "args": [
            "rbio",
            "stripe",
            "pagenr",
            "0"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "page_in_rbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "923-939",
          "snippet": "static struct page *page_in_rbio(struct btrfs_raid_bio *rbio,\n\t\t\t\t int index, int pagenr, int bio_list_only)\n{\n\tint chunk_page;\n\tstruct page *p = NULL;\n\n\tchunk_page = index * (rbio->stripe_len >> PAGE_SHIFT) + pagenr;\n\n\tspin_lock_irq(&rbio->bio_list_lock);\n\tp = rbio->bio_pages[chunk_page];\n\tspin_unlock_irq(&rbio->bio_list_lock);\n\n\tif (p || bio_list_only)\n\t\treturn p;\n\n\treturn rbio->stripe_pages[chunk_page];\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic struct page *page_in_rbio(struct btrfs_raid_bio *rbio,\n\t\t\t\t int index, int pagenr, int bio_list_only)\n{\n\tint chunk_page;\n\tstruct page *p = NULL;\n\n\tchunk_page = index * (rbio->stripe_len >> PAGE_SHIFT) + pagenr;\n\n\tspin_lock_irq(&rbio->bio_list_lock);\n\tp = rbio->bio_pages[chunk_page];\n\tspin_unlock_irq(&rbio->bio_list_lock);\n\n\tif (p || bio_list_only)\n\t\treturn p;\n\n\treturn rbio->stripe_pages[chunk_page];\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_xor",
          "args": [
            "pointers",
            "rbio->nr_data - 1",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1929
        },
        "resolved": true,
        "details": {
          "function_name": "run_xor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "520-533",
          "snippet": "static void run_xor(void **pages, int src_cnt, ssize_t len)\n{\n\tint src_off = 0;\n\tint xor_src_cnt = 0;\n\tvoid *dest = pages[src_cnt];\n\n\twhile(src_cnt > 0) {\n\t\txor_src_cnt = min(src_cnt, MAX_XOR_BLOCKS);\n\t\txor_blocks(xor_src_cnt, len, dest, pages + src_off);\n\n\t\tsrc_cnt -= xor_src_cnt;\n\t\tsrc_off += xor_src_cnt;\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic void run_xor(void **pages, int src_cnt, ssize_t len)\n{\n\tint src_off = 0;\n\tint xor_src_cnt = 0;\n\tvoid *dest = pages[src_cnt];\n\n\twhile(src_cnt > 0) {\n\t\txor_src_cnt = min(src_cnt, MAX_XOR_BLOCKS);\n\t\txor_blocks(xor_src_cnt, len, dest, pages + src_off);\n\n\t\tsrc_cnt -= xor_src_cnt;\n\t\tsrc_off += xor_src_cnt;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pointers[faila]",
            "pointers[rbio->nr_data]",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "failb != -1"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raid6_2data_recov",
          "args": [
            "rbio->real_stripes",
            "PAGE_SIZE",
            "faila",
            "failb",
            "pointers"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raid6_datap_recov",
          "args": [
            "rbio->real_stripes",
            "PAGE_SIZE",
            "faila",
            "pointers"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "pagenr",
            "rbio->dbitmap"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_rbio_pages",
          "args": [
            "rbio"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "index_rbio_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1141-1162",
          "snippet": "static void index_rbio_pages(struct btrfs_raid_bio *rbio)\n{\n\tstruct bio *bio;\n\tu64 start;\n\tunsigned long stripe_offset;\n\tunsigned long page_index;\n\tstruct page *p;\n\tint i;\n\n\tspin_lock_irq(&rbio->bio_list_lock);\n\tbio_list_for_each(bio, &rbio->bio_list) {\n\t\tstart = (u64)bio->bi_iter.bi_sector << 9;\n\t\tstripe_offset = start - rbio->bbio->raid_map[0];\n\t\tpage_index = stripe_offset >> PAGE_CACHE_SHIFT;\n\n\t\tfor (i = 0; i < bio->bi_vcnt; i++) {\n\t\t\tp = bio->bi_io_vec[i].bv_page;\n\t\t\trbio->bio_pages[page_index + i] = p;\n\t\t}\n\t}\n\tspin_unlock_irq(&rbio->bio_list_lock);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio)\n{\n\tstruct bio *bio;\n\tu64 start;\n\tunsigned long stripe_offset;\n\tunsigned long page_index;\n\tstruct page *p;\n\tint i;\n\n\tspin_lock_irq(&rbio->bio_list_lock);\n\tbio_list_for_each(bio, &rbio->bio_list) {\n\t\tstart = (u64)bio->bi_iter.bi_sector << 9;\n\t\tstripe_offset = start - rbio->bbio->raid_map[0];\n\t\tpage_index = stripe_offset >> PAGE_CACHE_SHIFT;\n\n\t\tfor (i = 0; i < bio->bi_vcnt; i++) {\n\t\t\tp = bio->bi_io_vec[i].bv_page;\n\t\t\trbio->bio_pages[page_index + i] = p;\n\t\t}\n\t}\n\tspin_unlock_irq(&rbio->bio_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&rbio->bio_list_lock"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "RBIO_RMW_LOCKED_BIT",
            "&rbio->flags"
          ],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&rbio->bio_list_lock"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "rbio->real_stripes * sizeof(void *)",
            "GFP_NOFS"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "rbio->stripe_len",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_READY_BIT\t3\n#define RBIO_RMW_LOCKED_BIT\t1\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void __raid_recover_end_io(struct btrfs_raid_bio *rbio)\n{\n\tint pagenr, stripe;\n\tvoid **pointers;\n\tint faila = -1, failb = -1;\n\tint nr_pages = DIV_ROUND_UP(rbio->stripe_len, PAGE_CACHE_SIZE);\n\tstruct page *page;\n\tint err;\n\tint i;\n\n\tpointers = kzalloc(rbio->real_stripes * sizeof(void *),\n\t\t\t   GFP_NOFS);\n\tif (!pointers) {\n\t\terr = -ENOMEM;\n\t\tgoto cleanup_io;\n\t}\n\n\tfaila = rbio->faila;\n\tfailb = rbio->failb;\n\n\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD) {\n\t\tspin_lock_irq(&rbio->bio_list_lock);\n\t\tset_bit(RBIO_RMW_LOCKED_BIT, &rbio->flags);\n\t\tspin_unlock_irq(&rbio->bio_list_lock);\n\t}\n\n\tindex_rbio_pages(rbio);\n\n\tfor (pagenr = 0; pagenr < nr_pages; pagenr++) {\n\t\t/*\n\t\t * Now we just use bitmap to mark the horizontal stripes in\n\t\t * which we have data when doing parity scrub.\n\t\t */\n\t\tif (rbio->operation == BTRFS_RBIO_PARITY_SCRUB &&\n\t\t    !test_bit(pagenr, rbio->dbitmap))\n\t\t\tcontinue;\n\n\t\t/* setup our array of pointers with pages\n\t\t * from each stripe\n\t\t */\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\t\t/*\n\t\t\t * if we're rebuilding a read, we have to use\n\t\t\t * pages from the bio list\n\t\t\t */\n\t\t\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD &&\n\t\t\t    (stripe == faila || stripe == failb)) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\t} else {\n\t\t\t\tpage = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\t\t\tpointers[stripe] = kmap(page);\n\t\t}\n\n\t\t/* all raid6 handling here */\n\t\tif (rbio->bbio->map_type & BTRFS_BLOCK_GROUP_RAID6) {\n\t\t\t/*\n\t\t\t * single failure, rebuild from parity raid5\n\t\t\t * style\n\t\t\t */\n\t\t\tif (failb < 0) {\n\t\t\t\tif (faila == rbio->nr_data) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Just the P stripe has failed, without\n\t\t\t\t\t * a bad data or Q stripe.\n\t\t\t\t\t * TODO, we should redo the xor here.\n\t\t\t\t\t */\n\t\t\t\t\terr = -EIO;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * a single failure in raid6 is rebuilt\n\t\t\t\t * in the pstripe code below\n\t\t\t\t */\n\t\t\t\tgoto pstripe;\n\t\t\t}\n\n\t\t\t/* make sure our ps and qs are in order */\n\t\t\tif (faila > failb) {\n\t\t\t\tint tmp = failb;\n\t\t\t\tfailb = faila;\n\t\t\t\tfaila = tmp;\n\t\t\t}\n\n\t\t\t/* if the q stripe is failed, do a pstripe reconstruction\n\t\t\t * from the xors.\n\t\t\t * If both the q stripe and the P stripe are failed, we're\n\t\t\t * here due to a crc mismatch and we can't give them the\n\t\t\t * data they want\n\t\t\t */\n\t\t\tif (rbio->bbio->raid_map[failb] == RAID6_Q_STRIPE) {\n\t\t\t\tif (rbio->bbio->raid_map[faila] ==\n\t\t\t\t    RAID5_P_STRIPE) {\n\t\t\t\t\terr = -EIO;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * otherwise we have one bad data stripe and\n\t\t\t\t * a good P stripe.  raid5!\n\t\t\t\t */\n\t\t\t\tgoto pstripe;\n\t\t\t}\n\n\t\t\tif (rbio->bbio->raid_map[failb] == RAID5_P_STRIPE) {\n\t\t\t\traid6_datap_recov(rbio->real_stripes,\n\t\t\t\t\t\t  PAGE_SIZE, faila, pointers);\n\t\t\t} else {\n\t\t\t\traid6_2data_recov(rbio->real_stripes,\n\t\t\t\t\t\t  PAGE_SIZE, faila, failb,\n\t\t\t\t\t\t  pointers);\n\t\t\t}\n\t\t} else {\n\t\t\tvoid *p;\n\n\t\t\t/* rebuild from P stripe here (raid5 or raid6) */\n\t\t\tBUG_ON(failb != -1);\npstripe:\n\t\t\t/* Copy parity block into failed block to start with */\n\t\t\tmemcpy(pointers[faila],\n\t\t\t       pointers[rbio->nr_data],\n\t\t\t       PAGE_CACHE_SIZE);\n\n\t\t\t/* rearrange the pointer array */\n\t\t\tp = pointers[faila];\n\t\t\tfor (stripe = faila; stripe < rbio->nr_data - 1; stripe++)\n\t\t\t\tpointers[stripe] = pointers[stripe + 1];\n\t\t\tpointers[rbio->nr_data - 1] = p;\n\n\t\t\t/* xor in the rest */\n\t\t\trun_xor(pointers, rbio->nr_data - 1, PAGE_CACHE_SIZE);\n\t\t}\n\t\t/* if we're doing this rebuild as part of an rmw, go through\n\t\t * and set all of our private rbio pages in the\n\t\t * failed stripes as uptodate.  This way finish_rmw will\n\t\t * know they can be trusted.  If this was a read reconstruction,\n\t\t * other endio functions will fiddle the uptodate bits\n\t\t */\n\t\tif (rbio->operation == BTRFS_RBIO_WRITE) {\n\t\t\tfor (i = 0;  i < nr_pages; i++) {\n\t\t\t\tif (faila != -1) {\n\t\t\t\t\tpage = rbio_stripe_page(rbio, faila, i);\n\t\t\t\t\tSetPageUptodate(page);\n\t\t\t\t}\n\t\t\t\tif (failb != -1) {\n\t\t\t\t\tpage = rbio_stripe_page(rbio, failb, i);\n\t\t\t\t\tSetPageUptodate(page);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\t\t/*\n\t\t\t * if we're rebuilding a read, we have to use\n\t\t\t * pages from the bio list\n\t\t\t */\n\t\t\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD &&\n\t\t\t    (stripe == faila || stripe == failb)) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\t} else {\n\t\t\t\tpage = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\t\t\tkunmap(page);\n\t\t}\n\t}\n\n\terr = 0;\ncleanup:\n\tkfree(pointers);\n\ncleanup_io:\n\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD) {\n\t\tif (err == 0)\n\t\t\tcache_rbio_pages(rbio);\n\t\telse\n\t\t\tclear_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n\n\t\trbio_orig_end_io(rbio, err, err == 0);\n\t} else if (err == 0) {\n\t\trbio->faila = -1;\n\t\trbio->failb = -1;\n\n\t\tif (rbio->operation == BTRFS_RBIO_WRITE)\n\t\t\tfinish_rmw(rbio);\n\t\telse if (rbio->operation == BTRFS_RBIO_PARITY_SCRUB)\n\t\t\tfinish_parity_scrub(rbio, 0);\n\t\telse\n\t\t\tBUG();\n\t} else {\n\t\trbio_orig_end_io(rbio, err, 0);\n\t}\n}"
  },
  {
    "function_name": "raid56_parity_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "1746-1793",
    "snippet": "int raid56_parity_write(struct btrfs_root *root, struct bio *bio,\n\t\t\tstruct btrfs_bio *bbio, u64 stripe_len)\n{\n\tstruct btrfs_raid_bio *rbio;\n\tstruct btrfs_plug_cb *plug = NULL;\n\tstruct blk_plug_cb *cb;\n\tint ret;\n\n\trbio = alloc_rbio(root, bbio, stripe_len);\n\tif (IS_ERR(rbio)) {\n\t\tbtrfs_put_bbio(bbio);\n\t\treturn PTR_ERR(rbio);\n\t}\n\tbio_list_add(&rbio->bio_list, bio);\n\trbio->bio_list_bytes = bio->bi_iter.bi_size;\n\trbio->operation = BTRFS_RBIO_WRITE;\n\n\tbtrfs_bio_counter_inc_noblocked(root->fs_info);\n\trbio->generic_bio_cnt = 1;\n\n\t/*\n\t * don't plug on full rbios, just get them out the door\n\t * as quickly as we can\n\t */\n\tif (rbio_is_full(rbio)) {\n\t\tret = full_stripe_write(rbio);\n\t\tif (ret)\n\t\t\tbtrfs_bio_counter_dec(root->fs_info);\n\t\treturn ret;\n\t}\n\n\tcb = blk_check_plugged(btrfs_raid_unplug, root->fs_info,\n\t\t\t       sizeof(*plug));\n\tif (cb) {\n\t\tplug = container_of(cb, struct btrfs_plug_cb, cb);\n\t\tif (!plug->info) {\n\t\t\tplug->info = root->fs_info;\n\t\t\tINIT_LIST_HEAD(&plug->rbio_list);\n\t\t}\n\t\tlist_add_tail(&rbio->plug_list, &plug->rbio_list);\n\t\tret = 0;\n\t} else {\n\t\tret = __raid56_parity_write(rbio);\n\t\tif (ret)\n\t\t\tbtrfs_bio_counter_dec(root->fs_info);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_bio_counter_dec",
          "args": [
            "root->fs_info"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bio_counter_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4159-4162",
          "snippet": "static inline void btrfs_bio_counter_dec(struct btrfs_fs_info *fs_info)\n{\n\tbtrfs_bio_counter_sub(fs_info, 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_bio_counter_dec(struct btrfs_fs_info *fs_info)\n{\n\tbtrfs_bio_counter_sub(fs_info, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__raid56_parity_write",
          "args": [
            "rbio"
          ],
          "line": 1788
        },
        "resolved": true,
        "details": {
          "function_name": "__raid56_parity_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1638-1644",
          "snippet": "static int __raid56_parity_write(struct btrfs_raid_bio *rbio)\n{\n\t/* head off into rmw land if we don't have a full stripe */\n\tif (!rbio_is_full(rbio))\n\t\treturn partial_stripe_write(rbio);\n\treturn full_stripe_write(rbio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int __raid56_parity_write(struct btrfs_raid_bio *rbio)\n{\n\t/* head off into rmw land if we don't have a full stripe */\n\tif (!rbio_is_full(rbio))\n\t\treturn partial_stripe_write(rbio);\n\treturn full_stripe_write(rbio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&rbio->plug_list",
            "&plug->rbio_list"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&plug->rbio_list"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "cb",
            "structbtrfs_plug_cb",
            "cb"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_check_plugged",
          "args": [
            "btrfs_raid_unplug",
            "root->fs_info",
            "sizeof(*plug)"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "full_stripe_write",
          "args": [
            "rbio"
          ],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "full_stripe_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1601-1615",
          "snippet": "static int full_stripe_write(struct btrfs_raid_bio *rbio)\n{\n\tint ret;\n\n\tret = alloc_rbio_parity_pages(rbio);\n\tif (ret) {\n\t\t__free_raid_bio(rbio);\n\t\treturn ret;\n\t}\n\n\tret = lock_stripe_add(rbio);\n\tif (ret == 0)\n\t\tfinish_rmw(rbio);\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int full_stripe_write(struct btrfs_raid_bio *rbio)\n{\n\tint ret;\n\n\tret = alloc_rbio_parity_pages(rbio);\n\tif (ret) {\n\t\t__free_raid_bio(rbio);\n\t\treturn ret;\n\t}\n\n\tret = lock_stripe_add(rbio);\n\tif (ret == 0)\n\t\tfinish_rmw(rbio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rbio_is_full",
          "args": [
            "rbio"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_is_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "554-563",
          "snippet": "static int rbio_is_full(struct btrfs_raid_bio *rbio)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&rbio->bio_list_lock, flags);\n\tret = __rbio_is_full(rbio);\n\tspin_unlock_irqrestore(&rbio->bio_list_lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int rbio_is_full(struct btrfs_raid_bio *rbio)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&rbio->bio_list_lock, flags);\n\tret = __rbio_is_full(rbio);\n\tspin_unlock_irqrestore(&rbio->bio_list_lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_bio_counter_inc_noblocked",
          "args": [
            "root->fs_info"
          ],
          "line": 1763
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bio_counter_inc_noblocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "911-914",
          "snippet": "void btrfs_bio_counter_inc_noblocked(struct btrfs_fs_info *fs_info)\n{\n\tpercpu_counter_inc(&fs_info->bio_counter);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
            "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nvoid btrfs_bio_counter_inc_noblocked(struct btrfs_fs_info *fs_info)\n{\n\tpercpu_counter_inc(&fs_info->bio_counter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_list_add",
          "args": [
            "&rbio->bio_list",
            "bio"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rbio"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_put_bbio",
          "args": [
            "bbio"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_bbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4933-4939",
          "snippet": "void btrfs_put_bbio(struct btrfs_bio *bbio)\n{\n\tif (!bbio)\n\t\treturn;\n\tif (atomic_dec_and_test(&bbio->refs))\n\t\tkfree(bbio);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_put_bbio(struct btrfs_bio *bbio)\n{\n\tif (!bbio)\n\t\treturn;\n\tif (atomic_dec_and_test(&bbio->refs))\n\t\tkfree(bbio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rbio"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_rbio",
          "args": [
            "root",
            "bbio",
            "stripe_len"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_rbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "955-1006",
          "snippet": "static struct btrfs_raid_bio *alloc_rbio(struct btrfs_root *root,\n\t\t\t  struct btrfs_bio *bbio, u64 stripe_len)\n{\n\tstruct btrfs_raid_bio *rbio;\n\tint nr_data = 0;\n\tint real_stripes = bbio->num_stripes - bbio->num_tgtdevs;\n\tint num_pages = rbio_nr_pages(stripe_len, real_stripes);\n\tint stripe_npages = DIV_ROUND_UP(stripe_len, PAGE_SIZE);\n\tvoid *p;\n\n\trbio = kzalloc(sizeof(*rbio) + num_pages * sizeof(struct page *) * 2 +\n\t\t       DIV_ROUND_UP(stripe_npages, BITS_PER_LONG / 8),\n\t\t\tGFP_NOFS);\n\tif (!rbio)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbio_list_init(&rbio->bio_list);\n\tINIT_LIST_HEAD(&rbio->plug_list);\n\tspin_lock_init(&rbio->bio_list_lock);\n\tINIT_LIST_HEAD(&rbio->stripe_cache);\n\tINIT_LIST_HEAD(&rbio->hash_list);\n\trbio->bbio = bbio;\n\trbio->fs_info = root->fs_info;\n\trbio->stripe_len = stripe_len;\n\trbio->nr_pages = num_pages;\n\trbio->real_stripes = real_stripes;\n\trbio->stripe_npages = stripe_npages;\n\trbio->faila = -1;\n\trbio->failb = -1;\n\tatomic_set(&rbio->refs, 1);\n\tatomic_set(&rbio->error, 0);\n\tatomic_set(&rbio->stripes_pending, 0);\n\n\t/*\n\t * the stripe_pages and bio_pages array point to the extra\n\t * memory we allocated past the end of the rbio\n\t */\n\tp = rbio + 1;\n\trbio->stripe_pages = p;\n\trbio->bio_pages = p + sizeof(struct page *) * num_pages;\n\trbio->dbitmap = p + sizeof(struct page *) * num_pages * 2;\n\n\tif (bbio->map_type & BTRFS_BLOCK_GROUP_RAID5)\n\t\tnr_data = real_stripes - 1;\n\telse if (bbio->map_type & BTRFS_BLOCK_GROUP_RAID6)\n\t\tnr_data = real_stripes - 2;\n\telse\n\t\tBUG();\n\n\trbio->nr_data = nr_data;\n\treturn rbio;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic struct btrfs_raid_bio *alloc_rbio(struct btrfs_root *root,\n\t\t\t  struct btrfs_bio *bbio, u64 stripe_len)\n{\n\tstruct btrfs_raid_bio *rbio;\n\tint nr_data = 0;\n\tint real_stripes = bbio->num_stripes - bbio->num_tgtdevs;\n\tint num_pages = rbio_nr_pages(stripe_len, real_stripes);\n\tint stripe_npages = DIV_ROUND_UP(stripe_len, PAGE_SIZE);\n\tvoid *p;\n\n\trbio = kzalloc(sizeof(*rbio) + num_pages * sizeof(struct page *) * 2 +\n\t\t       DIV_ROUND_UP(stripe_npages, BITS_PER_LONG / 8),\n\t\t\tGFP_NOFS);\n\tif (!rbio)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbio_list_init(&rbio->bio_list);\n\tINIT_LIST_HEAD(&rbio->plug_list);\n\tspin_lock_init(&rbio->bio_list_lock);\n\tINIT_LIST_HEAD(&rbio->stripe_cache);\n\tINIT_LIST_HEAD(&rbio->hash_list);\n\trbio->bbio = bbio;\n\trbio->fs_info = root->fs_info;\n\trbio->stripe_len = stripe_len;\n\trbio->nr_pages = num_pages;\n\trbio->real_stripes = real_stripes;\n\trbio->stripe_npages = stripe_npages;\n\trbio->faila = -1;\n\trbio->failb = -1;\n\tatomic_set(&rbio->refs, 1);\n\tatomic_set(&rbio->error, 0);\n\tatomic_set(&rbio->stripes_pending, 0);\n\n\t/*\n\t * the stripe_pages and bio_pages array point to the extra\n\t * memory we allocated past the end of the rbio\n\t */\n\tp = rbio + 1;\n\trbio->stripe_pages = p;\n\trbio->bio_pages = p + sizeof(struct page *) * num_pages;\n\trbio->dbitmap = p + sizeof(struct page *) * num_pages * 2;\n\n\tif (bbio->map_type & BTRFS_BLOCK_GROUP_RAID5)\n\t\tnr_data = real_stripes - 1;\n\telse if (bbio->map_type & BTRFS_BLOCK_GROUP_RAID6)\n\t\tnr_data = real_stripes - 2;\n\telse\n\t\tBUG();\n\n\trbio->nr_data = nr_data;\n\treturn rbio;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nint raid56_parity_write(struct btrfs_root *root, struct bio *bio,\n\t\t\tstruct btrfs_bio *bbio, u64 stripe_len)\n{\n\tstruct btrfs_raid_bio *rbio;\n\tstruct btrfs_plug_cb *plug = NULL;\n\tstruct blk_plug_cb *cb;\n\tint ret;\n\n\trbio = alloc_rbio(root, bbio, stripe_len);\n\tif (IS_ERR(rbio)) {\n\t\tbtrfs_put_bbio(bbio);\n\t\treturn PTR_ERR(rbio);\n\t}\n\tbio_list_add(&rbio->bio_list, bio);\n\trbio->bio_list_bytes = bio->bi_iter.bi_size;\n\trbio->operation = BTRFS_RBIO_WRITE;\n\n\tbtrfs_bio_counter_inc_noblocked(root->fs_info);\n\trbio->generic_bio_cnt = 1;\n\n\t/*\n\t * don't plug on full rbios, just get them out the door\n\t * as quickly as we can\n\t */\n\tif (rbio_is_full(rbio)) {\n\t\tret = full_stripe_write(rbio);\n\t\tif (ret)\n\t\t\tbtrfs_bio_counter_dec(root->fs_info);\n\t\treturn ret;\n\t}\n\n\tcb = blk_check_plugged(btrfs_raid_unplug, root->fs_info,\n\t\t\t       sizeof(*plug));\n\tif (cb) {\n\t\tplug = container_of(cb, struct btrfs_plug_cb, cb);\n\t\tif (!plug->info) {\n\t\t\tplug->info = root->fs_info;\n\t\t\tINIT_LIST_HEAD(&plug->rbio_list);\n\t\t}\n\t\tlist_add_tail(&rbio->plug_list, &plug->rbio_list);\n\t\tret = 0;\n\t} else {\n\t\tret = __raid56_parity_write(rbio);\n\t\tif (ret)\n\t\t\tbtrfs_bio_counter_dec(root->fs_info);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_raid_unplug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "1728-1741",
    "snippet": "static void btrfs_raid_unplug(struct blk_plug_cb *cb, bool from_schedule)\n{\n\tstruct btrfs_plug_cb *plug;\n\tplug = container_of(cb, struct btrfs_plug_cb, cb);\n\n\tif (from_schedule) {\n\t\tbtrfs_init_work(&plug->work, btrfs_rmw_helper,\n\t\t\t\tunplug_work, NULL, NULL);\n\t\tbtrfs_queue_work(plug->info->rmw_workers,\n\t\t\t\t &plug->work);\n\t\treturn;\n\t}\n\trun_plug(plug);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void rmw_work(struct btrfs_work *work);",
      "static void read_rebuild_work(struct btrfs_work *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "run_plug",
          "args": [
            "plug"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "run_plug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1679-1715",
          "snippet": "static void run_plug(struct btrfs_plug_cb *plug)\n{\n\tstruct btrfs_raid_bio *cur;\n\tstruct btrfs_raid_bio *last = NULL;\n\n\t/*\n\t * sort our plug list then try to merge\n\t * everything we can in hopes of creating full\n\t * stripes.\n\t */\n\tlist_sort(NULL, &plug->rbio_list, plug_cmp);\n\twhile (!list_empty(&plug->rbio_list)) {\n\t\tcur = list_entry(plug->rbio_list.next,\n\t\t\t\t struct btrfs_raid_bio, plug_list);\n\t\tlist_del_init(&cur->plug_list);\n\n\t\tif (rbio_is_full(cur)) {\n\t\t\t/* we have a full stripe, send it down */\n\t\t\tfull_stripe_write(cur);\n\t\t\tcontinue;\n\t\t}\n\t\tif (last) {\n\t\t\tif (rbio_can_merge(last, cur)) {\n\t\t\t\tmerge_rbio(last, cur);\n\t\t\t\t__free_raid_bio(cur);\n\t\t\t\tcontinue;\n\n\t\t\t}\n\t\t\t__raid56_parity_write(last);\n\t\t}\n\t\tlast = cur;\n\t}\n\tif (last) {\n\t\t__raid56_parity_write(last);\n\t}\n\tkfree(plug);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic void run_plug(struct btrfs_plug_cb *plug)\n{\n\tstruct btrfs_raid_bio *cur;\n\tstruct btrfs_raid_bio *last = NULL;\n\n\t/*\n\t * sort our plug list then try to merge\n\t * everything we can in hopes of creating full\n\t * stripes.\n\t */\n\tlist_sort(NULL, &plug->rbio_list, plug_cmp);\n\twhile (!list_empty(&plug->rbio_list)) {\n\t\tcur = list_entry(plug->rbio_list.next,\n\t\t\t\t struct btrfs_raid_bio, plug_list);\n\t\tlist_del_init(&cur->plug_list);\n\n\t\tif (rbio_is_full(cur)) {\n\t\t\t/* we have a full stripe, send it down */\n\t\t\tfull_stripe_write(cur);\n\t\t\tcontinue;\n\t\t}\n\t\tif (last) {\n\t\t\tif (rbio_can_merge(last, cur)) {\n\t\t\t\tmerge_rbio(last, cur);\n\t\t\t\t__free_raid_bio(cur);\n\t\t\t\tcontinue;\n\n\t\t\t}\n\t\t\t__raid56_parity_write(last);\n\t\t}\n\t\tlast = cur;\n\t}\n\tif (last) {\n\t\t__raid56_parity_write(last);\n\t}\n\tkfree(plug);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_queue_work",
          "args": [
            "plug->info->rmw_workers",
            "&plug->work"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "323-333",
          "snippet": "void btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define WORK_HIGH_PRIO_BIT 2"
          ],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);",
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define WORK_HIGH_PRIO_BIT 2\n\nstatic void normal_work_helper(struct btrfs_work *work);\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_init_work",
          "args": [
            "&plug->work",
            "btrfs_rmw_helper",
            "unplug_work",
            "NULL",
            "NULL"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "294-305",
          "snippet": "void btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic void normal_work_helper(struct btrfs_work *work);\n\nvoid btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "cb",
            "structbtrfs_plug_cb",
            "cb"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic void rmw_work(struct btrfs_work *work);\nstatic void read_rebuild_work(struct btrfs_work *work);\n\nstatic void btrfs_raid_unplug(struct blk_plug_cb *cb, bool from_schedule)\n{\n\tstruct btrfs_plug_cb *plug;\n\tplug = container_of(cb, struct btrfs_plug_cb, cb);\n\n\tif (from_schedule) {\n\t\tbtrfs_init_work(&plug->work, btrfs_rmw_helper,\n\t\t\t\tunplug_work, NULL, NULL);\n\t\tbtrfs_queue_work(plug->info->rmw_workers,\n\t\t\t\t &plug->work);\n\t\treturn;\n\t}\n\trun_plug(plug);\n}"
  },
  {
    "function_name": "unplug_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "1721-1726",
    "snippet": "static void unplug_work(struct btrfs_work *work)\n{\n\tstruct btrfs_plug_cb *plug;\n\tplug = container_of(work, struct btrfs_plug_cb, work);\n\trun_plug(plug);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void rmw_work(struct btrfs_work *work);",
      "static void read_rebuild_work(struct btrfs_work *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "run_plug",
          "args": [
            "plug"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "run_plug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1679-1715",
          "snippet": "static void run_plug(struct btrfs_plug_cb *plug)\n{\n\tstruct btrfs_raid_bio *cur;\n\tstruct btrfs_raid_bio *last = NULL;\n\n\t/*\n\t * sort our plug list then try to merge\n\t * everything we can in hopes of creating full\n\t * stripes.\n\t */\n\tlist_sort(NULL, &plug->rbio_list, plug_cmp);\n\twhile (!list_empty(&plug->rbio_list)) {\n\t\tcur = list_entry(plug->rbio_list.next,\n\t\t\t\t struct btrfs_raid_bio, plug_list);\n\t\tlist_del_init(&cur->plug_list);\n\n\t\tif (rbio_is_full(cur)) {\n\t\t\t/* we have a full stripe, send it down */\n\t\t\tfull_stripe_write(cur);\n\t\t\tcontinue;\n\t\t}\n\t\tif (last) {\n\t\t\tif (rbio_can_merge(last, cur)) {\n\t\t\t\tmerge_rbio(last, cur);\n\t\t\t\t__free_raid_bio(cur);\n\t\t\t\tcontinue;\n\n\t\t\t}\n\t\t\t__raid56_parity_write(last);\n\t\t}\n\t\tlast = cur;\n\t}\n\tif (last) {\n\t\t__raid56_parity_write(last);\n\t}\n\tkfree(plug);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic void run_plug(struct btrfs_plug_cb *plug)\n{\n\tstruct btrfs_raid_bio *cur;\n\tstruct btrfs_raid_bio *last = NULL;\n\n\t/*\n\t * sort our plug list then try to merge\n\t * everything we can in hopes of creating full\n\t * stripes.\n\t */\n\tlist_sort(NULL, &plug->rbio_list, plug_cmp);\n\twhile (!list_empty(&plug->rbio_list)) {\n\t\tcur = list_entry(plug->rbio_list.next,\n\t\t\t\t struct btrfs_raid_bio, plug_list);\n\t\tlist_del_init(&cur->plug_list);\n\n\t\tif (rbio_is_full(cur)) {\n\t\t\t/* we have a full stripe, send it down */\n\t\t\tfull_stripe_write(cur);\n\t\t\tcontinue;\n\t\t}\n\t\tif (last) {\n\t\t\tif (rbio_can_merge(last, cur)) {\n\t\t\t\tmerge_rbio(last, cur);\n\t\t\t\t__free_raid_bio(cur);\n\t\t\t\tcontinue;\n\n\t\t\t}\n\t\t\t__raid56_parity_write(last);\n\t\t}\n\t\tlast = cur;\n\t}\n\tif (last) {\n\t\t__raid56_parity_write(last);\n\t}\n\tkfree(plug);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structbtrfs_plug_cb",
            "work"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic void rmw_work(struct btrfs_work *work);\nstatic void read_rebuild_work(struct btrfs_work *work);\n\nstatic void unplug_work(struct btrfs_work *work)\n{\n\tstruct btrfs_plug_cb *plug;\n\tplug = container_of(work, struct btrfs_plug_cb, work);\n\trun_plug(plug);\n}"
  },
  {
    "function_name": "run_plug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "1679-1715",
    "snippet": "static void run_plug(struct btrfs_plug_cb *plug)\n{\n\tstruct btrfs_raid_bio *cur;\n\tstruct btrfs_raid_bio *last = NULL;\n\n\t/*\n\t * sort our plug list then try to merge\n\t * everything we can in hopes of creating full\n\t * stripes.\n\t */\n\tlist_sort(NULL, &plug->rbio_list, plug_cmp);\n\twhile (!list_empty(&plug->rbio_list)) {\n\t\tcur = list_entry(plug->rbio_list.next,\n\t\t\t\t struct btrfs_raid_bio, plug_list);\n\t\tlist_del_init(&cur->plug_list);\n\n\t\tif (rbio_is_full(cur)) {\n\t\t\t/* we have a full stripe, send it down */\n\t\t\tfull_stripe_write(cur);\n\t\t\tcontinue;\n\t\t}\n\t\tif (last) {\n\t\t\tif (rbio_can_merge(last, cur)) {\n\t\t\t\tmerge_rbio(last, cur);\n\t\t\t\t__free_raid_bio(cur);\n\t\t\t\tcontinue;\n\n\t\t\t}\n\t\t\t__raid56_parity_write(last);\n\t\t}\n\t\tlast = cur;\n\t}\n\tif (last) {\n\t\t__raid56_parity_write(last);\n\t}\n\tkfree(plug);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "plug"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__raid56_parity_write",
          "args": [
            "last"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "__raid56_parity_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1638-1644",
          "snippet": "static int __raid56_parity_write(struct btrfs_raid_bio *rbio)\n{\n\t/* head off into rmw land if we don't have a full stripe */\n\tif (!rbio_is_full(rbio))\n\t\treturn partial_stripe_write(rbio);\n\treturn full_stripe_write(rbio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int __raid56_parity_write(struct btrfs_raid_bio *rbio)\n{\n\t/* head off into rmw land if we don't have a full stripe */\n\tif (!rbio_is_full(rbio))\n\t\treturn partial_stripe_write(rbio);\n\treturn full_stripe_write(rbio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_raid_bio",
          "args": [
            "cur"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "__free_raid_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "828-849",
          "snippet": "static void __free_raid_bio(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\n\tWARN_ON(atomic_read(&rbio->refs) < 0);\n\tif (!atomic_dec_and_test(&rbio->refs))\n\t\treturn;\n\n\tWARN_ON(!list_empty(&rbio->stripe_cache));\n\tWARN_ON(!list_empty(&rbio->hash_list));\n\tWARN_ON(!bio_list_empty(&rbio->bio_list));\n\n\tfor (i = 0; i < rbio->nr_pages; i++) {\n\t\tif (rbio->stripe_pages[i]) {\n\t\t\t__free_page(rbio->stripe_pages[i]);\n\t\t\trbio->stripe_pages[i] = NULL;\n\t\t}\n\t}\n\n\tbtrfs_put_bbio(rbio->bbio);\n\tkfree(rbio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\n\tWARN_ON(atomic_read(&rbio->refs) < 0);\n\tif (!atomic_dec_and_test(&rbio->refs))\n\t\treturn;\n\n\tWARN_ON(!list_empty(&rbio->stripe_cache));\n\tWARN_ON(!list_empty(&rbio->hash_list));\n\tWARN_ON(!bio_list_empty(&rbio->bio_list));\n\n\tfor (i = 0; i < rbio->nr_pages; i++) {\n\t\tif (rbio->stripe_pages[i]) {\n\t\t\t__free_page(rbio->stripe_pages[i]);\n\t\t\trbio->stripe_pages[i] = NULL;\n\t\t}\n\t}\n\n\tbtrfs_put_bbio(rbio->bbio);\n\tkfree(rbio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_rbio",
          "args": [
            "last",
            "cur"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "merge_rbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "338-345",
          "snippet": "static void merge_rbio(struct btrfs_raid_bio *dest,\n\t\t       struct btrfs_raid_bio *victim)\n{\n\tbio_list_merge(&dest->bio_list, &victim->bio_list);\n\tdest->bio_list_bytes += victim->bio_list_bytes;\n\tdest->generic_bio_cnt += victim->generic_bio_cnt;\n\tbio_list_init(&victim->bio_list);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic void merge_rbio(struct btrfs_raid_bio *dest,\n\t\t       struct btrfs_raid_bio *victim)\n{\n\tbio_list_merge(&dest->bio_list, &victim->bio_list);\n\tdest->bio_list_bytes += victim->bio_list_bytes;\n\tdest->generic_bio_cnt += victim->generic_bio_cnt;\n\tbio_list_init(&victim->bio_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rbio_can_merge",
          "args": [
            "last",
            "cur"
          ],
          "line": 1701
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_can_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "575-613",
          "snippet": "static int rbio_can_merge(struct btrfs_raid_bio *last,\n\t\t\t  struct btrfs_raid_bio *cur)\n{\n\tif (test_bit(RBIO_RMW_LOCKED_BIT, &last->flags) ||\n\t    test_bit(RBIO_RMW_LOCKED_BIT, &cur->flags))\n\t\treturn 0;\n\n\t/*\n\t * we can't merge with cached rbios, since the\n\t * idea is that when we merge the destination\n\t * rbio is going to run our IO for us.  We can\n\t * steal from cached rbio's though, other functions\n\t * handle that.\n\t */\n\tif (test_bit(RBIO_CACHE_BIT, &last->flags) ||\n\t    test_bit(RBIO_CACHE_BIT, &cur->flags))\n\t\treturn 0;\n\n\tif (last->bbio->raid_map[0] !=\n\t    cur->bbio->raid_map[0])\n\t\treturn 0;\n\n\t/* we can't merge with different operations */\n\tif (last->operation != cur->operation)\n\t\treturn 0;\n\t/*\n\t * We've need read the full stripe from the drive.\n\t * check and repair the parity and write the new results.\n\t *\n\t * We're not allowed to add any new bios to the\n\t * bio list here, anyone else that wants to\n\t * change this stripe needs to do their own rmw.\n\t */\n\tif (last->operation == BTRFS_RBIO_PARITY_SCRUB ||\n\t    cur->operation == BTRFS_RBIO_PARITY_SCRUB)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RBIO_CACHE_BIT\t\t2",
            "#define RBIO_RMW_LOCKED_BIT\t1"
          ],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_BIT\t\t2\n#define RBIO_RMW_LOCKED_BIT\t1\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int rbio_can_merge(struct btrfs_raid_bio *last,\n\t\t\t  struct btrfs_raid_bio *cur)\n{\n\tif (test_bit(RBIO_RMW_LOCKED_BIT, &last->flags) ||\n\t    test_bit(RBIO_RMW_LOCKED_BIT, &cur->flags))\n\t\treturn 0;\n\n\t/*\n\t * we can't merge with cached rbios, since the\n\t * idea is that when we merge the destination\n\t * rbio is going to run our IO for us.  We can\n\t * steal from cached rbio's though, other functions\n\t * handle that.\n\t */\n\tif (test_bit(RBIO_CACHE_BIT, &last->flags) ||\n\t    test_bit(RBIO_CACHE_BIT, &cur->flags))\n\t\treturn 0;\n\n\tif (last->bbio->raid_map[0] !=\n\t    cur->bbio->raid_map[0])\n\t\treturn 0;\n\n\t/* we can't merge with different operations */\n\tif (last->operation != cur->operation)\n\t\treturn 0;\n\t/*\n\t * We've need read the full stripe from the drive.\n\t * check and repair the parity and write the new results.\n\t *\n\t * We're not allowed to add any new bios to the\n\t * bio list here, anyone else that wants to\n\t * change this stripe needs to do their own rmw.\n\t */\n\tif (last->operation == BTRFS_RBIO_PARITY_SCRUB ||\n\t    cur->operation == BTRFS_RBIO_PARITY_SCRUB)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "full_stripe_write",
          "args": [
            "cur"
          ],
          "line": 1697
        },
        "resolved": true,
        "details": {
          "function_name": "full_stripe_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1601-1615",
          "snippet": "static int full_stripe_write(struct btrfs_raid_bio *rbio)\n{\n\tint ret;\n\n\tret = alloc_rbio_parity_pages(rbio);\n\tif (ret) {\n\t\t__free_raid_bio(rbio);\n\t\treturn ret;\n\t}\n\n\tret = lock_stripe_add(rbio);\n\tif (ret == 0)\n\t\tfinish_rmw(rbio);\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int full_stripe_write(struct btrfs_raid_bio *rbio)\n{\n\tint ret;\n\n\tret = alloc_rbio_parity_pages(rbio);\n\tif (ret) {\n\t\t__free_raid_bio(rbio);\n\t\treturn ret;\n\t}\n\n\tret = lock_stripe_add(rbio);\n\tif (ret == 0)\n\t\tfinish_rmw(rbio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rbio_is_full",
          "args": [
            "cur"
          ],
          "line": 1695
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_is_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "554-563",
          "snippet": "static int rbio_is_full(struct btrfs_raid_bio *rbio)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&rbio->bio_list_lock, flags);\n\tret = __rbio_is_full(rbio);\n\tspin_unlock_irqrestore(&rbio->bio_list_lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int rbio_is_full(struct btrfs_raid_bio *rbio)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&rbio->bio_list_lock, flags);\n\tret = __rbio_is_full(rbio);\n\tspin_unlock_irqrestore(&rbio->bio_list_lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&cur->plug_list"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "plug->rbio_list.next",
            "structbtrfs_raid_bio",
            "plug_list"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&plug->rbio_list"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_sort",
          "args": [
            "NULL",
            "&plug->rbio_list",
            "plug_cmp"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic void run_plug(struct btrfs_plug_cb *plug)\n{\n\tstruct btrfs_raid_bio *cur;\n\tstruct btrfs_raid_bio *last = NULL;\n\n\t/*\n\t * sort our plug list then try to merge\n\t * everything we can in hopes of creating full\n\t * stripes.\n\t */\n\tlist_sort(NULL, &plug->rbio_list, plug_cmp);\n\twhile (!list_empty(&plug->rbio_list)) {\n\t\tcur = list_entry(plug->rbio_list.next,\n\t\t\t\t struct btrfs_raid_bio, plug_list);\n\t\tlist_del_init(&cur->plug_list);\n\n\t\tif (rbio_is_full(cur)) {\n\t\t\t/* we have a full stripe, send it down */\n\t\t\tfull_stripe_write(cur);\n\t\t\tcontinue;\n\t\t}\n\t\tif (last) {\n\t\t\tif (rbio_can_merge(last, cur)) {\n\t\t\t\tmerge_rbio(last, cur);\n\t\t\t\t__free_raid_bio(cur);\n\t\t\t\tcontinue;\n\n\t\t\t}\n\t\t\t__raid56_parity_write(last);\n\t\t}\n\t\tlast = cur;\n\t}\n\tif (last) {\n\t\t__raid56_parity_write(last);\n\t}\n\tkfree(plug);\n}"
  },
  {
    "function_name": "plug_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "1663-1677",
    "snippet": "static int plug_cmp(void *priv, struct list_head *a, struct list_head *b)\n{\n\tstruct btrfs_raid_bio *ra = container_of(a, struct btrfs_raid_bio,\n\t\t\t\t\t\t plug_list);\n\tstruct btrfs_raid_bio *rb = container_of(b, struct btrfs_raid_bio,\n\t\t\t\t\t\t plug_list);\n\tu64 a_sector = ra->bio_list.head->bi_iter.bi_sector;\n\tu64 b_sector = rb->bio_list.head->bi_iter.bi_sector;\n\n\tif (a_sector < b_sector)\n\t\treturn -1;\n\tif (a_sector > b_sector)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "b",
            "structbtrfs_raid_bio",
            "plug_list"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "a",
            "structbtrfs_raid_bio",
            "plug_list"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int plug_cmp(void *priv, struct list_head *a, struct list_head *b)\n{\n\tstruct btrfs_raid_bio *ra = container_of(a, struct btrfs_raid_bio,\n\t\t\t\t\t\t plug_list);\n\tstruct btrfs_raid_bio *rb = container_of(b, struct btrfs_raid_bio,\n\t\t\t\t\t\t plug_list);\n\tu64 a_sector = ra->bio_list.head->bi_iter.bi_sector;\n\tu64 b_sector = rb->bio_list.head->bi_iter.bi_sector;\n\n\tif (a_sector < b_sector)\n\t\treturn -1;\n\tif (a_sector > b_sector)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "__raid56_parity_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "1638-1644",
    "snippet": "static int __raid56_parity_write(struct btrfs_raid_bio *rbio)\n{\n\t/* head off into rmw land if we don't have a full stripe */\n\tif (!rbio_is_full(rbio))\n\t\treturn partial_stripe_write(rbio);\n\treturn full_stripe_write(rbio);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "full_stripe_write",
          "args": [
            "rbio"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "full_stripe_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1601-1615",
          "snippet": "static int full_stripe_write(struct btrfs_raid_bio *rbio)\n{\n\tint ret;\n\n\tret = alloc_rbio_parity_pages(rbio);\n\tif (ret) {\n\t\t__free_raid_bio(rbio);\n\t\treturn ret;\n\t}\n\n\tret = lock_stripe_add(rbio);\n\tif (ret == 0)\n\t\tfinish_rmw(rbio);\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int full_stripe_write(struct btrfs_raid_bio *rbio)\n{\n\tint ret;\n\n\tret = alloc_rbio_parity_pages(rbio);\n\tif (ret) {\n\t\t__free_raid_bio(rbio);\n\t\treturn ret;\n\t}\n\n\tret = lock_stripe_add(rbio);\n\tif (ret == 0)\n\t\tfinish_rmw(rbio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "partial_stripe_write",
          "args": [
            "rbio"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "partial_stripe_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1622-1630",
          "snippet": "static int partial_stripe_write(struct btrfs_raid_bio *rbio)\n{\n\tint ret;\n\n\tret = lock_stripe_add(rbio);\n\tif (ret == 0)\n\t\tasync_rmw_stripe(rbio);\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int partial_stripe_write(struct btrfs_raid_bio *rbio)\n{\n\tint ret;\n\n\tret = lock_stripe_add(rbio);\n\tif (ret == 0)\n\t\tasync_rmw_stripe(rbio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rbio_is_full",
          "args": [
            "rbio"
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_is_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "554-563",
          "snippet": "static int rbio_is_full(struct btrfs_raid_bio *rbio)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&rbio->bio_list_lock, flags);\n\tret = __rbio_is_full(rbio);\n\tspin_unlock_irqrestore(&rbio->bio_list_lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int rbio_is_full(struct btrfs_raid_bio *rbio)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&rbio->bio_list_lock, flags);\n\tret = __rbio_is_full(rbio);\n\tspin_unlock_irqrestore(&rbio->bio_list_lock, flags);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int __raid56_parity_write(struct btrfs_raid_bio *rbio)\n{\n\t/* head off into rmw land if we don't have a full stripe */\n\tif (!rbio_is_full(rbio))\n\t\treturn partial_stripe_write(rbio);\n\treturn full_stripe_write(rbio);\n}"
  },
  {
    "function_name": "partial_stripe_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "1622-1630",
    "snippet": "static int partial_stripe_write(struct btrfs_raid_bio *rbio)\n{\n\tint ret;\n\n\tret = lock_stripe_add(rbio);\n\tif (ret == 0)\n\t\tasync_rmw_stripe(rbio);\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "async_rmw_stripe",
          "args": [
            "rbio"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "async_rmw_stripe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1482-1489",
          "snippet": "static void async_rmw_stripe(struct btrfs_raid_bio *rbio)\n{\n\tbtrfs_init_work(&rbio->work, btrfs_rmw_helper,\n\t\t\trmw_work, NULL, NULL);\n\n\tbtrfs_queue_work(rbio->fs_info->rmw_workers,\n\t\t\t &rbio->work);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void rmw_work(struct btrfs_work *work);",
            "static void read_rebuild_work(struct btrfs_work *work);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void rmw_work(struct btrfs_work *work);\nstatic void read_rebuild_work(struct btrfs_work *work);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio)\n{\n\tbtrfs_init_work(&rbio->work, btrfs_rmw_helper,\n\t\t\trmw_work, NULL, NULL);\n\n\tbtrfs_queue_work(rbio->fs_info->rmw_workers,\n\t\t\t &rbio->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_stripe_add",
          "args": [
            "rbio"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "lock_stripe_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "660-743",
          "snippet": "static noinline int lock_stripe_add(struct btrfs_raid_bio *rbio)\n{\n\tint bucket = rbio_bucket(rbio);\n\tstruct btrfs_stripe_hash *h = rbio->fs_info->stripe_hash_table->table + bucket;\n\tstruct btrfs_raid_bio *cur;\n\tstruct btrfs_raid_bio *pending;\n\tunsigned long flags;\n\tDEFINE_WAIT(wait);\n\tstruct btrfs_raid_bio *freeit = NULL;\n\tstruct btrfs_raid_bio *cache_drop = NULL;\n\tint ret = 0;\n\tint walk = 0;\n\n\tspin_lock_irqsave(&h->lock, flags);\n\tlist_for_each_entry(cur, &h->hash_list, hash_list) {\n\t\twalk++;\n\t\tif (cur->bbio->raid_map[0] == rbio->bbio->raid_map[0]) {\n\t\t\tspin_lock(&cur->bio_list_lock);\n\n\t\t\t/* can we steal this cached rbio's pages? */\n\t\t\tif (bio_list_empty(&cur->bio_list) &&\n\t\t\t    list_empty(&cur->plug_list) &&\n\t\t\t    test_bit(RBIO_CACHE_BIT, &cur->flags) &&\n\t\t\t    !test_bit(RBIO_RMW_LOCKED_BIT, &cur->flags)) {\n\t\t\t\tlist_del_init(&cur->hash_list);\n\t\t\t\tatomic_dec(&cur->refs);\n\n\t\t\t\tsteal_rbio(cur, rbio);\n\t\t\t\tcache_drop = cur;\n\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\n\t\t\t\tgoto lockit;\n\t\t\t}\n\n\t\t\t/* can we merge into the lock owner? */\n\t\t\tif (rbio_can_merge(cur, rbio)) {\n\t\t\t\tmerge_rbio(cur, rbio);\n\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\t\tfreeit = rbio;\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\n\t\t\t/*\n\t\t\t * we couldn't merge with the running\n\t\t\t * rbio, see if we can merge with the\n\t\t\t * pending ones.  We don't have to\n\t\t\t * check for rmw_locked because there\n\t\t\t * is no way they are inside finish_rmw\n\t\t\t * right now\n\t\t\t */\n\t\t\tlist_for_each_entry(pending, &cur->plug_list,\n\t\t\t\t\t    plug_list) {\n\t\t\t\tif (rbio_can_merge(pending, rbio)) {\n\t\t\t\t\tmerge_rbio(pending, rbio);\n\t\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\t\t\tfreeit = rbio;\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* no merging, put us on the tail of the plug list,\n\t\t\t * our rbio will be started with the currently\n\t\t\t * running rbio unlocks\n\t\t\t */\n\t\t\tlist_add_tail(&rbio->plug_list, &cur->plug_list);\n\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\nlockit:\n\tatomic_inc(&rbio->refs);\n\tlist_add(&rbio->hash_list, &h->hash_list);\nout:\n\tspin_unlock_irqrestore(&h->lock, flags);\n\tif (cache_drop)\n\t\tremove_rbio_from_cache(cache_drop);\n\tif (freeit)\n\t\t__free_raid_bio(freeit);\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RBIO_CACHE_BIT\t\t2",
            "#define RBIO_RMW_LOCKED_BIT\t1"
          ],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_BIT\t\t2\n#define RBIO_RMW_LOCKED_BIT\t1\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic noinline int lock_stripe_add(struct btrfs_raid_bio *rbio)\n{\n\tint bucket = rbio_bucket(rbio);\n\tstruct btrfs_stripe_hash *h = rbio->fs_info->stripe_hash_table->table + bucket;\n\tstruct btrfs_raid_bio *cur;\n\tstruct btrfs_raid_bio *pending;\n\tunsigned long flags;\n\tDEFINE_WAIT(wait);\n\tstruct btrfs_raid_bio *freeit = NULL;\n\tstruct btrfs_raid_bio *cache_drop = NULL;\n\tint ret = 0;\n\tint walk = 0;\n\n\tspin_lock_irqsave(&h->lock, flags);\n\tlist_for_each_entry(cur, &h->hash_list, hash_list) {\n\t\twalk++;\n\t\tif (cur->bbio->raid_map[0] == rbio->bbio->raid_map[0]) {\n\t\t\tspin_lock(&cur->bio_list_lock);\n\n\t\t\t/* can we steal this cached rbio's pages? */\n\t\t\tif (bio_list_empty(&cur->bio_list) &&\n\t\t\t    list_empty(&cur->plug_list) &&\n\t\t\t    test_bit(RBIO_CACHE_BIT, &cur->flags) &&\n\t\t\t    !test_bit(RBIO_RMW_LOCKED_BIT, &cur->flags)) {\n\t\t\t\tlist_del_init(&cur->hash_list);\n\t\t\t\tatomic_dec(&cur->refs);\n\n\t\t\t\tsteal_rbio(cur, rbio);\n\t\t\t\tcache_drop = cur;\n\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\n\t\t\t\tgoto lockit;\n\t\t\t}\n\n\t\t\t/* can we merge into the lock owner? */\n\t\t\tif (rbio_can_merge(cur, rbio)) {\n\t\t\t\tmerge_rbio(cur, rbio);\n\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\t\tfreeit = rbio;\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\n\t\t\t/*\n\t\t\t * we couldn't merge with the running\n\t\t\t * rbio, see if we can merge with the\n\t\t\t * pending ones.  We don't have to\n\t\t\t * check for rmw_locked because there\n\t\t\t * is no way they are inside finish_rmw\n\t\t\t * right now\n\t\t\t */\n\t\t\tlist_for_each_entry(pending, &cur->plug_list,\n\t\t\t\t\t    plug_list) {\n\t\t\t\tif (rbio_can_merge(pending, rbio)) {\n\t\t\t\t\tmerge_rbio(pending, rbio);\n\t\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\t\t\tfreeit = rbio;\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* no merging, put us on the tail of the plug list,\n\t\t\t * our rbio will be started with the currently\n\t\t\t * running rbio unlocks\n\t\t\t */\n\t\t\tlist_add_tail(&rbio->plug_list, &cur->plug_list);\n\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\nlockit:\n\tatomic_inc(&rbio->refs);\n\tlist_add(&rbio->hash_list, &h->hash_list);\nout:\n\tspin_unlock_irqrestore(&h->lock, flags);\n\tif (cache_drop)\n\t\tremove_rbio_from_cache(cache_drop);\n\tif (freeit)\n\t\t__free_raid_bio(freeit);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int partial_stripe_write(struct btrfs_raid_bio *rbio)\n{\n\tint ret;\n\n\tret = lock_stripe_add(rbio);\n\tif (ret == 0)\n\t\tasync_rmw_stripe(rbio);\n\treturn 0;\n}"
  },
  {
    "function_name": "full_stripe_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "1601-1615",
    "snippet": "static int full_stripe_write(struct btrfs_raid_bio *rbio)\n{\n\tint ret;\n\n\tret = alloc_rbio_parity_pages(rbio);\n\tif (ret) {\n\t\t__free_raid_bio(rbio);\n\t\treturn ret;\n\t}\n\n\tret = lock_stripe_add(rbio);\n\tif (ret == 0)\n\t\tfinish_rmw(rbio);\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_rmw",
          "args": [
            "rbio"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "finish_rmw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1172-1329",
          "snippet": "static noinline void finish_rmw(struct btrfs_raid_bio *rbio)\n{\n\tstruct btrfs_bio *bbio = rbio->bbio;\n\tvoid *pointers[rbio->real_stripes];\n\tint stripe_len = rbio->stripe_len;\n\tint nr_data = rbio->nr_data;\n\tint stripe;\n\tint pagenr;\n\tint p_stripe = -1;\n\tint q_stripe = -1;\n\tstruct bio_list bio_list;\n\tstruct bio *bio;\n\tint pages_per_stripe = stripe_len >> PAGE_CACHE_SHIFT;\n\tint ret;\n\n\tbio_list_init(&bio_list);\n\n\tif (rbio->real_stripes - rbio->nr_data == 1) {\n\t\tp_stripe = rbio->real_stripes - 1;\n\t} else if (rbio->real_stripes - rbio->nr_data == 2) {\n\t\tp_stripe = rbio->real_stripes - 2;\n\t\tq_stripe = rbio->real_stripes - 1;\n\t} else {\n\t\tBUG();\n\t}\n\n\t/* at this point we either have a full stripe,\n\t * or we've read the full stripe from the drive.\n\t * recalculate the parity and write the new results.\n\t *\n\t * We're not allowed to add any new bios to the\n\t * bio list here, anyone else that wants to\n\t * change this stripe needs to do their own rmw.\n\t */\n\tspin_lock_irq(&rbio->bio_list_lock);\n\tset_bit(RBIO_RMW_LOCKED_BIT, &rbio->flags);\n\tspin_unlock_irq(&rbio->bio_list_lock);\n\n\tatomic_set(&rbio->error, 0);\n\n\t/*\n\t * now that we've set rmw_locked, run through the\n\t * bio list one last time and map the page pointers\n\t *\n\t * We don't cache full rbios because we're assuming\n\t * the higher layers are unlikely to use this area of\n\t * the disk again soon.  If they do use it again,\n\t * hopefully they will send another full bio.\n\t */\n\tindex_rbio_pages(rbio);\n\tif (!rbio_is_full(rbio))\n\t\tcache_rbio_pages(rbio);\n\telse\n\t\tclear_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n\n\tfor (pagenr = 0; pagenr < pages_per_stripe; pagenr++) {\n\t\tstruct page *p;\n\t\t/* first collect one page from each data stripe */\n\t\tfor (stripe = 0; stripe < nr_data; stripe++) {\n\t\t\tp = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\tpointers[stripe] = kmap(p);\n\t\t}\n\n\t\t/* then add the parity stripe */\n\t\tp = rbio_pstripe_page(rbio, pagenr);\n\t\tSetPageUptodate(p);\n\t\tpointers[stripe++] = kmap(p);\n\n\t\tif (q_stripe != -1) {\n\n\t\t\t/*\n\t\t\t * raid6, add the qstripe and call the\n\t\t\t * library function to fill in our p/q\n\t\t\t */\n\t\t\tp = rbio_qstripe_page(rbio, pagenr);\n\t\t\tSetPageUptodate(p);\n\t\t\tpointers[stripe++] = kmap(p);\n\n\t\t\traid6_call.gen_syndrome(rbio->real_stripes, PAGE_SIZE,\n\t\t\t\t\t\tpointers);\n\t\t} else {\n\t\t\t/* raid5 */\n\t\t\tmemcpy(pointers[nr_data], pointers[0], PAGE_SIZE);\n\t\t\trun_xor(pointers + 1, nr_data - 1, PAGE_CACHE_SIZE);\n\t\t}\n\n\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++)\n\t\t\tkunmap(page_in_rbio(rbio, stripe, pagenr, 0));\n\t}\n\n\t/*\n\t * time to start writing.  Make bios for everything from the\n\t * higher layers (the bio_list in our rbio) and our p/q.  Ignore\n\t * everything else.\n\t */\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tfor (pagenr = 0; pagenr < pages_per_stripe; pagenr++) {\n\t\t\tstruct page *page;\n\t\t\tif (stripe < rbio->nr_data) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 1);\n\t\t\t\tif (!page)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t       page = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list,\n\t\t\t\t       page, stripe, pagenr, rbio->stripe_len);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (likely(!bbio->num_tgtdevs))\n\t\tgoto write_data;\n\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tif (!bbio->tgtdev_map[stripe])\n\t\t\tcontinue;\n\n\t\tfor (pagenr = 0; pagenr < pages_per_stripe; pagenr++) {\n\t\t\tstruct page *page;\n\t\t\tif (stripe < rbio->nr_data) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 1);\n\t\t\t\tif (!page)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t       page = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list, page,\n\t\t\t\t\t       rbio->bbio->tgtdev_map[stripe],\n\t\t\t\t\t       pagenr, rbio->stripe_len);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\nwrite_data:\n\tatomic_set(&rbio->stripes_pending, bio_list_size(&bio_list));\n\tBUG_ON(atomic_read(&rbio->stripes_pending) == 0);\n\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid_write_end_io;\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(WRITE, bio);\n\t}\n\treturn;\n\ncleanup:\n\trbio_orig_end_io(rbio, -EIO, 0);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RBIO_CACHE_READY_BIT\t3",
            "#define RBIO_RMW_LOCKED_BIT\t1"
          ],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_READY_BIT\t3\n#define RBIO_RMW_LOCKED_BIT\t1\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio)\n{\n\tstruct btrfs_bio *bbio = rbio->bbio;\n\tvoid *pointers[rbio->real_stripes];\n\tint stripe_len = rbio->stripe_len;\n\tint nr_data = rbio->nr_data;\n\tint stripe;\n\tint pagenr;\n\tint p_stripe = -1;\n\tint q_stripe = -1;\n\tstruct bio_list bio_list;\n\tstruct bio *bio;\n\tint pages_per_stripe = stripe_len >> PAGE_CACHE_SHIFT;\n\tint ret;\n\n\tbio_list_init(&bio_list);\n\n\tif (rbio->real_stripes - rbio->nr_data == 1) {\n\t\tp_stripe = rbio->real_stripes - 1;\n\t} else if (rbio->real_stripes - rbio->nr_data == 2) {\n\t\tp_stripe = rbio->real_stripes - 2;\n\t\tq_stripe = rbio->real_stripes - 1;\n\t} else {\n\t\tBUG();\n\t}\n\n\t/* at this point we either have a full stripe,\n\t * or we've read the full stripe from the drive.\n\t * recalculate the parity and write the new results.\n\t *\n\t * We're not allowed to add any new bios to the\n\t * bio list here, anyone else that wants to\n\t * change this stripe needs to do their own rmw.\n\t */\n\tspin_lock_irq(&rbio->bio_list_lock);\n\tset_bit(RBIO_RMW_LOCKED_BIT, &rbio->flags);\n\tspin_unlock_irq(&rbio->bio_list_lock);\n\n\tatomic_set(&rbio->error, 0);\n\n\t/*\n\t * now that we've set rmw_locked, run through the\n\t * bio list one last time and map the page pointers\n\t *\n\t * We don't cache full rbios because we're assuming\n\t * the higher layers are unlikely to use this area of\n\t * the disk again soon.  If they do use it again,\n\t * hopefully they will send another full bio.\n\t */\n\tindex_rbio_pages(rbio);\n\tif (!rbio_is_full(rbio))\n\t\tcache_rbio_pages(rbio);\n\telse\n\t\tclear_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n\n\tfor (pagenr = 0; pagenr < pages_per_stripe; pagenr++) {\n\t\tstruct page *p;\n\t\t/* first collect one page from each data stripe */\n\t\tfor (stripe = 0; stripe < nr_data; stripe++) {\n\t\t\tp = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\tpointers[stripe] = kmap(p);\n\t\t}\n\n\t\t/* then add the parity stripe */\n\t\tp = rbio_pstripe_page(rbio, pagenr);\n\t\tSetPageUptodate(p);\n\t\tpointers[stripe++] = kmap(p);\n\n\t\tif (q_stripe != -1) {\n\n\t\t\t/*\n\t\t\t * raid6, add the qstripe and call the\n\t\t\t * library function to fill in our p/q\n\t\t\t */\n\t\t\tp = rbio_qstripe_page(rbio, pagenr);\n\t\t\tSetPageUptodate(p);\n\t\t\tpointers[stripe++] = kmap(p);\n\n\t\t\traid6_call.gen_syndrome(rbio->real_stripes, PAGE_SIZE,\n\t\t\t\t\t\tpointers);\n\t\t} else {\n\t\t\t/* raid5 */\n\t\t\tmemcpy(pointers[nr_data], pointers[0], PAGE_SIZE);\n\t\t\trun_xor(pointers + 1, nr_data - 1, PAGE_CACHE_SIZE);\n\t\t}\n\n\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++)\n\t\t\tkunmap(page_in_rbio(rbio, stripe, pagenr, 0));\n\t}\n\n\t/*\n\t * time to start writing.  Make bios for everything from the\n\t * higher layers (the bio_list in our rbio) and our p/q.  Ignore\n\t * everything else.\n\t */\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tfor (pagenr = 0; pagenr < pages_per_stripe; pagenr++) {\n\t\t\tstruct page *page;\n\t\t\tif (stripe < rbio->nr_data) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 1);\n\t\t\t\tif (!page)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t       page = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list,\n\t\t\t\t       page, stripe, pagenr, rbio->stripe_len);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (likely(!bbio->num_tgtdevs))\n\t\tgoto write_data;\n\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tif (!bbio->tgtdev_map[stripe])\n\t\t\tcontinue;\n\n\t\tfor (pagenr = 0; pagenr < pages_per_stripe; pagenr++) {\n\t\t\tstruct page *page;\n\t\t\tif (stripe < rbio->nr_data) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 1);\n\t\t\t\tif (!page)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t       page = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list, page,\n\t\t\t\t\t       rbio->bbio->tgtdev_map[stripe],\n\t\t\t\t\t       pagenr, rbio->stripe_len);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\nwrite_data:\n\tatomic_set(&rbio->stripes_pending, bio_list_size(&bio_list));\n\tBUG_ON(atomic_read(&rbio->stripes_pending) == 0);\n\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid_write_end_io;\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(WRITE, bio);\n\t}\n\treturn;\n\ncleanup:\n\trbio_orig_end_io(rbio, -EIO, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_stripe_add",
          "args": [
            "rbio"
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "lock_stripe_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "660-743",
          "snippet": "static noinline int lock_stripe_add(struct btrfs_raid_bio *rbio)\n{\n\tint bucket = rbio_bucket(rbio);\n\tstruct btrfs_stripe_hash *h = rbio->fs_info->stripe_hash_table->table + bucket;\n\tstruct btrfs_raid_bio *cur;\n\tstruct btrfs_raid_bio *pending;\n\tunsigned long flags;\n\tDEFINE_WAIT(wait);\n\tstruct btrfs_raid_bio *freeit = NULL;\n\tstruct btrfs_raid_bio *cache_drop = NULL;\n\tint ret = 0;\n\tint walk = 0;\n\n\tspin_lock_irqsave(&h->lock, flags);\n\tlist_for_each_entry(cur, &h->hash_list, hash_list) {\n\t\twalk++;\n\t\tif (cur->bbio->raid_map[0] == rbio->bbio->raid_map[0]) {\n\t\t\tspin_lock(&cur->bio_list_lock);\n\n\t\t\t/* can we steal this cached rbio's pages? */\n\t\t\tif (bio_list_empty(&cur->bio_list) &&\n\t\t\t    list_empty(&cur->plug_list) &&\n\t\t\t    test_bit(RBIO_CACHE_BIT, &cur->flags) &&\n\t\t\t    !test_bit(RBIO_RMW_LOCKED_BIT, &cur->flags)) {\n\t\t\t\tlist_del_init(&cur->hash_list);\n\t\t\t\tatomic_dec(&cur->refs);\n\n\t\t\t\tsteal_rbio(cur, rbio);\n\t\t\t\tcache_drop = cur;\n\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\n\t\t\t\tgoto lockit;\n\t\t\t}\n\n\t\t\t/* can we merge into the lock owner? */\n\t\t\tif (rbio_can_merge(cur, rbio)) {\n\t\t\t\tmerge_rbio(cur, rbio);\n\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\t\tfreeit = rbio;\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\n\t\t\t/*\n\t\t\t * we couldn't merge with the running\n\t\t\t * rbio, see if we can merge with the\n\t\t\t * pending ones.  We don't have to\n\t\t\t * check for rmw_locked because there\n\t\t\t * is no way they are inside finish_rmw\n\t\t\t * right now\n\t\t\t */\n\t\t\tlist_for_each_entry(pending, &cur->plug_list,\n\t\t\t\t\t    plug_list) {\n\t\t\t\tif (rbio_can_merge(pending, rbio)) {\n\t\t\t\t\tmerge_rbio(pending, rbio);\n\t\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\t\t\tfreeit = rbio;\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* no merging, put us on the tail of the plug list,\n\t\t\t * our rbio will be started with the currently\n\t\t\t * running rbio unlocks\n\t\t\t */\n\t\t\tlist_add_tail(&rbio->plug_list, &cur->plug_list);\n\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\nlockit:\n\tatomic_inc(&rbio->refs);\n\tlist_add(&rbio->hash_list, &h->hash_list);\nout:\n\tspin_unlock_irqrestore(&h->lock, flags);\n\tif (cache_drop)\n\t\tremove_rbio_from_cache(cache_drop);\n\tif (freeit)\n\t\t__free_raid_bio(freeit);\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RBIO_CACHE_BIT\t\t2",
            "#define RBIO_RMW_LOCKED_BIT\t1"
          ],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_BIT\t\t2\n#define RBIO_RMW_LOCKED_BIT\t1\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic noinline int lock_stripe_add(struct btrfs_raid_bio *rbio)\n{\n\tint bucket = rbio_bucket(rbio);\n\tstruct btrfs_stripe_hash *h = rbio->fs_info->stripe_hash_table->table + bucket;\n\tstruct btrfs_raid_bio *cur;\n\tstruct btrfs_raid_bio *pending;\n\tunsigned long flags;\n\tDEFINE_WAIT(wait);\n\tstruct btrfs_raid_bio *freeit = NULL;\n\tstruct btrfs_raid_bio *cache_drop = NULL;\n\tint ret = 0;\n\tint walk = 0;\n\n\tspin_lock_irqsave(&h->lock, flags);\n\tlist_for_each_entry(cur, &h->hash_list, hash_list) {\n\t\twalk++;\n\t\tif (cur->bbio->raid_map[0] == rbio->bbio->raid_map[0]) {\n\t\t\tspin_lock(&cur->bio_list_lock);\n\n\t\t\t/* can we steal this cached rbio's pages? */\n\t\t\tif (bio_list_empty(&cur->bio_list) &&\n\t\t\t    list_empty(&cur->plug_list) &&\n\t\t\t    test_bit(RBIO_CACHE_BIT, &cur->flags) &&\n\t\t\t    !test_bit(RBIO_RMW_LOCKED_BIT, &cur->flags)) {\n\t\t\t\tlist_del_init(&cur->hash_list);\n\t\t\t\tatomic_dec(&cur->refs);\n\n\t\t\t\tsteal_rbio(cur, rbio);\n\t\t\t\tcache_drop = cur;\n\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\n\t\t\t\tgoto lockit;\n\t\t\t}\n\n\t\t\t/* can we merge into the lock owner? */\n\t\t\tif (rbio_can_merge(cur, rbio)) {\n\t\t\t\tmerge_rbio(cur, rbio);\n\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\t\tfreeit = rbio;\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\n\t\t\t/*\n\t\t\t * we couldn't merge with the running\n\t\t\t * rbio, see if we can merge with the\n\t\t\t * pending ones.  We don't have to\n\t\t\t * check for rmw_locked because there\n\t\t\t * is no way they are inside finish_rmw\n\t\t\t * right now\n\t\t\t */\n\t\t\tlist_for_each_entry(pending, &cur->plug_list,\n\t\t\t\t\t    plug_list) {\n\t\t\t\tif (rbio_can_merge(pending, rbio)) {\n\t\t\t\t\tmerge_rbio(pending, rbio);\n\t\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\t\t\tfreeit = rbio;\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* no merging, put us on the tail of the plug list,\n\t\t\t * our rbio will be started with the currently\n\t\t\t * running rbio unlocks\n\t\t\t */\n\t\t\tlist_add_tail(&rbio->plug_list, &cur->plug_list);\n\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\nlockit:\n\tatomic_inc(&rbio->refs);\n\tlist_add(&rbio->hash_list, &h->hash_list);\nout:\n\tspin_unlock_irqrestore(&h->lock, flags);\n\tif (cache_drop)\n\t\tremove_rbio_from_cache(cache_drop);\n\tif (freeit)\n\t\t__free_raid_bio(freeit);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_raid_bio",
          "args": [
            "rbio"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "__free_raid_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "828-849",
          "snippet": "static void __free_raid_bio(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\n\tWARN_ON(atomic_read(&rbio->refs) < 0);\n\tif (!atomic_dec_and_test(&rbio->refs))\n\t\treturn;\n\n\tWARN_ON(!list_empty(&rbio->stripe_cache));\n\tWARN_ON(!list_empty(&rbio->hash_list));\n\tWARN_ON(!bio_list_empty(&rbio->bio_list));\n\n\tfor (i = 0; i < rbio->nr_pages; i++) {\n\t\tif (rbio->stripe_pages[i]) {\n\t\t\t__free_page(rbio->stripe_pages[i]);\n\t\t\trbio->stripe_pages[i] = NULL;\n\t\t}\n\t}\n\n\tbtrfs_put_bbio(rbio->bbio);\n\tkfree(rbio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\n\tWARN_ON(atomic_read(&rbio->refs) < 0);\n\tif (!atomic_dec_and_test(&rbio->refs))\n\t\treturn;\n\n\tWARN_ON(!list_empty(&rbio->stripe_cache));\n\tWARN_ON(!list_empty(&rbio->hash_list));\n\tWARN_ON(!bio_list_empty(&rbio->bio_list));\n\n\tfor (i = 0; i < rbio->nr_pages; i++) {\n\t\tif (rbio->stripe_pages[i]) {\n\t\t\t__free_page(rbio->stripe_pages[i]);\n\t\t\trbio->stripe_pages[i] = NULL;\n\t\t}\n\t}\n\n\tbtrfs_put_bbio(rbio->bbio);\n\tkfree(rbio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_rbio_parity_pages",
          "args": [
            "rbio"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_rbio_parity_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1027-1043",
          "snippet": "static int alloc_rbio_parity_pages(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\tstruct page *page;\n\n\ti = (rbio->nr_data * rbio->stripe_len) >> PAGE_CACHE_SHIFT;\n\n\tfor (; i < rbio->nr_pages; i++) {\n\t\tif (rbio->stripe_pages[i])\n\t\t\tcontinue;\n\t\tpage = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\trbio->stripe_pages[i] = page;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int alloc_rbio_parity_pages(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\tstruct page *page;\n\n\ti = (rbio->nr_data * rbio->stripe_len) >> PAGE_CACHE_SHIFT;\n\n\tfor (; i < rbio->nr_pages; i++) {\n\t\tif (rbio->stripe_pages[i])\n\t\t\tcontinue;\n\t\tpage = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\trbio->stripe_pages[i] = page;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int full_stripe_write(struct btrfs_raid_bio *rbio)\n{\n\tint ret;\n\n\tret = alloc_rbio_parity_pages(rbio);\n\tif (ret) {\n\t\t__free_raid_bio(rbio);\n\t\treturn ret;\n\t}\n\n\tret = lock_stripe_add(rbio);\n\tif (ret == 0)\n\t\tfinish_rmw(rbio);\n\treturn 0;\n}"
  },
  {
    "function_name": "raid56_rmw_stripe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "1504-1595",
    "snippet": "static int raid56_rmw_stripe(struct btrfs_raid_bio *rbio)\n{\n\tint bios_to_read = 0;\n\tstruct bio_list bio_list;\n\tint ret;\n\tint nr_pages = DIV_ROUND_UP(rbio->stripe_len, PAGE_CACHE_SIZE);\n\tint pagenr;\n\tint stripe;\n\tstruct bio *bio;\n\n\tbio_list_init(&bio_list);\n\n\tret = alloc_rbio_pages(rbio);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tindex_rbio_pages(rbio);\n\n\tatomic_set(&rbio->error, 0);\n\t/*\n\t * build a list of bios to read all the missing parts of this\n\t * stripe\n\t */\n\tfor (stripe = 0; stripe < rbio->nr_data; stripe++) {\n\t\tfor (pagenr = 0; pagenr < nr_pages; pagenr++) {\n\t\t\tstruct page *page;\n\t\t\t/*\n\t\t\t * we want to find all the pages missing from\n\t\t\t * the rbio and read them from the disk.  If\n\t\t\t * page_in_rbio finds a page in the bio list\n\t\t\t * we don't need to read it off the stripe.\n\t\t\t */\n\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 1);\n\t\t\tif (page)\n\t\t\t\tcontinue;\n\n\t\t\tpage = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t/*\n\t\t\t * the bio cache may have handed us an uptodate\n\t\t\t * page.  If so, be happy and use it\n\t\t\t */\n\t\t\tif (PageUptodate(page))\n\t\t\t\tcontinue;\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list, page,\n\t\t\t\t       stripe, pagenr, rbio->stripe_len);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tbios_to_read = bio_list_size(&bio_list);\n\tif (!bios_to_read) {\n\t\t/*\n\t\t * this can happen if others have merged with\n\t\t * us, it means there is nothing left to read.\n\t\t * But if there are missing devices it may not be\n\t\t * safe to do the full stripe write yet.\n\t\t */\n\t\tgoto finish;\n\t}\n\n\t/*\n\t * the bbio may be freed once we submit the last bio.  Make sure\n\t * not to touch it after that\n\t */\n\tatomic_set(&rbio->stripes_pending, bios_to_read);\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid_rmw_end_io;\n\n\t\tbtrfs_bio_wq_end_io(rbio->fs_info, bio,\n\t\t\t\t    BTRFS_WQ_ENDIO_RAID56);\n\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(READ, bio);\n\t}\n\t/* the actual write will happen once the reads are done */\n\treturn 0;\n\ncleanup:\n\trbio_orig_end_io(rbio, -EIO, 0);\n\treturn -EIO;\n\nfinish:\n\tvalidate_rbio_for_rmw(rbio);\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "validate_rbio_for_rmw",
          "args": [
            "rbio"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "validate_rbio_for_rmw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1111-1119",
          "snippet": "static void validate_rbio_for_rmw(struct btrfs_raid_bio *rbio)\n{\n\tif (rbio->faila >= 0 || rbio->failb >= 0) {\n\t\tBUG_ON(rbio->faila == rbio->real_stripes - 1);\n\t\t__raid56_parity_recover(rbio);\n\t} else {\n\t\tfinish_rmw(rbio);\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void validate_rbio_for_rmw(struct btrfs_raid_bio *rbio)\n{\n\tif (rbio->faila >= 0 || rbio->failb >= 0) {\n\t\tBUG_ON(rbio->faila == rbio->real_stripes - 1);\n\t\t__raid56_parity_recover(rbio);\n\t} else {\n\t\tfinish_rmw(rbio);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rbio_orig_end_io",
          "args": [
            "rbio",
            "-EIO",
            "0"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_orig_end_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "861-879",
          "snippet": "static void rbio_orig_end_io(struct btrfs_raid_bio *rbio, int err, int uptodate)\n{\n\tstruct bio *cur = bio_list_get(&rbio->bio_list);\n\tstruct bio *next;\n\n\tif (rbio->generic_bio_cnt)\n\t\tbtrfs_bio_counter_sub(rbio->fs_info, rbio->generic_bio_cnt);\n\n\tfree_raid_bio(rbio);\n\n\twhile (cur) {\n\t\tnext = cur->bi_next;\n\t\tcur->bi_next = NULL;\n\t\tif (uptodate)\n\t\t\tset_bit(BIO_UPTODATE, &cur->bi_flags);\n\t\tbio_endio(cur, err);\n\t\tcur = next;\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void rbio_orig_end_io(struct btrfs_raid_bio *rbio, int err, int uptodate)\n{\n\tstruct bio *cur = bio_list_get(&rbio->bio_list);\n\tstruct bio *next;\n\n\tif (rbio->generic_bio_cnt)\n\t\tbtrfs_bio_counter_sub(rbio->fs_info, rbio->generic_bio_cnt);\n\n\tfree_raid_bio(rbio);\n\n\twhile (cur) {\n\t\tnext = cur->bi_next;\n\t\tcur->bi_next = NULL;\n\t\tif (uptodate)\n\t\t\tset_bit(BIO_UPTODATE, &cur->bi_flags);\n\t\tbio_endio(cur, err);\n\t\tcur = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "READ",
            "bio"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_submit_bio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "3067-3071",
          "snippet": "int btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!test_bit(BIO_UPTODATE, &bio->bi_flags)"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BIO_UPTODATE",
            "&bio->bi_flags"
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_bio_wq_end_io",
          "args": [
            "rbio->fs_info",
            "bio",
            "BTRFS_WQ_ENDIO_RAID56"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bio_wq_end_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "756-775",
          "snippet": "int btrfs_bio_wq_end_io(struct btrfs_fs_info *info, struct bio *bio,\n\t\t\tenum btrfs_wq_endio_type metadata)\n{\n\tstruct btrfs_end_io_wq *end_io_wq;\n\n\tend_io_wq = kmem_cache_alloc(btrfs_end_io_wq_cache, GFP_NOFS);\n\tif (!end_io_wq)\n\t\treturn -ENOMEM;\n\n\tend_io_wq->private = bio->bi_private;\n\tend_io_wq->end_io = bio->bi_end_io;\n\tend_io_wq->info = info;\n\tend_io_wq->error = 0;\n\tend_io_wq->bio = bio;\n\tend_io_wq->metadata = metadata;\n\n\tbio->bi_private = end_io_wq;\n\tbio->bi_end_io = end_workqueue_bio;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_end_io_wq_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *btrfs_end_io_wq_cache;\n\nint btrfs_bio_wq_end_io(struct btrfs_fs_info *info, struct bio *bio,\n\t\t\tenum btrfs_wq_endio_type metadata)\n{\n\tstruct btrfs_end_io_wq *end_io_wq;\n\n\tend_io_wq = kmem_cache_alloc(btrfs_end_io_wq_cache, GFP_NOFS);\n\tif (!end_io_wq)\n\t\treturn -ENOMEM;\n\n\tend_io_wq->private = bio->bi_private;\n\tend_io_wq->end_io = bio->bi_end_io;\n\tend_io_wq->info = info;\n\tend_io_wq->error = 0;\n\tend_io_wq->bio = bio;\n\tend_io_wq->metadata = metadata;\n\n\tbio->bi_private = end_io_wq;\n\tbio->bi_end_io = end_workqueue_bio;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_list_pop",
          "args": [
            "&bio_list"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&rbio->stripes_pending",
            "bios_to_read"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_list_size",
          "args": [
            "&bio_list"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rbio_add_io_page",
          "args": [
            "rbio",
            "&bio_list",
            "page",
            "stripe",
            "pagenr",
            "rbio->stripe_len"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_add_io_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1050-1102",
          "snippet": "static int rbio_add_io_page(struct btrfs_raid_bio *rbio,\n\t\t\t    struct bio_list *bio_list,\n\t\t\t    struct page *page,\n\t\t\t    int stripe_nr,\n\t\t\t    unsigned long page_index,\n\t\t\t    unsigned long bio_max_len)\n{\n\tstruct bio *last = bio_list->tail;\n\tu64 last_end = 0;\n\tint ret;\n\tstruct bio *bio;\n\tstruct btrfs_bio_stripe *stripe;\n\tu64 disk_start;\n\n\tstripe = &rbio->bbio->stripes[stripe_nr];\n\tdisk_start = stripe->physical + (page_index << PAGE_CACHE_SHIFT);\n\n\t/* if the device is missing, just fail this stripe */\n\tif (!stripe->dev->bdev)\n\t\treturn fail_rbio_index(rbio, stripe_nr);\n\n\t/* see if we can add this page onto our existing bio */\n\tif (last) {\n\t\tlast_end = (u64)last->bi_iter.bi_sector << 9;\n\t\tlast_end += last->bi_iter.bi_size;\n\n\t\t/*\n\t\t * we can't merge these if they are from different\n\t\t * devices or if they are not contiguous\n\t\t */\n\t\tif (last_end == disk_start && stripe->dev->bdev &&\n\t\t    test_bit(BIO_UPTODATE, &last->bi_flags) &&\n\t\t    last->bi_bdev == stripe->dev->bdev) {\n\t\t\tret = bio_add_page(last, page, PAGE_CACHE_SIZE, 0);\n\t\t\tif (ret == PAGE_CACHE_SIZE)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* put a new bio on the list */\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, bio_max_len >> PAGE_SHIFT?:1);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\n\tbio->bi_iter.bi_size = 0;\n\tbio->bi_bdev = stripe->dev->bdev;\n\tbio->bi_iter.bi_sector = disk_start >> 9;\n\tset_bit(BIO_UPTODATE, &bio->bi_flags);\n\n\tbio_add_page(bio, page, PAGE_CACHE_SIZE, 0);\n\tbio_list_add(bio_list, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int rbio_add_io_page(struct btrfs_raid_bio *rbio,\n\t\t\t    struct bio_list *bio_list,\n\t\t\t    struct page *page,\n\t\t\t    int stripe_nr,\n\t\t\t    unsigned long page_index,\n\t\t\t    unsigned long bio_max_len)\n{\n\tstruct bio *last = bio_list->tail;\n\tu64 last_end = 0;\n\tint ret;\n\tstruct bio *bio;\n\tstruct btrfs_bio_stripe *stripe;\n\tu64 disk_start;\n\n\tstripe = &rbio->bbio->stripes[stripe_nr];\n\tdisk_start = stripe->physical + (page_index << PAGE_CACHE_SHIFT);\n\n\t/* if the device is missing, just fail this stripe */\n\tif (!stripe->dev->bdev)\n\t\treturn fail_rbio_index(rbio, stripe_nr);\n\n\t/* see if we can add this page onto our existing bio */\n\tif (last) {\n\t\tlast_end = (u64)last->bi_iter.bi_sector << 9;\n\t\tlast_end += last->bi_iter.bi_size;\n\n\t\t/*\n\t\t * we can't merge these if they are from different\n\t\t * devices or if they are not contiguous\n\t\t */\n\t\tif (last_end == disk_start && stripe->dev->bdev &&\n\t\t    test_bit(BIO_UPTODATE, &last->bi_flags) &&\n\t\t    last->bi_bdev == stripe->dev->bdev) {\n\t\t\tret = bio_add_page(last, page, PAGE_CACHE_SIZE, 0);\n\t\t\tif (ret == PAGE_CACHE_SIZE)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* put a new bio on the list */\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, bio_max_len >> PAGE_SHIFT?:1);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\n\tbio->bi_iter.bi_size = 0;\n\tbio->bi_bdev = stripe->dev->bdev;\n\tbio->bi_iter.bi_sector = disk_start >> 9;\n\tset_bit(BIO_UPTODATE, &bio->bi_flags);\n\n\tbio_add_page(bio, page, PAGE_CACHE_SIZE, 0);\n\tbio_list_add(bio_list, bio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rbio_stripe_page",
          "args": [
            "rbio",
            "stripe",
            "pagenr"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_stripe_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1125-1131",
          "snippet": "static struct page *rbio_stripe_page(struct btrfs_raid_bio *rbio, int stripe, int page)\n{\n\tint index;\n\tindex = stripe * (rbio->stripe_len >> PAGE_CACHE_SHIFT);\n\tindex += page;\n\treturn rbio->stripe_pages[index];\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic struct page *rbio_stripe_page(struct btrfs_raid_bio *rbio, int stripe, int page)\n{\n\tint index;\n\tindex = stripe * (rbio->stripe_len >> PAGE_CACHE_SHIFT);\n\tindex += page;\n\treturn rbio->stripe_pages[index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_in_rbio",
          "args": [
            "rbio",
            "stripe",
            "pagenr",
            "1"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "page_in_rbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "923-939",
          "snippet": "static struct page *page_in_rbio(struct btrfs_raid_bio *rbio,\n\t\t\t\t int index, int pagenr, int bio_list_only)\n{\n\tint chunk_page;\n\tstruct page *p = NULL;\n\n\tchunk_page = index * (rbio->stripe_len >> PAGE_SHIFT) + pagenr;\n\n\tspin_lock_irq(&rbio->bio_list_lock);\n\tp = rbio->bio_pages[chunk_page];\n\tspin_unlock_irq(&rbio->bio_list_lock);\n\n\tif (p || bio_list_only)\n\t\treturn p;\n\n\treturn rbio->stripe_pages[chunk_page];\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic struct page *page_in_rbio(struct btrfs_raid_bio *rbio,\n\t\t\t\t int index, int pagenr, int bio_list_only)\n{\n\tint chunk_page;\n\tstruct page *p = NULL;\n\n\tchunk_page = index * (rbio->stripe_len >> PAGE_SHIFT) + pagenr;\n\n\tspin_lock_irq(&rbio->bio_list_lock);\n\tp = rbio->bio_pages[chunk_page];\n\tspin_unlock_irq(&rbio->bio_list_lock);\n\n\tif (p || bio_list_only)\n\t\treturn p;\n\n\treturn rbio->stripe_pages[chunk_page];\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&rbio->error",
            "0"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_rbio_pages",
          "args": [
            "rbio"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "index_rbio_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1141-1162",
          "snippet": "static void index_rbio_pages(struct btrfs_raid_bio *rbio)\n{\n\tstruct bio *bio;\n\tu64 start;\n\tunsigned long stripe_offset;\n\tunsigned long page_index;\n\tstruct page *p;\n\tint i;\n\n\tspin_lock_irq(&rbio->bio_list_lock);\n\tbio_list_for_each(bio, &rbio->bio_list) {\n\t\tstart = (u64)bio->bi_iter.bi_sector << 9;\n\t\tstripe_offset = start - rbio->bbio->raid_map[0];\n\t\tpage_index = stripe_offset >> PAGE_CACHE_SHIFT;\n\n\t\tfor (i = 0; i < bio->bi_vcnt; i++) {\n\t\t\tp = bio->bi_io_vec[i].bv_page;\n\t\t\trbio->bio_pages[page_index + i] = p;\n\t\t}\n\t}\n\tspin_unlock_irq(&rbio->bio_list_lock);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio)\n{\n\tstruct bio *bio;\n\tu64 start;\n\tunsigned long stripe_offset;\n\tunsigned long page_index;\n\tstruct page *p;\n\tint i;\n\n\tspin_lock_irq(&rbio->bio_list_lock);\n\tbio_list_for_each(bio, &rbio->bio_list) {\n\t\tstart = (u64)bio->bi_iter.bi_sector << 9;\n\t\tstripe_offset = start - rbio->bbio->raid_map[0];\n\t\tpage_index = stripe_offset >> PAGE_CACHE_SHIFT;\n\n\t\tfor (i = 0; i < bio->bi_vcnt; i++) {\n\t\t\tp = bio->bi_io_vec[i].bv_page;\n\t\t\trbio->bio_pages[page_index + i] = p;\n\t\t}\n\t}\n\tspin_unlock_irq(&rbio->bio_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_rbio_pages",
          "args": [
            "rbio"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_rbio_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1009-1024",
          "snippet": "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\tstruct page *page;\n\n\tfor (i = 0; i < rbio->nr_pages; i++) {\n\t\tif (rbio->stripe_pages[i])\n\t\t\tcontinue;\n\t\tpage = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\trbio->stripe_pages[i] = page;\n\t\tClearPageUptodate(page);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\tstruct page *page;\n\n\tfor (i = 0; i < rbio->nr_pages; i++) {\n\t\tif (rbio->stripe_pages[i])\n\t\t\tcontinue;\n\t\tpage = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\trbio->stripe_pages[i] = page;\n\t\tClearPageUptodate(page);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_list_init",
          "args": [
            "&bio_list"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "rbio->stripe_len",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int raid56_rmw_stripe(struct btrfs_raid_bio *rbio)\n{\n\tint bios_to_read = 0;\n\tstruct bio_list bio_list;\n\tint ret;\n\tint nr_pages = DIV_ROUND_UP(rbio->stripe_len, PAGE_CACHE_SIZE);\n\tint pagenr;\n\tint stripe;\n\tstruct bio *bio;\n\n\tbio_list_init(&bio_list);\n\n\tret = alloc_rbio_pages(rbio);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tindex_rbio_pages(rbio);\n\n\tatomic_set(&rbio->error, 0);\n\t/*\n\t * build a list of bios to read all the missing parts of this\n\t * stripe\n\t */\n\tfor (stripe = 0; stripe < rbio->nr_data; stripe++) {\n\t\tfor (pagenr = 0; pagenr < nr_pages; pagenr++) {\n\t\t\tstruct page *page;\n\t\t\t/*\n\t\t\t * we want to find all the pages missing from\n\t\t\t * the rbio and read them from the disk.  If\n\t\t\t * page_in_rbio finds a page in the bio list\n\t\t\t * we don't need to read it off the stripe.\n\t\t\t */\n\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 1);\n\t\t\tif (page)\n\t\t\t\tcontinue;\n\n\t\t\tpage = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t/*\n\t\t\t * the bio cache may have handed us an uptodate\n\t\t\t * page.  If so, be happy and use it\n\t\t\t */\n\t\t\tif (PageUptodate(page))\n\t\t\t\tcontinue;\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list, page,\n\t\t\t\t       stripe, pagenr, rbio->stripe_len);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tbios_to_read = bio_list_size(&bio_list);\n\tif (!bios_to_read) {\n\t\t/*\n\t\t * this can happen if others have merged with\n\t\t * us, it means there is nothing left to read.\n\t\t * But if there are missing devices it may not be\n\t\t * safe to do the full stripe write yet.\n\t\t */\n\t\tgoto finish;\n\t}\n\n\t/*\n\t * the bbio may be freed once we submit the last bio.  Make sure\n\t * not to touch it after that\n\t */\n\tatomic_set(&rbio->stripes_pending, bios_to_read);\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid_rmw_end_io;\n\n\t\tbtrfs_bio_wq_end_io(rbio->fs_info, bio,\n\t\t\t\t    BTRFS_WQ_ENDIO_RAID56);\n\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(READ, bio);\n\t}\n\t/* the actual write will happen once the reads are done */\n\treturn 0;\n\ncleanup:\n\trbio_orig_end_io(rbio, -EIO, 0);\n\treturn -EIO;\n\nfinish:\n\tvalidate_rbio_for_rmw(rbio);\n\treturn 0;\n}"
  },
  {
    "function_name": "async_read_rebuild",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "1491-1498",
    "snippet": "static void async_read_rebuild(struct btrfs_raid_bio *rbio)\n{\n\tbtrfs_init_work(&rbio->work, btrfs_rmw_helper,\n\t\t\tread_rebuild_work, NULL, NULL);\n\n\tbtrfs_queue_work(rbio->fs_info->rmw_workers,\n\t\t\t &rbio->work);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void rmw_work(struct btrfs_work *work);",
      "static void read_rebuild_work(struct btrfs_work *work);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_queue_work",
          "args": [
            "rbio->fs_info->rmw_workers",
            "&rbio->work"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "323-333",
          "snippet": "void btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define WORK_HIGH_PRIO_BIT 2"
          ],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);",
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define WORK_HIGH_PRIO_BIT 2\n\nstatic void normal_work_helper(struct btrfs_work *work);\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_init_work",
          "args": [
            "&rbio->work",
            "btrfs_rmw_helper",
            "read_rebuild_work",
            "NULL",
            "NULL"
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "294-305",
          "snippet": "void btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic void normal_work_helper(struct btrfs_work *work);\n\nvoid btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void rmw_work(struct btrfs_work *work);\nstatic void read_rebuild_work(struct btrfs_work *work);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio)\n{\n\tbtrfs_init_work(&rbio->work, btrfs_rmw_helper,\n\t\t\tread_rebuild_work, NULL, NULL);\n\n\tbtrfs_queue_work(rbio->fs_info->rmw_workers,\n\t\t\t &rbio->work);\n}"
  },
  {
    "function_name": "async_rmw_stripe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "1482-1489",
    "snippet": "static void async_rmw_stripe(struct btrfs_raid_bio *rbio)\n{\n\tbtrfs_init_work(&rbio->work, btrfs_rmw_helper,\n\t\t\trmw_work, NULL, NULL);\n\n\tbtrfs_queue_work(rbio->fs_info->rmw_workers,\n\t\t\t &rbio->work);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void rmw_work(struct btrfs_work *work);",
      "static void read_rebuild_work(struct btrfs_work *work);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_queue_work",
          "args": [
            "rbio->fs_info->rmw_workers",
            "&rbio->work"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "323-333",
          "snippet": "void btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define WORK_HIGH_PRIO_BIT 2"
          ],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);",
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define WORK_HIGH_PRIO_BIT 2\n\nstatic void normal_work_helper(struct btrfs_work *work);\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_init_work",
          "args": [
            "&rbio->work",
            "btrfs_rmw_helper",
            "rmw_work",
            "NULL",
            "NULL"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "294-305",
          "snippet": "void btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic void normal_work_helper(struct btrfs_work *work);\n\nvoid btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void rmw_work(struct btrfs_work *work);\nstatic void read_rebuild_work(struct btrfs_work *work);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio)\n{\n\tbtrfs_init_work(&rbio->work, btrfs_rmw_helper,\n\t\t\trmw_work, NULL, NULL);\n\n\tbtrfs_queue_work(rbio->fs_info->rmw_workers,\n\t\t\t &rbio->work);\n}"
  },
  {
    "function_name": "raid_rmw_end_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "1451-1480",
    "snippet": "static void raid_rmw_end_io(struct bio *bio, int err)\n{\n\tstruct btrfs_raid_bio *rbio = bio->bi_private;\n\n\tif (err)\n\t\tfail_bio_stripe(rbio, bio);\n\telse\n\t\tset_bio_pages_uptodate(bio);\n\n\tbio_put(bio);\n\n\tif (!atomic_dec_and_test(&rbio->stripes_pending))\n\t\treturn;\n\n\terr = 0;\n\tif (atomic_read(&rbio->error) > rbio->bbio->max_errors)\n\t\tgoto cleanup;\n\n\t/*\n\t * this will normally call finish_rmw to start our write\n\t * but if there are any failed stripes we'll reconstruct\n\t * from parity first\n\t */\n\tvalidate_rbio_for_rmw(rbio);\n\treturn;\n\ncleanup:\n\n\trbio_orig_end_io(rbio, -EIO, 0);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
      "static int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rbio_orig_end_io",
          "args": [
            "rbio",
            "-EIO",
            "0"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_orig_end_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "861-879",
          "snippet": "static void rbio_orig_end_io(struct btrfs_raid_bio *rbio, int err, int uptodate)\n{\n\tstruct bio *cur = bio_list_get(&rbio->bio_list);\n\tstruct bio *next;\n\n\tif (rbio->generic_bio_cnt)\n\t\tbtrfs_bio_counter_sub(rbio->fs_info, rbio->generic_bio_cnt);\n\n\tfree_raid_bio(rbio);\n\n\twhile (cur) {\n\t\tnext = cur->bi_next;\n\t\tcur->bi_next = NULL;\n\t\tif (uptodate)\n\t\t\tset_bit(BIO_UPTODATE, &cur->bi_flags);\n\t\tbio_endio(cur, err);\n\t\tcur = next;\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void rbio_orig_end_io(struct btrfs_raid_bio *rbio, int err, int uptodate)\n{\n\tstruct bio *cur = bio_list_get(&rbio->bio_list);\n\tstruct bio *next;\n\n\tif (rbio->generic_bio_cnt)\n\t\tbtrfs_bio_counter_sub(rbio->fs_info, rbio->generic_bio_cnt);\n\n\tfree_raid_bio(rbio);\n\n\twhile (cur) {\n\t\tnext = cur->bi_next;\n\t\tcur->bi_next = NULL;\n\t\tif (uptodate)\n\t\t\tset_bit(BIO_UPTODATE, &cur->bi_flags);\n\t\tbio_endio(cur, err);\n\t\tcur = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_rbio_for_rmw",
          "args": [
            "rbio"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "validate_rbio_for_rmw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1111-1119",
          "snippet": "static void validate_rbio_for_rmw(struct btrfs_raid_bio *rbio)\n{\n\tif (rbio->faila >= 0 || rbio->failb >= 0) {\n\t\tBUG_ON(rbio->faila == rbio->real_stripes - 1);\n\t\t__raid56_parity_recover(rbio);\n\t} else {\n\t\tfinish_rmw(rbio);\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void validate_rbio_for_rmw(struct btrfs_raid_bio *rbio)\n{\n\tif (rbio->faila >= 0 || rbio->failb >= 0) {\n\t\tBUG_ON(rbio->faila == rbio->real_stripes - 1);\n\t\t__raid56_parity_recover(rbio);\n\t} else {\n\t\tfinish_rmw(rbio);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rbio->error"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&rbio->stripes_pending"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bio_pages_uptodate",
          "args": [
            "bio"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "set_bio_pages_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1432-1441",
          "snippet": "static void set_bio_pages_uptodate(struct bio *bio)\n{\n\tint i;\n\tstruct page *p;\n\n\tfor (i = 0; i < bio->bi_vcnt; i++) {\n\t\tp = bio->bi_io_vec[i].bv_page;\n\t\tSetPageUptodate(p);\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\n\nstatic void set_bio_pages_uptodate(struct bio *bio)\n{\n\tint i;\n\tstruct page *p;\n\n\tfor (i = 0; i < bio->bi_vcnt; i++) {\n\t\tp = bio->bi_io_vec[i].bv_page;\n\t\tSetPageUptodate(p);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fail_bio_stripe",
          "args": [
            "rbio",
            "bio"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "fail_bio_stripe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1417-1426",
          "snippet": "static int fail_bio_stripe(struct btrfs_raid_bio *rbio,\n\t\t\t   struct bio *bio)\n{\n\tint failed = find_bio_stripe(rbio, bio);\n\n\tif (failed < 0)\n\t\treturn -EIO;\n\n\treturn fail_rbio_index(rbio, failed);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio,\n\t\t\t   struct bio *bio)\n{\n\tint failed = find_bio_stripe(rbio, bio);\n\n\tif (failed < 0)\n\t\treturn -EIO;\n\n\treturn fail_rbio_index(rbio, failed);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void raid_rmw_end_io(struct bio *bio, int err)\n{\n\tstruct btrfs_raid_bio *rbio = bio->bi_private;\n\n\tif (err)\n\t\tfail_bio_stripe(rbio, bio);\n\telse\n\t\tset_bio_pages_uptodate(bio);\n\n\tbio_put(bio);\n\n\tif (!atomic_dec_and_test(&rbio->stripes_pending))\n\t\treturn;\n\n\terr = 0;\n\tif (atomic_read(&rbio->error) > rbio->bbio->max_errors)\n\t\tgoto cleanup;\n\n\t/*\n\t * this will normally call finish_rmw to start our write\n\t * but if there are any failed stripes we'll reconstruct\n\t * from parity first\n\t */\n\tvalidate_rbio_for_rmw(rbio);\n\treturn;\n\ncleanup:\n\n\trbio_orig_end_io(rbio, -EIO, 0);\n}"
  },
  {
    "function_name": "set_bio_pages_uptodate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "1432-1441",
    "snippet": "static void set_bio_pages_uptodate(struct bio *bio)\n{\n\tint i;\n\tstruct page *p;\n\n\tfor (i = 0; i < bio->bi_vcnt; i++) {\n\t\tp = bio->bi_io_vec[i].bv_page;\n\t\tSetPageUptodate(p);\n\t}\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "p"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\n\nstatic void set_bio_pages_uptodate(struct bio *bio)\n{\n\tint i;\n\tstruct page *p;\n\n\tfor (i = 0; i < bio->bi_vcnt; i++) {\n\t\tp = bio->bi_io_vec[i].bv_page;\n\t\tSetPageUptodate(p);\n\t}\n}"
  },
  {
    "function_name": "fail_bio_stripe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "1417-1426",
    "snippet": "static int fail_bio_stripe(struct btrfs_raid_bio *rbio,\n\t\t\t   struct bio *bio)\n{\n\tint failed = find_bio_stripe(rbio, bio);\n\n\tif (failed < 0)\n\t\treturn -EIO;\n\n\treturn fail_rbio_index(rbio, failed);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
      "static int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fail_rbio_index",
          "args": [
            "rbio",
            "failed"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "fail_rbio_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1385-1411",
          "snippet": "static int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&rbio->bio_list_lock, flags);\n\n\t/* we already know this stripe is bad, move on */\n\tif (rbio->faila == failed || rbio->failb == failed)\n\t\tgoto out;\n\n\tif (rbio->faila == -1) {\n\t\t/* first failure on this rbio */\n\t\trbio->faila = failed;\n\t\tatomic_inc(&rbio->error);\n\t} else if (rbio->failb == -1) {\n\t\t/* second failure on this rbio */\n\t\trbio->failb = failed;\n\t\tatomic_inc(&rbio->error);\n\t} else {\n\t\tret = -EIO;\n\t}\nout:\n\tspin_unlock_irqrestore(&rbio->bio_list_lock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&rbio->bio_list_lock, flags);\n\n\t/* we already know this stripe is bad, move on */\n\tif (rbio->faila == failed || rbio->failb == failed)\n\t\tgoto out;\n\n\tif (rbio->faila == -1) {\n\t\t/* first failure on this rbio */\n\t\trbio->faila = failed;\n\t\tatomic_inc(&rbio->error);\n\t} else if (rbio->failb == -1) {\n\t\t/* second failure on this rbio */\n\t\trbio->failb = failed;\n\t\tatomic_inc(&rbio->error);\n\t} else {\n\t\tret = -EIO;\n\t}\nout:\n\tspin_unlock_irqrestore(&rbio->bio_list_lock, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_bio_stripe",
          "args": [
            "rbio",
            "bio"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "find_bio_stripe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1336-1356",
          "snippet": "static int find_bio_stripe(struct btrfs_raid_bio *rbio,\n\t\t\t   struct bio *bio)\n{\n\tu64 physical = bio->bi_iter.bi_sector;\n\tu64 stripe_start;\n\tint i;\n\tstruct btrfs_bio_stripe *stripe;\n\n\tphysical <<= 9;\n\n\tfor (i = 0; i < rbio->bbio->num_stripes; i++) {\n\t\tstripe = &rbio->bbio->stripes[i];\n\t\tstripe_start = stripe->physical;\n\t\tif (physical >= stripe_start &&\n\t\t    physical < stripe_start + rbio->stripe_len &&\n\t\t    bio->bi_bdev == stripe->dev->bdev) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int find_bio_stripe(struct btrfs_raid_bio *rbio,\n\t\t\t   struct bio *bio)\n{\n\tu64 physical = bio->bi_iter.bi_sector;\n\tu64 stripe_start;\n\tint i;\n\tstruct btrfs_bio_stripe *stripe;\n\n\tphysical <<= 9;\n\n\tfor (i = 0; i < rbio->bbio->num_stripes; i++) {\n\t\tstripe = &rbio->bbio->stripes[i];\n\t\tstripe_start = stripe->physical;\n\t\tif (physical >= stripe_start &&\n\t\t    physical < stripe_start + rbio->stripe_len &&\n\t\t    bio->bi_bdev == stripe->dev->bdev) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio,\n\t\t\t   struct bio *bio)\n{\n\tint failed = find_bio_stripe(rbio, bio);\n\n\tif (failed < 0)\n\t\treturn -EIO;\n\n\treturn fail_rbio_index(rbio, failed);\n}"
  },
  {
    "function_name": "fail_rbio_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "1385-1411",
    "snippet": "static int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&rbio->bio_list_lock, flags);\n\n\t/* we already know this stripe is bad, move on */\n\tif (rbio->faila == failed || rbio->failb == failed)\n\t\tgoto out;\n\n\tif (rbio->faila == -1) {\n\t\t/* first failure on this rbio */\n\t\trbio->faila = failed;\n\t\tatomic_inc(&rbio->error);\n\t} else if (rbio->failb == -1) {\n\t\t/* second failure on this rbio */\n\t\trbio->failb = failed;\n\t\tatomic_inc(&rbio->error);\n\t} else {\n\t\tret = -EIO;\n\t}\nout:\n\tspin_unlock_irqrestore(&rbio->bio_list_lock, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&rbio->bio_list_lock",
            "flags"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&rbio->error"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&rbio->error"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&rbio->bio_list_lock",
            "flags"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&rbio->bio_list_lock, flags);\n\n\t/* we already know this stripe is bad, move on */\n\tif (rbio->faila == failed || rbio->failb == failed)\n\t\tgoto out;\n\n\tif (rbio->faila == -1) {\n\t\t/* first failure on this rbio */\n\t\trbio->faila = failed;\n\t\tatomic_inc(&rbio->error);\n\t} else if (rbio->failb == -1) {\n\t\t/* second failure on this rbio */\n\t\trbio->failb = failed;\n\t\tatomic_inc(&rbio->error);\n\t} else {\n\t\tret = -EIO;\n\t}\nout:\n\tspin_unlock_irqrestore(&rbio->bio_list_lock, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "find_logical_bio_stripe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "1363-1380",
    "snippet": "static int find_logical_bio_stripe(struct btrfs_raid_bio *rbio,\n\t\t\t\t   struct bio *bio)\n{\n\tu64 logical = bio->bi_iter.bi_sector;\n\tu64 stripe_start;\n\tint i;\n\n\tlogical <<= 9;\n\n\tfor (i = 0; i < rbio->nr_data; i++) {\n\t\tstripe_start = rbio->bbio->raid_map[i];\n\t\tif (logical >= stripe_start &&\n\t\t    logical < stripe_start + rbio->stripe_len) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int find_logical_bio_stripe(struct btrfs_raid_bio *rbio,\n\t\t\t\t   struct bio *bio)\n{\n\tu64 logical = bio->bi_iter.bi_sector;\n\tu64 stripe_start;\n\tint i;\n\n\tlogical <<= 9;\n\n\tfor (i = 0; i < rbio->nr_data; i++) {\n\t\tstripe_start = rbio->bbio->raid_map[i];\n\t\tif (logical >= stripe_start &&\n\t\t    logical < stripe_start + rbio->stripe_len) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}"
  },
  {
    "function_name": "find_bio_stripe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "1336-1356",
    "snippet": "static int find_bio_stripe(struct btrfs_raid_bio *rbio,\n\t\t\t   struct bio *bio)\n{\n\tu64 physical = bio->bi_iter.bi_sector;\n\tu64 stripe_start;\n\tint i;\n\tstruct btrfs_bio_stripe *stripe;\n\n\tphysical <<= 9;\n\n\tfor (i = 0; i < rbio->bbio->num_stripes; i++) {\n\t\tstripe = &rbio->bbio->stripes[i];\n\t\tstripe_start = stripe->physical;\n\t\tif (physical >= stripe_start &&\n\t\t    physical < stripe_start + rbio->stripe_len &&\n\t\t    bio->bi_bdev == stripe->dev->bdev) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int find_bio_stripe(struct btrfs_raid_bio *rbio,\n\t\t\t   struct bio *bio)\n{\n\tu64 physical = bio->bi_iter.bi_sector;\n\tu64 stripe_start;\n\tint i;\n\tstruct btrfs_bio_stripe *stripe;\n\n\tphysical <<= 9;\n\n\tfor (i = 0; i < rbio->bbio->num_stripes; i++) {\n\t\tstripe = &rbio->bbio->stripes[i];\n\t\tstripe_start = stripe->physical;\n\t\tif (physical >= stripe_start &&\n\t\t    physical < stripe_start + rbio->stripe_len &&\n\t\t    bio->bi_bdev == stripe->dev->bdev) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}"
  },
  {
    "function_name": "finish_rmw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "1172-1329",
    "snippet": "static noinline void finish_rmw(struct btrfs_raid_bio *rbio)\n{\n\tstruct btrfs_bio *bbio = rbio->bbio;\n\tvoid *pointers[rbio->real_stripes];\n\tint stripe_len = rbio->stripe_len;\n\tint nr_data = rbio->nr_data;\n\tint stripe;\n\tint pagenr;\n\tint p_stripe = -1;\n\tint q_stripe = -1;\n\tstruct bio_list bio_list;\n\tstruct bio *bio;\n\tint pages_per_stripe = stripe_len >> PAGE_CACHE_SHIFT;\n\tint ret;\n\n\tbio_list_init(&bio_list);\n\n\tif (rbio->real_stripes - rbio->nr_data == 1) {\n\t\tp_stripe = rbio->real_stripes - 1;\n\t} else if (rbio->real_stripes - rbio->nr_data == 2) {\n\t\tp_stripe = rbio->real_stripes - 2;\n\t\tq_stripe = rbio->real_stripes - 1;\n\t} else {\n\t\tBUG();\n\t}\n\n\t/* at this point we either have a full stripe,\n\t * or we've read the full stripe from the drive.\n\t * recalculate the parity and write the new results.\n\t *\n\t * We're not allowed to add any new bios to the\n\t * bio list here, anyone else that wants to\n\t * change this stripe needs to do their own rmw.\n\t */\n\tspin_lock_irq(&rbio->bio_list_lock);\n\tset_bit(RBIO_RMW_LOCKED_BIT, &rbio->flags);\n\tspin_unlock_irq(&rbio->bio_list_lock);\n\n\tatomic_set(&rbio->error, 0);\n\n\t/*\n\t * now that we've set rmw_locked, run through the\n\t * bio list one last time and map the page pointers\n\t *\n\t * We don't cache full rbios because we're assuming\n\t * the higher layers are unlikely to use this area of\n\t * the disk again soon.  If they do use it again,\n\t * hopefully they will send another full bio.\n\t */\n\tindex_rbio_pages(rbio);\n\tif (!rbio_is_full(rbio))\n\t\tcache_rbio_pages(rbio);\n\telse\n\t\tclear_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n\n\tfor (pagenr = 0; pagenr < pages_per_stripe; pagenr++) {\n\t\tstruct page *p;\n\t\t/* first collect one page from each data stripe */\n\t\tfor (stripe = 0; stripe < nr_data; stripe++) {\n\t\t\tp = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\tpointers[stripe] = kmap(p);\n\t\t}\n\n\t\t/* then add the parity stripe */\n\t\tp = rbio_pstripe_page(rbio, pagenr);\n\t\tSetPageUptodate(p);\n\t\tpointers[stripe++] = kmap(p);\n\n\t\tif (q_stripe != -1) {\n\n\t\t\t/*\n\t\t\t * raid6, add the qstripe and call the\n\t\t\t * library function to fill in our p/q\n\t\t\t */\n\t\t\tp = rbio_qstripe_page(rbio, pagenr);\n\t\t\tSetPageUptodate(p);\n\t\t\tpointers[stripe++] = kmap(p);\n\n\t\t\traid6_call.gen_syndrome(rbio->real_stripes, PAGE_SIZE,\n\t\t\t\t\t\tpointers);\n\t\t} else {\n\t\t\t/* raid5 */\n\t\t\tmemcpy(pointers[nr_data], pointers[0], PAGE_SIZE);\n\t\t\trun_xor(pointers + 1, nr_data - 1, PAGE_CACHE_SIZE);\n\t\t}\n\n\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++)\n\t\t\tkunmap(page_in_rbio(rbio, stripe, pagenr, 0));\n\t}\n\n\t/*\n\t * time to start writing.  Make bios for everything from the\n\t * higher layers (the bio_list in our rbio) and our p/q.  Ignore\n\t * everything else.\n\t */\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tfor (pagenr = 0; pagenr < pages_per_stripe; pagenr++) {\n\t\t\tstruct page *page;\n\t\t\tif (stripe < rbio->nr_data) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 1);\n\t\t\t\tif (!page)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t       page = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list,\n\t\t\t\t       page, stripe, pagenr, rbio->stripe_len);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (likely(!bbio->num_tgtdevs))\n\t\tgoto write_data;\n\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tif (!bbio->tgtdev_map[stripe])\n\t\t\tcontinue;\n\n\t\tfor (pagenr = 0; pagenr < pages_per_stripe; pagenr++) {\n\t\t\tstruct page *page;\n\t\t\tif (stripe < rbio->nr_data) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 1);\n\t\t\t\tif (!page)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t       page = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list, page,\n\t\t\t\t\t       rbio->bbio->tgtdev_map[stripe],\n\t\t\t\t\t       pagenr, rbio->stripe_len);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\nwrite_data:\n\tatomic_set(&rbio->stripes_pending, bio_list_size(&bio_list));\n\tBUG_ON(atomic_read(&rbio->stripes_pending) == 0);\n\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid_write_end_io;\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(WRITE, bio);\n\t}\n\treturn;\n\ncleanup:\n\trbio_orig_end_io(rbio, -EIO, 0);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define RBIO_CACHE_READY_BIT\t3",
      "#define RBIO_RMW_LOCKED_BIT\t1"
    ],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rbio_orig_end_io",
          "args": [
            "rbio",
            "-EIO",
            "0"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_orig_end_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "861-879",
          "snippet": "static void rbio_orig_end_io(struct btrfs_raid_bio *rbio, int err, int uptodate)\n{\n\tstruct bio *cur = bio_list_get(&rbio->bio_list);\n\tstruct bio *next;\n\n\tif (rbio->generic_bio_cnt)\n\t\tbtrfs_bio_counter_sub(rbio->fs_info, rbio->generic_bio_cnt);\n\n\tfree_raid_bio(rbio);\n\n\twhile (cur) {\n\t\tnext = cur->bi_next;\n\t\tcur->bi_next = NULL;\n\t\tif (uptodate)\n\t\t\tset_bit(BIO_UPTODATE, &cur->bi_flags);\n\t\tbio_endio(cur, err);\n\t\tcur = next;\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void rbio_orig_end_io(struct btrfs_raid_bio *rbio, int err, int uptodate)\n{\n\tstruct bio *cur = bio_list_get(&rbio->bio_list);\n\tstruct bio *next;\n\n\tif (rbio->generic_bio_cnt)\n\t\tbtrfs_bio_counter_sub(rbio->fs_info, rbio->generic_bio_cnt);\n\n\tfree_raid_bio(rbio);\n\n\twhile (cur) {\n\t\tnext = cur->bi_next;\n\t\tcur->bi_next = NULL;\n\t\tif (uptodate)\n\t\t\tset_bit(BIO_UPTODATE, &cur->bi_flags);\n\t\tbio_endio(cur, err);\n\t\tcur = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "WRITE",
            "bio"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_submit_bio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "3067-3071",
          "snippet": "int btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!test_bit(BIO_UPTODATE, &bio->bi_flags)"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BIO_UPTODATE",
            "&bio->bi_flags"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_list_pop",
          "args": [
            "&bio_list"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&rbio->stripes_pending) == 0"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rbio->stripes_pending"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&rbio->stripes_pending",
            "bio_list_size(&bio_list)"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_list_size",
          "args": [
            "&bio_list"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rbio_add_io_page",
          "args": [
            "rbio",
            "&bio_list",
            "page",
            "rbio->bbio->tgtdev_map[stripe]",
            "pagenr",
            "rbio->stripe_len"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_add_io_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1050-1102",
          "snippet": "static int rbio_add_io_page(struct btrfs_raid_bio *rbio,\n\t\t\t    struct bio_list *bio_list,\n\t\t\t    struct page *page,\n\t\t\t    int stripe_nr,\n\t\t\t    unsigned long page_index,\n\t\t\t    unsigned long bio_max_len)\n{\n\tstruct bio *last = bio_list->tail;\n\tu64 last_end = 0;\n\tint ret;\n\tstruct bio *bio;\n\tstruct btrfs_bio_stripe *stripe;\n\tu64 disk_start;\n\n\tstripe = &rbio->bbio->stripes[stripe_nr];\n\tdisk_start = stripe->physical + (page_index << PAGE_CACHE_SHIFT);\n\n\t/* if the device is missing, just fail this stripe */\n\tif (!stripe->dev->bdev)\n\t\treturn fail_rbio_index(rbio, stripe_nr);\n\n\t/* see if we can add this page onto our existing bio */\n\tif (last) {\n\t\tlast_end = (u64)last->bi_iter.bi_sector << 9;\n\t\tlast_end += last->bi_iter.bi_size;\n\n\t\t/*\n\t\t * we can't merge these if they are from different\n\t\t * devices or if they are not contiguous\n\t\t */\n\t\tif (last_end == disk_start && stripe->dev->bdev &&\n\t\t    test_bit(BIO_UPTODATE, &last->bi_flags) &&\n\t\t    last->bi_bdev == stripe->dev->bdev) {\n\t\t\tret = bio_add_page(last, page, PAGE_CACHE_SIZE, 0);\n\t\t\tif (ret == PAGE_CACHE_SIZE)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* put a new bio on the list */\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, bio_max_len >> PAGE_SHIFT?:1);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\n\tbio->bi_iter.bi_size = 0;\n\tbio->bi_bdev = stripe->dev->bdev;\n\tbio->bi_iter.bi_sector = disk_start >> 9;\n\tset_bit(BIO_UPTODATE, &bio->bi_flags);\n\n\tbio_add_page(bio, page, PAGE_CACHE_SIZE, 0);\n\tbio_list_add(bio_list, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int rbio_add_io_page(struct btrfs_raid_bio *rbio,\n\t\t\t    struct bio_list *bio_list,\n\t\t\t    struct page *page,\n\t\t\t    int stripe_nr,\n\t\t\t    unsigned long page_index,\n\t\t\t    unsigned long bio_max_len)\n{\n\tstruct bio *last = bio_list->tail;\n\tu64 last_end = 0;\n\tint ret;\n\tstruct bio *bio;\n\tstruct btrfs_bio_stripe *stripe;\n\tu64 disk_start;\n\n\tstripe = &rbio->bbio->stripes[stripe_nr];\n\tdisk_start = stripe->physical + (page_index << PAGE_CACHE_SHIFT);\n\n\t/* if the device is missing, just fail this stripe */\n\tif (!stripe->dev->bdev)\n\t\treturn fail_rbio_index(rbio, stripe_nr);\n\n\t/* see if we can add this page onto our existing bio */\n\tif (last) {\n\t\tlast_end = (u64)last->bi_iter.bi_sector << 9;\n\t\tlast_end += last->bi_iter.bi_size;\n\n\t\t/*\n\t\t * we can't merge these if they are from different\n\t\t * devices or if they are not contiguous\n\t\t */\n\t\tif (last_end == disk_start && stripe->dev->bdev &&\n\t\t    test_bit(BIO_UPTODATE, &last->bi_flags) &&\n\t\t    last->bi_bdev == stripe->dev->bdev) {\n\t\t\tret = bio_add_page(last, page, PAGE_CACHE_SIZE, 0);\n\t\t\tif (ret == PAGE_CACHE_SIZE)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* put a new bio on the list */\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, bio_max_len >> PAGE_SHIFT?:1);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\n\tbio->bi_iter.bi_size = 0;\n\tbio->bi_bdev = stripe->dev->bdev;\n\tbio->bi_iter.bi_sector = disk_start >> 9;\n\tset_bit(BIO_UPTODATE, &bio->bi_flags);\n\n\tbio_add_page(bio, page, PAGE_CACHE_SIZE, 0);\n\tbio_list_add(bio_list, bio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rbio_stripe_page",
          "args": [
            "rbio",
            "stripe",
            "pagenr"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_stripe_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1125-1131",
          "snippet": "static struct page *rbio_stripe_page(struct btrfs_raid_bio *rbio, int stripe, int page)\n{\n\tint index;\n\tindex = stripe * (rbio->stripe_len >> PAGE_CACHE_SHIFT);\n\tindex += page;\n\treturn rbio->stripe_pages[index];\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic struct page *rbio_stripe_page(struct btrfs_raid_bio *rbio, int stripe, int page)\n{\n\tint index;\n\tindex = stripe * (rbio->stripe_len >> PAGE_CACHE_SHIFT);\n\tindex += page;\n\treturn rbio->stripe_pages[index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_in_rbio",
          "args": [
            "rbio",
            "stripe",
            "pagenr",
            "1"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "page_in_rbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "923-939",
          "snippet": "static struct page *page_in_rbio(struct btrfs_raid_bio *rbio,\n\t\t\t\t int index, int pagenr, int bio_list_only)\n{\n\tint chunk_page;\n\tstruct page *p = NULL;\n\n\tchunk_page = index * (rbio->stripe_len >> PAGE_SHIFT) + pagenr;\n\n\tspin_lock_irq(&rbio->bio_list_lock);\n\tp = rbio->bio_pages[chunk_page];\n\tspin_unlock_irq(&rbio->bio_list_lock);\n\n\tif (p || bio_list_only)\n\t\treturn p;\n\n\treturn rbio->stripe_pages[chunk_page];\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic struct page *page_in_rbio(struct btrfs_raid_bio *rbio,\n\t\t\t\t int index, int pagenr, int bio_list_only)\n{\n\tint chunk_page;\n\tstruct page *p = NULL;\n\n\tchunk_page = index * (rbio->stripe_len >> PAGE_SHIFT) + pagenr;\n\n\tspin_lock_irq(&rbio->bio_list_lock);\n\tp = rbio->bio_pages[chunk_page];\n\tspin_unlock_irq(&rbio->bio_list_lock);\n\n\tif (p || bio_list_only)\n\t\treturn p;\n\n\treturn rbio->stripe_pages[chunk_page];\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!bbio->num_tgtdevs"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page_in_rbio(rbio, stripe, pagenr, 0)"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_xor",
          "args": [
            "pointers + 1",
            "nr_data - 1",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "run_xor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "520-533",
          "snippet": "static void run_xor(void **pages, int src_cnt, ssize_t len)\n{\n\tint src_off = 0;\n\tint xor_src_cnt = 0;\n\tvoid *dest = pages[src_cnt];\n\n\twhile(src_cnt > 0) {\n\t\txor_src_cnt = min(src_cnt, MAX_XOR_BLOCKS);\n\t\txor_blocks(xor_src_cnt, len, dest, pages + src_off);\n\n\t\tsrc_cnt -= xor_src_cnt;\n\t\tsrc_off += xor_src_cnt;\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic void run_xor(void **pages, int src_cnt, ssize_t len)\n{\n\tint src_off = 0;\n\tint xor_src_cnt = 0;\n\tvoid *dest = pages[src_cnt];\n\n\twhile(src_cnt > 0) {\n\t\txor_src_cnt = min(src_cnt, MAX_XOR_BLOCKS);\n\t\txor_blocks(xor_src_cnt, len, dest, pages + src_off);\n\n\t\tsrc_cnt -= xor_src_cnt;\n\t\tsrc_off += xor_src_cnt;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pointers[nr_data]",
            "pointers[0]",
            "PAGE_SIZE"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raid6_call.gen_syndrome",
          "args": [
            "rbio->real_stripes",
            "PAGE_SIZE",
            "pointers"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "p"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "p"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rbio_qstripe_page",
          "args": [
            "rbio",
            "pagenr"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_qstripe_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "628-636",
          "snippet": "static struct page *rbio_qstripe_page(struct btrfs_raid_bio *rbio, int index)\n{\n\tif (rbio->nr_data + 1 == rbio->real_stripes)\n\t\treturn NULL;\n\n\tindex += ((rbio->nr_data + 1) * rbio->stripe_len) >>\n\t\tPAGE_CACHE_SHIFT;\n\treturn rbio->stripe_pages[index];\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic struct page *rbio_qstripe_page(struct btrfs_raid_bio *rbio, int index)\n{\n\tif (rbio->nr_data + 1 == rbio->real_stripes)\n\t\treturn NULL;\n\n\tindex += ((rbio->nr_data + 1) * rbio->stripe_len) >>\n\t\tPAGE_CACHE_SHIFT;\n\treturn rbio->stripe_pages[index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "p"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "p"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rbio_pstripe_page",
          "args": [
            "rbio",
            "pagenr"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_pstripe_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "618-622",
          "snippet": "static struct page *rbio_pstripe_page(struct btrfs_raid_bio *rbio, int index)\n{\n\tindex += (rbio->nr_data * rbio->stripe_len) >> PAGE_CACHE_SHIFT;\n\treturn rbio->stripe_pages[index];\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic struct page *rbio_pstripe_page(struct btrfs_raid_bio *rbio, int index)\n{\n\tindex += (rbio->nr_data * rbio->stripe_len) >> PAGE_CACHE_SHIFT;\n\treturn rbio->stripe_pages[index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "p"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "RBIO_CACHE_READY_BIT",
            "&rbio->flags"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_rbio_pages",
          "args": [
            "rbio"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "cache_rbio_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "258-283",
          "snippet": "static void cache_rbio_pages(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\tchar *s;\n\tchar *d;\n\tint ret;\n\n\tret = alloc_rbio_pages(rbio);\n\tif (ret)\n\t\treturn;\n\n\tfor (i = 0; i < rbio->nr_pages; i++) {\n\t\tif (!rbio->bio_pages[i])\n\t\t\tcontinue;\n\n\t\ts = kmap(rbio->bio_pages[i]);\n\t\td = kmap(rbio->stripe_pages[i]);\n\n\t\tmemcpy(d, s, PAGE_CACHE_SIZE);\n\n\t\tkunmap(rbio->bio_pages[i]);\n\t\tkunmap(rbio->stripe_pages[i]);\n\t\tSetPageUptodate(rbio->stripe_pages[i]);\n\t}\n\tset_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RBIO_CACHE_READY_BIT\t3"
          ],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_READY_BIT\t3\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void cache_rbio_pages(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\tchar *s;\n\tchar *d;\n\tint ret;\n\n\tret = alloc_rbio_pages(rbio);\n\tif (ret)\n\t\treturn;\n\n\tfor (i = 0; i < rbio->nr_pages; i++) {\n\t\tif (!rbio->bio_pages[i])\n\t\t\tcontinue;\n\n\t\ts = kmap(rbio->bio_pages[i]);\n\t\td = kmap(rbio->stripe_pages[i]);\n\n\t\tmemcpy(d, s, PAGE_CACHE_SIZE);\n\n\t\tkunmap(rbio->bio_pages[i]);\n\t\tkunmap(rbio->stripe_pages[i]);\n\t\tSetPageUptodate(rbio->stripe_pages[i]);\n\t}\n\tset_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rbio_is_full",
          "args": [
            "rbio"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_is_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "554-563",
          "snippet": "static int rbio_is_full(struct btrfs_raid_bio *rbio)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&rbio->bio_list_lock, flags);\n\tret = __rbio_is_full(rbio);\n\tspin_unlock_irqrestore(&rbio->bio_list_lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int rbio_is_full(struct btrfs_raid_bio *rbio)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&rbio->bio_list_lock, flags);\n\tret = __rbio_is_full(rbio);\n\tspin_unlock_irqrestore(&rbio->bio_list_lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_rbio_pages",
          "args": [
            "rbio"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "index_rbio_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1141-1162",
          "snippet": "static void index_rbio_pages(struct btrfs_raid_bio *rbio)\n{\n\tstruct bio *bio;\n\tu64 start;\n\tunsigned long stripe_offset;\n\tunsigned long page_index;\n\tstruct page *p;\n\tint i;\n\n\tspin_lock_irq(&rbio->bio_list_lock);\n\tbio_list_for_each(bio, &rbio->bio_list) {\n\t\tstart = (u64)bio->bi_iter.bi_sector << 9;\n\t\tstripe_offset = start - rbio->bbio->raid_map[0];\n\t\tpage_index = stripe_offset >> PAGE_CACHE_SHIFT;\n\n\t\tfor (i = 0; i < bio->bi_vcnt; i++) {\n\t\t\tp = bio->bi_io_vec[i].bv_page;\n\t\t\trbio->bio_pages[page_index + i] = p;\n\t\t}\n\t}\n\tspin_unlock_irq(&rbio->bio_list_lock);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio)\n{\n\tstruct bio *bio;\n\tu64 start;\n\tunsigned long stripe_offset;\n\tunsigned long page_index;\n\tstruct page *p;\n\tint i;\n\n\tspin_lock_irq(&rbio->bio_list_lock);\n\tbio_list_for_each(bio, &rbio->bio_list) {\n\t\tstart = (u64)bio->bi_iter.bi_sector << 9;\n\t\tstripe_offset = start - rbio->bbio->raid_map[0];\n\t\tpage_index = stripe_offset >> PAGE_CACHE_SHIFT;\n\n\t\tfor (i = 0; i < bio->bi_vcnt; i++) {\n\t\t\tp = bio->bi_io_vec[i].bv_page;\n\t\t\trbio->bio_pages[page_index + i] = p;\n\t\t}\n\t}\n\tspin_unlock_irq(&rbio->bio_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&rbio->error",
            "0"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&rbio->bio_list_lock"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "RBIO_RMW_LOCKED_BIT",
            "&rbio->flags"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&rbio->bio_list_lock"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_list_init",
          "args": [
            "&bio_list"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_READY_BIT\t3\n#define RBIO_RMW_LOCKED_BIT\t1\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio)\n{\n\tstruct btrfs_bio *bbio = rbio->bbio;\n\tvoid *pointers[rbio->real_stripes];\n\tint stripe_len = rbio->stripe_len;\n\tint nr_data = rbio->nr_data;\n\tint stripe;\n\tint pagenr;\n\tint p_stripe = -1;\n\tint q_stripe = -1;\n\tstruct bio_list bio_list;\n\tstruct bio *bio;\n\tint pages_per_stripe = stripe_len >> PAGE_CACHE_SHIFT;\n\tint ret;\n\n\tbio_list_init(&bio_list);\n\n\tif (rbio->real_stripes - rbio->nr_data == 1) {\n\t\tp_stripe = rbio->real_stripes - 1;\n\t} else if (rbio->real_stripes - rbio->nr_data == 2) {\n\t\tp_stripe = rbio->real_stripes - 2;\n\t\tq_stripe = rbio->real_stripes - 1;\n\t} else {\n\t\tBUG();\n\t}\n\n\t/* at this point we either have a full stripe,\n\t * or we've read the full stripe from the drive.\n\t * recalculate the parity and write the new results.\n\t *\n\t * We're not allowed to add any new bios to the\n\t * bio list here, anyone else that wants to\n\t * change this stripe needs to do their own rmw.\n\t */\n\tspin_lock_irq(&rbio->bio_list_lock);\n\tset_bit(RBIO_RMW_LOCKED_BIT, &rbio->flags);\n\tspin_unlock_irq(&rbio->bio_list_lock);\n\n\tatomic_set(&rbio->error, 0);\n\n\t/*\n\t * now that we've set rmw_locked, run through the\n\t * bio list one last time and map the page pointers\n\t *\n\t * We don't cache full rbios because we're assuming\n\t * the higher layers are unlikely to use this area of\n\t * the disk again soon.  If they do use it again,\n\t * hopefully they will send another full bio.\n\t */\n\tindex_rbio_pages(rbio);\n\tif (!rbio_is_full(rbio))\n\t\tcache_rbio_pages(rbio);\n\telse\n\t\tclear_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n\n\tfor (pagenr = 0; pagenr < pages_per_stripe; pagenr++) {\n\t\tstruct page *p;\n\t\t/* first collect one page from each data stripe */\n\t\tfor (stripe = 0; stripe < nr_data; stripe++) {\n\t\t\tp = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\tpointers[stripe] = kmap(p);\n\t\t}\n\n\t\t/* then add the parity stripe */\n\t\tp = rbio_pstripe_page(rbio, pagenr);\n\t\tSetPageUptodate(p);\n\t\tpointers[stripe++] = kmap(p);\n\n\t\tif (q_stripe != -1) {\n\n\t\t\t/*\n\t\t\t * raid6, add the qstripe and call the\n\t\t\t * library function to fill in our p/q\n\t\t\t */\n\t\t\tp = rbio_qstripe_page(rbio, pagenr);\n\t\t\tSetPageUptodate(p);\n\t\t\tpointers[stripe++] = kmap(p);\n\n\t\t\traid6_call.gen_syndrome(rbio->real_stripes, PAGE_SIZE,\n\t\t\t\t\t\tpointers);\n\t\t} else {\n\t\t\t/* raid5 */\n\t\t\tmemcpy(pointers[nr_data], pointers[0], PAGE_SIZE);\n\t\t\trun_xor(pointers + 1, nr_data - 1, PAGE_CACHE_SIZE);\n\t\t}\n\n\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++)\n\t\t\tkunmap(page_in_rbio(rbio, stripe, pagenr, 0));\n\t}\n\n\t/*\n\t * time to start writing.  Make bios for everything from the\n\t * higher layers (the bio_list in our rbio) and our p/q.  Ignore\n\t * everything else.\n\t */\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tfor (pagenr = 0; pagenr < pages_per_stripe; pagenr++) {\n\t\t\tstruct page *page;\n\t\t\tif (stripe < rbio->nr_data) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 1);\n\t\t\t\tif (!page)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t       page = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list,\n\t\t\t\t       page, stripe, pagenr, rbio->stripe_len);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (likely(!bbio->num_tgtdevs))\n\t\tgoto write_data;\n\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tif (!bbio->tgtdev_map[stripe])\n\t\t\tcontinue;\n\n\t\tfor (pagenr = 0; pagenr < pages_per_stripe; pagenr++) {\n\t\t\tstruct page *page;\n\t\t\tif (stripe < rbio->nr_data) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 1);\n\t\t\t\tif (!page)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t       page = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list, page,\n\t\t\t\t\t       rbio->bbio->tgtdev_map[stripe],\n\t\t\t\t\t       pagenr, rbio->stripe_len);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\nwrite_data:\n\tatomic_set(&rbio->stripes_pending, bio_list_size(&bio_list));\n\tBUG_ON(atomic_read(&rbio->stripes_pending) == 0);\n\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid_write_end_io;\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(WRITE, bio);\n\t}\n\treturn;\n\ncleanup:\n\trbio_orig_end_io(rbio, -EIO, 0);\n}"
  },
  {
    "function_name": "index_rbio_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "1141-1162",
    "snippet": "static void index_rbio_pages(struct btrfs_raid_bio *rbio)\n{\n\tstruct bio *bio;\n\tu64 start;\n\tunsigned long stripe_offset;\n\tunsigned long page_index;\n\tstruct page *p;\n\tint i;\n\n\tspin_lock_irq(&rbio->bio_list_lock);\n\tbio_list_for_each(bio, &rbio->bio_list) {\n\t\tstart = (u64)bio->bi_iter.bi_sector << 9;\n\t\tstripe_offset = start - rbio->bbio->raid_map[0];\n\t\tpage_index = stripe_offset >> PAGE_CACHE_SHIFT;\n\n\t\tfor (i = 0; i < bio->bi_vcnt; i++) {\n\t\t\tp = bio->bi_io_vec[i].bv_page;\n\t\t\trbio->bio_pages[page_index + i] = p;\n\t\t}\n\t}\n\tspin_unlock_irq(&rbio->bio_list_lock);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&rbio->bio_list_lock"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_list_for_each",
          "args": [
            "bio",
            "&rbio->bio_list"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&rbio->bio_list_lock"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio)\n{\n\tstruct bio *bio;\n\tu64 start;\n\tunsigned long stripe_offset;\n\tunsigned long page_index;\n\tstruct page *p;\n\tint i;\n\n\tspin_lock_irq(&rbio->bio_list_lock);\n\tbio_list_for_each(bio, &rbio->bio_list) {\n\t\tstart = (u64)bio->bi_iter.bi_sector << 9;\n\t\tstripe_offset = start - rbio->bbio->raid_map[0];\n\t\tpage_index = stripe_offset >> PAGE_CACHE_SHIFT;\n\n\t\tfor (i = 0; i < bio->bi_vcnt; i++) {\n\t\t\tp = bio->bi_io_vec[i].bv_page;\n\t\t\trbio->bio_pages[page_index + i] = p;\n\t\t}\n\t}\n\tspin_unlock_irq(&rbio->bio_list_lock);\n}"
  },
  {
    "function_name": "rbio_stripe_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "1125-1131",
    "snippet": "static struct page *rbio_stripe_page(struct btrfs_raid_bio *rbio, int stripe, int page)\n{\n\tint index;\n\tindex = stripe * (rbio->stripe_len >> PAGE_CACHE_SHIFT);\n\tindex += page;\n\treturn rbio->stripe_pages[index];\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic struct page *rbio_stripe_page(struct btrfs_raid_bio *rbio, int stripe, int page)\n{\n\tint index;\n\tindex = stripe * (rbio->stripe_len >> PAGE_CACHE_SHIFT);\n\tindex += page;\n\treturn rbio->stripe_pages[index];\n}"
  },
  {
    "function_name": "validate_rbio_for_rmw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "1111-1119",
    "snippet": "static void validate_rbio_for_rmw(struct btrfs_raid_bio *rbio)\n{\n\tif (rbio->faila >= 0 || rbio->failb >= 0) {\n\t\tBUG_ON(rbio->faila == rbio->real_stripes - 1);\n\t\t__raid56_parity_recover(rbio);\n\t} else {\n\t\tfinish_rmw(rbio);\n\t}\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_rmw",
          "args": [
            "rbio"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "finish_rmw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1172-1329",
          "snippet": "static noinline void finish_rmw(struct btrfs_raid_bio *rbio)\n{\n\tstruct btrfs_bio *bbio = rbio->bbio;\n\tvoid *pointers[rbio->real_stripes];\n\tint stripe_len = rbio->stripe_len;\n\tint nr_data = rbio->nr_data;\n\tint stripe;\n\tint pagenr;\n\tint p_stripe = -1;\n\tint q_stripe = -1;\n\tstruct bio_list bio_list;\n\tstruct bio *bio;\n\tint pages_per_stripe = stripe_len >> PAGE_CACHE_SHIFT;\n\tint ret;\n\n\tbio_list_init(&bio_list);\n\n\tif (rbio->real_stripes - rbio->nr_data == 1) {\n\t\tp_stripe = rbio->real_stripes - 1;\n\t} else if (rbio->real_stripes - rbio->nr_data == 2) {\n\t\tp_stripe = rbio->real_stripes - 2;\n\t\tq_stripe = rbio->real_stripes - 1;\n\t} else {\n\t\tBUG();\n\t}\n\n\t/* at this point we either have a full stripe,\n\t * or we've read the full stripe from the drive.\n\t * recalculate the parity and write the new results.\n\t *\n\t * We're not allowed to add any new bios to the\n\t * bio list here, anyone else that wants to\n\t * change this stripe needs to do their own rmw.\n\t */\n\tspin_lock_irq(&rbio->bio_list_lock);\n\tset_bit(RBIO_RMW_LOCKED_BIT, &rbio->flags);\n\tspin_unlock_irq(&rbio->bio_list_lock);\n\n\tatomic_set(&rbio->error, 0);\n\n\t/*\n\t * now that we've set rmw_locked, run through the\n\t * bio list one last time and map the page pointers\n\t *\n\t * We don't cache full rbios because we're assuming\n\t * the higher layers are unlikely to use this area of\n\t * the disk again soon.  If they do use it again,\n\t * hopefully they will send another full bio.\n\t */\n\tindex_rbio_pages(rbio);\n\tif (!rbio_is_full(rbio))\n\t\tcache_rbio_pages(rbio);\n\telse\n\t\tclear_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n\n\tfor (pagenr = 0; pagenr < pages_per_stripe; pagenr++) {\n\t\tstruct page *p;\n\t\t/* first collect one page from each data stripe */\n\t\tfor (stripe = 0; stripe < nr_data; stripe++) {\n\t\t\tp = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\tpointers[stripe] = kmap(p);\n\t\t}\n\n\t\t/* then add the parity stripe */\n\t\tp = rbio_pstripe_page(rbio, pagenr);\n\t\tSetPageUptodate(p);\n\t\tpointers[stripe++] = kmap(p);\n\n\t\tif (q_stripe != -1) {\n\n\t\t\t/*\n\t\t\t * raid6, add the qstripe and call the\n\t\t\t * library function to fill in our p/q\n\t\t\t */\n\t\t\tp = rbio_qstripe_page(rbio, pagenr);\n\t\t\tSetPageUptodate(p);\n\t\t\tpointers[stripe++] = kmap(p);\n\n\t\t\traid6_call.gen_syndrome(rbio->real_stripes, PAGE_SIZE,\n\t\t\t\t\t\tpointers);\n\t\t} else {\n\t\t\t/* raid5 */\n\t\t\tmemcpy(pointers[nr_data], pointers[0], PAGE_SIZE);\n\t\t\trun_xor(pointers + 1, nr_data - 1, PAGE_CACHE_SIZE);\n\t\t}\n\n\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++)\n\t\t\tkunmap(page_in_rbio(rbio, stripe, pagenr, 0));\n\t}\n\n\t/*\n\t * time to start writing.  Make bios for everything from the\n\t * higher layers (the bio_list in our rbio) and our p/q.  Ignore\n\t * everything else.\n\t */\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tfor (pagenr = 0; pagenr < pages_per_stripe; pagenr++) {\n\t\t\tstruct page *page;\n\t\t\tif (stripe < rbio->nr_data) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 1);\n\t\t\t\tif (!page)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t       page = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list,\n\t\t\t\t       page, stripe, pagenr, rbio->stripe_len);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (likely(!bbio->num_tgtdevs))\n\t\tgoto write_data;\n\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tif (!bbio->tgtdev_map[stripe])\n\t\t\tcontinue;\n\n\t\tfor (pagenr = 0; pagenr < pages_per_stripe; pagenr++) {\n\t\t\tstruct page *page;\n\t\t\tif (stripe < rbio->nr_data) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 1);\n\t\t\t\tif (!page)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t       page = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list, page,\n\t\t\t\t\t       rbio->bbio->tgtdev_map[stripe],\n\t\t\t\t\t       pagenr, rbio->stripe_len);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\nwrite_data:\n\tatomic_set(&rbio->stripes_pending, bio_list_size(&bio_list));\n\tBUG_ON(atomic_read(&rbio->stripes_pending) == 0);\n\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid_write_end_io;\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(WRITE, bio);\n\t}\n\treturn;\n\ncleanup:\n\trbio_orig_end_io(rbio, -EIO, 0);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RBIO_CACHE_READY_BIT\t3",
            "#define RBIO_RMW_LOCKED_BIT\t1"
          ],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_READY_BIT\t3\n#define RBIO_RMW_LOCKED_BIT\t1\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio)\n{\n\tstruct btrfs_bio *bbio = rbio->bbio;\n\tvoid *pointers[rbio->real_stripes];\n\tint stripe_len = rbio->stripe_len;\n\tint nr_data = rbio->nr_data;\n\tint stripe;\n\tint pagenr;\n\tint p_stripe = -1;\n\tint q_stripe = -1;\n\tstruct bio_list bio_list;\n\tstruct bio *bio;\n\tint pages_per_stripe = stripe_len >> PAGE_CACHE_SHIFT;\n\tint ret;\n\n\tbio_list_init(&bio_list);\n\n\tif (rbio->real_stripes - rbio->nr_data == 1) {\n\t\tp_stripe = rbio->real_stripes - 1;\n\t} else if (rbio->real_stripes - rbio->nr_data == 2) {\n\t\tp_stripe = rbio->real_stripes - 2;\n\t\tq_stripe = rbio->real_stripes - 1;\n\t} else {\n\t\tBUG();\n\t}\n\n\t/* at this point we either have a full stripe,\n\t * or we've read the full stripe from the drive.\n\t * recalculate the parity and write the new results.\n\t *\n\t * We're not allowed to add any new bios to the\n\t * bio list here, anyone else that wants to\n\t * change this stripe needs to do their own rmw.\n\t */\n\tspin_lock_irq(&rbio->bio_list_lock);\n\tset_bit(RBIO_RMW_LOCKED_BIT, &rbio->flags);\n\tspin_unlock_irq(&rbio->bio_list_lock);\n\n\tatomic_set(&rbio->error, 0);\n\n\t/*\n\t * now that we've set rmw_locked, run through the\n\t * bio list one last time and map the page pointers\n\t *\n\t * We don't cache full rbios because we're assuming\n\t * the higher layers are unlikely to use this area of\n\t * the disk again soon.  If they do use it again,\n\t * hopefully they will send another full bio.\n\t */\n\tindex_rbio_pages(rbio);\n\tif (!rbio_is_full(rbio))\n\t\tcache_rbio_pages(rbio);\n\telse\n\t\tclear_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n\n\tfor (pagenr = 0; pagenr < pages_per_stripe; pagenr++) {\n\t\tstruct page *p;\n\t\t/* first collect one page from each data stripe */\n\t\tfor (stripe = 0; stripe < nr_data; stripe++) {\n\t\t\tp = page_in_rbio(rbio, stripe, pagenr, 0);\n\t\t\tpointers[stripe] = kmap(p);\n\t\t}\n\n\t\t/* then add the parity stripe */\n\t\tp = rbio_pstripe_page(rbio, pagenr);\n\t\tSetPageUptodate(p);\n\t\tpointers[stripe++] = kmap(p);\n\n\t\tif (q_stripe != -1) {\n\n\t\t\t/*\n\t\t\t * raid6, add the qstripe and call the\n\t\t\t * library function to fill in our p/q\n\t\t\t */\n\t\t\tp = rbio_qstripe_page(rbio, pagenr);\n\t\t\tSetPageUptodate(p);\n\t\t\tpointers[stripe++] = kmap(p);\n\n\t\t\traid6_call.gen_syndrome(rbio->real_stripes, PAGE_SIZE,\n\t\t\t\t\t\tpointers);\n\t\t} else {\n\t\t\t/* raid5 */\n\t\t\tmemcpy(pointers[nr_data], pointers[0], PAGE_SIZE);\n\t\t\trun_xor(pointers + 1, nr_data - 1, PAGE_CACHE_SIZE);\n\t\t}\n\n\n\t\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++)\n\t\t\tkunmap(page_in_rbio(rbio, stripe, pagenr, 0));\n\t}\n\n\t/*\n\t * time to start writing.  Make bios for everything from the\n\t * higher layers (the bio_list in our rbio) and our p/q.  Ignore\n\t * everything else.\n\t */\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tfor (pagenr = 0; pagenr < pages_per_stripe; pagenr++) {\n\t\t\tstruct page *page;\n\t\t\tif (stripe < rbio->nr_data) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 1);\n\t\t\t\tif (!page)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t       page = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list,\n\t\t\t\t       page, stripe, pagenr, rbio->stripe_len);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (likely(!bbio->num_tgtdevs))\n\t\tgoto write_data;\n\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tif (!bbio->tgtdev_map[stripe])\n\t\t\tcontinue;\n\n\t\tfor (pagenr = 0; pagenr < pages_per_stripe; pagenr++) {\n\t\t\tstruct page *page;\n\t\t\tif (stripe < rbio->nr_data) {\n\t\t\t\tpage = page_in_rbio(rbio, stripe, pagenr, 1);\n\t\t\t\tif (!page)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t       page = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\t}\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list, page,\n\t\t\t\t\t       rbio->bbio->tgtdev_map[stripe],\n\t\t\t\t\t       pagenr, rbio->stripe_len);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\nwrite_data:\n\tatomic_set(&rbio->stripes_pending, bio_list_size(&bio_list));\n\tBUG_ON(atomic_read(&rbio->stripes_pending) == 0);\n\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid_write_end_io;\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(WRITE, bio);\n\t}\n\treturn;\n\ncleanup:\n\trbio_orig_end_io(rbio, -EIO, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__raid56_parity_recover",
          "args": [
            "rbio"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "__raid56_parity_recover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "2026-2115",
          "snippet": "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio)\n{\n\tint bios_to_read = 0;\n\tstruct bio_list bio_list;\n\tint ret;\n\tint nr_pages = DIV_ROUND_UP(rbio->stripe_len, PAGE_CACHE_SIZE);\n\tint pagenr;\n\tint stripe;\n\tstruct bio *bio;\n\n\tbio_list_init(&bio_list);\n\n\tret = alloc_rbio_pages(rbio);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tatomic_set(&rbio->error, 0);\n\n\t/*\n\t * read everything that hasn't failed.  Thanks to the\n\t * stripe cache, it is possible that some or all of these\n\t * pages are going to be uptodate.\n\t */\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tif (rbio->faila == stripe || rbio->failb == stripe) {\n\t\t\tatomic_inc(&rbio->error);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (pagenr = 0; pagenr < nr_pages; pagenr++) {\n\t\t\tstruct page *p;\n\n\t\t\t/*\n\t\t\t * the rmw code may have already read this\n\t\t\t * page in\n\t\t\t */\n\t\t\tp = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\tif (PageUptodate(p))\n\t\t\t\tcontinue;\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list,\n\t\t\t\t       rbio_stripe_page(rbio, stripe, pagenr),\n\t\t\t\t       stripe, pagenr, rbio->stripe_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tbios_to_read = bio_list_size(&bio_list);\n\tif (!bios_to_read) {\n\t\t/*\n\t\t * we might have no bios to read just because the pages\n\t\t * were up to date, or we might have no bios to read because\n\t\t * the devices were gone.\n\t\t */\n\t\tif (atomic_read(&rbio->error) <= rbio->bbio->max_errors) {\n\t\t\t__raid_recover_end_io(rbio);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/*\n\t * the bbio may be freed once we submit the last bio.  Make sure\n\t * not to touch it after that\n\t */\n\tatomic_set(&rbio->stripes_pending, bios_to_read);\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid_recover_end_io;\n\n\t\tbtrfs_bio_wq_end_io(rbio->fs_info, bio,\n\t\t\t\t    BTRFS_WQ_ENDIO_RAID56);\n\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(READ, bio);\n\t}\nout:\n\treturn 0;\n\ncleanup:\n\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD)\n\t\trbio_orig_end_io(rbio, -EIO, 0);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio)\n{\n\tint bios_to_read = 0;\n\tstruct bio_list bio_list;\n\tint ret;\n\tint nr_pages = DIV_ROUND_UP(rbio->stripe_len, PAGE_CACHE_SIZE);\n\tint pagenr;\n\tint stripe;\n\tstruct bio *bio;\n\n\tbio_list_init(&bio_list);\n\n\tret = alloc_rbio_pages(rbio);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tatomic_set(&rbio->error, 0);\n\n\t/*\n\t * read everything that hasn't failed.  Thanks to the\n\t * stripe cache, it is possible that some or all of these\n\t * pages are going to be uptodate.\n\t */\n\tfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\n\t\tif (rbio->faila == stripe || rbio->failb == stripe) {\n\t\t\tatomic_inc(&rbio->error);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (pagenr = 0; pagenr < nr_pages; pagenr++) {\n\t\t\tstruct page *p;\n\n\t\t\t/*\n\t\t\t * the rmw code may have already read this\n\t\t\t * page in\n\t\t\t */\n\t\t\tp = rbio_stripe_page(rbio, stripe, pagenr);\n\t\t\tif (PageUptodate(p))\n\t\t\t\tcontinue;\n\n\t\t\tret = rbio_add_io_page(rbio, &bio_list,\n\t\t\t\t       rbio_stripe_page(rbio, stripe, pagenr),\n\t\t\t\t       stripe, pagenr, rbio->stripe_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tbios_to_read = bio_list_size(&bio_list);\n\tif (!bios_to_read) {\n\t\t/*\n\t\t * we might have no bios to read just because the pages\n\t\t * were up to date, or we might have no bios to read because\n\t\t * the devices were gone.\n\t\t */\n\t\tif (atomic_read(&rbio->error) <= rbio->bbio->max_errors) {\n\t\t\t__raid_recover_end_io(rbio);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/*\n\t * the bbio may be freed once we submit the last bio.  Make sure\n\t * not to touch it after that\n\t */\n\tatomic_set(&rbio->stripes_pending, bios_to_read);\n\twhile (1) {\n\t\tbio = bio_list_pop(&bio_list);\n\t\tif (!bio)\n\t\t\tbreak;\n\n\t\tbio->bi_private = rbio;\n\t\tbio->bi_end_io = raid_recover_end_io;\n\n\t\tbtrfs_bio_wq_end_io(rbio->fs_info, bio,\n\t\t\t\t    BTRFS_WQ_ENDIO_RAID56);\n\n\t\tBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\n\t\tsubmit_bio(READ, bio);\n\t}\nout:\n\treturn 0;\n\ncleanup:\n\tif (rbio->operation == BTRFS_RBIO_READ_REBUILD)\n\t\trbio_orig_end_io(rbio, -EIO, 0);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "rbio->faila == rbio->real_stripes - 1"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void validate_rbio_for_rmw(struct btrfs_raid_bio *rbio)\n{\n\tif (rbio->faila >= 0 || rbio->failb >= 0) {\n\t\tBUG_ON(rbio->faila == rbio->real_stripes - 1);\n\t\t__raid56_parity_recover(rbio);\n\t} else {\n\t\tfinish_rmw(rbio);\n\t}\n}"
  },
  {
    "function_name": "rbio_add_io_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "1050-1102",
    "snippet": "static int rbio_add_io_page(struct btrfs_raid_bio *rbio,\n\t\t\t    struct bio_list *bio_list,\n\t\t\t    struct page *page,\n\t\t\t    int stripe_nr,\n\t\t\t    unsigned long page_index,\n\t\t\t    unsigned long bio_max_len)\n{\n\tstruct bio *last = bio_list->tail;\n\tu64 last_end = 0;\n\tint ret;\n\tstruct bio *bio;\n\tstruct btrfs_bio_stripe *stripe;\n\tu64 disk_start;\n\n\tstripe = &rbio->bbio->stripes[stripe_nr];\n\tdisk_start = stripe->physical + (page_index << PAGE_CACHE_SHIFT);\n\n\t/* if the device is missing, just fail this stripe */\n\tif (!stripe->dev->bdev)\n\t\treturn fail_rbio_index(rbio, stripe_nr);\n\n\t/* see if we can add this page onto our existing bio */\n\tif (last) {\n\t\tlast_end = (u64)last->bi_iter.bi_sector << 9;\n\t\tlast_end += last->bi_iter.bi_size;\n\n\t\t/*\n\t\t * we can't merge these if they are from different\n\t\t * devices or if they are not contiguous\n\t\t */\n\t\tif (last_end == disk_start && stripe->dev->bdev &&\n\t\t    test_bit(BIO_UPTODATE, &last->bi_flags) &&\n\t\t    last->bi_bdev == stripe->dev->bdev) {\n\t\t\tret = bio_add_page(last, page, PAGE_CACHE_SIZE, 0);\n\t\t\tif (ret == PAGE_CACHE_SIZE)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* put a new bio on the list */\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, bio_max_len >> PAGE_SHIFT?:1);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\n\tbio->bi_iter.bi_size = 0;\n\tbio->bi_bdev = stripe->dev->bdev;\n\tbio->bi_iter.bi_sector = disk_start >> 9;\n\tset_bit(BIO_UPTODATE, &bio->bi_flags);\n\n\tbio_add_page(bio, page, PAGE_CACHE_SIZE, 0);\n\tbio_list_add(bio_list, bio);\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_list_add",
          "args": [
            "bio_list",
            "bio"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "bio",
            "page",
            "PAGE_CACHE_SIZE",
            "0"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BIO_UPTODATE",
            "&bio->bi_flags"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_io_bio_alloc",
          "args": [
            "GFP_NOFS",
            "bio_max_len >> PAGE_SHIFT?:1"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2733-2746",
          "snippet": "struct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "last",
            "page",
            "PAGE_CACHE_SIZE",
            "0"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BIO_UPTODATE",
            "&last->bi_flags"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fail_rbio_index",
          "args": [
            "rbio",
            "stripe_nr"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "fail_rbio_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1385-1411",
          "snippet": "static int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&rbio->bio_list_lock, flags);\n\n\t/* we already know this stripe is bad, move on */\n\tif (rbio->faila == failed || rbio->failb == failed)\n\t\tgoto out;\n\n\tif (rbio->faila == -1) {\n\t\t/* first failure on this rbio */\n\t\trbio->faila = failed;\n\t\tatomic_inc(&rbio->error);\n\t} else if (rbio->failb == -1) {\n\t\t/* second failure on this rbio */\n\t\trbio->failb = failed;\n\t\tatomic_inc(&rbio->error);\n\t} else {\n\t\tret = -EIO;\n\t}\nout:\n\tspin_unlock_irqrestore(&rbio->bio_list_lock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&rbio->bio_list_lock, flags);\n\n\t/* we already know this stripe is bad, move on */\n\tif (rbio->faila == failed || rbio->failb == failed)\n\t\tgoto out;\n\n\tif (rbio->faila == -1) {\n\t\t/* first failure on this rbio */\n\t\trbio->faila = failed;\n\t\tatomic_inc(&rbio->error);\n\t} else if (rbio->failb == -1) {\n\t\t/* second failure on this rbio */\n\t\trbio->failb = failed;\n\t\tatomic_inc(&rbio->error);\n\t} else {\n\t\tret = -EIO;\n\t}\nout:\n\tspin_unlock_irqrestore(&rbio->bio_list_lock, flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int rbio_add_io_page(struct btrfs_raid_bio *rbio,\n\t\t\t    struct bio_list *bio_list,\n\t\t\t    struct page *page,\n\t\t\t    int stripe_nr,\n\t\t\t    unsigned long page_index,\n\t\t\t    unsigned long bio_max_len)\n{\n\tstruct bio *last = bio_list->tail;\n\tu64 last_end = 0;\n\tint ret;\n\tstruct bio *bio;\n\tstruct btrfs_bio_stripe *stripe;\n\tu64 disk_start;\n\n\tstripe = &rbio->bbio->stripes[stripe_nr];\n\tdisk_start = stripe->physical + (page_index << PAGE_CACHE_SHIFT);\n\n\t/* if the device is missing, just fail this stripe */\n\tif (!stripe->dev->bdev)\n\t\treturn fail_rbio_index(rbio, stripe_nr);\n\n\t/* see if we can add this page onto our existing bio */\n\tif (last) {\n\t\tlast_end = (u64)last->bi_iter.bi_sector << 9;\n\t\tlast_end += last->bi_iter.bi_size;\n\n\t\t/*\n\t\t * we can't merge these if they are from different\n\t\t * devices or if they are not contiguous\n\t\t */\n\t\tif (last_end == disk_start && stripe->dev->bdev &&\n\t\t    test_bit(BIO_UPTODATE, &last->bi_flags) &&\n\t\t    last->bi_bdev == stripe->dev->bdev) {\n\t\t\tret = bio_add_page(last, page, PAGE_CACHE_SIZE, 0);\n\t\t\tif (ret == PAGE_CACHE_SIZE)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* put a new bio on the list */\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, bio_max_len >> PAGE_SHIFT?:1);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\n\tbio->bi_iter.bi_size = 0;\n\tbio->bi_bdev = stripe->dev->bdev;\n\tbio->bi_iter.bi_sector = disk_start >> 9;\n\tset_bit(BIO_UPTODATE, &bio->bi_flags);\n\n\tbio_add_page(bio, page, PAGE_CACHE_SIZE, 0);\n\tbio_list_add(bio_list, bio);\n\treturn 0;\n}"
  },
  {
    "function_name": "alloc_rbio_parity_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "1027-1043",
    "snippet": "static int alloc_rbio_parity_pages(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\tstruct page *page;\n\n\ti = (rbio->nr_data * rbio->stripe_len) >> PAGE_CACHE_SHIFT;\n\n\tfor (; i < rbio->nr_pages; i++) {\n\t\tif (rbio->stripe_pages[i])\n\t\t\tcontinue;\n\t\tpage = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\trbio->stripe_pages[i] = page;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_NOFS | __GFP_HIGHMEM"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int alloc_rbio_parity_pages(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\tstruct page *page;\n\n\ti = (rbio->nr_data * rbio->stripe_len) >> PAGE_CACHE_SHIFT;\n\n\tfor (; i < rbio->nr_pages; i++) {\n\t\tif (rbio->stripe_pages[i])\n\t\t\tcontinue;\n\t\tpage = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\trbio->stripe_pages[i] = page;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "alloc_rbio_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "1009-1024",
    "snippet": "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\tstruct page *page;\n\n\tfor (i = 0; i < rbio->nr_pages; i++) {\n\t\tif (rbio->stripe_pages[i])\n\t\t\tcontinue;\n\t\tpage = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\trbio->stripe_pages[i] = page;\n\t\tClearPageUptodate(page);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_NOFS | __GFP_HIGHMEM"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\tstruct page *page;\n\n\tfor (i = 0; i < rbio->nr_pages; i++) {\n\t\tif (rbio->stripe_pages[i])\n\t\t\tcontinue;\n\t\tpage = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\trbio->stripe_pages[i] = page;\n\t\tClearPageUptodate(page);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "alloc_rbio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "955-1006",
    "snippet": "static struct btrfs_raid_bio *alloc_rbio(struct btrfs_root *root,\n\t\t\t  struct btrfs_bio *bbio, u64 stripe_len)\n{\n\tstruct btrfs_raid_bio *rbio;\n\tint nr_data = 0;\n\tint real_stripes = bbio->num_stripes - bbio->num_tgtdevs;\n\tint num_pages = rbio_nr_pages(stripe_len, real_stripes);\n\tint stripe_npages = DIV_ROUND_UP(stripe_len, PAGE_SIZE);\n\tvoid *p;\n\n\trbio = kzalloc(sizeof(*rbio) + num_pages * sizeof(struct page *) * 2 +\n\t\t       DIV_ROUND_UP(stripe_npages, BITS_PER_LONG / 8),\n\t\t\tGFP_NOFS);\n\tif (!rbio)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbio_list_init(&rbio->bio_list);\n\tINIT_LIST_HEAD(&rbio->plug_list);\n\tspin_lock_init(&rbio->bio_list_lock);\n\tINIT_LIST_HEAD(&rbio->stripe_cache);\n\tINIT_LIST_HEAD(&rbio->hash_list);\n\trbio->bbio = bbio;\n\trbio->fs_info = root->fs_info;\n\trbio->stripe_len = stripe_len;\n\trbio->nr_pages = num_pages;\n\trbio->real_stripes = real_stripes;\n\trbio->stripe_npages = stripe_npages;\n\trbio->faila = -1;\n\trbio->failb = -1;\n\tatomic_set(&rbio->refs, 1);\n\tatomic_set(&rbio->error, 0);\n\tatomic_set(&rbio->stripes_pending, 0);\n\n\t/*\n\t * the stripe_pages and bio_pages array point to the extra\n\t * memory we allocated past the end of the rbio\n\t */\n\tp = rbio + 1;\n\trbio->stripe_pages = p;\n\trbio->bio_pages = p + sizeof(struct page *) * num_pages;\n\trbio->dbitmap = p + sizeof(struct page *) * num_pages * 2;\n\n\tif (bbio->map_type & BTRFS_BLOCK_GROUP_RAID5)\n\t\tnr_data = real_stripes - 1;\n\telse if (bbio->map_type & BTRFS_BLOCK_GROUP_RAID6)\n\t\tnr_data = real_stripes - 2;\n\telse\n\t\tBUG();\n\n\trbio->nr_data = nr_data;\n\treturn rbio;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&rbio->stripes_pending",
            "0"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&rbio->error",
            "0"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&rbio->refs",
            "1"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&rbio->hash_list"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&rbio->stripe_cache"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&rbio->bio_list_lock"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&rbio->plug_list"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_list_init",
          "args": [
            "&rbio->bio_list"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*rbio) + num_pages * sizeof(struct page *) * 2 +\n\t\t       DIV_ROUND_UP(stripe_npages, BITS_PER_LONG / 8)",
            "GFP_NOFS"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "stripe_npages",
            "BITS_PER_LONG / 8"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "stripe_len",
            "PAGE_SIZE"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rbio_nr_pages",
          "args": [
            "stripe_len",
            "real_stripes"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_nr_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "945-949",
          "snippet": "static unsigned long rbio_nr_pages(unsigned long stripe_len, int nr_stripes)\n{\n\tunsigned long nr = stripe_len * nr_stripes;\n\treturn DIV_ROUND_UP(nr, PAGE_CACHE_SIZE);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic unsigned long rbio_nr_pages(unsigned long stripe_len, int nr_stripes)\n{\n\tunsigned long nr = stripe_len * nr_stripes;\n\treturn DIV_ROUND_UP(nr, PAGE_CACHE_SIZE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic struct btrfs_raid_bio *alloc_rbio(struct btrfs_root *root,\n\t\t\t  struct btrfs_bio *bbio, u64 stripe_len)\n{\n\tstruct btrfs_raid_bio *rbio;\n\tint nr_data = 0;\n\tint real_stripes = bbio->num_stripes - bbio->num_tgtdevs;\n\tint num_pages = rbio_nr_pages(stripe_len, real_stripes);\n\tint stripe_npages = DIV_ROUND_UP(stripe_len, PAGE_SIZE);\n\tvoid *p;\n\n\trbio = kzalloc(sizeof(*rbio) + num_pages * sizeof(struct page *) * 2 +\n\t\t       DIV_ROUND_UP(stripe_npages, BITS_PER_LONG / 8),\n\t\t\tGFP_NOFS);\n\tif (!rbio)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbio_list_init(&rbio->bio_list);\n\tINIT_LIST_HEAD(&rbio->plug_list);\n\tspin_lock_init(&rbio->bio_list_lock);\n\tINIT_LIST_HEAD(&rbio->stripe_cache);\n\tINIT_LIST_HEAD(&rbio->hash_list);\n\trbio->bbio = bbio;\n\trbio->fs_info = root->fs_info;\n\trbio->stripe_len = stripe_len;\n\trbio->nr_pages = num_pages;\n\trbio->real_stripes = real_stripes;\n\trbio->stripe_npages = stripe_npages;\n\trbio->faila = -1;\n\trbio->failb = -1;\n\tatomic_set(&rbio->refs, 1);\n\tatomic_set(&rbio->error, 0);\n\tatomic_set(&rbio->stripes_pending, 0);\n\n\t/*\n\t * the stripe_pages and bio_pages array point to the extra\n\t * memory we allocated past the end of the rbio\n\t */\n\tp = rbio + 1;\n\trbio->stripe_pages = p;\n\trbio->bio_pages = p + sizeof(struct page *) * num_pages;\n\trbio->dbitmap = p + sizeof(struct page *) * num_pages * 2;\n\n\tif (bbio->map_type & BTRFS_BLOCK_GROUP_RAID5)\n\t\tnr_data = real_stripes - 1;\n\telse if (bbio->map_type & BTRFS_BLOCK_GROUP_RAID6)\n\t\tnr_data = real_stripes - 2;\n\telse\n\t\tBUG();\n\n\trbio->nr_data = nr_data;\n\treturn rbio;\n}"
  },
  {
    "function_name": "rbio_nr_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "945-949",
    "snippet": "static unsigned long rbio_nr_pages(unsigned long stripe_len, int nr_stripes)\n{\n\tunsigned long nr = stripe_len * nr_stripes;\n\treturn DIV_ROUND_UP(nr, PAGE_CACHE_SIZE);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "nr",
            "PAGE_CACHE_SIZE"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic unsigned long rbio_nr_pages(unsigned long stripe_len, int nr_stripes)\n{\n\tunsigned long nr = stripe_len * nr_stripes;\n\treturn DIV_ROUND_UP(nr, PAGE_CACHE_SIZE);\n}"
  },
  {
    "function_name": "page_in_rbio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "923-939",
    "snippet": "static struct page *page_in_rbio(struct btrfs_raid_bio *rbio,\n\t\t\t\t int index, int pagenr, int bio_list_only)\n{\n\tint chunk_page;\n\tstruct page *p = NULL;\n\n\tchunk_page = index * (rbio->stripe_len >> PAGE_SHIFT) + pagenr;\n\n\tspin_lock_irq(&rbio->bio_list_lock);\n\tp = rbio->bio_pages[chunk_page];\n\tspin_unlock_irq(&rbio->bio_list_lock);\n\n\tif (p || bio_list_only)\n\t\treturn p;\n\n\treturn rbio->stripe_pages[chunk_page];\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&rbio->bio_list_lock"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&rbio->bio_list_lock"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic struct page *page_in_rbio(struct btrfs_raid_bio *rbio,\n\t\t\t\t int index, int pagenr, int bio_list_only)\n{\n\tint chunk_page;\n\tstruct page *p = NULL;\n\n\tchunk_page = index * (rbio->stripe_len >> PAGE_SHIFT) + pagenr;\n\n\tspin_lock_irq(&rbio->bio_list_lock);\n\tp = rbio->bio_pages[chunk_page];\n\tspin_unlock_irq(&rbio->bio_list_lock);\n\n\tif (p || bio_list_only)\n\t\treturn p;\n\n\treturn rbio->stripe_pages[chunk_page];\n}"
  },
  {
    "function_name": "raid_write_end_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "885-905",
    "snippet": "static void raid_write_end_io(struct bio *bio, int err)\n{\n\tstruct btrfs_raid_bio *rbio = bio->bi_private;\n\n\tif (err)\n\t\tfail_bio_stripe(rbio, bio);\n\n\tbio_put(bio);\n\n\tif (!atomic_dec_and_test(&rbio->stripes_pending))\n\t\treturn;\n\n\terr = 0;\n\n\t/* OK, we have read all the stripes we need to. */\n\tif (atomic_read(&rbio->error) > rbio->bbio->max_errors)\n\t\terr = -EIO;\n\n\trbio_orig_end_io(rbio, err, 0);\n\treturn;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rbio_orig_end_io",
          "args": [
            "rbio",
            "err",
            "0"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_orig_end_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "861-879",
          "snippet": "static void rbio_orig_end_io(struct btrfs_raid_bio *rbio, int err, int uptodate)\n{\n\tstruct bio *cur = bio_list_get(&rbio->bio_list);\n\tstruct bio *next;\n\n\tif (rbio->generic_bio_cnt)\n\t\tbtrfs_bio_counter_sub(rbio->fs_info, rbio->generic_bio_cnt);\n\n\tfree_raid_bio(rbio);\n\n\twhile (cur) {\n\t\tnext = cur->bi_next;\n\t\tcur->bi_next = NULL;\n\t\tif (uptodate)\n\t\t\tset_bit(BIO_UPTODATE, &cur->bi_flags);\n\t\tbio_endio(cur, err);\n\t\tcur = next;\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void rbio_orig_end_io(struct btrfs_raid_bio *rbio, int err, int uptodate)\n{\n\tstruct bio *cur = bio_list_get(&rbio->bio_list);\n\tstruct bio *next;\n\n\tif (rbio->generic_bio_cnt)\n\t\tbtrfs_bio_counter_sub(rbio->fs_info, rbio->generic_bio_cnt);\n\n\tfree_raid_bio(rbio);\n\n\twhile (cur) {\n\t\tnext = cur->bi_next;\n\t\tcur->bi_next = NULL;\n\t\tif (uptodate)\n\t\t\tset_bit(BIO_UPTODATE, &cur->bi_flags);\n\t\tbio_endio(cur, err);\n\t\tcur = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rbio->error"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&rbio->stripes_pending"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fail_bio_stripe",
          "args": [
            "rbio",
            "bio"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "fail_bio_stripe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1417-1426",
          "snippet": "static int fail_bio_stripe(struct btrfs_raid_bio *rbio,\n\t\t\t   struct bio *bio)\n{\n\tint failed = find_bio_stripe(rbio, bio);\n\n\tif (failed < 0)\n\t\treturn -EIO;\n\n\treturn fail_rbio_index(rbio, failed);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio,\n\t\t\t   struct bio *bio)\n{\n\tint failed = find_bio_stripe(rbio, bio);\n\n\tif (failed < 0)\n\t\treturn -EIO;\n\n\treturn fail_rbio_index(rbio, failed);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void raid_write_end_io(struct bio *bio, int err)\n{\n\tstruct btrfs_raid_bio *rbio = bio->bi_private;\n\n\tif (err)\n\t\tfail_bio_stripe(rbio, bio);\n\n\tbio_put(bio);\n\n\tif (!atomic_dec_and_test(&rbio->stripes_pending))\n\t\treturn;\n\n\terr = 0;\n\n\t/* OK, we have read all the stripes we need to. */\n\tif (atomic_read(&rbio->error) > rbio->bbio->max_errors)\n\t\terr = -EIO;\n\n\trbio_orig_end_io(rbio, err, 0);\n\treturn;\n}"
  },
  {
    "function_name": "rbio_orig_end_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "861-879",
    "snippet": "static void rbio_orig_end_io(struct btrfs_raid_bio *rbio, int err, int uptodate)\n{\n\tstruct bio *cur = bio_list_get(&rbio->bio_list);\n\tstruct bio *next;\n\n\tif (rbio->generic_bio_cnt)\n\t\tbtrfs_bio_counter_sub(rbio->fs_info, rbio->generic_bio_cnt);\n\n\tfree_raid_bio(rbio);\n\n\twhile (cur) {\n\t\tnext = cur->bi_next;\n\t\tcur->bi_next = NULL;\n\t\tif (uptodate)\n\t\t\tset_bit(BIO_UPTODATE, &cur->bi_flags);\n\t\tbio_endio(cur, err);\n\t\tcur = next;\n\t}\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_endio",
          "args": [
            "cur",
            "err"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_parity_bio_endio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2667-2679",
          "snippet": "static void scrub_parity_bio_endio(struct bio *bio, int error)\n{\n\tstruct scrub_parity *sparity = (struct scrub_parity *)bio->bi_private;\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\n\tif (error)\n\t\tbitmap_or(sparity->ebitmap, sparity->ebitmap, sparity->dbitmap,\n\t\t\t  sparity->nsectors);\n\n\tscrub_free_parity(sparity);\n\tscrub_pending_bio_dec(sctx);\n\tbio_put(bio);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_parity_bio_endio(struct bio *bio, int error)\n{\n\tstruct scrub_parity *sparity = (struct scrub_parity *)bio->bi_private;\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\n\tif (error)\n\t\tbitmap_or(sparity->ebitmap, sparity->ebitmap, sparity->dbitmap,\n\t\t\t  sparity->nsectors);\n\n\tscrub_free_parity(sparity);\n\tscrub_pending_bio_dec(sctx);\n\tbio_put(bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BIO_UPTODATE",
            "&cur->bi_flags"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_raid_bio",
          "args": [
            "rbio"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "free_raid_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "851-855",
          "snippet": "static void free_raid_bio(struct btrfs_raid_bio *rbio)\n{\n\tunlock_stripe(rbio);\n\t__free_raid_bio(rbio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void free_raid_bio(struct btrfs_raid_bio *rbio)\n{\n\tunlock_stripe(rbio);\n\t__free_raid_bio(rbio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_bio_counter_sub",
          "args": [
            "rbio->fs_info",
            "rbio->generic_bio_cnt"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bio_counter_sub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "916-922",
          "snippet": "void btrfs_bio_counter_sub(struct btrfs_fs_info *fs_info, s64 amount)\n{\n\tpercpu_counter_sub(&fs_info->bio_counter, amount);\n\n\tif (waitqueue_active(&fs_info->replace_wait))\n\t\twake_up(&fs_info->replace_wait);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
            "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nvoid btrfs_bio_counter_sub(struct btrfs_fs_info *fs_info, s64 amount)\n{\n\tpercpu_counter_sub(&fs_info->bio_counter, amount);\n\n\tif (waitqueue_active(&fs_info->replace_wait))\n\t\twake_up(&fs_info->replace_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_list_get",
          "args": [
            "&rbio->bio_list"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void rbio_orig_end_io(struct btrfs_raid_bio *rbio, int err, int uptodate)\n{\n\tstruct bio *cur = bio_list_get(&rbio->bio_list);\n\tstruct bio *next;\n\n\tif (rbio->generic_bio_cnt)\n\t\tbtrfs_bio_counter_sub(rbio->fs_info, rbio->generic_bio_cnt);\n\n\tfree_raid_bio(rbio);\n\n\twhile (cur) {\n\t\tnext = cur->bi_next;\n\t\tcur->bi_next = NULL;\n\t\tif (uptodate)\n\t\t\tset_bit(BIO_UPTODATE, &cur->bi_flags);\n\t\tbio_endio(cur, err);\n\t\tcur = next;\n\t}\n}"
  },
  {
    "function_name": "free_raid_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "851-855",
    "snippet": "static void free_raid_bio(struct btrfs_raid_bio *rbio)\n{\n\tunlock_stripe(rbio);\n\t__free_raid_bio(rbio);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_raid_bio",
          "args": [
            "rbio"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "__free_raid_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "828-849",
          "snippet": "static void __free_raid_bio(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\n\tWARN_ON(atomic_read(&rbio->refs) < 0);\n\tif (!atomic_dec_and_test(&rbio->refs))\n\t\treturn;\n\n\tWARN_ON(!list_empty(&rbio->stripe_cache));\n\tWARN_ON(!list_empty(&rbio->hash_list));\n\tWARN_ON(!bio_list_empty(&rbio->bio_list));\n\n\tfor (i = 0; i < rbio->nr_pages; i++) {\n\t\tif (rbio->stripe_pages[i]) {\n\t\t\t__free_page(rbio->stripe_pages[i]);\n\t\t\trbio->stripe_pages[i] = NULL;\n\t\t}\n\t}\n\n\tbtrfs_put_bbio(rbio->bbio);\n\tkfree(rbio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\n\tWARN_ON(atomic_read(&rbio->refs) < 0);\n\tif (!atomic_dec_and_test(&rbio->refs))\n\t\treturn;\n\n\tWARN_ON(!list_empty(&rbio->stripe_cache));\n\tWARN_ON(!list_empty(&rbio->hash_list));\n\tWARN_ON(!bio_list_empty(&rbio->bio_list));\n\n\tfor (i = 0; i < rbio->nr_pages; i++) {\n\t\tif (rbio->stripe_pages[i]) {\n\t\t\t__free_page(rbio->stripe_pages[i]);\n\t\t\trbio->stripe_pages[i] = NULL;\n\t\t}\n\t}\n\n\tbtrfs_put_bbio(rbio->bbio);\n\tkfree(rbio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_stripe",
          "args": [
            "rbio"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_stripe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "749-826",
          "snippet": "static noinline void unlock_stripe(struct btrfs_raid_bio *rbio)\n{\n\tint bucket;\n\tstruct btrfs_stripe_hash *h;\n\tunsigned long flags;\n\tint keep_cache = 0;\n\n\tbucket = rbio_bucket(rbio);\n\th = rbio->fs_info->stripe_hash_table->table + bucket;\n\n\tif (list_empty(&rbio->plug_list))\n\t\tcache_rbio(rbio);\n\n\tspin_lock_irqsave(&h->lock, flags);\n\tspin_lock(&rbio->bio_list_lock);\n\n\tif (!list_empty(&rbio->hash_list)) {\n\t\t/*\n\t\t * if we're still cached and there is no other IO\n\t\t * to perform, just leave this rbio here for others\n\t\t * to steal from later\n\t\t */\n\t\tif (list_empty(&rbio->plug_list) &&\n\t\t    test_bit(RBIO_CACHE_BIT, &rbio->flags)) {\n\t\t\tkeep_cache = 1;\n\t\t\tclear_bit(RBIO_RMW_LOCKED_BIT, &rbio->flags);\n\t\t\tBUG_ON(!bio_list_empty(&rbio->bio_list));\n\t\t\tgoto done;\n\t\t}\n\n\t\tlist_del_init(&rbio->hash_list);\n\t\tatomic_dec(&rbio->refs);\n\n\t\t/*\n\t\t * we use the plug list to hold all the rbios\n\t\t * waiting for the chance to lock this stripe.\n\t\t * hand the lock over to one of them.\n\t\t */\n\t\tif (!list_empty(&rbio->plug_list)) {\n\t\t\tstruct btrfs_raid_bio *next;\n\t\t\tstruct list_head *head = rbio->plug_list.next;\n\n\t\t\tnext = list_entry(head, struct btrfs_raid_bio,\n\t\t\t\t\t  plug_list);\n\n\t\t\tlist_del_init(&rbio->plug_list);\n\n\t\t\tlist_add(&next->hash_list, &h->hash_list);\n\t\t\tatomic_inc(&next->refs);\n\t\t\tspin_unlock(&rbio->bio_list_lock);\n\t\t\tspin_unlock_irqrestore(&h->lock, flags);\n\n\t\t\tif (next->operation == BTRFS_RBIO_READ_REBUILD)\n\t\t\t\tasync_read_rebuild(next);\n\t\t\telse if (next->operation == BTRFS_RBIO_WRITE) {\n\t\t\t\tsteal_rbio(rbio, next);\n\t\t\t\tasync_rmw_stripe(next);\n\t\t\t} else if (next->operation == BTRFS_RBIO_PARITY_SCRUB) {\n\t\t\t\tsteal_rbio(rbio, next);\n\t\t\t\tasync_scrub_parity(next);\n\t\t\t}\n\n\t\t\tgoto done_nolock;\n\t\t} else  if (waitqueue_active(&h->wait)) {\n\t\t\tspin_unlock(&rbio->bio_list_lock);\n\t\t\tspin_unlock_irqrestore(&h->lock, flags);\n\t\t\twake_up(&h->wait);\n\t\t\tgoto done_nolock;\n\t\t}\n\t}\ndone:\n\tspin_unlock(&rbio->bio_list_lock);\n\tspin_unlock_irqrestore(&h->lock, flags);\n\ndone_nolock:\n\tif (!keep_cache)\n\t\tremove_rbio_from_cache(rbio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RBIO_CACHE_BIT\t\t2",
            "#define RBIO_RMW_LOCKED_BIT\t1"
          ],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_BIT\t\t2\n#define RBIO_RMW_LOCKED_BIT\t1\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic noinline void unlock_stripe(struct btrfs_raid_bio *rbio)\n{\n\tint bucket;\n\tstruct btrfs_stripe_hash *h;\n\tunsigned long flags;\n\tint keep_cache = 0;\n\n\tbucket = rbio_bucket(rbio);\n\th = rbio->fs_info->stripe_hash_table->table + bucket;\n\n\tif (list_empty(&rbio->plug_list))\n\t\tcache_rbio(rbio);\n\n\tspin_lock_irqsave(&h->lock, flags);\n\tspin_lock(&rbio->bio_list_lock);\n\n\tif (!list_empty(&rbio->hash_list)) {\n\t\t/*\n\t\t * if we're still cached and there is no other IO\n\t\t * to perform, just leave this rbio here for others\n\t\t * to steal from later\n\t\t */\n\t\tif (list_empty(&rbio->plug_list) &&\n\t\t    test_bit(RBIO_CACHE_BIT, &rbio->flags)) {\n\t\t\tkeep_cache = 1;\n\t\t\tclear_bit(RBIO_RMW_LOCKED_BIT, &rbio->flags);\n\t\t\tBUG_ON(!bio_list_empty(&rbio->bio_list));\n\t\t\tgoto done;\n\t\t}\n\n\t\tlist_del_init(&rbio->hash_list);\n\t\tatomic_dec(&rbio->refs);\n\n\t\t/*\n\t\t * we use the plug list to hold all the rbios\n\t\t * waiting for the chance to lock this stripe.\n\t\t * hand the lock over to one of them.\n\t\t */\n\t\tif (!list_empty(&rbio->plug_list)) {\n\t\t\tstruct btrfs_raid_bio *next;\n\t\t\tstruct list_head *head = rbio->plug_list.next;\n\n\t\t\tnext = list_entry(head, struct btrfs_raid_bio,\n\t\t\t\t\t  plug_list);\n\n\t\t\tlist_del_init(&rbio->plug_list);\n\n\t\t\tlist_add(&next->hash_list, &h->hash_list);\n\t\t\tatomic_inc(&next->refs);\n\t\t\tspin_unlock(&rbio->bio_list_lock);\n\t\t\tspin_unlock_irqrestore(&h->lock, flags);\n\n\t\t\tif (next->operation == BTRFS_RBIO_READ_REBUILD)\n\t\t\t\tasync_read_rebuild(next);\n\t\t\telse if (next->operation == BTRFS_RBIO_WRITE) {\n\t\t\t\tsteal_rbio(rbio, next);\n\t\t\t\tasync_rmw_stripe(next);\n\t\t\t} else if (next->operation == BTRFS_RBIO_PARITY_SCRUB) {\n\t\t\t\tsteal_rbio(rbio, next);\n\t\t\t\tasync_scrub_parity(next);\n\t\t\t}\n\n\t\t\tgoto done_nolock;\n\t\t} else  if (waitqueue_active(&h->wait)) {\n\t\t\tspin_unlock(&rbio->bio_list_lock);\n\t\t\tspin_unlock_irqrestore(&h->lock, flags);\n\t\t\twake_up(&h->wait);\n\t\t\tgoto done_nolock;\n\t\t}\n\t}\ndone:\n\tspin_unlock(&rbio->bio_list_lock);\n\tspin_unlock_irqrestore(&h->lock, flags);\n\ndone_nolock:\n\tif (!keep_cache)\n\t\tremove_rbio_from_cache(rbio);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void free_raid_bio(struct btrfs_raid_bio *rbio)\n{\n\tunlock_stripe(rbio);\n\t__free_raid_bio(rbio);\n}"
  },
  {
    "function_name": "__free_raid_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "828-849",
    "snippet": "static void __free_raid_bio(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\n\tWARN_ON(atomic_read(&rbio->refs) < 0);\n\tif (!atomic_dec_and_test(&rbio->refs))\n\t\treturn;\n\n\tWARN_ON(!list_empty(&rbio->stripe_cache));\n\tWARN_ON(!list_empty(&rbio->hash_list));\n\tWARN_ON(!bio_list_empty(&rbio->bio_list));\n\n\tfor (i = 0; i < rbio->nr_pages; i++) {\n\t\tif (rbio->stripe_pages[i]) {\n\t\t\t__free_page(rbio->stripe_pages[i]);\n\t\t\trbio->stripe_pages[i] = NULL;\n\t\t}\n\t}\n\n\tbtrfs_put_bbio(rbio->bbio);\n\tkfree(rbio);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rbio"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_put_bbio",
          "args": [
            "rbio->bbio"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_bbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4933-4939",
          "snippet": "void btrfs_put_bbio(struct btrfs_bio *bbio)\n{\n\tif (!bbio)\n\t\treturn;\n\tif (atomic_dec_and_test(&bbio->refs))\n\t\tkfree(bbio);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_put_bbio(struct btrfs_bio *bbio)\n{\n\tif (!bbio)\n\t\treturn;\n\tif (atomic_dec_and_test(&bbio->refs))\n\t\tkfree(bbio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "rbio->stripe_pages[i]"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!bio_list_empty(&rbio->bio_list)"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_list_empty",
          "args": [
            "&rbio->bio_list"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&rbio->hash_list)"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&rbio->hash_list"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&rbio->stripe_cache)"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&rbio->refs"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_read(&rbio->refs) < 0"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rbio->refs"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\n\tWARN_ON(atomic_read(&rbio->refs) < 0);\n\tif (!atomic_dec_and_test(&rbio->refs))\n\t\treturn;\n\n\tWARN_ON(!list_empty(&rbio->stripe_cache));\n\tWARN_ON(!list_empty(&rbio->hash_list));\n\tWARN_ON(!bio_list_empty(&rbio->bio_list));\n\n\tfor (i = 0; i < rbio->nr_pages; i++) {\n\t\tif (rbio->stripe_pages[i]) {\n\t\t\t__free_page(rbio->stripe_pages[i]);\n\t\t\trbio->stripe_pages[i] = NULL;\n\t\t}\n\t}\n\n\tbtrfs_put_bbio(rbio->bbio);\n\tkfree(rbio);\n}"
  },
  {
    "function_name": "unlock_stripe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "749-826",
    "snippet": "static noinline void unlock_stripe(struct btrfs_raid_bio *rbio)\n{\n\tint bucket;\n\tstruct btrfs_stripe_hash *h;\n\tunsigned long flags;\n\tint keep_cache = 0;\n\n\tbucket = rbio_bucket(rbio);\n\th = rbio->fs_info->stripe_hash_table->table + bucket;\n\n\tif (list_empty(&rbio->plug_list))\n\t\tcache_rbio(rbio);\n\n\tspin_lock_irqsave(&h->lock, flags);\n\tspin_lock(&rbio->bio_list_lock);\n\n\tif (!list_empty(&rbio->hash_list)) {\n\t\t/*\n\t\t * if we're still cached and there is no other IO\n\t\t * to perform, just leave this rbio here for others\n\t\t * to steal from later\n\t\t */\n\t\tif (list_empty(&rbio->plug_list) &&\n\t\t    test_bit(RBIO_CACHE_BIT, &rbio->flags)) {\n\t\t\tkeep_cache = 1;\n\t\t\tclear_bit(RBIO_RMW_LOCKED_BIT, &rbio->flags);\n\t\t\tBUG_ON(!bio_list_empty(&rbio->bio_list));\n\t\t\tgoto done;\n\t\t}\n\n\t\tlist_del_init(&rbio->hash_list);\n\t\tatomic_dec(&rbio->refs);\n\n\t\t/*\n\t\t * we use the plug list to hold all the rbios\n\t\t * waiting for the chance to lock this stripe.\n\t\t * hand the lock over to one of them.\n\t\t */\n\t\tif (!list_empty(&rbio->plug_list)) {\n\t\t\tstruct btrfs_raid_bio *next;\n\t\t\tstruct list_head *head = rbio->plug_list.next;\n\n\t\t\tnext = list_entry(head, struct btrfs_raid_bio,\n\t\t\t\t\t  plug_list);\n\n\t\t\tlist_del_init(&rbio->plug_list);\n\n\t\t\tlist_add(&next->hash_list, &h->hash_list);\n\t\t\tatomic_inc(&next->refs);\n\t\t\tspin_unlock(&rbio->bio_list_lock);\n\t\t\tspin_unlock_irqrestore(&h->lock, flags);\n\n\t\t\tif (next->operation == BTRFS_RBIO_READ_REBUILD)\n\t\t\t\tasync_read_rebuild(next);\n\t\t\telse if (next->operation == BTRFS_RBIO_WRITE) {\n\t\t\t\tsteal_rbio(rbio, next);\n\t\t\t\tasync_rmw_stripe(next);\n\t\t\t} else if (next->operation == BTRFS_RBIO_PARITY_SCRUB) {\n\t\t\t\tsteal_rbio(rbio, next);\n\t\t\t\tasync_scrub_parity(next);\n\t\t\t}\n\n\t\t\tgoto done_nolock;\n\t\t} else  if (waitqueue_active(&h->wait)) {\n\t\t\tspin_unlock(&rbio->bio_list_lock);\n\t\t\tspin_unlock_irqrestore(&h->lock, flags);\n\t\t\twake_up(&h->wait);\n\t\t\tgoto done_nolock;\n\t\t}\n\t}\ndone:\n\tspin_unlock(&rbio->bio_list_lock);\n\tspin_unlock_irqrestore(&h->lock, flags);\n\ndone_nolock:\n\tif (!keep_cache)\n\t\tremove_rbio_from_cache(rbio);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define RBIO_CACHE_BIT\t\t2",
      "#define RBIO_RMW_LOCKED_BIT\t1"
    ],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_rbio_from_cache",
          "args": [
            "rbio"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "remove_rbio_from_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "411-424",
          "snippet": "static void remove_rbio_from_cache(struct btrfs_raid_bio *rbio)\n{\n\tstruct btrfs_stripe_hash_table *table;\n\tunsigned long flags;\n\n\tif (!test_bit(RBIO_CACHE_BIT, &rbio->flags))\n\t\treturn;\n\n\ttable = rbio->fs_info->stripe_hash_table;\n\n\tspin_lock_irqsave(&table->cache_lock, flags);\n\t__remove_rbio_from_cache(rbio);\n\tspin_unlock_irqrestore(&table->cache_lock, flags);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RBIO_CACHE_BIT\t\t2"
          ],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_BIT\t\t2\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void remove_rbio_from_cache(struct btrfs_raid_bio *rbio)\n{\n\tstruct btrfs_stripe_hash_table *table;\n\tunsigned long flags;\n\n\tif (!test_bit(RBIO_CACHE_BIT, &rbio->flags))\n\t\treturn;\n\n\ttable = rbio->fs_info->stripe_hash_table;\n\n\tspin_lock_irqsave(&table->cache_lock, flags);\n\t__remove_rbio_from_cache(rbio);\n\tspin_unlock_irqrestore(&table->cache_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&h->lock",
            "flags"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&rbio->bio_list_lock"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&h->wait"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&h->lock",
            "flags"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&h->wait"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "async_scrub_parity",
          "args": [
            "next"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "async_scrub_parity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "2665-2672",
          "snippet": "static void async_scrub_parity(struct btrfs_raid_bio *rbio)\n{\n\tbtrfs_init_work(&rbio->work, btrfs_rmw_helper,\n\t\t\tscrub_parity_work, NULL, NULL);\n\n\tbtrfs_queue_work(rbio->fs_info->rmw_workers,\n\t\t\t &rbio->work);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void rmw_work(struct btrfs_work *work);",
            "static void read_rebuild_work(struct btrfs_work *work);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void rmw_work(struct btrfs_work *work);\nstatic void read_rebuild_work(struct btrfs_work *work);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio)\n{\n\tbtrfs_init_work(&rbio->work, btrfs_rmw_helper,\n\t\t\tscrub_parity_work, NULL, NULL);\n\n\tbtrfs_queue_work(rbio->fs_info->rmw_workers,\n\t\t\t &rbio->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "steal_rbio",
          "args": [
            "rbio",
            "next"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "steal_rbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "307-329",
          "snippet": "static void steal_rbio(struct btrfs_raid_bio *src, struct btrfs_raid_bio *dest)\n{\n\tint i;\n\tstruct page *s;\n\tstruct page *d;\n\n\tif (!test_bit(RBIO_CACHE_READY_BIT, &src->flags))\n\t\treturn;\n\n\tfor (i = 0; i < dest->nr_pages; i++) {\n\t\ts = src->stripe_pages[i];\n\t\tif (!s || !PageUptodate(s)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\td = dest->stripe_pages[i];\n\t\tif (d)\n\t\t\t__free_page(d);\n\n\t\tdest->stripe_pages[i] = s;\n\t\tsrc->stripe_pages[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RBIO_CACHE_READY_BIT\t3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_READY_BIT\t3\n\nstatic void steal_rbio(struct btrfs_raid_bio *src, struct btrfs_raid_bio *dest)\n{\n\tint i;\n\tstruct page *s;\n\tstruct page *d;\n\n\tif (!test_bit(RBIO_CACHE_READY_BIT, &src->flags))\n\t\treturn;\n\n\tfor (i = 0; i < dest->nr_pages; i++) {\n\t\ts = src->stripe_pages[i];\n\t\tif (!s || !PageUptodate(s)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\td = dest->stripe_pages[i];\n\t\tif (d)\n\t\t\t__free_page(d);\n\n\t\tdest->stripe_pages[i] = s;\n\t\tsrc->stripe_pages[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "async_rmw_stripe",
          "args": [
            "next"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "async_rmw_stripe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1482-1489",
          "snippet": "static void async_rmw_stripe(struct btrfs_raid_bio *rbio)\n{\n\tbtrfs_init_work(&rbio->work, btrfs_rmw_helper,\n\t\t\trmw_work, NULL, NULL);\n\n\tbtrfs_queue_work(rbio->fs_info->rmw_workers,\n\t\t\t &rbio->work);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void rmw_work(struct btrfs_work *work);",
            "static void read_rebuild_work(struct btrfs_work *work);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void rmw_work(struct btrfs_work *work);\nstatic void read_rebuild_work(struct btrfs_work *work);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio)\n{\n\tbtrfs_init_work(&rbio->work, btrfs_rmw_helper,\n\t\t\trmw_work, NULL, NULL);\n\n\tbtrfs_queue_work(rbio->fs_info->rmw_workers,\n\t\t\t &rbio->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "async_read_rebuild",
          "args": [
            "next"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "async_read_rebuild",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1491-1498",
          "snippet": "static void async_read_rebuild(struct btrfs_raid_bio *rbio)\n{\n\tbtrfs_init_work(&rbio->work, btrfs_rmw_helper,\n\t\t\tread_rebuild_work, NULL, NULL);\n\n\tbtrfs_queue_work(rbio->fs_info->rmw_workers,\n\t\t\t &rbio->work);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void rmw_work(struct btrfs_work *work);",
            "static void read_rebuild_work(struct btrfs_work *work);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void rmw_work(struct btrfs_work *work);\nstatic void read_rebuild_work(struct btrfs_work *work);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio)\n{\n\tbtrfs_init_work(&rbio->work, btrfs_rmw_helper,\n\t\t\tread_rebuild_work, NULL, NULL);\n\n\tbtrfs_queue_work(rbio->fs_info->rmw_workers,\n\t\t\t &rbio->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&h->lock",
            "flags"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&next->refs"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&next->hash_list",
            "&h->hash_list"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&rbio->plug_list"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "head",
            "structbtrfs_raid_bio",
            "plug_list"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&rbio->plug_list"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&rbio->refs"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&rbio->hash_list"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!bio_list_empty(&rbio->bio_list)"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_list_empty",
          "args": [
            "&rbio->bio_list"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "RBIO_RMW_LOCKED_BIT",
            "&rbio->flags"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "RBIO_CACHE_BIT",
            "&rbio->flags"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&rbio->bio_list_lock"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&h->lock",
            "flags"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_rbio",
          "args": [
            "rbio"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "cache_rbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "474-513",
          "snippet": "static void cache_rbio(struct btrfs_raid_bio *rbio)\n{\n\tstruct btrfs_stripe_hash_table *table;\n\tunsigned long flags;\n\n\tif (!test_bit(RBIO_CACHE_READY_BIT, &rbio->flags))\n\t\treturn;\n\n\ttable = rbio->fs_info->stripe_hash_table;\n\n\tspin_lock_irqsave(&table->cache_lock, flags);\n\tspin_lock(&rbio->bio_list_lock);\n\n\t/* bump our ref if we were not in the list before */\n\tif (!test_and_set_bit(RBIO_CACHE_BIT, &rbio->flags))\n\t\tatomic_inc(&rbio->refs);\n\n\tif (!list_empty(&rbio->stripe_cache)){\n\t\tlist_move(&rbio->stripe_cache, &table->stripe_cache);\n\t} else {\n\t\tlist_add(&rbio->stripe_cache, &table->stripe_cache);\n\t\ttable->cache_size += 1;\n\t}\n\n\tspin_unlock(&rbio->bio_list_lock);\n\n\tif (table->cache_size > RBIO_CACHE_SIZE) {\n\t\tstruct btrfs_raid_bio *found;\n\n\t\tfound = list_entry(table->stripe_cache.prev,\n\t\t\t\t  struct btrfs_raid_bio,\n\t\t\t\t  stripe_cache);\n\n\t\tif (found != rbio)\n\t\t\t__remove_rbio_from_cache(found);\n\t}\n\n\tspin_unlock_irqrestore(&table->cache_lock, flags);\n\treturn;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RBIO_CACHE_SIZE 1024",
            "#define RBIO_CACHE_READY_BIT\t3",
            "#define RBIO_CACHE_BIT\t\t2"
          ],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_SIZE 1024\n#define RBIO_CACHE_READY_BIT\t3\n#define RBIO_CACHE_BIT\t\t2\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void cache_rbio(struct btrfs_raid_bio *rbio)\n{\n\tstruct btrfs_stripe_hash_table *table;\n\tunsigned long flags;\n\n\tif (!test_bit(RBIO_CACHE_READY_BIT, &rbio->flags))\n\t\treturn;\n\n\ttable = rbio->fs_info->stripe_hash_table;\n\n\tspin_lock_irqsave(&table->cache_lock, flags);\n\tspin_lock(&rbio->bio_list_lock);\n\n\t/* bump our ref if we were not in the list before */\n\tif (!test_and_set_bit(RBIO_CACHE_BIT, &rbio->flags))\n\t\tatomic_inc(&rbio->refs);\n\n\tif (!list_empty(&rbio->stripe_cache)){\n\t\tlist_move(&rbio->stripe_cache, &table->stripe_cache);\n\t} else {\n\t\tlist_add(&rbio->stripe_cache, &table->stripe_cache);\n\t\ttable->cache_size += 1;\n\t}\n\n\tspin_unlock(&rbio->bio_list_lock);\n\n\tif (table->cache_size > RBIO_CACHE_SIZE) {\n\t\tstruct btrfs_raid_bio *found;\n\n\t\tfound = list_entry(table->stripe_cache.prev,\n\t\t\t\t  struct btrfs_raid_bio,\n\t\t\t\t  stripe_cache);\n\n\t\tif (found != rbio)\n\t\t\t__remove_rbio_from_cache(found);\n\t}\n\n\tspin_unlock_irqrestore(&table->cache_lock, flags);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rbio_bucket",
          "args": [
            "rbio"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "288-301",
          "snippet": "static int rbio_bucket(struct btrfs_raid_bio *rbio)\n{\n\tu64 num = rbio->bbio->raid_map[0];\n\n\t/*\n\t * we shift down quite a bit.  We're using byte\n\t * addressing, and most of the lower bits are zeros.\n\t * This tends to upset hash_64, and it consistently\n\t * returns just one or two different values.\n\t *\n\t * shifting off the lower bits fixes things.\n\t */\n\treturn hash_64(num >> 16, BTRFS_STRIPE_HASH_TABLE_BITS);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int rbio_bucket(struct btrfs_raid_bio *rbio)\n{\n\tu64 num = rbio->bbio->raid_map[0];\n\n\t/*\n\t * we shift down quite a bit.  We're using byte\n\t * addressing, and most of the lower bits are zeros.\n\t * This tends to upset hash_64, and it consistently\n\t * returns just one or two different values.\n\t *\n\t * shifting off the lower bits fixes things.\n\t */\n\treturn hash_64(num >> 16, BTRFS_STRIPE_HASH_TABLE_BITS);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_BIT\t\t2\n#define RBIO_RMW_LOCKED_BIT\t1\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic noinline void unlock_stripe(struct btrfs_raid_bio *rbio)\n{\n\tint bucket;\n\tstruct btrfs_stripe_hash *h;\n\tunsigned long flags;\n\tint keep_cache = 0;\n\n\tbucket = rbio_bucket(rbio);\n\th = rbio->fs_info->stripe_hash_table->table + bucket;\n\n\tif (list_empty(&rbio->plug_list))\n\t\tcache_rbio(rbio);\n\n\tspin_lock_irqsave(&h->lock, flags);\n\tspin_lock(&rbio->bio_list_lock);\n\n\tif (!list_empty(&rbio->hash_list)) {\n\t\t/*\n\t\t * if we're still cached and there is no other IO\n\t\t * to perform, just leave this rbio here for others\n\t\t * to steal from later\n\t\t */\n\t\tif (list_empty(&rbio->plug_list) &&\n\t\t    test_bit(RBIO_CACHE_BIT, &rbio->flags)) {\n\t\t\tkeep_cache = 1;\n\t\t\tclear_bit(RBIO_RMW_LOCKED_BIT, &rbio->flags);\n\t\t\tBUG_ON(!bio_list_empty(&rbio->bio_list));\n\t\t\tgoto done;\n\t\t}\n\n\t\tlist_del_init(&rbio->hash_list);\n\t\tatomic_dec(&rbio->refs);\n\n\t\t/*\n\t\t * we use the plug list to hold all the rbios\n\t\t * waiting for the chance to lock this stripe.\n\t\t * hand the lock over to one of them.\n\t\t */\n\t\tif (!list_empty(&rbio->plug_list)) {\n\t\t\tstruct btrfs_raid_bio *next;\n\t\t\tstruct list_head *head = rbio->plug_list.next;\n\n\t\t\tnext = list_entry(head, struct btrfs_raid_bio,\n\t\t\t\t\t  plug_list);\n\n\t\t\tlist_del_init(&rbio->plug_list);\n\n\t\t\tlist_add(&next->hash_list, &h->hash_list);\n\t\t\tatomic_inc(&next->refs);\n\t\t\tspin_unlock(&rbio->bio_list_lock);\n\t\t\tspin_unlock_irqrestore(&h->lock, flags);\n\n\t\t\tif (next->operation == BTRFS_RBIO_READ_REBUILD)\n\t\t\t\tasync_read_rebuild(next);\n\t\t\telse if (next->operation == BTRFS_RBIO_WRITE) {\n\t\t\t\tsteal_rbio(rbio, next);\n\t\t\t\tasync_rmw_stripe(next);\n\t\t\t} else if (next->operation == BTRFS_RBIO_PARITY_SCRUB) {\n\t\t\t\tsteal_rbio(rbio, next);\n\t\t\t\tasync_scrub_parity(next);\n\t\t\t}\n\n\t\t\tgoto done_nolock;\n\t\t} else  if (waitqueue_active(&h->wait)) {\n\t\t\tspin_unlock(&rbio->bio_list_lock);\n\t\t\tspin_unlock_irqrestore(&h->lock, flags);\n\t\t\twake_up(&h->wait);\n\t\t\tgoto done_nolock;\n\t\t}\n\t}\ndone:\n\tspin_unlock(&rbio->bio_list_lock);\n\tspin_unlock_irqrestore(&h->lock, flags);\n\ndone_nolock:\n\tif (!keep_cache)\n\t\tremove_rbio_from_cache(rbio);\n}"
  },
  {
    "function_name": "lock_stripe_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "660-743",
    "snippet": "static noinline int lock_stripe_add(struct btrfs_raid_bio *rbio)\n{\n\tint bucket = rbio_bucket(rbio);\n\tstruct btrfs_stripe_hash *h = rbio->fs_info->stripe_hash_table->table + bucket;\n\tstruct btrfs_raid_bio *cur;\n\tstruct btrfs_raid_bio *pending;\n\tunsigned long flags;\n\tDEFINE_WAIT(wait);\n\tstruct btrfs_raid_bio *freeit = NULL;\n\tstruct btrfs_raid_bio *cache_drop = NULL;\n\tint ret = 0;\n\tint walk = 0;\n\n\tspin_lock_irqsave(&h->lock, flags);\n\tlist_for_each_entry(cur, &h->hash_list, hash_list) {\n\t\twalk++;\n\t\tif (cur->bbio->raid_map[0] == rbio->bbio->raid_map[0]) {\n\t\t\tspin_lock(&cur->bio_list_lock);\n\n\t\t\t/* can we steal this cached rbio's pages? */\n\t\t\tif (bio_list_empty(&cur->bio_list) &&\n\t\t\t    list_empty(&cur->plug_list) &&\n\t\t\t    test_bit(RBIO_CACHE_BIT, &cur->flags) &&\n\t\t\t    !test_bit(RBIO_RMW_LOCKED_BIT, &cur->flags)) {\n\t\t\t\tlist_del_init(&cur->hash_list);\n\t\t\t\tatomic_dec(&cur->refs);\n\n\t\t\t\tsteal_rbio(cur, rbio);\n\t\t\t\tcache_drop = cur;\n\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\n\t\t\t\tgoto lockit;\n\t\t\t}\n\n\t\t\t/* can we merge into the lock owner? */\n\t\t\tif (rbio_can_merge(cur, rbio)) {\n\t\t\t\tmerge_rbio(cur, rbio);\n\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\t\tfreeit = rbio;\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\n\t\t\t/*\n\t\t\t * we couldn't merge with the running\n\t\t\t * rbio, see if we can merge with the\n\t\t\t * pending ones.  We don't have to\n\t\t\t * check for rmw_locked because there\n\t\t\t * is no way they are inside finish_rmw\n\t\t\t * right now\n\t\t\t */\n\t\t\tlist_for_each_entry(pending, &cur->plug_list,\n\t\t\t\t\t    plug_list) {\n\t\t\t\tif (rbio_can_merge(pending, rbio)) {\n\t\t\t\t\tmerge_rbio(pending, rbio);\n\t\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\t\t\tfreeit = rbio;\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* no merging, put us on the tail of the plug list,\n\t\t\t * our rbio will be started with the currently\n\t\t\t * running rbio unlocks\n\t\t\t */\n\t\t\tlist_add_tail(&rbio->plug_list, &cur->plug_list);\n\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\nlockit:\n\tatomic_inc(&rbio->refs);\n\tlist_add(&rbio->hash_list, &h->hash_list);\nout:\n\tspin_unlock_irqrestore(&h->lock, flags);\n\tif (cache_drop)\n\t\tremove_rbio_from_cache(cache_drop);\n\tif (freeit)\n\t\t__free_raid_bio(freeit);\n\treturn ret;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define RBIO_CACHE_BIT\t\t2",
      "#define RBIO_RMW_LOCKED_BIT\t1"
    ],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_raid_bio",
          "args": [
            "freeit"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "__free_raid_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "828-849",
          "snippet": "static void __free_raid_bio(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\n\tWARN_ON(atomic_read(&rbio->refs) < 0);\n\tif (!atomic_dec_and_test(&rbio->refs))\n\t\treturn;\n\n\tWARN_ON(!list_empty(&rbio->stripe_cache));\n\tWARN_ON(!list_empty(&rbio->hash_list));\n\tWARN_ON(!bio_list_empty(&rbio->bio_list));\n\n\tfor (i = 0; i < rbio->nr_pages; i++) {\n\t\tif (rbio->stripe_pages[i]) {\n\t\t\t__free_page(rbio->stripe_pages[i]);\n\t\t\trbio->stripe_pages[i] = NULL;\n\t\t}\n\t}\n\n\tbtrfs_put_bbio(rbio->bbio);\n\tkfree(rbio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\n\tWARN_ON(atomic_read(&rbio->refs) < 0);\n\tif (!atomic_dec_and_test(&rbio->refs))\n\t\treturn;\n\n\tWARN_ON(!list_empty(&rbio->stripe_cache));\n\tWARN_ON(!list_empty(&rbio->hash_list));\n\tWARN_ON(!bio_list_empty(&rbio->bio_list));\n\n\tfor (i = 0; i < rbio->nr_pages; i++) {\n\t\tif (rbio->stripe_pages[i]) {\n\t\t\t__free_page(rbio->stripe_pages[i]);\n\t\t\trbio->stripe_pages[i] = NULL;\n\t\t}\n\t}\n\n\tbtrfs_put_bbio(rbio->bbio);\n\tkfree(rbio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_rbio_from_cache",
          "args": [
            "cache_drop"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "remove_rbio_from_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "411-424",
          "snippet": "static void remove_rbio_from_cache(struct btrfs_raid_bio *rbio)\n{\n\tstruct btrfs_stripe_hash_table *table;\n\tunsigned long flags;\n\n\tif (!test_bit(RBIO_CACHE_BIT, &rbio->flags))\n\t\treturn;\n\n\ttable = rbio->fs_info->stripe_hash_table;\n\n\tspin_lock_irqsave(&table->cache_lock, flags);\n\t__remove_rbio_from_cache(rbio);\n\tspin_unlock_irqrestore(&table->cache_lock, flags);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RBIO_CACHE_BIT\t\t2"
          ],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_BIT\t\t2\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void remove_rbio_from_cache(struct btrfs_raid_bio *rbio)\n{\n\tstruct btrfs_stripe_hash_table *table;\n\tunsigned long flags;\n\n\tif (!test_bit(RBIO_CACHE_BIT, &rbio->flags))\n\t\treturn;\n\n\ttable = rbio->fs_info->stripe_hash_table;\n\n\tspin_lock_irqsave(&table->cache_lock, flags);\n\t__remove_rbio_from_cache(rbio);\n\tspin_unlock_irqrestore(&table->cache_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&h->lock",
            "flags"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&rbio->hash_list",
            "&h->hash_list"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&rbio->refs"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cur->bio_list_lock"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&rbio->plug_list",
            "&cur->plug_list"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "merge_rbio",
          "args": [
            "pending",
            "rbio"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "merge_rbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "338-345",
          "snippet": "static void merge_rbio(struct btrfs_raid_bio *dest,\n\t\t       struct btrfs_raid_bio *victim)\n{\n\tbio_list_merge(&dest->bio_list, &victim->bio_list);\n\tdest->bio_list_bytes += victim->bio_list_bytes;\n\tdest->generic_bio_cnt += victim->generic_bio_cnt;\n\tbio_list_init(&victim->bio_list);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic void merge_rbio(struct btrfs_raid_bio *dest,\n\t\t       struct btrfs_raid_bio *victim)\n{\n\tbio_list_merge(&dest->bio_list, &victim->bio_list);\n\tdest->bio_list_bytes += victim->bio_list_bytes;\n\tdest->generic_bio_cnt += victim->generic_bio_cnt;\n\tbio_list_init(&victim->bio_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rbio_can_merge",
          "args": [
            "pending",
            "rbio"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_can_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "575-613",
          "snippet": "static int rbio_can_merge(struct btrfs_raid_bio *last,\n\t\t\t  struct btrfs_raid_bio *cur)\n{\n\tif (test_bit(RBIO_RMW_LOCKED_BIT, &last->flags) ||\n\t    test_bit(RBIO_RMW_LOCKED_BIT, &cur->flags))\n\t\treturn 0;\n\n\t/*\n\t * we can't merge with cached rbios, since the\n\t * idea is that when we merge the destination\n\t * rbio is going to run our IO for us.  We can\n\t * steal from cached rbio's though, other functions\n\t * handle that.\n\t */\n\tif (test_bit(RBIO_CACHE_BIT, &last->flags) ||\n\t    test_bit(RBIO_CACHE_BIT, &cur->flags))\n\t\treturn 0;\n\n\tif (last->bbio->raid_map[0] !=\n\t    cur->bbio->raid_map[0])\n\t\treturn 0;\n\n\t/* we can't merge with different operations */\n\tif (last->operation != cur->operation)\n\t\treturn 0;\n\t/*\n\t * We've need read the full stripe from the drive.\n\t * check and repair the parity and write the new results.\n\t *\n\t * We're not allowed to add any new bios to the\n\t * bio list here, anyone else that wants to\n\t * change this stripe needs to do their own rmw.\n\t */\n\tif (last->operation == BTRFS_RBIO_PARITY_SCRUB ||\n\t    cur->operation == BTRFS_RBIO_PARITY_SCRUB)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RBIO_CACHE_BIT\t\t2",
            "#define RBIO_RMW_LOCKED_BIT\t1"
          ],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_BIT\t\t2\n#define RBIO_RMW_LOCKED_BIT\t1\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int rbio_can_merge(struct btrfs_raid_bio *last,\n\t\t\t  struct btrfs_raid_bio *cur)\n{\n\tif (test_bit(RBIO_RMW_LOCKED_BIT, &last->flags) ||\n\t    test_bit(RBIO_RMW_LOCKED_BIT, &cur->flags))\n\t\treturn 0;\n\n\t/*\n\t * we can't merge with cached rbios, since the\n\t * idea is that when we merge the destination\n\t * rbio is going to run our IO for us.  We can\n\t * steal from cached rbio's though, other functions\n\t * handle that.\n\t */\n\tif (test_bit(RBIO_CACHE_BIT, &last->flags) ||\n\t    test_bit(RBIO_CACHE_BIT, &cur->flags))\n\t\treturn 0;\n\n\tif (last->bbio->raid_map[0] !=\n\t    cur->bbio->raid_map[0])\n\t\treturn 0;\n\n\t/* we can't merge with different operations */\n\tif (last->operation != cur->operation)\n\t\treturn 0;\n\t/*\n\t * We've need read the full stripe from the drive.\n\t * check and repair the parity and write the new results.\n\t *\n\t * We're not allowed to add any new bios to the\n\t * bio list here, anyone else that wants to\n\t * change this stripe needs to do their own rmw.\n\t */\n\tif (last->operation == BTRFS_RBIO_PARITY_SCRUB ||\n\t    cur->operation == BTRFS_RBIO_PARITY_SCRUB)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pending",
            "&cur->plug_list",
            "plug_list"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "steal_rbio",
          "args": [
            "cur",
            "rbio"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "steal_rbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "307-329",
          "snippet": "static void steal_rbio(struct btrfs_raid_bio *src, struct btrfs_raid_bio *dest)\n{\n\tint i;\n\tstruct page *s;\n\tstruct page *d;\n\n\tif (!test_bit(RBIO_CACHE_READY_BIT, &src->flags))\n\t\treturn;\n\n\tfor (i = 0; i < dest->nr_pages; i++) {\n\t\ts = src->stripe_pages[i];\n\t\tif (!s || !PageUptodate(s)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\td = dest->stripe_pages[i];\n\t\tif (d)\n\t\t\t__free_page(d);\n\n\t\tdest->stripe_pages[i] = s;\n\t\tsrc->stripe_pages[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RBIO_CACHE_READY_BIT\t3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_READY_BIT\t3\n\nstatic void steal_rbio(struct btrfs_raid_bio *src, struct btrfs_raid_bio *dest)\n{\n\tint i;\n\tstruct page *s;\n\tstruct page *d;\n\n\tif (!test_bit(RBIO_CACHE_READY_BIT, &src->flags))\n\t\treturn;\n\n\tfor (i = 0; i < dest->nr_pages; i++) {\n\t\ts = src->stripe_pages[i];\n\t\tif (!s || !PageUptodate(s)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\td = dest->stripe_pages[i];\n\t\tif (d)\n\t\t\t__free_page(d);\n\n\t\tdest->stripe_pages[i] = s;\n\t\tsrc->stripe_pages[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&cur->refs"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&cur->hash_list"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "RBIO_RMW_LOCKED_BIT",
            "&cur->flags"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cur->plug_list"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_list_empty",
          "args": [
            "&cur->bio_list"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cur->bio_list_lock"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cur",
            "&h->hash_list",
            "hash_list"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&h->lock",
            "flags"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rbio_bucket",
          "args": [
            "rbio"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "288-301",
          "snippet": "static int rbio_bucket(struct btrfs_raid_bio *rbio)\n{\n\tu64 num = rbio->bbio->raid_map[0];\n\n\t/*\n\t * we shift down quite a bit.  We're using byte\n\t * addressing, and most of the lower bits are zeros.\n\t * This tends to upset hash_64, and it consistently\n\t * returns just one or two different values.\n\t *\n\t * shifting off the lower bits fixes things.\n\t */\n\treturn hash_64(num >> 16, BTRFS_STRIPE_HASH_TABLE_BITS);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int rbio_bucket(struct btrfs_raid_bio *rbio)\n{\n\tu64 num = rbio->bbio->raid_map[0];\n\n\t/*\n\t * we shift down quite a bit.  We're using byte\n\t * addressing, and most of the lower bits are zeros.\n\t * This tends to upset hash_64, and it consistently\n\t * returns just one or two different values.\n\t *\n\t * shifting off the lower bits fixes things.\n\t */\n\treturn hash_64(num >> 16, BTRFS_STRIPE_HASH_TABLE_BITS);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_BIT\t\t2\n#define RBIO_RMW_LOCKED_BIT\t1\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic noinline int lock_stripe_add(struct btrfs_raid_bio *rbio)\n{\n\tint bucket = rbio_bucket(rbio);\n\tstruct btrfs_stripe_hash *h = rbio->fs_info->stripe_hash_table->table + bucket;\n\tstruct btrfs_raid_bio *cur;\n\tstruct btrfs_raid_bio *pending;\n\tunsigned long flags;\n\tDEFINE_WAIT(wait);\n\tstruct btrfs_raid_bio *freeit = NULL;\n\tstruct btrfs_raid_bio *cache_drop = NULL;\n\tint ret = 0;\n\tint walk = 0;\n\n\tspin_lock_irqsave(&h->lock, flags);\n\tlist_for_each_entry(cur, &h->hash_list, hash_list) {\n\t\twalk++;\n\t\tif (cur->bbio->raid_map[0] == rbio->bbio->raid_map[0]) {\n\t\t\tspin_lock(&cur->bio_list_lock);\n\n\t\t\t/* can we steal this cached rbio's pages? */\n\t\t\tif (bio_list_empty(&cur->bio_list) &&\n\t\t\t    list_empty(&cur->plug_list) &&\n\t\t\t    test_bit(RBIO_CACHE_BIT, &cur->flags) &&\n\t\t\t    !test_bit(RBIO_RMW_LOCKED_BIT, &cur->flags)) {\n\t\t\t\tlist_del_init(&cur->hash_list);\n\t\t\t\tatomic_dec(&cur->refs);\n\n\t\t\t\tsteal_rbio(cur, rbio);\n\t\t\t\tcache_drop = cur;\n\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\n\t\t\t\tgoto lockit;\n\t\t\t}\n\n\t\t\t/* can we merge into the lock owner? */\n\t\t\tif (rbio_can_merge(cur, rbio)) {\n\t\t\t\tmerge_rbio(cur, rbio);\n\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\t\tfreeit = rbio;\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\n\t\t\t/*\n\t\t\t * we couldn't merge with the running\n\t\t\t * rbio, see if we can merge with the\n\t\t\t * pending ones.  We don't have to\n\t\t\t * check for rmw_locked because there\n\t\t\t * is no way they are inside finish_rmw\n\t\t\t * right now\n\t\t\t */\n\t\t\tlist_for_each_entry(pending, &cur->plug_list,\n\t\t\t\t\t    plug_list) {\n\t\t\t\tif (rbio_can_merge(pending, rbio)) {\n\t\t\t\t\tmerge_rbio(pending, rbio);\n\t\t\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\t\t\tfreeit = rbio;\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* no merging, put us on the tail of the plug list,\n\t\t\t * our rbio will be started with the currently\n\t\t\t * running rbio unlocks\n\t\t\t */\n\t\t\tlist_add_tail(&rbio->plug_list, &cur->plug_list);\n\t\t\tspin_unlock(&cur->bio_list_lock);\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\nlockit:\n\tatomic_inc(&rbio->refs);\n\tlist_add(&rbio->hash_list, &h->hash_list);\nout:\n\tspin_unlock_irqrestore(&h->lock, flags);\n\tif (cache_drop)\n\t\tremove_rbio_from_cache(cache_drop);\n\tif (freeit)\n\t\t__free_raid_bio(freeit);\n\treturn ret;\n}"
  },
  {
    "function_name": "rbio_qstripe_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "628-636",
    "snippet": "static struct page *rbio_qstripe_page(struct btrfs_raid_bio *rbio, int index)\n{\n\tif (rbio->nr_data + 1 == rbio->real_stripes)\n\t\treturn NULL;\n\n\tindex += ((rbio->nr_data + 1) * rbio->stripe_len) >>\n\t\tPAGE_CACHE_SHIFT;\n\treturn rbio->stripe_pages[index];\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic struct page *rbio_qstripe_page(struct btrfs_raid_bio *rbio, int index)\n{\n\tif (rbio->nr_data + 1 == rbio->real_stripes)\n\t\treturn NULL;\n\n\tindex += ((rbio->nr_data + 1) * rbio->stripe_len) >>\n\t\tPAGE_CACHE_SHIFT;\n\treturn rbio->stripe_pages[index];\n}"
  },
  {
    "function_name": "rbio_pstripe_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "618-622",
    "snippet": "static struct page *rbio_pstripe_page(struct btrfs_raid_bio *rbio, int index)\n{\n\tindex += (rbio->nr_data * rbio->stripe_len) >> PAGE_CACHE_SHIFT;\n\treturn rbio->stripe_pages[index];\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic struct page *rbio_pstripe_page(struct btrfs_raid_bio *rbio, int index)\n{\n\tindex += (rbio->nr_data * rbio->stripe_len) >> PAGE_CACHE_SHIFT;\n\treturn rbio->stripe_pages[index];\n}"
  },
  {
    "function_name": "rbio_can_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "575-613",
    "snippet": "static int rbio_can_merge(struct btrfs_raid_bio *last,\n\t\t\t  struct btrfs_raid_bio *cur)\n{\n\tif (test_bit(RBIO_RMW_LOCKED_BIT, &last->flags) ||\n\t    test_bit(RBIO_RMW_LOCKED_BIT, &cur->flags))\n\t\treturn 0;\n\n\t/*\n\t * we can't merge with cached rbios, since the\n\t * idea is that when we merge the destination\n\t * rbio is going to run our IO for us.  We can\n\t * steal from cached rbio's though, other functions\n\t * handle that.\n\t */\n\tif (test_bit(RBIO_CACHE_BIT, &last->flags) ||\n\t    test_bit(RBIO_CACHE_BIT, &cur->flags))\n\t\treturn 0;\n\n\tif (last->bbio->raid_map[0] !=\n\t    cur->bbio->raid_map[0])\n\t\treturn 0;\n\n\t/* we can't merge with different operations */\n\tif (last->operation != cur->operation)\n\t\treturn 0;\n\t/*\n\t * We've need read the full stripe from the drive.\n\t * check and repair the parity and write the new results.\n\t *\n\t * We're not allowed to add any new bios to the\n\t * bio list here, anyone else that wants to\n\t * change this stripe needs to do their own rmw.\n\t */\n\tif (last->operation == BTRFS_RBIO_PARITY_SCRUB ||\n\t    cur->operation == BTRFS_RBIO_PARITY_SCRUB)\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define RBIO_CACHE_BIT\t\t2",
      "#define RBIO_RMW_LOCKED_BIT\t1"
    ],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "RBIO_CACHE_BIT",
            "&cur->flags"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_BIT\t\t2\n#define RBIO_RMW_LOCKED_BIT\t1\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int rbio_can_merge(struct btrfs_raid_bio *last,\n\t\t\t  struct btrfs_raid_bio *cur)\n{\n\tif (test_bit(RBIO_RMW_LOCKED_BIT, &last->flags) ||\n\t    test_bit(RBIO_RMW_LOCKED_BIT, &cur->flags))\n\t\treturn 0;\n\n\t/*\n\t * we can't merge with cached rbios, since the\n\t * idea is that when we merge the destination\n\t * rbio is going to run our IO for us.  We can\n\t * steal from cached rbio's though, other functions\n\t * handle that.\n\t */\n\tif (test_bit(RBIO_CACHE_BIT, &last->flags) ||\n\t    test_bit(RBIO_CACHE_BIT, &cur->flags))\n\t\treturn 0;\n\n\tif (last->bbio->raid_map[0] !=\n\t    cur->bbio->raid_map[0])\n\t\treturn 0;\n\n\t/* we can't merge with different operations */\n\tif (last->operation != cur->operation)\n\t\treturn 0;\n\t/*\n\t * We've need read the full stripe from the drive.\n\t * check and repair the parity and write the new results.\n\t *\n\t * We're not allowed to add any new bios to the\n\t * bio list here, anyone else that wants to\n\t * change this stripe needs to do their own rmw.\n\t */\n\tif (last->operation == BTRFS_RBIO_PARITY_SCRUB ||\n\t    cur->operation == BTRFS_RBIO_PARITY_SCRUB)\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "rbio_is_full",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "554-563",
    "snippet": "static int rbio_is_full(struct btrfs_raid_bio *rbio)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&rbio->bio_list_lock, flags);\n\tret = __rbio_is_full(rbio);\n\tspin_unlock_irqrestore(&rbio->bio_list_lock, flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&rbio->bio_list_lock",
            "flags"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__rbio_is_full",
          "args": [
            "rbio"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "__rbio_is_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "542-552",
          "snippet": "static int __rbio_is_full(struct btrfs_raid_bio *rbio)\n{\n\tunsigned long size = rbio->bio_list_bytes;\n\tint ret = 1;\n\n\tif (size != rbio->nr_data * rbio->stripe_len)\n\t\tret = 0;\n\n\tBUG_ON(size > rbio->nr_data * rbio->stripe_len);\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int __rbio_is_full(struct btrfs_raid_bio *rbio)\n{\n\tunsigned long size = rbio->bio_list_bytes;\n\tint ret = 1;\n\n\tif (size != rbio->nr_data * rbio->stripe_len)\n\t\tret = 0;\n\n\tBUG_ON(size > rbio->nr_data * rbio->stripe_len);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&rbio->bio_list_lock",
            "flags"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int rbio_is_full(struct btrfs_raid_bio *rbio)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&rbio->bio_list_lock, flags);\n\tret = __rbio_is_full(rbio);\n\tspin_unlock_irqrestore(&rbio->bio_list_lock, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "__rbio_is_full",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "542-552",
    "snippet": "static int __rbio_is_full(struct btrfs_raid_bio *rbio)\n{\n\tunsigned long size = rbio->bio_list_bytes;\n\tint ret = 1;\n\n\tif (size != rbio->nr_data * rbio->stripe_len)\n\t\tret = 0;\n\n\tBUG_ON(size > rbio->nr_data * rbio->stripe_len);\n\treturn ret;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "size > rbio->nr_data * rbio->stripe_len"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int __rbio_is_full(struct btrfs_raid_bio *rbio)\n{\n\tunsigned long size = rbio->bio_list_bytes;\n\tint ret = 1;\n\n\tif (size != rbio->nr_data * rbio->stripe_len)\n\t\tret = 0;\n\n\tBUG_ON(size > rbio->nr_data * rbio->stripe_len);\n\treturn ret;\n}"
  },
  {
    "function_name": "run_xor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "520-533",
    "snippet": "static void run_xor(void **pages, int src_cnt, ssize_t len)\n{\n\tint src_off = 0;\n\tint xor_src_cnt = 0;\n\tvoid *dest = pages[src_cnt];\n\n\twhile(src_cnt > 0) {\n\t\txor_src_cnt = min(src_cnt, MAX_XOR_BLOCKS);\n\t\txor_blocks(xor_src_cnt, len, dest, pages + src_off);\n\n\t\tsrc_cnt -= xor_src_cnt;\n\t\tsrc_off += xor_src_cnt;\n\t}\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xor_blocks",
          "args": [
            "xor_src_cnt",
            "len",
            "dest",
            "pages + src_off"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "src_cnt",
            "MAX_XOR_BLOCKS"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic void run_xor(void **pages, int src_cnt, ssize_t len)\n{\n\tint src_off = 0;\n\tint xor_src_cnt = 0;\n\tvoid *dest = pages[src_cnt];\n\n\twhile(src_cnt > 0) {\n\t\txor_src_cnt = min(src_cnt, MAX_XOR_BLOCKS);\n\t\txor_blocks(xor_src_cnt, len, dest, pages + src_off);\n\n\t\tsrc_cnt -= xor_src_cnt;\n\t\tsrc_off += xor_src_cnt;\n\t}\n}"
  },
  {
    "function_name": "cache_rbio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "474-513",
    "snippet": "static void cache_rbio(struct btrfs_raid_bio *rbio)\n{\n\tstruct btrfs_stripe_hash_table *table;\n\tunsigned long flags;\n\n\tif (!test_bit(RBIO_CACHE_READY_BIT, &rbio->flags))\n\t\treturn;\n\n\ttable = rbio->fs_info->stripe_hash_table;\n\n\tspin_lock_irqsave(&table->cache_lock, flags);\n\tspin_lock(&rbio->bio_list_lock);\n\n\t/* bump our ref if we were not in the list before */\n\tif (!test_and_set_bit(RBIO_CACHE_BIT, &rbio->flags))\n\t\tatomic_inc(&rbio->refs);\n\n\tif (!list_empty(&rbio->stripe_cache)){\n\t\tlist_move(&rbio->stripe_cache, &table->stripe_cache);\n\t} else {\n\t\tlist_add(&rbio->stripe_cache, &table->stripe_cache);\n\t\ttable->cache_size += 1;\n\t}\n\n\tspin_unlock(&rbio->bio_list_lock);\n\n\tif (table->cache_size > RBIO_CACHE_SIZE) {\n\t\tstruct btrfs_raid_bio *found;\n\n\t\tfound = list_entry(table->stripe_cache.prev,\n\t\t\t\t  struct btrfs_raid_bio,\n\t\t\t\t  stripe_cache);\n\n\t\tif (found != rbio)\n\t\t\t__remove_rbio_from_cache(found);\n\t}\n\n\tspin_unlock_irqrestore(&table->cache_lock, flags);\n\treturn;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define RBIO_CACHE_SIZE 1024",
      "#define RBIO_CACHE_READY_BIT\t3",
      "#define RBIO_CACHE_BIT\t\t2"
    ],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&table->cache_lock",
            "flags"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__remove_rbio_from_cache",
          "args": [
            "found"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_rbio_from_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "351-406",
          "snippet": "static void __remove_rbio_from_cache(struct btrfs_raid_bio *rbio)\n{\n\tint bucket = rbio_bucket(rbio);\n\tstruct btrfs_stripe_hash_table *table;\n\tstruct btrfs_stripe_hash *h;\n\tint freeit = 0;\n\n\t/*\n\t * check the bit again under the hash table lock.\n\t */\n\tif (!test_bit(RBIO_CACHE_BIT, &rbio->flags))\n\t\treturn;\n\n\ttable = rbio->fs_info->stripe_hash_table;\n\th = table->table + bucket;\n\n\t/* hold the lock for the bucket because we may be\n\t * removing it from the hash table\n\t */\n\tspin_lock(&h->lock);\n\n\t/*\n\t * hold the lock for the bio list because we need\n\t * to make sure the bio list is empty\n\t */\n\tspin_lock(&rbio->bio_list_lock);\n\n\tif (test_and_clear_bit(RBIO_CACHE_BIT, &rbio->flags)) {\n\t\tlist_del_init(&rbio->stripe_cache);\n\t\ttable->cache_size -= 1;\n\t\tfreeit = 1;\n\n\t\t/* if the bio list isn't empty, this rbio is\n\t\t * still involved in an IO.  We take it out\n\t\t * of the cache list, and drop the ref that\n\t\t * was held for the list.\n\t\t *\n\t\t * If the bio_list was empty, we also remove\n\t\t * the rbio from the hash_table, and drop\n\t\t * the corresponding ref\n\t\t */\n\t\tif (bio_list_empty(&rbio->bio_list)) {\n\t\t\tif (!list_empty(&rbio->hash_list)) {\n\t\t\t\tlist_del_init(&rbio->hash_list);\n\t\t\t\tatomic_dec(&rbio->refs);\n\t\t\t\tBUG_ON(!list_empty(&rbio->plug_list));\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock(&rbio->bio_list_lock);\n\tspin_unlock(&h->lock);\n\n\tif (freeit)\n\t\t__free_raid_bio(rbio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RBIO_CACHE_BIT\t\t2"
          ],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_BIT\t\t2\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void __remove_rbio_from_cache(struct btrfs_raid_bio *rbio)\n{\n\tint bucket = rbio_bucket(rbio);\n\tstruct btrfs_stripe_hash_table *table;\n\tstruct btrfs_stripe_hash *h;\n\tint freeit = 0;\n\n\t/*\n\t * check the bit again under the hash table lock.\n\t */\n\tif (!test_bit(RBIO_CACHE_BIT, &rbio->flags))\n\t\treturn;\n\n\ttable = rbio->fs_info->stripe_hash_table;\n\th = table->table + bucket;\n\n\t/* hold the lock for the bucket because we may be\n\t * removing it from the hash table\n\t */\n\tspin_lock(&h->lock);\n\n\t/*\n\t * hold the lock for the bio list because we need\n\t * to make sure the bio list is empty\n\t */\n\tspin_lock(&rbio->bio_list_lock);\n\n\tif (test_and_clear_bit(RBIO_CACHE_BIT, &rbio->flags)) {\n\t\tlist_del_init(&rbio->stripe_cache);\n\t\ttable->cache_size -= 1;\n\t\tfreeit = 1;\n\n\t\t/* if the bio list isn't empty, this rbio is\n\t\t * still involved in an IO.  We take it out\n\t\t * of the cache list, and drop the ref that\n\t\t * was held for the list.\n\t\t *\n\t\t * If the bio_list was empty, we also remove\n\t\t * the rbio from the hash_table, and drop\n\t\t * the corresponding ref\n\t\t */\n\t\tif (bio_list_empty(&rbio->bio_list)) {\n\t\t\tif (!list_empty(&rbio->hash_list)) {\n\t\t\t\tlist_del_init(&rbio->hash_list);\n\t\t\t\tatomic_dec(&rbio->refs);\n\t\t\t\tBUG_ON(!list_empty(&rbio->plug_list));\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock(&rbio->bio_list_lock);\n\tspin_unlock(&h->lock);\n\n\tif (freeit)\n\t\t__free_raid_bio(rbio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "table->stripe_cache.prev",
            "structbtrfs_raid_bio",
            "stripe_cache"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&rbio->bio_list_lock"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&rbio->stripe_cache",
            "&table->stripe_cache"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&rbio->stripe_cache",
            "&table->stripe_cache"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&rbio->stripe_cache"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&rbio->refs"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "RBIO_CACHE_BIT",
            "&rbio->flags"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&rbio->bio_list_lock"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&table->cache_lock",
            "flags"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "RBIO_CACHE_READY_BIT",
            "&rbio->flags"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_SIZE 1024\n#define RBIO_CACHE_READY_BIT\t3\n#define RBIO_CACHE_BIT\t\t2\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void cache_rbio(struct btrfs_raid_bio *rbio)\n{\n\tstruct btrfs_stripe_hash_table *table;\n\tunsigned long flags;\n\n\tif (!test_bit(RBIO_CACHE_READY_BIT, &rbio->flags))\n\t\treturn;\n\n\ttable = rbio->fs_info->stripe_hash_table;\n\n\tspin_lock_irqsave(&table->cache_lock, flags);\n\tspin_lock(&rbio->bio_list_lock);\n\n\t/* bump our ref if we were not in the list before */\n\tif (!test_and_set_bit(RBIO_CACHE_BIT, &rbio->flags))\n\t\tatomic_inc(&rbio->refs);\n\n\tif (!list_empty(&rbio->stripe_cache)){\n\t\tlist_move(&rbio->stripe_cache, &table->stripe_cache);\n\t} else {\n\t\tlist_add(&rbio->stripe_cache, &table->stripe_cache);\n\t\ttable->cache_size += 1;\n\t}\n\n\tspin_unlock(&rbio->bio_list_lock);\n\n\tif (table->cache_size > RBIO_CACHE_SIZE) {\n\t\tstruct btrfs_raid_bio *found;\n\n\t\tfound = list_entry(table->stripe_cache.prev,\n\t\t\t\t  struct btrfs_raid_bio,\n\t\t\t\t  stripe_cache);\n\n\t\tif (found != rbio)\n\t\t\t__remove_rbio_from_cache(found);\n\t}\n\n\tspin_unlock_irqrestore(&table->cache_lock, flags);\n\treturn;\n}"
  },
  {
    "function_name": "btrfs_free_stripe_hash_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "451-461",
    "snippet": "void btrfs_free_stripe_hash_table(struct btrfs_fs_info *info)\n{\n\tif (!info->stripe_hash_table)\n\t\treturn;\n\tbtrfs_clear_rbio_cache(info);\n\tif (is_vmalloc_addr(info->stripe_hash_table))\n\t\tvfree(info->stripe_hash_table);\n\telse\n\t\tkfree(info->stripe_hash_table);\n\tinfo->stripe_hash_table = NULL;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "info->stripe_hash_table"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "info->stripe_hash_table"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vmalloc_addr",
          "args": [
            "info->stripe_hash_table"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_clear_rbio_cache",
          "args": [
            "info"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_clear_rbio_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "429-445",
          "snippet": "static void btrfs_clear_rbio_cache(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_stripe_hash_table *table;\n\tunsigned long flags;\n\tstruct btrfs_raid_bio *rbio;\n\n\ttable = info->stripe_hash_table;\n\n\tspin_lock_irqsave(&table->cache_lock, flags);\n\twhile (!list_empty(&table->stripe_cache)) {\n\t\trbio = list_entry(table->stripe_cache.next,\n\t\t\t\t  struct btrfs_raid_bio,\n\t\t\t\t  stripe_cache);\n\t\t__remove_rbio_from_cache(rbio);\n\t}\n\tspin_unlock_irqrestore(&table->cache_lock, flags);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void btrfs_clear_rbio_cache(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_stripe_hash_table *table;\n\tunsigned long flags;\n\tstruct btrfs_raid_bio *rbio;\n\n\ttable = info->stripe_hash_table;\n\n\tspin_lock_irqsave(&table->cache_lock, flags);\n\twhile (!list_empty(&table->stripe_cache)) {\n\t\trbio = list_entry(table->stripe_cache.next,\n\t\t\t\t  struct btrfs_raid_bio,\n\t\t\t\t  stripe_cache);\n\t\t__remove_rbio_from_cache(rbio);\n\t}\n\tspin_unlock_irqrestore(&table->cache_lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nvoid btrfs_free_stripe_hash_table(struct btrfs_fs_info *info)\n{\n\tif (!info->stripe_hash_table)\n\t\treturn;\n\tbtrfs_clear_rbio_cache(info);\n\tif (is_vmalloc_addr(info->stripe_hash_table))\n\t\tvfree(info->stripe_hash_table);\n\telse\n\t\tkfree(info->stripe_hash_table);\n\tinfo->stripe_hash_table = NULL;\n}"
  },
  {
    "function_name": "btrfs_clear_rbio_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "429-445",
    "snippet": "static void btrfs_clear_rbio_cache(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_stripe_hash_table *table;\n\tunsigned long flags;\n\tstruct btrfs_raid_bio *rbio;\n\n\ttable = info->stripe_hash_table;\n\n\tspin_lock_irqsave(&table->cache_lock, flags);\n\twhile (!list_empty(&table->stripe_cache)) {\n\t\trbio = list_entry(table->stripe_cache.next,\n\t\t\t\t  struct btrfs_raid_bio,\n\t\t\t\t  stripe_cache);\n\t\t__remove_rbio_from_cache(rbio);\n\t}\n\tspin_unlock_irqrestore(&table->cache_lock, flags);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&table->cache_lock",
            "flags"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__remove_rbio_from_cache",
          "args": [
            "rbio"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_rbio_from_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "351-406",
          "snippet": "static void __remove_rbio_from_cache(struct btrfs_raid_bio *rbio)\n{\n\tint bucket = rbio_bucket(rbio);\n\tstruct btrfs_stripe_hash_table *table;\n\tstruct btrfs_stripe_hash *h;\n\tint freeit = 0;\n\n\t/*\n\t * check the bit again under the hash table lock.\n\t */\n\tif (!test_bit(RBIO_CACHE_BIT, &rbio->flags))\n\t\treturn;\n\n\ttable = rbio->fs_info->stripe_hash_table;\n\th = table->table + bucket;\n\n\t/* hold the lock for the bucket because we may be\n\t * removing it from the hash table\n\t */\n\tspin_lock(&h->lock);\n\n\t/*\n\t * hold the lock for the bio list because we need\n\t * to make sure the bio list is empty\n\t */\n\tspin_lock(&rbio->bio_list_lock);\n\n\tif (test_and_clear_bit(RBIO_CACHE_BIT, &rbio->flags)) {\n\t\tlist_del_init(&rbio->stripe_cache);\n\t\ttable->cache_size -= 1;\n\t\tfreeit = 1;\n\n\t\t/* if the bio list isn't empty, this rbio is\n\t\t * still involved in an IO.  We take it out\n\t\t * of the cache list, and drop the ref that\n\t\t * was held for the list.\n\t\t *\n\t\t * If the bio_list was empty, we also remove\n\t\t * the rbio from the hash_table, and drop\n\t\t * the corresponding ref\n\t\t */\n\t\tif (bio_list_empty(&rbio->bio_list)) {\n\t\t\tif (!list_empty(&rbio->hash_list)) {\n\t\t\t\tlist_del_init(&rbio->hash_list);\n\t\t\t\tatomic_dec(&rbio->refs);\n\t\t\t\tBUG_ON(!list_empty(&rbio->plug_list));\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock(&rbio->bio_list_lock);\n\tspin_unlock(&h->lock);\n\n\tif (freeit)\n\t\t__free_raid_bio(rbio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RBIO_CACHE_BIT\t\t2"
          ],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_BIT\t\t2\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void __remove_rbio_from_cache(struct btrfs_raid_bio *rbio)\n{\n\tint bucket = rbio_bucket(rbio);\n\tstruct btrfs_stripe_hash_table *table;\n\tstruct btrfs_stripe_hash *h;\n\tint freeit = 0;\n\n\t/*\n\t * check the bit again under the hash table lock.\n\t */\n\tif (!test_bit(RBIO_CACHE_BIT, &rbio->flags))\n\t\treturn;\n\n\ttable = rbio->fs_info->stripe_hash_table;\n\th = table->table + bucket;\n\n\t/* hold the lock for the bucket because we may be\n\t * removing it from the hash table\n\t */\n\tspin_lock(&h->lock);\n\n\t/*\n\t * hold the lock for the bio list because we need\n\t * to make sure the bio list is empty\n\t */\n\tspin_lock(&rbio->bio_list_lock);\n\n\tif (test_and_clear_bit(RBIO_CACHE_BIT, &rbio->flags)) {\n\t\tlist_del_init(&rbio->stripe_cache);\n\t\ttable->cache_size -= 1;\n\t\tfreeit = 1;\n\n\t\t/* if the bio list isn't empty, this rbio is\n\t\t * still involved in an IO.  We take it out\n\t\t * of the cache list, and drop the ref that\n\t\t * was held for the list.\n\t\t *\n\t\t * If the bio_list was empty, we also remove\n\t\t * the rbio from the hash_table, and drop\n\t\t * the corresponding ref\n\t\t */\n\t\tif (bio_list_empty(&rbio->bio_list)) {\n\t\t\tif (!list_empty(&rbio->hash_list)) {\n\t\t\t\tlist_del_init(&rbio->hash_list);\n\t\t\t\tatomic_dec(&rbio->refs);\n\t\t\t\tBUG_ON(!list_empty(&rbio->plug_list));\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock(&rbio->bio_list_lock);\n\tspin_unlock(&h->lock);\n\n\tif (freeit)\n\t\t__free_raid_bio(rbio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "table->stripe_cache.next",
            "structbtrfs_raid_bio",
            "stripe_cache"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&table->stripe_cache"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&table->cache_lock",
            "flags"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void btrfs_clear_rbio_cache(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_stripe_hash_table *table;\n\tunsigned long flags;\n\tstruct btrfs_raid_bio *rbio;\n\n\ttable = info->stripe_hash_table;\n\n\tspin_lock_irqsave(&table->cache_lock, flags);\n\twhile (!list_empty(&table->stripe_cache)) {\n\t\trbio = list_entry(table->stripe_cache.next,\n\t\t\t\t  struct btrfs_raid_bio,\n\t\t\t\t  stripe_cache);\n\t\t__remove_rbio_from_cache(rbio);\n\t}\n\tspin_unlock_irqrestore(&table->cache_lock, flags);\n}"
  },
  {
    "function_name": "remove_rbio_from_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "411-424",
    "snippet": "static void remove_rbio_from_cache(struct btrfs_raid_bio *rbio)\n{\n\tstruct btrfs_stripe_hash_table *table;\n\tunsigned long flags;\n\n\tif (!test_bit(RBIO_CACHE_BIT, &rbio->flags))\n\t\treturn;\n\n\ttable = rbio->fs_info->stripe_hash_table;\n\n\tspin_lock_irqsave(&table->cache_lock, flags);\n\t__remove_rbio_from_cache(rbio);\n\tspin_unlock_irqrestore(&table->cache_lock, flags);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define RBIO_CACHE_BIT\t\t2"
    ],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&table->cache_lock",
            "flags"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__remove_rbio_from_cache",
          "args": [
            "rbio"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_rbio_from_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "351-406",
          "snippet": "static void __remove_rbio_from_cache(struct btrfs_raid_bio *rbio)\n{\n\tint bucket = rbio_bucket(rbio);\n\tstruct btrfs_stripe_hash_table *table;\n\tstruct btrfs_stripe_hash *h;\n\tint freeit = 0;\n\n\t/*\n\t * check the bit again under the hash table lock.\n\t */\n\tif (!test_bit(RBIO_CACHE_BIT, &rbio->flags))\n\t\treturn;\n\n\ttable = rbio->fs_info->stripe_hash_table;\n\th = table->table + bucket;\n\n\t/* hold the lock for the bucket because we may be\n\t * removing it from the hash table\n\t */\n\tspin_lock(&h->lock);\n\n\t/*\n\t * hold the lock for the bio list because we need\n\t * to make sure the bio list is empty\n\t */\n\tspin_lock(&rbio->bio_list_lock);\n\n\tif (test_and_clear_bit(RBIO_CACHE_BIT, &rbio->flags)) {\n\t\tlist_del_init(&rbio->stripe_cache);\n\t\ttable->cache_size -= 1;\n\t\tfreeit = 1;\n\n\t\t/* if the bio list isn't empty, this rbio is\n\t\t * still involved in an IO.  We take it out\n\t\t * of the cache list, and drop the ref that\n\t\t * was held for the list.\n\t\t *\n\t\t * If the bio_list was empty, we also remove\n\t\t * the rbio from the hash_table, and drop\n\t\t * the corresponding ref\n\t\t */\n\t\tif (bio_list_empty(&rbio->bio_list)) {\n\t\t\tif (!list_empty(&rbio->hash_list)) {\n\t\t\t\tlist_del_init(&rbio->hash_list);\n\t\t\t\tatomic_dec(&rbio->refs);\n\t\t\t\tBUG_ON(!list_empty(&rbio->plug_list));\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock(&rbio->bio_list_lock);\n\tspin_unlock(&h->lock);\n\n\tif (freeit)\n\t\t__free_raid_bio(rbio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RBIO_CACHE_BIT\t\t2"
          ],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_BIT\t\t2\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void __remove_rbio_from_cache(struct btrfs_raid_bio *rbio)\n{\n\tint bucket = rbio_bucket(rbio);\n\tstruct btrfs_stripe_hash_table *table;\n\tstruct btrfs_stripe_hash *h;\n\tint freeit = 0;\n\n\t/*\n\t * check the bit again under the hash table lock.\n\t */\n\tif (!test_bit(RBIO_CACHE_BIT, &rbio->flags))\n\t\treturn;\n\n\ttable = rbio->fs_info->stripe_hash_table;\n\th = table->table + bucket;\n\n\t/* hold the lock for the bucket because we may be\n\t * removing it from the hash table\n\t */\n\tspin_lock(&h->lock);\n\n\t/*\n\t * hold the lock for the bio list because we need\n\t * to make sure the bio list is empty\n\t */\n\tspin_lock(&rbio->bio_list_lock);\n\n\tif (test_and_clear_bit(RBIO_CACHE_BIT, &rbio->flags)) {\n\t\tlist_del_init(&rbio->stripe_cache);\n\t\ttable->cache_size -= 1;\n\t\tfreeit = 1;\n\n\t\t/* if the bio list isn't empty, this rbio is\n\t\t * still involved in an IO.  We take it out\n\t\t * of the cache list, and drop the ref that\n\t\t * was held for the list.\n\t\t *\n\t\t * If the bio_list was empty, we also remove\n\t\t * the rbio from the hash_table, and drop\n\t\t * the corresponding ref\n\t\t */\n\t\tif (bio_list_empty(&rbio->bio_list)) {\n\t\t\tif (!list_empty(&rbio->hash_list)) {\n\t\t\t\tlist_del_init(&rbio->hash_list);\n\t\t\t\tatomic_dec(&rbio->refs);\n\t\t\t\tBUG_ON(!list_empty(&rbio->plug_list));\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock(&rbio->bio_list_lock);\n\tspin_unlock(&h->lock);\n\n\tif (freeit)\n\t\t__free_raid_bio(rbio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&table->cache_lock",
            "flags"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "RBIO_CACHE_BIT",
            "&rbio->flags"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_BIT\t\t2\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void remove_rbio_from_cache(struct btrfs_raid_bio *rbio)\n{\n\tstruct btrfs_stripe_hash_table *table;\n\tunsigned long flags;\n\n\tif (!test_bit(RBIO_CACHE_BIT, &rbio->flags))\n\t\treturn;\n\n\ttable = rbio->fs_info->stripe_hash_table;\n\n\tspin_lock_irqsave(&table->cache_lock, flags);\n\t__remove_rbio_from_cache(rbio);\n\tspin_unlock_irqrestore(&table->cache_lock, flags);\n}"
  },
  {
    "function_name": "__remove_rbio_from_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "351-406",
    "snippet": "static void __remove_rbio_from_cache(struct btrfs_raid_bio *rbio)\n{\n\tint bucket = rbio_bucket(rbio);\n\tstruct btrfs_stripe_hash_table *table;\n\tstruct btrfs_stripe_hash *h;\n\tint freeit = 0;\n\n\t/*\n\t * check the bit again under the hash table lock.\n\t */\n\tif (!test_bit(RBIO_CACHE_BIT, &rbio->flags))\n\t\treturn;\n\n\ttable = rbio->fs_info->stripe_hash_table;\n\th = table->table + bucket;\n\n\t/* hold the lock for the bucket because we may be\n\t * removing it from the hash table\n\t */\n\tspin_lock(&h->lock);\n\n\t/*\n\t * hold the lock for the bio list because we need\n\t * to make sure the bio list is empty\n\t */\n\tspin_lock(&rbio->bio_list_lock);\n\n\tif (test_and_clear_bit(RBIO_CACHE_BIT, &rbio->flags)) {\n\t\tlist_del_init(&rbio->stripe_cache);\n\t\ttable->cache_size -= 1;\n\t\tfreeit = 1;\n\n\t\t/* if the bio list isn't empty, this rbio is\n\t\t * still involved in an IO.  We take it out\n\t\t * of the cache list, and drop the ref that\n\t\t * was held for the list.\n\t\t *\n\t\t * If the bio_list was empty, we also remove\n\t\t * the rbio from the hash_table, and drop\n\t\t * the corresponding ref\n\t\t */\n\t\tif (bio_list_empty(&rbio->bio_list)) {\n\t\t\tif (!list_empty(&rbio->hash_list)) {\n\t\t\t\tlist_del_init(&rbio->hash_list);\n\t\t\t\tatomic_dec(&rbio->refs);\n\t\t\t\tBUG_ON(!list_empty(&rbio->plug_list));\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock(&rbio->bio_list_lock);\n\tspin_unlock(&h->lock);\n\n\tif (freeit)\n\t\t__free_raid_bio(rbio);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define RBIO_CACHE_BIT\t\t2"
    ],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_raid_bio",
          "args": [
            "rbio"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "__free_raid_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "828-849",
          "snippet": "static void __free_raid_bio(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\n\tWARN_ON(atomic_read(&rbio->refs) < 0);\n\tif (!atomic_dec_and_test(&rbio->refs))\n\t\treturn;\n\n\tWARN_ON(!list_empty(&rbio->stripe_cache));\n\tWARN_ON(!list_empty(&rbio->hash_list));\n\tWARN_ON(!bio_list_empty(&rbio->bio_list));\n\n\tfor (i = 0; i < rbio->nr_pages; i++) {\n\t\tif (rbio->stripe_pages[i]) {\n\t\t\t__free_page(rbio->stripe_pages[i]);\n\t\t\trbio->stripe_pages[i] = NULL;\n\t\t}\n\t}\n\n\tbtrfs_put_bbio(rbio->bbio);\n\tkfree(rbio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\n\tWARN_ON(atomic_read(&rbio->refs) < 0);\n\tif (!atomic_dec_and_test(&rbio->refs))\n\t\treturn;\n\n\tWARN_ON(!list_empty(&rbio->stripe_cache));\n\tWARN_ON(!list_empty(&rbio->hash_list));\n\tWARN_ON(!bio_list_empty(&rbio->bio_list));\n\n\tfor (i = 0; i < rbio->nr_pages; i++) {\n\t\tif (rbio->stripe_pages[i]) {\n\t\t\t__free_page(rbio->stripe_pages[i]);\n\t\t\trbio->stripe_pages[i] = NULL;\n\t\t}\n\t}\n\n\tbtrfs_put_bbio(rbio->bbio);\n\tkfree(rbio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&h->lock"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&rbio->plug_list)"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&rbio->plug_list"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&rbio->refs"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&rbio->hash_list"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_list_empty",
          "args": [
            "&rbio->bio_list"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&rbio->stripe_cache"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "RBIO_CACHE_BIT",
            "&rbio->flags"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&rbio->bio_list_lock"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "RBIO_CACHE_BIT",
            "&rbio->flags"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rbio_bucket",
          "args": [
            "rbio"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "rbio_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "288-301",
          "snippet": "static int rbio_bucket(struct btrfs_raid_bio *rbio)\n{\n\tu64 num = rbio->bbio->raid_map[0];\n\n\t/*\n\t * we shift down quite a bit.  We're using byte\n\t * addressing, and most of the lower bits are zeros.\n\t * This tends to upset hash_64, and it consistently\n\t * returns just one or two different values.\n\t *\n\t * shifting off the lower bits fixes things.\n\t */\n\treturn hash_64(num >> 16, BTRFS_STRIPE_HASH_TABLE_BITS);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int rbio_bucket(struct btrfs_raid_bio *rbio)\n{\n\tu64 num = rbio->bbio->raid_map[0];\n\n\t/*\n\t * we shift down quite a bit.  We're using byte\n\t * addressing, and most of the lower bits are zeros.\n\t * This tends to upset hash_64, and it consistently\n\t * returns just one or two different values.\n\t *\n\t * shifting off the lower bits fixes things.\n\t */\n\treturn hash_64(num >> 16, BTRFS_STRIPE_HASH_TABLE_BITS);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_BIT\t\t2\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio, struct bio *bio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void __remove_rbio_from_cache(struct btrfs_raid_bio *rbio)\n{\n\tint bucket = rbio_bucket(rbio);\n\tstruct btrfs_stripe_hash_table *table;\n\tstruct btrfs_stripe_hash *h;\n\tint freeit = 0;\n\n\t/*\n\t * check the bit again under the hash table lock.\n\t */\n\tif (!test_bit(RBIO_CACHE_BIT, &rbio->flags))\n\t\treturn;\n\n\ttable = rbio->fs_info->stripe_hash_table;\n\th = table->table + bucket;\n\n\t/* hold the lock for the bucket because we may be\n\t * removing it from the hash table\n\t */\n\tspin_lock(&h->lock);\n\n\t/*\n\t * hold the lock for the bio list because we need\n\t * to make sure the bio list is empty\n\t */\n\tspin_lock(&rbio->bio_list_lock);\n\n\tif (test_and_clear_bit(RBIO_CACHE_BIT, &rbio->flags)) {\n\t\tlist_del_init(&rbio->stripe_cache);\n\t\ttable->cache_size -= 1;\n\t\tfreeit = 1;\n\n\t\t/* if the bio list isn't empty, this rbio is\n\t\t * still involved in an IO.  We take it out\n\t\t * of the cache list, and drop the ref that\n\t\t * was held for the list.\n\t\t *\n\t\t * If the bio_list was empty, we also remove\n\t\t * the rbio from the hash_table, and drop\n\t\t * the corresponding ref\n\t\t */\n\t\tif (bio_list_empty(&rbio->bio_list)) {\n\t\t\tif (!list_empty(&rbio->hash_list)) {\n\t\t\t\tlist_del_init(&rbio->hash_list);\n\t\t\t\tatomic_dec(&rbio->refs);\n\t\t\t\tBUG_ON(!list_empty(&rbio->plug_list));\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock(&rbio->bio_list_lock);\n\tspin_unlock(&h->lock);\n\n\tif (freeit)\n\t\t__free_raid_bio(rbio);\n}"
  },
  {
    "function_name": "merge_rbio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "338-345",
    "snippet": "static void merge_rbio(struct btrfs_raid_bio *dest,\n\t\t       struct btrfs_raid_bio *victim)\n{\n\tbio_list_merge(&dest->bio_list, &victim->bio_list);\n\tdest->bio_list_bytes += victim->bio_list_bytes;\n\tdest->generic_bio_cnt += victim->generic_bio_cnt;\n\tbio_list_init(&victim->bio_list);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_list_init",
          "args": [
            "&victim->bio_list"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_list_merge",
          "args": [
            "&dest->bio_list",
            "&victim->bio_list"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic void merge_rbio(struct btrfs_raid_bio *dest,\n\t\t       struct btrfs_raid_bio *victim)\n{\n\tbio_list_merge(&dest->bio_list, &victim->bio_list);\n\tdest->bio_list_bytes += victim->bio_list_bytes;\n\tdest->generic_bio_cnt += victim->generic_bio_cnt;\n\tbio_list_init(&victim->bio_list);\n}"
  },
  {
    "function_name": "steal_rbio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "307-329",
    "snippet": "static void steal_rbio(struct btrfs_raid_bio *src, struct btrfs_raid_bio *dest)\n{\n\tint i;\n\tstruct page *s;\n\tstruct page *d;\n\n\tif (!test_bit(RBIO_CACHE_READY_BIT, &src->flags))\n\t\treturn;\n\n\tfor (i = 0; i < dest->nr_pages; i++) {\n\t\ts = src->stripe_pages[i];\n\t\tif (!s || !PageUptodate(s)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\td = dest->stripe_pages[i];\n\t\tif (d)\n\t\t\t__free_page(d);\n\n\t\tdest->stripe_pages[i] = s;\n\t\tsrc->stripe_pages[i] = NULL;\n\t}\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define RBIO_CACHE_READY_BIT\t3"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "d"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "s"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "RBIO_CACHE_READY_BIT",
            "&src->flags"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_READY_BIT\t3\n\nstatic void steal_rbio(struct btrfs_raid_bio *src, struct btrfs_raid_bio *dest)\n{\n\tint i;\n\tstruct page *s;\n\tstruct page *d;\n\n\tif (!test_bit(RBIO_CACHE_READY_BIT, &src->flags))\n\t\treturn;\n\n\tfor (i = 0; i < dest->nr_pages; i++) {\n\t\ts = src->stripe_pages[i];\n\t\tif (!s || !PageUptodate(s)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\td = dest->stripe_pages[i];\n\t\tif (d)\n\t\t\t__free_page(d);\n\n\t\tdest->stripe_pages[i] = s;\n\t\tsrc->stripe_pages[i] = NULL;\n\t}\n}"
  },
  {
    "function_name": "rbio_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "288-301",
    "snippet": "static int rbio_bucket(struct btrfs_raid_bio *rbio)\n{\n\tu64 num = rbio->bbio->raid_map[0];\n\n\t/*\n\t * we shift down quite a bit.  We're using byte\n\t * addressing, and most of the lower bits are zeros.\n\t * This tends to upset hash_64, and it consistently\n\t * returns just one or two different values.\n\t *\n\t * shifting off the lower bits fixes things.\n\t */\n\treturn hash_64(num >> 16, BTRFS_STRIPE_HASH_TABLE_BITS);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_64",
          "args": [
            "num >> 16",
            "BTRFS_STRIPE_HASH_TABLE_BITS"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int rbio_bucket(struct btrfs_raid_bio *rbio)\n{\n\tu64 num = rbio->bbio->raid_map[0];\n\n\t/*\n\t * we shift down quite a bit.  We're using byte\n\t * addressing, and most of the lower bits are zeros.\n\t * This tends to upset hash_64, and it consistently\n\t * returns just one or two different values.\n\t *\n\t * shifting off the lower bits fixes things.\n\t */\n\treturn hash_64(num >> 16, BTRFS_STRIPE_HASH_TABLE_BITS);\n}"
  },
  {
    "function_name": "cache_rbio_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "258-283",
    "snippet": "static void cache_rbio_pages(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\tchar *s;\n\tchar *d;\n\tint ret;\n\n\tret = alloc_rbio_pages(rbio);\n\tif (ret)\n\t\treturn;\n\n\tfor (i = 0; i < rbio->nr_pages; i++) {\n\t\tif (!rbio->bio_pages[i])\n\t\t\tcontinue;\n\n\t\ts = kmap(rbio->bio_pages[i]);\n\t\td = kmap(rbio->stripe_pages[i]);\n\n\t\tmemcpy(d, s, PAGE_CACHE_SIZE);\n\n\t\tkunmap(rbio->bio_pages[i]);\n\t\tkunmap(rbio->stripe_pages[i]);\n\t\tSetPageUptodate(rbio->stripe_pages[i]);\n\t}\n\tset_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define RBIO_CACHE_READY_BIT\t3"
    ],
    "globals_used": [
      "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
      "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
      "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
      "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
      "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
      "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
      "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "RBIO_CACHE_READY_BIT",
            "&rbio->flags"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "rbio->stripe_pages[i]"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "rbio->stripe_pages[i]"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "rbio->bio_pages[i]"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "d",
            "s",
            "PAGE_CACHE_SIZE"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "rbio->stripe_pages[i]"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "rbio->bio_pages[i]"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_rbio_pages",
          "args": [
            "rbio"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_rbio_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
          "lines": "1009-1024",
          "snippet": "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\tstruct page *page;\n\n\tfor (i = 0; i < rbio->nr_pages; i++) {\n\t\tif (rbio->stripe_pages[i])\n\t\t\tcontinue;\n\t\tpage = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\trbio->stripe_pages[i] = page;\n\t\tClearPageUptodate(page);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/raid/xor.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/hash.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __raid56_parity_recover(struct btrfs_raid_bio *rbio);",
            "static noinline void finish_rmw(struct btrfs_raid_bio *rbio);",
            "static void async_rmw_stripe(struct btrfs_raid_bio *rbio);",
            "static void async_read_rebuild(struct btrfs_raid_bio *rbio);",
            "static void __free_raid_bio(struct btrfs_raid_bio *rbio);",
            "static void index_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static int alloc_rbio_pages(struct btrfs_raid_bio *rbio);",
            "static void async_scrub_parity(struct btrfs_raid_bio *rbio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\tstruct page *page;\n\n\tfor (i = 0; i < rbio->nr_pages; i++) {\n\t\tif (rbio->stripe_pages[i])\n\t\t\tcontinue;\n\t\tpage = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\trbio->stripe_pages[i] = page;\n\t\tClearPageUptodate(page);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#define RBIO_CACHE_READY_BIT\t3\n\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio);\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio);\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio);\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio);\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio);\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio);\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio);\n\nstatic void cache_rbio_pages(struct btrfs_raid_bio *rbio)\n{\n\tint i;\n\tchar *s;\n\tchar *d;\n\tint ret;\n\n\tret = alloc_rbio_pages(rbio);\n\tif (ret)\n\t\treturn;\n\n\tfor (i = 0; i < rbio->nr_pages; i++) {\n\t\tif (!rbio->bio_pages[i])\n\t\t\tcontinue;\n\n\t\ts = kmap(rbio->bio_pages[i]);\n\t\td = kmap(rbio->stripe_pages[i]);\n\n\t\tmemcpy(d, s, PAGE_CACHE_SIZE);\n\n\t\tkunmap(rbio->bio_pages[i]);\n\t\tkunmap(rbio->stripe_pages[i]);\n\t\tSetPageUptodate(rbio->stripe_pages[i]);\n\t}\n\tset_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\n}"
  },
  {
    "function_name": "btrfs_alloc_stripe_hash_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/raid56.c",
    "lines": "199-247",
    "snippet": "int btrfs_alloc_stripe_hash_table(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_stripe_hash_table *table;\n\tstruct btrfs_stripe_hash_table *x;\n\tstruct btrfs_stripe_hash *cur;\n\tstruct btrfs_stripe_hash *h;\n\tint num_entries = 1 << BTRFS_STRIPE_HASH_TABLE_BITS;\n\tint i;\n\tint table_size;\n\n\tif (info->stripe_hash_table)\n\t\treturn 0;\n\n\t/*\n\t * The table is large, starting with order 4 and can go as high as\n\t * order 7 in case lock debugging is turned on.\n\t *\n\t * Try harder to allocate and fallback to vmalloc to lower the chance\n\t * of a failing mount.\n\t */\n\ttable_size = sizeof(*table) + sizeof(*h) * num_entries;\n\ttable = kzalloc(table_size, GFP_KERNEL | __GFP_NOWARN | __GFP_REPEAT);\n\tif (!table) {\n\t\ttable = vzalloc(table_size);\n\t\tif (!table)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_init(&table->cache_lock);\n\tINIT_LIST_HEAD(&table->stripe_cache);\n\n\th = table->table;\n\n\tfor (i = 0; i < num_entries; i++) {\n\t\tcur = h + i;\n\t\tINIT_LIST_HEAD(&cur->hash_list);\n\t\tspin_lock_init(&cur->lock);\n\t\tinit_waitqueue_head(&cur->wait);\n\t}\n\n\tx = cmpxchg(&info->stripe_hash_table, NULL, table);\n\tif (x) {\n\t\tif (is_vmalloc_addr(x))\n\t\t\tvfree(x);\n\t\telse\n\t\t\tkfree(x);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"raid56.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/raid/xor.h>",
      "#include <linux/list_sort.h>",
      "#include <linux/hash.h>",
      "#include <linux/raid/pq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "x"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "x"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vmalloc_addr",
          "args": [
            "x"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&info->stripe_hash_table",
            "NULL",
            "table"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&cur->wait"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&cur->lock"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cur->hash_list"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&table->stripe_cache"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&table->cache_lock"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vzalloc",
          "args": [
            "table_size"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "table_size",
            "GFP_KERNEL | __GFP_NOWARN | __GFP_REPEAT"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/xor.h>\n#include <linux/list_sort.h>\n#include <linux/hash.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\nint btrfs_alloc_stripe_hash_table(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_stripe_hash_table *table;\n\tstruct btrfs_stripe_hash_table *x;\n\tstruct btrfs_stripe_hash *cur;\n\tstruct btrfs_stripe_hash *h;\n\tint num_entries = 1 << BTRFS_STRIPE_HASH_TABLE_BITS;\n\tint i;\n\tint table_size;\n\n\tif (info->stripe_hash_table)\n\t\treturn 0;\n\n\t/*\n\t * The table is large, starting with order 4 and can go as high as\n\t * order 7 in case lock debugging is turned on.\n\t *\n\t * Try harder to allocate and fallback to vmalloc to lower the chance\n\t * of a failing mount.\n\t */\n\ttable_size = sizeof(*table) + sizeof(*h) * num_entries;\n\ttable = kzalloc(table_size, GFP_KERNEL | __GFP_NOWARN | __GFP_REPEAT);\n\tif (!table) {\n\t\ttable = vzalloc(table_size);\n\t\tif (!table)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_init(&table->cache_lock);\n\tINIT_LIST_HEAD(&table->stripe_cache);\n\n\th = table->table;\n\n\tfor (i = 0; i < num_entries; i++) {\n\t\tcur = h + i;\n\t\tINIT_LIST_HEAD(&cur->hash_list);\n\t\tspin_lock_init(&cur->lock);\n\t\tinit_waitqueue_head(&cur->wait);\n\t}\n\n\tx = cmpxchg(&info->stripe_hash_table, NULL, table);\n\tif (x) {\n\t\tif (is_vmalloc_addr(x))\n\t\t\tvfree(x);\n\t\telse\n\t\t\tkfree(x);\n\t}\n\treturn 0;\n}"
  }
]