[
  {
    "function_name": "jbd2_journal_clear_revoke",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
    "lines": "745-762",
    "snippet": "void jbd2_journal_clear_revoke(journal_t *journal)\n{\n\tint i;\n\tstruct list_head *hash_list;\n\tstruct jbd2_revoke_record_s *record;\n\tstruct jbd2_revoke_table_s *revoke;\n\n\trevoke = journal->j_revoke;\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\thash_list = &revoke->hash_table[i];\n\t\twhile (!list_empty(hash_list)) {\n\t\t\trecord = (struct jbd2_revoke_record_s*) hash_list->next;\n\t\t\tlist_del(&record->hash);\n\t\t\tkmem_cache_free(jbd2_revoke_record_cache, record);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *jbd2_revoke_record_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "jbd2_revoke_record_cache",
            "record"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&record->hash"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "hash_list"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *jbd2_revoke_record_cache;\n\nvoid jbd2_journal_clear_revoke(journal_t *journal)\n{\n\tint i;\n\tstruct list_head *hash_list;\n\tstruct jbd2_revoke_record_s *record;\n\tstruct jbd2_revoke_table_s *revoke;\n\n\trevoke = journal->j_revoke;\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\thash_list = &revoke->hash_table[i];\n\t\twhile (!list_empty(hash_list)) {\n\t\t\trecord = (struct jbd2_revoke_record_s*) hash_list->next;\n\t\t\tlist_del(&record->hash);\n\t\t\tkmem_cache_free(jbd2_revoke_record_cache, record);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "jbd2_journal_test_revoke",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
    "lines": "726-738",
    "snippet": "int jbd2_journal_test_revoke(journal_t *journal,\n\t\t\tunsigned long long blocknr,\n\t\t\ttid_t sequence)\n{\n\tstruct jbd2_revoke_record_s *record;\n\n\trecord = find_revoke_record(journal, blocknr);\n\tif (!record)\n\t\treturn 0;\n\tif (tid_gt(sequence, record->sequence))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tid_gt",
          "args": [
            "sequence",
            "record->sequence"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_revoke_record",
          "args": [
            "journal",
            "blocknr"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "find_revoke_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "168-187",
          "snippet": "static struct jbd2_revoke_record_s *find_revoke_record(journal_t *journal,\n\t\t\t\t\t\t      unsigned long long blocknr)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd2_revoke_record_s *record;\n\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\n\tspin_lock(&journal->j_revoke_lock);\n\trecord = (struct jbd2_revoke_record_s *) hash_list->next;\n\twhile (&(record->hash) != hash_list) {\n\t\tif (record->blocknr == blocknr) {\n\t\t\tspin_unlock(&journal->j_revoke_lock);\n\t\t\treturn record;\n\t\t}\n\t\trecord = (struct jbd2_revoke_record_s *) record->hash.next;\n\t}\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct jbd2_revoke_record_s *find_revoke_record(journal_t *journal,\n\t\t\t\t\t\t      unsigned long long blocknr)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd2_revoke_record_s *record;\n\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\n\tspin_lock(&journal->j_revoke_lock);\n\trecord = (struct jbd2_revoke_record_s *) hash_list->next;\n\twhile (&(record->hash) != hash_list) {\n\t\tif (record->blocknr == blocknr) {\n\t\t\tspin_unlock(&journal->j_revoke_lock);\n\t\t\treturn record;\n\t\t}\n\t\trecord = (struct jbd2_revoke_record_s *) record->hash.next;\n\t}\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nint jbd2_journal_test_revoke(journal_t *journal,\n\t\t\tunsigned long long blocknr,\n\t\t\ttid_t sequence)\n{\n\tstruct jbd2_revoke_record_s *record;\n\n\trecord = find_revoke_record(journal, blocknr);\n\tif (!record)\n\t\treturn 0;\n\tif (tid_gt(sequence, record->sequence))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "jbd2_journal_set_revoke",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
    "lines": "702-717",
    "snippet": "int jbd2_journal_set_revoke(journal_t *journal,\n\t\t       unsigned long long blocknr,\n\t\t       tid_t sequence)\n{\n\tstruct jbd2_revoke_record_s *record;\n\n\trecord = find_revoke_record(journal, blocknr);\n\tif (record) {\n\t\t/* If we have multiple occurrences, only record the\n\t\t * latest sequence number in the hashed record */\n\t\tif (tid_gt(sequence, record->sequence))\n\t\t\trecord->sequence = sequence;\n\t\treturn 0;\n\t}\n\treturn insert_revoke_hash(journal, blocknr, sequence);\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "insert_revoke_hash",
          "args": [
            "journal",
            "blocknr",
            "sequence"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "insert_revoke_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "139-164",
          "snippet": "static int insert_revoke_hash(journal_t *journal, unsigned long long blocknr,\n\t\t\t      tid_t seq)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd2_revoke_record_s *record;\n\nrepeat:\n\trecord = kmem_cache_alloc(jbd2_revoke_record_cache, GFP_NOFS);\n\tif (!record)\n\t\tgoto oom;\n\n\trecord->sequence = seq;\n\trecord->blocknr = blocknr;\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\tspin_lock(&journal->j_revoke_lock);\n\tlist_add(&record->hash, hash_list);\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn 0;\n\noom:\n\tif (!journal_oom_retry)\n\t\treturn -ENOMEM;\n\tjbd_debug(1, \"ENOMEM in %s, retrying\\n\", __func__);\n\tyield();\n\tgoto repeat;\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *jbd2_revoke_record_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *jbd2_revoke_record_cache;\n\nstatic int insert_revoke_hash(journal_t *journal, unsigned long long blocknr,\n\t\t\t      tid_t seq)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd2_revoke_record_s *record;\n\nrepeat:\n\trecord = kmem_cache_alloc(jbd2_revoke_record_cache, GFP_NOFS);\n\tif (!record)\n\t\tgoto oom;\n\n\trecord->sequence = seq;\n\trecord->blocknr = blocknr;\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\tspin_lock(&journal->j_revoke_lock);\n\tlist_add(&record->hash, hash_list);\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn 0;\n\noom:\n\tif (!journal_oom_retry)\n\t\treturn -ENOMEM;\n\tjbd_debug(1, \"ENOMEM in %s, retrying\\n\", __func__);\n\tyield();\n\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tid_gt",
          "args": [
            "sequence",
            "record->sequence"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_revoke_record",
          "args": [
            "journal",
            "blocknr"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "find_revoke_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "168-187",
          "snippet": "static struct jbd2_revoke_record_s *find_revoke_record(journal_t *journal,\n\t\t\t\t\t\t      unsigned long long blocknr)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd2_revoke_record_s *record;\n\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\n\tspin_lock(&journal->j_revoke_lock);\n\trecord = (struct jbd2_revoke_record_s *) hash_list->next;\n\twhile (&(record->hash) != hash_list) {\n\t\tif (record->blocknr == blocknr) {\n\t\t\tspin_unlock(&journal->j_revoke_lock);\n\t\t\treturn record;\n\t\t}\n\t\trecord = (struct jbd2_revoke_record_s *) record->hash.next;\n\t}\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct jbd2_revoke_record_s *find_revoke_record(journal_t *journal,\n\t\t\t\t\t\t      unsigned long long blocknr)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd2_revoke_record_s *record;\n\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\n\tspin_lock(&journal->j_revoke_lock);\n\trecord = (struct jbd2_revoke_record_s *) hash_list->next;\n\twhile (&(record->hash) != hash_list) {\n\t\tif (record->blocknr == blocknr) {\n\t\t\tspin_unlock(&journal->j_revoke_lock);\n\t\t\treturn record;\n\t\t}\n\t\trecord = (struct jbd2_revoke_record_s *) record->hash.next;\n\t}\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nint jbd2_journal_set_revoke(journal_t *journal,\n\t\t       unsigned long long blocknr,\n\t\t       tid_t sequence)\n{\n\tstruct jbd2_revoke_record_s *record;\n\n\trecord = find_revoke_record(journal, blocknr);\n\tif (record) {\n\t\t/* If we have multiple occurrences, only record the\n\t\t * latest sequence number in the hashed record */\n\t\tif (tid_gt(sequence, record->sequence))\n\t\t\trecord->sequence = sequence;\n\t\treturn 0;\n\t}\n\treturn insert_revoke_hash(journal, blocknr, sequence);\n}"
  },
  {
    "function_name": "flush_descriptor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
    "lines": "658-677",
    "snippet": "static void flush_descriptor(journal_t *journal,\n\t\t\t     struct buffer_head *descriptor,\n\t\t\t     int offset, int write_op)\n{\n\tjbd2_journal_revoke_header_t *header;\n\n\tif (is_journal_aborted(journal)) {\n\t\tput_bh(descriptor);\n\t\treturn;\n\t}\n\n\theader = (jbd2_journal_revoke_header_t *)descriptor->b_data;\n\theader->r_count = cpu_to_be32(offset);\n\tjbd2_revoke_csum_set(journal, descriptor);\n\n\tset_buffer_jwrite(descriptor);\n\tBUFFER_TRACE(descriptor, \"write\");\n\tset_buffer_dirty(descriptor);\n\twrite_dirty_buffer(descriptor, write_op);\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_dirty_buffer",
          "args": [
            "descriptor",
            "write_op"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "write_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3115-3125",
          "snippet": "void write_dirty_buffer(struct buffer_head *bh, int rw)\n{\n\tlock_buffer(bh);\n\tif (!test_clear_buffer_dirty(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn;\n\t}\n\tbh->b_end_io = end_buffer_write_sync;\n\tget_bh(bh);\n\tsubmit_bh(rw, bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid write_dirty_buffer(struct buffer_head *bh, int rw)\n{\n\tlock_buffer(bh);\n\tif (!test_clear_buffer_dirty(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn;\n\t}\n\tbh->b_end_io = end_buffer_write_sync;\n\tget_bh(bh);\n\tsubmit_bh(rw, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_dirty",
          "args": [
            "descriptor"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "descriptor",
            "\"write\""
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_jwrite",
          "args": [
            "descriptor"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_revoke_csum_set",
          "args": [
            "journal",
            "descriptor"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_revoke_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "636-649",
          "snippet": "static void jbd2_revoke_csum_set(journal_t *j, struct buffer_head *bh)\n{\n\tstruct jbd2_journal_revoke_tail *tail;\n\t__u32 csum;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn;\n\n\ttail = (struct jbd2_journal_revoke_tail *)(bh->b_data + j->j_blocksize -\n\t\t\tsizeof(struct jbd2_journal_revoke_tail));\n\ttail->r_checksum = 0;\n\tcsum = jbd2_chksum(j, j->j_csum_seed, bh->b_data, j->j_blocksize);\n\ttail->r_checksum = cpu_to_be32(csum);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic void jbd2_revoke_csum_set(journal_t *j, struct buffer_head *bh)\n{\n\tstruct jbd2_journal_revoke_tail *tail;\n\t__u32 csum;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn;\n\n\ttail = (struct jbd2_journal_revoke_tail *)(bh->b_data + j->j_blocksize -\n\t\t\tsizeof(struct jbd2_journal_revoke_tail));\n\ttail->r_checksum = 0;\n\tcsum = jbd2_chksum(j, j->j_csum_seed, bh->b_data, j->j_blocksize);\n\ttail->r_checksum = cpu_to_be32(csum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "offset"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "descriptor"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_journal_aborted",
          "args": [
            "journal"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_is_journal_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "760-764",
          "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic void flush_descriptor(journal_t *journal,\n\t\t\t     struct buffer_head *descriptor,\n\t\t\t     int offset, int write_op)\n{\n\tjbd2_journal_revoke_header_t *header;\n\n\tif (is_journal_aborted(journal)) {\n\t\tput_bh(descriptor);\n\t\treturn;\n\t}\n\n\theader = (jbd2_journal_revoke_header_t *)descriptor->b_data;\n\theader->r_count = cpu_to_be32(offset);\n\tjbd2_revoke_csum_set(journal, descriptor);\n\n\tset_buffer_jwrite(descriptor);\n\tBUFFER_TRACE(descriptor, \"write\");\n\tset_buffer_dirty(descriptor);\n\twrite_dirty_buffer(descriptor, write_op);\n}"
  },
  {
    "function_name": "jbd2_revoke_csum_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
    "lines": "636-649",
    "snippet": "static void jbd2_revoke_csum_set(journal_t *j, struct buffer_head *bh)\n{\n\tstruct jbd2_journal_revoke_tail *tail;\n\t__u32 csum;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn;\n\n\ttail = (struct jbd2_journal_revoke_tail *)(bh->b_data + j->j_blocksize -\n\t\t\tsizeof(struct jbd2_journal_revoke_tail));\n\ttail->r_checksum = 0;\n\tcsum = jbd2_chksum(j, j->j_csum_seed, bh->b_data, j->j_blocksize);\n\ttail->r_checksum = cpu_to_be32(csum);\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "csum"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_chksum",
          "args": [
            "j",
            "j->j_csum_seed",
            "bh->b_data",
            "j->j_blocksize"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_has_csum_v2or3",
          "args": [
            "j"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic void jbd2_revoke_csum_set(journal_t *j, struct buffer_head *bh)\n{\n\tstruct jbd2_journal_revoke_tail *tail;\n\t__u32 csum;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn;\n\n\ttail = (struct jbd2_journal_revoke_tail *)(bh->b_data + j->j_blocksize -\n\t\t\tsizeof(struct jbd2_journal_revoke_tail));\n\ttail->r_checksum = 0;\n\tcsum = jbd2_chksum(j, j->j_csum_seed, bh->b_data, j->j_blocksize);\n\ttail->r_checksum = cpu_to_be32(csum);\n}"
  },
  {
    "function_name": "write_one_revoke_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
    "lines": "570-634",
    "snippet": "static void write_one_revoke_record(journal_t *journal,\n\t\t\t\t    transaction_t *transaction,\n\t\t\t\t    struct list_head *log_bufs,\n\t\t\t\t    struct buffer_head **descriptorp,\n\t\t\t\t    int *offsetp,\n\t\t\t\t    struct jbd2_revoke_record_s *record,\n\t\t\t\t    int write_op)\n{\n\tint csum_size = 0;\n\tstruct buffer_head *descriptor;\n\tint offset;\n\tjournal_header_t *header;\n\n\t/* If we are already aborting, this all becomes a noop.  We\n           still need to go round the loop in\n           jbd2_journal_write_revoke_records in order to free all of the\n           revoke records: only the IO to the journal is omitted. */\n\tif (is_journal_aborted(journal))\n\t\treturn;\n\n\tdescriptor = *descriptorp;\n\toffset = *offsetp;\n\n\t/* Do we need to leave space at the end for a checksum? */\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\tcsum_size = sizeof(struct jbd2_journal_revoke_tail);\n\n\t/* Make sure we have a descriptor with space left for the record */\n\tif (descriptor) {\n\t\tif (offset >= journal->j_blocksize - csum_size) {\n\t\t\tflush_descriptor(journal, descriptor, offset, write_op);\n\t\t\tdescriptor = NULL;\n\t\t}\n\t}\n\n\tif (!descriptor) {\n\t\tdescriptor = jbd2_journal_get_descriptor_buffer(journal);\n\t\tif (!descriptor)\n\t\t\treturn;\n\t\theader = (journal_header_t *)descriptor->b_data;\n\t\theader->h_magic     = cpu_to_be32(JBD2_MAGIC_NUMBER);\n\t\theader->h_blocktype = cpu_to_be32(JBD2_REVOKE_BLOCK);\n\t\theader->h_sequence  = cpu_to_be32(transaction->t_tid);\n\n\t\t/* Record it so that we can wait for IO completion later */\n\t\tBUFFER_TRACE(descriptor, \"file in log_bufs\");\n\t\tjbd2_file_log_bh(log_bufs, descriptor);\n\n\t\toffset = sizeof(jbd2_journal_revoke_header_t);\n\t\t*descriptorp = descriptor;\n\t}\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\t* ((__be64 *)(&descriptor->b_data[offset])) =\n\t\t\tcpu_to_be64(record->blocknr);\n\t\toffset += 8;\n\n\t} else {\n\t\t* ((__be32 *)(&descriptor->b_data[offset])) =\n\t\t\tcpu_to_be32(record->blocknr);\n\t\toffset += 4;\n\t}\n\n\t*offsetp = offset;\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "record->blocknr"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "record->blocknr"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBD2_HAS_INCOMPAT_FEATURE",
          "args": [
            "journal",
            "JBD2_FEATURE_INCOMPAT_64BIT"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_file_log_bh",
          "args": [
            "log_bufs",
            "descriptor"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "descriptor",
            "\"file in log_bufs\""
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "transaction->t_tid"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JBD2_REVOKE_BLOCK"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JBD2_MAGIC_NUMBER"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_get_descriptor_buffer",
          "args": [
            "journal"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_get_descriptor_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "817-837",
          "snippet": "struct buffer_head *jbd2_journal_get_descriptor_buffer(journal_t *journal)\n{\n\tstruct buffer_head *bh;\n\tunsigned long long blocknr;\n\tint err;\n\n\terr = jbd2_journal_next_log_block(journal, &blocknr);\n\n\tif (err)\n\t\treturn NULL;\n\n\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh)\n\t\treturn NULL;\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, journal->j_blocksize);\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\tBUFFER_TRACE(bh, \"return this buffer\");\n\treturn bh;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstruct buffer_head *jbd2_journal_get_descriptor_buffer(journal_t *journal)\n{\n\tstruct buffer_head *bh;\n\tunsigned long long blocknr;\n\tint err;\n\n\terr = jbd2_journal_next_log_block(journal, &blocknr);\n\n\tif (err)\n\t\treturn NULL;\n\n\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh)\n\t\treturn NULL;\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, journal->j_blocksize);\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\tBUFFER_TRACE(bh, \"return this buffer\");\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_descriptor",
          "args": [
            "journal",
            "descriptor",
            "offset",
            "write_op"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "flush_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "658-677",
          "snippet": "static void flush_descriptor(journal_t *journal,\n\t\t\t     struct buffer_head *descriptor,\n\t\t\t     int offset, int write_op)\n{\n\tjbd2_journal_revoke_header_t *header;\n\n\tif (is_journal_aborted(journal)) {\n\t\tput_bh(descriptor);\n\t\treturn;\n\t}\n\n\theader = (jbd2_journal_revoke_header_t *)descriptor->b_data;\n\theader->r_count = cpu_to_be32(offset);\n\tjbd2_revoke_csum_set(journal, descriptor);\n\n\tset_buffer_jwrite(descriptor);\n\tBUFFER_TRACE(descriptor, \"write\");\n\tset_buffer_dirty(descriptor);\n\twrite_dirty_buffer(descriptor, write_op);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic void flush_descriptor(journal_t *journal,\n\t\t\t     struct buffer_head *descriptor,\n\t\t\t     int offset, int write_op)\n{\n\tjbd2_journal_revoke_header_t *header;\n\n\tif (is_journal_aborted(journal)) {\n\t\tput_bh(descriptor);\n\t\treturn;\n\t}\n\n\theader = (jbd2_journal_revoke_header_t *)descriptor->b_data;\n\theader->r_count = cpu_to_be32(offset);\n\tjbd2_revoke_csum_set(journal, descriptor);\n\n\tset_buffer_jwrite(descriptor);\n\tBUFFER_TRACE(descriptor, \"write\");\n\tset_buffer_dirty(descriptor);\n\twrite_dirty_buffer(descriptor, write_op);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_has_csum_v2or3",
          "args": [
            "journal"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_journal_aborted",
          "args": [
            "journal"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_is_journal_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "760-764",
          "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic void write_one_revoke_record(journal_t *journal,\n\t\t\t\t    transaction_t *transaction,\n\t\t\t\t    struct list_head *log_bufs,\n\t\t\t\t    struct buffer_head **descriptorp,\n\t\t\t\t    int *offsetp,\n\t\t\t\t    struct jbd2_revoke_record_s *record,\n\t\t\t\t    int write_op)\n{\n\tint csum_size = 0;\n\tstruct buffer_head *descriptor;\n\tint offset;\n\tjournal_header_t *header;\n\n\t/* If we are already aborting, this all becomes a noop.  We\n           still need to go round the loop in\n           jbd2_journal_write_revoke_records in order to free all of the\n           revoke records: only the IO to the journal is omitted. */\n\tif (is_journal_aborted(journal))\n\t\treturn;\n\n\tdescriptor = *descriptorp;\n\toffset = *offsetp;\n\n\t/* Do we need to leave space at the end for a checksum? */\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\tcsum_size = sizeof(struct jbd2_journal_revoke_tail);\n\n\t/* Make sure we have a descriptor with space left for the record */\n\tif (descriptor) {\n\t\tif (offset >= journal->j_blocksize - csum_size) {\n\t\t\tflush_descriptor(journal, descriptor, offset, write_op);\n\t\t\tdescriptor = NULL;\n\t\t}\n\t}\n\n\tif (!descriptor) {\n\t\tdescriptor = jbd2_journal_get_descriptor_buffer(journal);\n\t\tif (!descriptor)\n\t\t\treturn;\n\t\theader = (journal_header_t *)descriptor->b_data;\n\t\theader->h_magic     = cpu_to_be32(JBD2_MAGIC_NUMBER);\n\t\theader->h_blocktype = cpu_to_be32(JBD2_REVOKE_BLOCK);\n\t\theader->h_sequence  = cpu_to_be32(transaction->t_tid);\n\n\t\t/* Record it so that we can wait for IO completion later */\n\t\tBUFFER_TRACE(descriptor, \"file in log_bufs\");\n\t\tjbd2_file_log_bh(log_bufs, descriptor);\n\n\t\toffset = sizeof(jbd2_journal_revoke_header_t);\n\t\t*descriptorp = descriptor;\n\t}\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\t* ((__be64 *)(&descriptor->b_data[offset])) =\n\t\t\tcpu_to_be64(record->blocknr);\n\t\toffset += 8;\n\n\t} else {\n\t\t* ((__be32 *)(&descriptor->b_data[offset])) =\n\t\t\tcpu_to_be32(record->blocknr);\n\t\toffset += 4;\n\t}\n\n\t*offsetp = offset;\n}"
  },
  {
    "function_name": "jbd2_journal_write_revoke_records",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
    "lines": "527-563",
    "snippet": "void jbd2_journal_write_revoke_records(journal_t *journal,\n\t\t\t\t       transaction_t *transaction,\n\t\t\t\t       struct list_head *log_bufs,\n\t\t\t\t       int write_op)\n{\n\tstruct buffer_head *descriptor;\n\tstruct jbd2_revoke_record_s *record;\n\tstruct jbd2_revoke_table_s *revoke;\n\tstruct list_head *hash_list;\n\tint i, offset, count;\n\n\tdescriptor = NULL;\n\toffset = 0;\n\tcount = 0;\n\n\t/* select revoke table for committing transaction */\n\trevoke = journal->j_revoke == journal->j_revoke_table[0] ?\n\t\tjournal->j_revoke_table[1] : journal->j_revoke_table[0];\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\thash_list = &revoke->hash_table[i];\n\n\t\twhile (!list_empty(hash_list)) {\n\t\t\trecord = (struct jbd2_revoke_record_s *)\n\t\t\t\thash_list->next;\n\t\t\twrite_one_revoke_record(journal, transaction, log_bufs,\n\t\t\t\t\t\t&descriptor, &offset,\n\t\t\t\t\t\trecord, write_op);\n\t\t\tcount++;\n\t\t\tlist_del(&record->hash);\n\t\t\tkmem_cache_free(jbd2_revoke_record_cache, record);\n\t\t}\n\t}\n\tif (descriptor)\n\t\tflush_descriptor(journal, descriptor, offset, write_op);\n\tjbd_debug(1, \"Wrote %d revoke records\\n\", count);\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *jbd2_revoke_record_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"Wrote %d revoke records\\n\"",
            "count"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_descriptor",
          "args": [
            "journal",
            "descriptor",
            "offset",
            "write_op"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "flush_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "658-677",
          "snippet": "static void flush_descriptor(journal_t *journal,\n\t\t\t     struct buffer_head *descriptor,\n\t\t\t     int offset, int write_op)\n{\n\tjbd2_journal_revoke_header_t *header;\n\n\tif (is_journal_aborted(journal)) {\n\t\tput_bh(descriptor);\n\t\treturn;\n\t}\n\n\theader = (jbd2_journal_revoke_header_t *)descriptor->b_data;\n\theader->r_count = cpu_to_be32(offset);\n\tjbd2_revoke_csum_set(journal, descriptor);\n\n\tset_buffer_jwrite(descriptor);\n\tBUFFER_TRACE(descriptor, \"write\");\n\tset_buffer_dirty(descriptor);\n\twrite_dirty_buffer(descriptor, write_op);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic void flush_descriptor(journal_t *journal,\n\t\t\t     struct buffer_head *descriptor,\n\t\t\t     int offset, int write_op)\n{\n\tjbd2_journal_revoke_header_t *header;\n\n\tif (is_journal_aborted(journal)) {\n\t\tput_bh(descriptor);\n\t\treturn;\n\t}\n\n\theader = (jbd2_journal_revoke_header_t *)descriptor->b_data;\n\theader->r_count = cpu_to_be32(offset);\n\tjbd2_revoke_csum_set(journal, descriptor);\n\n\tset_buffer_jwrite(descriptor);\n\tBUFFER_TRACE(descriptor, \"write\");\n\tset_buffer_dirty(descriptor);\n\twrite_dirty_buffer(descriptor, write_op);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "jbd2_revoke_record_cache",
            "record"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&record->hash"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_one_revoke_record",
          "args": [
            "journal",
            "transaction",
            "log_bufs",
            "&descriptor",
            "&offset",
            "record",
            "write_op"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "write_one_revoke_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "570-634",
          "snippet": "static void write_one_revoke_record(journal_t *journal,\n\t\t\t\t    transaction_t *transaction,\n\t\t\t\t    struct list_head *log_bufs,\n\t\t\t\t    struct buffer_head **descriptorp,\n\t\t\t\t    int *offsetp,\n\t\t\t\t    struct jbd2_revoke_record_s *record,\n\t\t\t\t    int write_op)\n{\n\tint csum_size = 0;\n\tstruct buffer_head *descriptor;\n\tint offset;\n\tjournal_header_t *header;\n\n\t/* If we are already aborting, this all becomes a noop.  We\n           still need to go round the loop in\n           jbd2_journal_write_revoke_records in order to free all of the\n           revoke records: only the IO to the journal is omitted. */\n\tif (is_journal_aborted(journal))\n\t\treturn;\n\n\tdescriptor = *descriptorp;\n\toffset = *offsetp;\n\n\t/* Do we need to leave space at the end for a checksum? */\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\tcsum_size = sizeof(struct jbd2_journal_revoke_tail);\n\n\t/* Make sure we have a descriptor with space left for the record */\n\tif (descriptor) {\n\t\tif (offset >= journal->j_blocksize - csum_size) {\n\t\t\tflush_descriptor(journal, descriptor, offset, write_op);\n\t\t\tdescriptor = NULL;\n\t\t}\n\t}\n\n\tif (!descriptor) {\n\t\tdescriptor = jbd2_journal_get_descriptor_buffer(journal);\n\t\tif (!descriptor)\n\t\t\treturn;\n\t\theader = (journal_header_t *)descriptor->b_data;\n\t\theader->h_magic     = cpu_to_be32(JBD2_MAGIC_NUMBER);\n\t\theader->h_blocktype = cpu_to_be32(JBD2_REVOKE_BLOCK);\n\t\theader->h_sequence  = cpu_to_be32(transaction->t_tid);\n\n\t\t/* Record it so that we can wait for IO completion later */\n\t\tBUFFER_TRACE(descriptor, \"file in log_bufs\");\n\t\tjbd2_file_log_bh(log_bufs, descriptor);\n\n\t\toffset = sizeof(jbd2_journal_revoke_header_t);\n\t\t*descriptorp = descriptor;\n\t}\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\t* ((__be64 *)(&descriptor->b_data[offset])) =\n\t\t\tcpu_to_be64(record->blocknr);\n\t\toffset += 8;\n\n\t} else {\n\t\t* ((__be32 *)(&descriptor->b_data[offset])) =\n\t\t\tcpu_to_be32(record->blocknr);\n\t\toffset += 4;\n\t}\n\n\t*offsetp = offset;\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic void write_one_revoke_record(journal_t *journal,\n\t\t\t\t    transaction_t *transaction,\n\t\t\t\t    struct list_head *log_bufs,\n\t\t\t\t    struct buffer_head **descriptorp,\n\t\t\t\t    int *offsetp,\n\t\t\t\t    struct jbd2_revoke_record_s *record,\n\t\t\t\t    int write_op)\n{\n\tint csum_size = 0;\n\tstruct buffer_head *descriptor;\n\tint offset;\n\tjournal_header_t *header;\n\n\t/* If we are already aborting, this all becomes a noop.  We\n           still need to go round the loop in\n           jbd2_journal_write_revoke_records in order to free all of the\n           revoke records: only the IO to the journal is omitted. */\n\tif (is_journal_aborted(journal))\n\t\treturn;\n\n\tdescriptor = *descriptorp;\n\toffset = *offsetp;\n\n\t/* Do we need to leave space at the end for a checksum? */\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\tcsum_size = sizeof(struct jbd2_journal_revoke_tail);\n\n\t/* Make sure we have a descriptor with space left for the record */\n\tif (descriptor) {\n\t\tif (offset >= journal->j_blocksize - csum_size) {\n\t\t\tflush_descriptor(journal, descriptor, offset, write_op);\n\t\t\tdescriptor = NULL;\n\t\t}\n\t}\n\n\tif (!descriptor) {\n\t\tdescriptor = jbd2_journal_get_descriptor_buffer(journal);\n\t\tif (!descriptor)\n\t\t\treturn;\n\t\theader = (journal_header_t *)descriptor->b_data;\n\t\theader->h_magic     = cpu_to_be32(JBD2_MAGIC_NUMBER);\n\t\theader->h_blocktype = cpu_to_be32(JBD2_REVOKE_BLOCK);\n\t\theader->h_sequence  = cpu_to_be32(transaction->t_tid);\n\n\t\t/* Record it so that we can wait for IO completion later */\n\t\tBUFFER_TRACE(descriptor, \"file in log_bufs\");\n\t\tjbd2_file_log_bh(log_bufs, descriptor);\n\n\t\toffset = sizeof(jbd2_journal_revoke_header_t);\n\t\t*descriptorp = descriptor;\n\t}\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\t* ((__be64 *)(&descriptor->b_data[offset])) =\n\t\t\tcpu_to_be64(record->blocknr);\n\t\toffset += 8;\n\n\t} else {\n\t\t* ((__be32 *)(&descriptor->b_data[offset])) =\n\t\t\tcpu_to_be32(record->blocknr);\n\t\toffset += 4;\n\t}\n\n\t*offsetp = offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "hash_list"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *jbd2_revoke_record_cache;\n\nvoid jbd2_journal_write_revoke_records(journal_t *journal,\n\t\t\t\t       transaction_t *transaction,\n\t\t\t\t       struct list_head *log_bufs,\n\t\t\t\t       int write_op)\n{\n\tstruct buffer_head *descriptor;\n\tstruct jbd2_revoke_record_s *record;\n\tstruct jbd2_revoke_table_s *revoke;\n\tstruct list_head *hash_list;\n\tint i, offset, count;\n\n\tdescriptor = NULL;\n\toffset = 0;\n\tcount = 0;\n\n\t/* select revoke table for committing transaction */\n\trevoke = journal->j_revoke == journal->j_revoke_table[0] ?\n\t\tjournal->j_revoke_table[1] : journal->j_revoke_table[0];\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\thash_list = &revoke->hash_table[i];\n\n\t\twhile (!list_empty(hash_list)) {\n\t\t\trecord = (struct jbd2_revoke_record_s *)\n\t\t\t\thash_list->next;\n\t\t\twrite_one_revoke_record(journal, transaction, log_bufs,\n\t\t\t\t\t\t&descriptor, &offset,\n\t\t\t\t\t\trecord, write_op);\n\t\t\tcount++;\n\t\t\tlist_del(&record->hash);\n\t\t\tkmem_cache_free(jbd2_revoke_record_cache, record);\n\t\t}\n\t}\n\tif (descriptor)\n\t\tflush_descriptor(journal, descriptor, offset, write_op);\n\tjbd_debug(1, \"Wrote %d revoke records\\n\", count);\n}"
  },
  {
    "function_name": "jbd2_journal_switch_revoke_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
    "lines": "510-521",
    "snippet": "void jbd2_journal_switch_revoke_table(journal_t *journal)\n{\n\tint i;\n\n\tif (journal->j_revoke == journal->j_revoke_table[0])\n\t\tjournal->j_revoke = journal->j_revoke_table[1];\n\telse\n\t\tjournal->j_revoke = journal->j_revoke_table[0];\n\n\tfor (i = 0; i < journal->j_revoke->hash_size; i++)\n\t\tINIT_LIST_HEAD(&journal->j_revoke->hash_table[i]);\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&journal->j_revoke->hash_table[i]"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nvoid jbd2_journal_switch_revoke_table(journal_t *journal)\n{\n\tint i;\n\n\tif (journal->j_revoke == journal->j_revoke_table[0])\n\t\tjournal->j_revoke = journal->j_revoke_table[1];\n\telse\n\t\tjournal->j_revoke = journal->j_revoke_table[0];\n\n\tfor (i = 0; i < journal->j_revoke->hash_size; i++)\n\t\tINIT_LIST_HEAD(&journal->j_revoke->hash_table[i]);\n}"
  },
  {
    "function_name": "jbd2_clear_buffer_revoked_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
    "lines": "481-504",
    "snippet": "void jbd2_clear_buffer_revoked_flags(journal_t *journal)\n{\n\tstruct jbd2_revoke_table_s *revoke = journal->j_revoke;\n\tint i = 0;\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\tstruct list_head *hash_list;\n\t\tstruct list_head *list_entry;\n\t\thash_list = &revoke->hash_table[i];\n\n\t\tlist_for_each(list_entry, hash_list) {\n\t\t\tstruct jbd2_revoke_record_s *record;\n\t\t\tstruct buffer_head *bh;\n\t\t\trecord = (struct jbd2_revoke_record_s *)list_entry;\n\t\t\tbh = __find_get_block(journal->j_fs_dev,\n\t\t\t\t\t      record->blocknr,\n\t\t\t\t\t      journal->j_blocksize);\n\t\t\tif (bh) {\n\t\t\t\tclear_buffer_revoked(bh);\n\t\t\t\t__brelse(bh);\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__brelse",
          "args": [
            "bh"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_revoked",
          "args": [
            "bh"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_clear_buffer_revoked_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "481-504",
          "snippet": "void jbd2_clear_buffer_revoked_flags(journal_t *journal)\n{\n\tstruct jbd2_revoke_table_s *revoke = journal->j_revoke;\n\tint i = 0;\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\tstruct list_head *hash_list;\n\t\tstruct list_head *list_entry;\n\t\thash_list = &revoke->hash_table[i];\n\n\t\tlist_for_each(list_entry, hash_list) {\n\t\t\tstruct jbd2_revoke_record_s *record;\n\t\t\tstruct buffer_head *bh;\n\t\t\trecord = (struct jbd2_revoke_record_s *)list_entry;\n\t\t\tbh = __find_get_block(journal->j_fs_dev,\n\t\t\t\t\t      record->blocknr,\n\t\t\t\t\t      journal->j_blocksize);\n\t\t\tif (bh) {\n\t\t\t\tclear_buffer_revoked(bh);\n\t\t\t\t__brelse(bh);\n\t\t\t}\n\t\t}\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "__find_get_block",
          "args": [
            "journal->j_fs_dev",
            "record->blocknr",
            "journal->j_blocksize"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "__find_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1340-1354",
          "snippet": "struct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstruct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "list_entry",
            "hash_list"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nvoid jbd2_clear_buffer_revoked_flags(journal_t *journal)\n{\n\tstruct jbd2_revoke_table_s *revoke = journal->j_revoke;\n\tint i = 0;\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\tstruct list_head *hash_list;\n\t\tstruct list_head *list_entry;\n\t\thash_list = &revoke->hash_table[i];\n\n\t\tlist_for_each(list_entry, hash_list) {\n\t\t\tstruct jbd2_revoke_record_s *record;\n\t\t\tstruct buffer_head *bh;\n\t\t\trecord = (struct jbd2_revoke_record_s *)list_entry;\n\t\t\tbh = __find_get_block(journal->j_fs_dev,\n\t\t\t\t\t      record->blocknr,\n\t\t\t\t\t      journal->j_blocksize);\n\t\t\tif (bh) {\n\t\t\t\tclear_buffer_revoked(bh);\n\t\t\t\t__brelse(bh);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "jbd2_journal_cancel_revoke",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
    "lines": "420-474",
    "snippet": "int jbd2_journal_cancel_revoke(handle_t *handle, struct journal_head *jh)\n{\n\tstruct jbd2_revoke_record_s *record;\n\tjournal_t *journal = handle->h_transaction->t_journal;\n\tint need_cancel;\n\tint did_revoke = 0;\t/* akpm: debug */\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_debug(4, \"journal_head %p, cancelling revoke\\n\", jh);\n\n\t/* Is the existing Revoke bit valid?  If so, we trust it, and\n\t * only perform the full cancel if the revoke bit is set.  If\n\t * not, we can't trust the revoke bit, and we need to do the\n\t * full search for a revoke record. */\n\tif (test_set_buffer_revokevalid(bh)) {\n\t\tneed_cancel = test_clear_buffer_revoked(bh);\n\t} else {\n\t\tneed_cancel = 1;\n\t\tclear_buffer_revoked(bh);\n\t}\n\n\tif (need_cancel) {\n\t\trecord = find_revoke_record(journal, bh->b_blocknr);\n\t\tif (record) {\n\t\t\tjbd_debug(4, \"cancelled existing revoke on \"\n\t\t\t\t  \"blocknr %llu\\n\", (unsigned long long)bh->b_blocknr);\n\t\t\tspin_lock(&journal->j_revoke_lock);\n\t\t\tlist_del(&record->hash);\n\t\t\tspin_unlock(&journal->j_revoke_lock);\n\t\t\tkmem_cache_free(jbd2_revoke_record_cache, record);\n\t\t\tdid_revoke = 1;\n\t\t}\n\t}\n\n#ifdef JBD2_EXPENSIVE_CHECKING\n\t/* There better not be one left behind by now! */\n\trecord = find_revoke_record(journal, bh->b_blocknr);\n\tJ_ASSERT_JH(jh, record == NULL);\n#endif\n\n\t/* Finally, have we just cleared revoke on an unhashed\n\t * buffer_head?  If so, we'd better make sure we clear the\n\t * revoked status on any hashed alias too, otherwise the revoke\n\t * state machine will get very upset later on. */\n\tif (need_cancel) {\n\t\tstruct buffer_head *bh2;\n\t\tbh2 = __find_get_block(bh->b_bdev, bh->b_blocknr, bh->b_size);\n\t\tif (bh2) {\n\t\t\tif (bh2 != bh)\n\t\t\t\tclear_buffer_revoked(bh2);\n\t\t\t__brelse(bh2);\n\t\t}\n\t}\n\treturn did_revoke;\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *jbd2_revoke_record_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__brelse",
          "args": [
            "bh2"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_revoked",
          "args": [
            "bh2"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_clear_buffer_revoked_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "481-504",
          "snippet": "void jbd2_clear_buffer_revoked_flags(journal_t *journal)\n{\n\tstruct jbd2_revoke_table_s *revoke = journal->j_revoke;\n\tint i = 0;\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\tstruct list_head *hash_list;\n\t\tstruct list_head *list_entry;\n\t\thash_list = &revoke->hash_table[i];\n\n\t\tlist_for_each(list_entry, hash_list) {\n\t\t\tstruct jbd2_revoke_record_s *record;\n\t\t\tstruct buffer_head *bh;\n\t\t\trecord = (struct jbd2_revoke_record_s *)list_entry;\n\t\t\tbh = __find_get_block(journal->j_fs_dev,\n\t\t\t\t\t      record->blocknr,\n\t\t\t\t\t      journal->j_blocksize);\n\t\t\tif (bh) {\n\t\t\t\tclear_buffer_revoked(bh);\n\t\t\t\t__brelse(bh);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nvoid jbd2_clear_buffer_revoked_flags(journal_t *journal)\n{\n\tstruct jbd2_revoke_table_s *revoke = journal->j_revoke;\n\tint i = 0;\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\tstruct list_head *hash_list;\n\t\tstruct list_head *list_entry;\n\t\thash_list = &revoke->hash_table[i];\n\n\t\tlist_for_each(list_entry, hash_list) {\n\t\t\tstruct jbd2_revoke_record_s *record;\n\t\t\tstruct buffer_head *bh;\n\t\t\trecord = (struct jbd2_revoke_record_s *)list_entry;\n\t\t\tbh = __find_get_block(journal->j_fs_dev,\n\t\t\t\t\t      record->blocknr,\n\t\t\t\t\t      journal->j_blocksize);\n\t\t\tif (bh) {\n\t\t\t\tclear_buffer_revoked(bh);\n\t\t\t\t__brelse(bh);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__find_get_block",
          "args": [
            "bh->b_bdev",
            "bh->b_blocknr",
            "bh->b_size"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "__find_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1340-1354",
          "snippet": "struct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstruct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "record == NULL"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_revoke_record",
          "args": [
            "journal",
            "bh->b_blocknr"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "find_revoke_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "168-187",
          "snippet": "static struct jbd2_revoke_record_s *find_revoke_record(journal_t *journal,\n\t\t\t\t\t\t      unsigned long long blocknr)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd2_revoke_record_s *record;\n\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\n\tspin_lock(&journal->j_revoke_lock);\n\trecord = (struct jbd2_revoke_record_s *) hash_list->next;\n\twhile (&(record->hash) != hash_list) {\n\t\tif (record->blocknr == blocknr) {\n\t\t\tspin_unlock(&journal->j_revoke_lock);\n\t\t\treturn record;\n\t\t}\n\t\trecord = (struct jbd2_revoke_record_s *) record->hash.next;\n\t}\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct jbd2_revoke_record_s *find_revoke_record(journal_t *journal,\n\t\t\t\t\t\t      unsigned long long blocknr)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd2_revoke_record_s *record;\n\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\n\tspin_lock(&journal->j_revoke_lock);\n\trecord = (struct jbd2_revoke_record_s *) hash_list->next;\n\twhile (&(record->hash) != hash_list) {\n\t\tif (record->blocknr == blocknr) {\n\t\t\tspin_unlock(&journal->j_revoke_lock);\n\t\t\treturn record;\n\t\t}\n\t\trecord = (struct jbd2_revoke_record_s *) record->hash.next;\n\t}\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "jbd2_revoke_record_cache",
            "record"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_revoke_lock"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&record->hash"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_revoke_lock"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "4",
            "\"cancelled existing revoke on \"\n\t\t\t\t  \"blocknr %llu\\n\"",
            "(unsigned long long)bh->b_blocknr"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_clear_buffer_revoked",
          "args": [
            "bh"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_set_buffer_revokevalid",
          "args": [
            "bh"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "4",
            "\"journal_head %p, cancelling revoke\\n\"",
            "jh"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *jbd2_revoke_record_cache;\n\nint jbd2_journal_cancel_revoke(handle_t *handle, struct journal_head *jh)\n{\n\tstruct jbd2_revoke_record_s *record;\n\tjournal_t *journal = handle->h_transaction->t_journal;\n\tint need_cancel;\n\tint did_revoke = 0;\t/* akpm: debug */\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_debug(4, \"journal_head %p, cancelling revoke\\n\", jh);\n\n\t/* Is the existing Revoke bit valid?  If so, we trust it, and\n\t * only perform the full cancel if the revoke bit is set.  If\n\t * not, we can't trust the revoke bit, and we need to do the\n\t * full search for a revoke record. */\n\tif (test_set_buffer_revokevalid(bh)) {\n\t\tneed_cancel = test_clear_buffer_revoked(bh);\n\t} else {\n\t\tneed_cancel = 1;\n\t\tclear_buffer_revoked(bh);\n\t}\n\n\tif (need_cancel) {\n\t\trecord = find_revoke_record(journal, bh->b_blocknr);\n\t\tif (record) {\n\t\t\tjbd_debug(4, \"cancelled existing revoke on \"\n\t\t\t\t  \"blocknr %llu\\n\", (unsigned long long)bh->b_blocknr);\n\t\t\tspin_lock(&journal->j_revoke_lock);\n\t\t\tlist_del(&record->hash);\n\t\t\tspin_unlock(&journal->j_revoke_lock);\n\t\t\tkmem_cache_free(jbd2_revoke_record_cache, record);\n\t\t\tdid_revoke = 1;\n\t\t}\n\t}\n\n#ifdef JBD2_EXPENSIVE_CHECKING\n\t/* There better not be one left behind by now! */\n\trecord = find_revoke_record(journal, bh->b_blocknr);\n\tJ_ASSERT_JH(jh, record == NULL);\n#endif\n\n\t/* Finally, have we just cleared revoke on an unhashed\n\t * buffer_head?  If so, we'd better make sure we clear the\n\t * revoked status on any hashed alias too, otherwise the revoke\n\t * state machine will get very upset later on. */\n\tif (need_cancel) {\n\t\tstruct buffer_head *bh2;\n\t\tbh2 = __find_get_block(bh->b_bdev, bh->b_blocknr, bh->b_size);\n\t\tif (bh2) {\n\t\t\tif (bh2 != bh)\n\t\t\t\tclear_buffer_revoked(bh2);\n\t\t\t__brelse(bh2);\n\t\t}\n\t}\n\treturn did_revoke;\n}"
  },
  {
    "function_name": "jbd2_journal_revoke",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
    "lines": "329-403",
    "snippet": "int jbd2_journal_revoke(handle_t *handle, unsigned long long blocknr,\n\t\t   struct buffer_head *bh_in)\n{\n\tstruct buffer_head *bh = NULL;\n\tjournal_t *journal;\n\tstruct block_device *bdev;\n\tint err;\n\n\tmight_sleep();\n\tif (bh_in)\n\t\tBUFFER_TRACE(bh_in, \"enter\");\n\n\tjournal = handle->h_transaction->t_journal;\n\tif (!jbd2_journal_set_features(journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)){\n\t\tJ_ASSERT (!\"Cannot set revoke feature!\");\n\t\treturn -EINVAL;\n\t}\n\n\tbdev = journal->j_fs_dev;\n\tbh = bh_in;\n\n\tif (!bh) {\n\t\tbh = __find_get_block(bdev, blocknr, journal->j_blocksize);\n\t\tif (bh)\n\t\t\tBUFFER_TRACE(bh, \"found on hash\");\n\t}\n#ifdef JBD2_EXPENSIVE_CHECKING\n\telse {\n\t\tstruct buffer_head *bh2;\n\n\t\t/* If there is a different buffer_head lying around in\n\t\t * memory anywhere... */\n\t\tbh2 = __find_get_block(bdev, blocknr, journal->j_blocksize);\n\t\tif (bh2) {\n\t\t\t/* ... and it has RevokeValid status... */\n\t\t\tif (bh2 != bh && buffer_revokevalid(bh2))\n\t\t\t\t/* ...then it better be revoked too,\n\t\t\t\t * since it's illegal to create a revoke\n\t\t\t\t * record against a buffer_head which is\n\t\t\t\t * not marked revoked --- that would\n\t\t\t\t * risk missing a subsequent revoke\n\t\t\t\t * cancel. */\n\t\t\t\tJ_ASSERT_BH(bh2, buffer_revoked(bh2));\n\t\t\tput_bh(bh2);\n\t\t}\n\t}\n#endif\n\n\t/* We really ought not ever to revoke twice in a row without\n           first having the revoke cancelled: it's illegal to free a\n           block twice without allocating it in between! */\n\tif (bh) {\n\t\tif (!J_EXPECT_BH(bh, !buffer_revoked(bh),\n\t\t\t\t \"inconsistent data on disk\")) {\n\t\t\tif (!bh_in)\n\t\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t\tset_buffer_revoked(bh);\n\t\tset_buffer_revokevalid(bh);\n\t\tif (bh_in) {\n\t\t\tBUFFER_TRACE(bh_in, \"call jbd2_journal_forget\");\n\t\t\tjbd2_journal_forget(handle, bh_in);\n\t\t} else {\n\t\t\tBUFFER_TRACE(bh, \"call brelse\");\n\t\t\t__brelse(bh);\n\t\t}\n\t}\n\n\tjbd_debug(2, \"insert revoke for block %llu, bh_in=%p\\n\",blocknr, bh_in);\n\terr = insert_revoke_hash(journal, blocknr,\n\t\t\t\thandle->h_transaction->t_tid);\n\tBUFFER_TRACE(bh_in, \"exit\");\n\treturn err;\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh_in",
            "\"exit\""
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insert_revoke_hash",
          "args": [
            "journal",
            "blocknr",
            "handle->h_transaction->t_tid"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "insert_revoke_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "139-164",
          "snippet": "static int insert_revoke_hash(journal_t *journal, unsigned long long blocknr,\n\t\t\t      tid_t seq)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd2_revoke_record_s *record;\n\nrepeat:\n\trecord = kmem_cache_alloc(jbd2_revoke_record_cache, GFP_NOFS);\n\tif (!record)\n\t\tgoto oom;\n\n\trecord->sequence = seq;\n\trecord->blocknr = blocknr;\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\tspin_lock(&journal->j_revoke_lock);\n\tlist_add(&record->hash, hash_list);\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn 0;\n\noom:\n\tif (!journal_oom_retry)\n\t\treturn -ENOMEM;\n\tjbd_debug(1, \"ENOMEM in %s, retrying\\n\", __func__);\n\tyield();\n\tgoto repeat;\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *jbd2_revoke_record_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *jbd2_revoke_record_cache;\n\nstatic int insert_revoke_hash(journal_t *journal, unsigned long long blocknr,\n\t\t\t      tid_t seq)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd2_revoke_record_s *record;\n\nrepeat:\n\trecord = kmem_cache_alloc(jbd2_revoke_record_cache, GFP_NOFS);\n\tif (!record)\n\t\tgoto oom;\n\n\trecord->sequence = seq;\n\trecord->blocknr = blocknr;\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\tspin_lock(&journal->j_revoke_lock);\n\tlist_add(&record->hash, hash_list);\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn 0;\n\noom:\n\tif (!journal_oom_retry)\n\t\treturn -ENOMEM;\n\tjbd_debug(1, \"ENOMEM in %s, retrying\\n\", __func__);\n\tyield();\n\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "2",
            "\"insert revoke for block %llu, bh_in=%p\\n\"",
            "blocknr",
            "bh_in"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__brelse",
          "args": [
            "bh"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"call brelse\""
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_forget",
          "args": [
            "handle",
            "bh_in"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "1391-1507",
          "snippet": "int jbd2_journal_forget (handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tstruct journal_head *jh;\n\tint drop_reserve = 0;\n\tint err = 0;\n\tint was_modified = 0;\n\n\tWARN_ON(!transaction);\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tjournal = transaction->t_journal;\n\n\tBUFFER_TRACE(bh, \"entry\");\n\n\tjbd_lock_bh_state(bh);\n\n\tif (!buffer_jbd(bh))\n\t\tgoto not_jbd;\n\tjh = bh2jh(bh);\n\n\t/* Critical error: attempting to delete a bitmap buffer, maybe?\n\t * Don't do any jbd operations, and return an error. */\n\tif (!J_EXPECT_JH(jh, !jh->b_committed_data,\n\t\t\t \"inconsistent data on disk\")) {\n\t\terr = -EIO;\n\t\tgoto not_jbd;\n\t}\n\n\t/* keep track of whether or not this transaction modified us */\n\twas_modified = jh->b_modified;\n\n\t/*\n\t * The buffer's going from the transaction, we must drop\n\t * all references -bzzz\n\t */\n\tjh->b_modified = 0;\n\n\tif (jh->b_transaction == transaction) {\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\n\t\t/* If we are forgetting a buffer which is already part\n\t\t * of this transaction, then we can just drop it from\n\t\t * the transaction immediately. */\n\t\tclear_buffer_dirty(bh);\n\t\tclear_buffer_jbddirty(bh);\n\n\t\tJBUFFER_TRACE(jh, \"belongs to current transaction: unfile\");\n\n\t\t/*\n\t\t * we only want to drop a reference if this transaction\n\t\t * modified the buffer\n\t\t */\n\t\tif (was_modified)\n\t\t\tdrop_reserve = 1;\n\n\t\t/*\n\t\t * We are no longer going to journal this buffer.\n\t\t * However, the commit of this transaction is still\n\t\t * important to the buffer: the delete that we are now\n\t\t * processing might obsolete an old log entry, so by\n\t\t * committing, we can satisfy the buffer's checkpoint.\n\t\t *\n\t\t * So, if we have a checkpoint on the buffer, we should\n\t\t * now refile the buffer on our BJ_Forget list so that\n\t\t * we know to remove the checkpoint after we commit.\n\t\t */\n\n\t\tspin_lock(&journal->j_list_lock);\n\t\tif (jh->b_cp_transaction) {\n\t\t\t__jbd2_journal_temp_unlink_buffer(jh);\n\t\t\t__jbd2_journal_file_buffer(jh, transaction, BJ_Forget);\n\t\t} else {\n\t\t\t__jbd2_journal_unfile_buffer(jh);\n\t\t\tif (!buffer_jbd(bh)) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tjbd_unlock_bh_state(bh);\n\t\t\t\t__bforget(bh);\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&journal->j_list_lock);\n\t} else if (jh->b_transaction) {\n\t\tJ_ASSERT_JH(jh, (jh->b_transaction ==\n\t\t\t\t journal->j_committing_transaction));\n\t\t/* However, if the buffer is still owned by a prior\n\t\t * (committing) transaction, we can't drop it yet... */\n\t\tJBUFFER_TRACE(jh, \"belongs to older transaction\");\n\t\t/* ... but we CAN drop it from the new transaction if we\n\t\t * have also modified it since the original commit. */\n\n\t\tif (jh->b_next_transaction) {\n\t\t\tJ_ASSERT(jh->b_next_transaction == transaction);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tjh->b_next_transaction = NULL;\n\t\t\tspin_unlock(&journal->j_list_lock);\n\n\t\t\t/*\n\t\t\t * only drop a reference if this transaction modified\n\t\t\t * the buffer\n\t\t\t */\n\t\t\tif (was_modified)\n\t\t\t\tdrop_reserve = 1;\n\t\t}\n\t}\n\nnot_jbd:\n\tjbd_unlock_bh_state(bh);\n\t__brelse(bh);\ndrop:\n\tif (drop_reserve) {\n\t\t/* no need to reserve log space for this block -bzzz */\n\t\thandle->h_buffer_credits++;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);",
            "static void __jbd2_journal_unfile_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);\nstatic void __jbd2_journal_unfile_buffer(struct journal_head *jh);\n\nint jbd2_journal_forget (handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tstruct journal_head *jh;\n\tint drop_reserve = 0;\n\tint err = 0;\n\tint was_modified = 0;\n\n\tWARN_ON(!transaction);\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tjournal = transaction->t_journal;\n\n\tBUFFER_TRACE(bh, \"entry\");\n\n\tjbd_lock_bh_state(bh);\n\n\tif (!buffer_jbd(bh))\n\t\tgoto not_jbd;\n\tjh = bh2jh(bh);\n\n\t/* Critical error: attempting to delete a bitmap buffer, maybe?\n\t * Don't do any jbd operations, and return an error. */\n\tif (!J_EXPECT_JH(jh, !jh->b_committed_data,\n\t\t\t \"inconsistent data on disk\")) {\n\t\terr = -EIO;\n\t\tgoto not_jbd;\n\t}\n\n\t/* keep track of whether or not this transaction modified us */\n\twas_modified = jh->b_modified;\n\n\t/*\n\t * The buffer's going from the transaction, we must drop\n\t * all references -bzzz\n\t */\n\tjh->b_modified = 0;\n\n\tif (jh->b_transaction == transaction) {\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\n\t\t/* If we are forgetting a buffer which is already part\n\t\t * of this transaction, then we can just drop it from\n\t\t * the transaction immediately. */\n\t\tclear_buffer_dirty(bh);\n\t\tclear_buffer_jbddirty(bh);\n\n\t\tJBUFFER_TRACE(jh, \"belongs to current transaction: unfile\");\n\n\t\t/*\n\t\t * we only want to drop a reference if this transaction\n\t\t * modified the buffer\n\t\t */\n\t\tif (was_modified)\n\t\t\tdrop_reserve = 1;\n\n\t\t/*\n\t\t * We are no longer going to journal this buffer.\n\t\t * However, the commit of this transaction is still\n\t\t * important to the buffer: the delete that we are now\n\t\t * processing might obsolete an old log entry, so by\n\t\t * committing, we can satisfy the buffer's checkpoint.\n\t\t *\n\t\t * So, if we have a checkpoint on the buffer, we should\n\t\t * now refile the buffer on our BJ_Forget list so that\n\t\t * we know to remove the checkpoint after we commit.\n\t\t */\n\n\t\tspin_lock(&journal->j_list_lock);\n\t\tif (jh->b_cp_transaction) {\n\t\t\t__jbd2_journal_temp_unlink_buffer(jh);\n\t\t\t__jbd2_journal_file_buffer(jh, transaction, BJ_Forget);\n\t\t} else {\n\t\t\t__jbd2_journal_unfile_buffer(jh);\n\t\t\tif (!buffer_jbd(bh)) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tjbd_unlock_bh_state(bh);\n\t\t\t\t__bforget(bh);\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&journal->j_list_lock);\n\t} else if (jh->b_transaction) {\n\t\tJ_ASSERT_JH(jh, (jh->b_transaction ==\n\t\t\t\t journal->j_committing_transaction));\n\t\t/* However, if the buffer is still owned by a prior\n\t\t * (committing) transaction, we can't drop it yet... */\n\t\tJBUFFER_TRACE(jh, \"belongs to older transaction\");\n\t\t/* ... but we CAN drop it from the new transaction if we\n\t\t * have also modified it since the original commit. */\n\n\t\tif (jh->b_next_transaction) {\n\t\t\tJ_ASSERT(jh->b_next_transaction == transaction);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tjh->b_next_transaction = NULL;\n\t\t\tspin_unlock(&journal->j_list_lock);\n\n\t\t\t/*\n\t\t\t * only drop a reference if this transaction modified\n\t\t\t * the buffer\n\t\t\t */\n\t\t\tif (was_modified)\n\t\t\t\tdrop_reserve = 1;\n\t\t}\n\t}\n\nnot_jbd:\n\tjbd_unlock_bh_state(bh);\n\t__brelse(bh);\ndrop:\n\tif (drop_reserve) {\n\t\t/* no need to reserve log space for this block -bzzz */\n\t\thandle->h_buffer_credits++;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh_in",
            "\"call jbd2_journal_forget\""
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_revokevalid",
          "args": [
            "bh"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_revoked",
          "args": [
            "bh"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_EXPECT_BH",
          "args": [
            "bh",
            "!buffer_revoked(bh)",
            "\"inconsistent data on disk\""
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_revoked",
          "args": [
            "bh"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_clear_buffer_revoked_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "481-504",
          "snippet": "void jbd2_clear_buffer_revoked_flags(journal_t *journal)\n{\n\tstruct jbd2_revoke_table_s *revoke = journal->j_revoke;\n\tint i = 0;\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\tstruct list_head *hash_list;\n\t\tstruct list_head *list_entry;\n\t\thash_list = &revoke->hash_table[i];\n\n\t\tlist_for_each(list_entry, hash_list) {\n\t\t\tstruct jbd2_revoke_record_s *record;\n\t\t\tstruct buffer_head *bh;\n\t\t\trecord = (struct jbd2_revoke_record_s *)list_entry;\n\t\t\tbh = __find_get_block(journal->j_fs_dev,\n\t\t\t\t\t      record->blocknr,\n\t\t\t\t\t      journal->j_blocksize);\n\t\t\tif (bh) {\n\t\t\t\tclear_buffer_revoked(bh);\n\t\t\t\t__brelse(bh);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nvoid jbd2_clear_buffer_revoked_flags(journal_t *journal)\n{\n\tstruct jbd2_revoke_table_s *revoke = journal->j_revoke;\n\tint i = 0;\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\tstruct list_head *hash_list;\n\t\tstruct list_head *list_entry;\n\t\thash_list = &revoke->hash_table[i];\n\n\t\tlist_for_each(list_entry, hash_list) {\n\t\t\tstruct jbd2_revoke_record_s *record;\n\t\t\tstruct buffer_head *bh;\n\t\t\trecord = (struct jbd2_revoke_record_s *)list_entry;\n\t\t\tbh = __find_get_block(journal->j_fs_dev,\n\t\t\t\t\t      record->blocknr,\n\t\t\t\t\t      journal->j_blocksize);\n\t\t\tif (bh) {\n\t\t\t\tclear_buffer_revoked(bh);\n\t\t\t\t__brelse(bh);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh2"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_BH",
          "args": [
            "bh2",
            "buffer_revoked(bh2)"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_revokevalid",
          "args": [
            "bh2"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__find_get_block",
          "args": [
            "bdev",
            "blocknr",
            "journal->j_blocksize"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "__find_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1340-1354",
          "snippet": "struct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstruct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"found on hash\""
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "!\"Cannot set revoke feature!\""
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_set_features",
          "args": [
            "journal",
            "0",
            "0",
            "JBD2_FEATURE_INCOMPAT_REVOKE"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_set_features",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1808-1876",
          "snippet": "int jbd2_journal_set_features (journal_t *journal, unsigned long compat,\n\t\t\t  unsigned long ro, unsigned long incompat)\n{\n#define INCOMPAT_FEATURE_ON(f) \\\n\t\t((incompat & (f)) && !(sb->s_feature_incompat & cpu_to_be32(f)))\n#define COMPAT_FEATURE_ON(f) \\\n\t\t((compat & (f)) && !(sb->s_feature_compat & cpu_to_be32(f)))\n\tjournal_superblock_t *sb;\n\n\tif (jbd2_journal_check_used_features(journal, compat, ro, incompat))\n\t\treturn 1;\n\n\tif (!jbd2_journal_check_available_features(journal, compat, ro, incompat))\n\t\treturn 0;\n\n\t/* If enabling v2 checksums, turn on v3 instead */\n\tif (incompat & JBD2_FEATURE_INCOMPAT_CSUM_V2) {\n\t\tincompat &= ~JBD2_FEATURE_INCOMPAT_CSUM_V2;\n\t\tincompat |= JBD2_FEATURE_INCOMPAT_CSUM_V3;\n\t}\n\n\t/* Asking for checksumming v3 and v1?  Only give them v3. */\n\tif (incompat & JBD2_FEATURE_INCOMPAT_CSUM_V3 &&\n\t    compat & JBD2_FEATURE_COMPAT_CHECKSUM)\n\t\tcompat &= ~JBD2_FEATURE_COMPAT_CHECKSUM;\n\n\tjbd_debug(1, \"Setting new features 0x%lx/0x%lx/0x%lx\\n\",\n\t\t  compat, ro, incompat);\n\n\tsb = journal->j_superblock;\n\n\t/* If enabling v3 checksums, update superblock */\n\tif (INCOMPAT_FEATURE_ON(JBD2_FEATURE_INCOMPAT_CSUM_V3)) {\n\t\tsb->s_checksum_type = JBD2_CRC32C_CHKSUM;\n\t\tsb->s_feature_compat &=\n\t\t\t~cpu_to_be32(JBD2_FEATURE_COMPAT_CHECKSUM);\n\n\t\t/* Load the checksum driver */\n\t\tif (journal->j_chksum_driver == NULL) {\n\t\t\tjournal->j_chksum_driver = crypto_alloc_shash(\"crc32c\",\n\t\t\t\t\t\t\t\t      0, 0);\n\t\t\tif (IS_ERR(journal->j_chksum_driver)) {\n\t\t\t\tprintk(KERN_ERR \"JBD2: Cannot load crc32c \"\n\t\t\t\t       \"driver.\\n\");\n\t\t\t\tjournal->j_chksum_driver = NULL;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Precompute checksum seed for all metadata */\n\t\t\tjournal->j_csum_seed = jbd2_chksum(journal, ~0,\n\t\t\t\t\t\t\t   sb->s_uuid,\n\t\t\t\t\t\t\t   sizeof(sb->s_uuid));\n\t\t}\n\t}\n\n\t/* If enabling v1 checksums, downgrade superblock */\n\tif (COMPAT_FEATURE_ON(JBD2_FEATURE_COMPAT_CHECKSUM))\n\t\tsb->s_feature_incompat &=\n\t\t\t~cpu_to_be32(JBD2_FEATURE_INCOMPAT_CSUM_V2 |\n\t\t\t\t     JBD2_FEATURE_INCOMPAT_CSUM_V3);\n\n\tsb->s_feature_compat    |= cpu_to_be32(compat);\n\tsb->s_feature_ro_compat |= cpu_to_be32(ro);\n\tsb->s_feature_incompat  |= cpu_to_be32(incompat);\n\n\treturn 1;\n#undef COMPAT_FEATURE_ON\n#undef INCOMPAT_FEATURE_ON\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_set_features (journal_t *journal, unsigned long compat,\n\t\t\t  unsigned long ro, unsigned long incompat)\n{\n#define INCOMPAT_FEATURE_ON(f) \\\n\t\t((incompat & (f)) && !(sb->s_feature_incompat & cpu_to_be32(f)))\n#define COMPAT_FEATURE_ON(f) \\\n\t\t((compat & (f)) && !(sb->s_feature_compat & cpu_to_be32(f)))\n\tjournal_superblock_t *sb;\n\n\tif (jbd2_journal_check_used_features(journal, compat, ro, incompat))\n\t\treturn 1;\n\n\tif (!jbd2_journal_check_available_features(journal, compat, ro, incompat))\n\t\treturn 0;\n\n\t/* If enabling v2 checksums, turn on v3 instead */\n\tif (incompat & JBD2_FEATURE_INCOMPAT_CSUM_V2) {\n\t\tincompat &= ~JBD2_FEATURE_INCOMPAT_CSUM_V2;\n\t\tincompat |= JBD2_FEATURE_INCOMPAT_CSUM_V3;\n\t}\n\n\t/* Asking for checksumming v3 and v1?  Only give them v3. */\n\tif (incompat & JBD2_FEATURE_INCOMPAT_CSUM_V3 &&\n\t    compat & JBD2_FEATURE_COMPAT_CHECKSUM)\n\t\tcompat &= ~JBD2_FEATURE_COMPAT_CHECKSUM;\n\n\tjbd_debug(1, \"Setting new features 0x%lx/0x%lx/0x%lx\\n\",\n\t\t  compat, ro, incompat);\n\n\tsb = journal->j_superblock;\n\n\t/* If enabling v3 checksums, update superblock */\n\tif (INCOMPAT_FEATURE_ON(JBD2_FEATURE_INCOMPAT_CSUM_V3)) {\n\t\tsb->s_checksum_type = JBD2_CRC32C_CHKSUM;\n\t\tsb->s_feature_compat &=\n\t\t\t~cpu_to_be32(JBD2_FEATURE_COMPAT_CHECKSUM);\n\n\t\t/* Load the checksum driver */\n\t\tif (journal->j_chksum_driver == NULL) {\n\t\t\tjournal->j_chksum_driver = crypto_alloc_shash(\"crc32c\",\n\t\t\t\t\t\t\t\t      0, 0);\n\t\t\tif (IS_ERR(journal->j_chksum_driver)) {\n\t\t\t\tprintk(KERN_ERR \"JBD2: Cannot load crc32c \"\n\t\t\t\t       \"driver.\\n\");\n\t\t\t\tjournal->j_chksum_driver = NULL;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Precompute checksum seed for all metadata */\n\t\t\tjournal->j_csum_seed = jbd2_chksum(journal, ~0,\n\t\t\t\t\t\t\t   sb->s_uuid,\n\t\t\t\t\t\t\t   sizeof(sb->s_uuid));\n\t\t}\n\t}\n\n\t/* If enabling v1 checksums, downgrade superblock */\n\tif (COMPAT_FEATURE_ON(JBD2_FEATURE_COMPAT_CHECKSUM))\n\t\tsb->s_feature_incompat &=\n\t\t\t~cpu_to_be32(JBD2_FEATURE_INCOMPAT_CSUM_V2 |\n\t\t\t\t     JBD2_FEATURE_INCOMPAT_CSUM_V3);\n\n\tsb->s_feature_compat    |= cpu_to_be32(compat);\n\tsb->s_feature_ro_compat |= cpu_to_be32(ro);\n\tsb->s_feature_incompat  |= cpu_to_be32(incompat);\n\n\treturn 1;\n#undef COMPAT_FEATURE_ON\n#undef INCOMPAT_FEATURE_ON\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh_in",
            "\"enter\""
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nint jbd2_journal_revoke(handle_t *handle, unsigned long long blocknr,\n\t\t   struct buffer_head *bh_in)\n{\n\tstruct buffer_head *bh = NULL;\n\tjournal_t *journal;\n\tstruct block_device *bdev;\n\tint err;\n\n\tmight_sleep();\n\tif (bh_in)\n\t\tBUFFER_TRACE(bh_in, \"enter\");\n\n\tjournal = handle->h_transaction->t_journal;\n\tif (!jbd2_journal_set_features(journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)){\n\t\tJ_ASSERT (!\"Cannot set revoke feature!\");\n\t\treturn -EINVAL;\n\t}\n\n\tbdev = journal->j_fs_dev;\n\tbh = bh_in;\n\n\tif (!bh) {\n\t\tbh = __find_get_block(bdev, blocknr, journal->j_blocksize);\n\t\tif (bh)\n\t\t\tBUFFER_TRACE(bh, \"found on hash\");\n\t}\n#ifdef JBD2_EXPENSIVE_CHECKING\n\telse {\n\t\tstruct buffer_head *bh2;\n\n\t\t/* If there is a different buffer_head lying around in\n\t\t * memory anywhere... */\n\t\tbh2 = __find_get_block(bdev, blocknr, journal->j_blocksize);\n\t\tif (bh2) {\n\t\t\t/* ... and it has RevokeValid status... */\n\t\t\tif (bh2 != bh && buffer_revokevalid(bh2))\n\t\t\t\t/* ...then it better be revoked too,\n\t\t\t\t * since it's illegal to create a revoke\n\t\t\t\t * record against a buffer_head which is\n\t\t\t\t * not marked revoked --- that would\n\t\t\t\t * risk missing a subsequent revoke\n\t\t\t\t * cancel. */\n\t\t\t\tJ_ASSERT_BH(bh2, buffer_revoked(bh2));\n\t\t\tput_bh(bh2);\n\t\t}\n\t}\n#endif\n\n\t/* We really ought not ever to revoke twice in a row without\n           first having the revoke cancelled: it's illegal to free a\n           block twice without allocating it in between! */\n\tif (bh) {\n\t\tif (!J_EXPECT_BH(bh, !buffer_revoked(bh),\n\t\t\t\t \"inconsistent data on disk\")) {\n\t\t\tif (!bh_in)\n\t\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t\tset_buffer_revoked(bh);\n\t\tset_buffer_revokevalid(bh);\n\t\tif (bh_in) {\n\t\t\tBUFFER_TRACE(bh_in, \"call jbd2_journal_forget\");\n\t\t\tjbd2_journal_forget(handle, bh_in);\n\t\t} else {\n\t\t\tBUFFER_TRACE(bh, \"call brelse\");\n\t\t\t__brelse(bh);\n\t\t}\n\t}\n\n\tjbd_debug(2, \"insert revoke for block %llu, bh_in=%p\\n\",blocknr, bh_in);\n\terr = insert_revoke_hash(journal, blocknr,\n\t\t\t\thandle->h_transaction->t_tid);\n\tBUFFER_TRACE(bh_in, \"exit\");\n\treturn err;\n}"
  },
  {
    "function_name": "jbd2_journal_destroy_revoke",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
    "lines": "293-300",
    "snippet": "void jbd2_journal_destroy_revoke(journal_t *journal)\n{\n\tjournal->j_revoke = NULL;\n\tif (journal->j_revoke_table[0])\n\t\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[0]);\n\tif (journal->j_revoke_table[1])\n\t\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[1]);\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_journal_destroy_revoke_table",
          "args": [
            "journal->j_revoke_table[1]"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_destroy_revoke_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "252-264",
          "snippet": "static void jbd2_journal_destroy_revoke_table(struct jbd2_revoke_table_s *table)\n{\n\tint i;\n\tstruct list_head *hash_list;\n\n\tfor (i = 0; i < table->hash_size; i++) {\n\t\thash_list = &table->hash_table[i];\n\t\tJ_ASSERT(list_empty(hash_list));\n\t}\n\n\tkfree(table->hash_table);\n\tkmem_cache_free(jbd2_revoke_table_cache, table);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *jbd2_revoke_table_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *jbd2_revoke_table_cache;\n\nstatic void jbd2_journal_destroy_revoke_table(struct jbd2_revoke_table_s *table)\n{\n\tint i;\n\tstruct list_head *hash_list;\n\n\tfor (i = 0; i < table->hash_size; i++) {\n\t\thash_list = &table->hash_table[i];\n\t\tJ_ASSERT(list_empty(hash_list));\n\t}\n\n\tkfree(table->hash_table);\n\tkmem_cache_free(jbd2_revoke_table_cache, table);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nvoid jbd2_journal_destroy_revoke(journal_t *journal)\n{\n\tjournal->j_revoke = NULL;\n\tif (journal->j_revoke_table[0])\n\t\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[0]);\n\tif (journal->j_revoke_table[1])\n\t\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[1]);\n}"
  },
  {
    "function_name": "jbd2_journal_init_revoke",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
    "lines": "267-290",
    "snippet": "int jbd2_journal_init_revoke(journal_t *journal, int hash_size)\n{\n\tJ_ASSERT(journal->j_revoke_table[0] == NULL);\n\tJ_ASSERT(is_power_of_2(hash_size));\n\n\tjournal->j_revoke_table[0] = jbd2_journal_init_revoke_table(hash_size);\n\tif (!journal->j_revoke_table[0])\n\t\tgoto fail0;\n\n\tjournal->j_revoke_table[1] = jbd2_journal_init_revoke_table(hash_size);\n\tif (!journal->j_revoke_table[1])\n\t\tgoto fail1;\n\n\tjournal->j_revoke = journal->j_revoke_table[1];\n\n\tspin_lock_init(&journal->j_revoke_lock);\n\n\treturn 0;\n\nfail1:\n\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[0]);\nfail0:\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_journal_destroy_revoke_table",
          "args": [
            "journal->j_revoke_table[0]"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_destroy_revoke_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "252-264",
          "snippet": "static void jbd2_journal_destroy_revoke_table(struct jbd2_revoke_table_s *table)\n{\n\tint i;\n\tstruct list_head *hash_list;\n\n\tfor (i = 0; i < table->hash_size; i++) {\n\t\thash_list = &table->hash_table[i];\n\t\tJ_ASSERT(list_empty(hash_list));\n\t}\n\n\tkfree(table->hash_table);\n\tkmem_cache_free(jbd2_revoke_table_cache, table);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *jbd2_revoke_table_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *jbd2_revoke_table_cache;\n\nstatic void jbd2_journal_destroy_revoke_table(struct jbd2_revoke_table_s *table)\n{\n\tint i;\n\tstruct list_head *hash_list;\n\n\tfor (i = 0; i < table->hash_size; i++) {\n\t\thash_list = &table->hash_table[i];\n\t\tJ_ASSERT(list_empty(hash_list));\n\t}\n\n\tkfree(table->hash_table);\n\tkmem_cache_free(jbd2_revoke_table_cache, table);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&journal->j_revoke_lock"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_init_revoke_table",
          "args": [
            "hash_size"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_init_revoke_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "222-250",
          "snippet": "static struct jbd2_revoke_table_s *jbd2_journal_init_revoke_table(int hash_size)\n{\n\tint shift = 0;\n\tint tmp = hash_size;\n\tstruct jbd2_revoke_table_s *table;\n\n\ttable = kmem_cache_alloc(jbd2_revoke_table_cache, GFP_KERNEL);\n\tif (!table)\n\t\tgoto out;\n\n\twhile((tmp >>= 1UL) != 0UL)\n\t\tshift++;\n\n\ttable->hash_size = hash_size;\n\ttable->hash_shift = shift;\n\ttable->hash_table =\n\t\tkmalloc(hash_size * sizeof(struct list_head), GFP_KERNEL);\n\tif (!table->hash_table) {\n\t\tkmem_cache_free(jbd2_revoke_table_cache, table);\n\t\ttable = NULL;\n\t\tgoto out;\n\t}\n\n\tfor (tmp = 0; tmp < hash_size; tmp++)\n\t\tINIT_LIST_HEAD(&table->hash_table[tmp]);\n\nout:\n\treturn table;\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *jbd2_revoke_table_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *jbd2_revoke_table_cache;\n\nstatic struct jbd2_revoke_table_s *jbd2_journal_init_revoke_table(int hash_size)\n{\n\tint shift = 0;\n\tint tmp = hash_size;\n\tstruct jbd2_revoke_table_s *table;\n\n\ttable = kmem_cache_alloc(jbd2_revoke_table_cache, GFP_KERNEL);\n\tif (!table)\n\t\tgoto out;\n\n\twhile((tmp >>= 1UL) != 0UL)\n\t\tshift++;\n\n\ttable->hash_size = hash_size;\n\ttable->hash_shift = shift;\n\ttable->hash_table =\n\t\tkmalloc(hash_size * sizeof(struct list_head), GFP_KERNEL);\n\tif (!table->hash_table) {\n\t\tkmem_cache_free(jbd2_revoke_table_cache, table);\n\t\ttable = NULL;\n\t\tgoto out;\n\t}\n\n\tfor (tmp = 0; tmp < hash_size; tmp++)\n\t\tINIT_LIST_HEAD(&table->hash_table[tmp]);\n\nout:\n\treturn table;\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "is_power_of_2(hash_size)"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "hash_size"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "journal->j_revoke_table[0] == NULL"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nint jbd2_journal_init_revoke(journal_t *journal, int hash_size)\n{\n\tJ_ASSERT(journal->j_revoke_table[0] == NULL);\n\tJ_ASSERT(is_power_of_2(hash_size));\n\n\tjournal->j_revoke_table[0] = jbd2_journal_init_revoke_table(hash_size);\n\tif (!journal->j_revoke_table[0])\n\t\tgoto fail0;\n\n\tjournal->j_revoke_table[1] = jbd2_journal_init_revoke_table(hash_size);\n\tif (!journal->j_revoke_table[1])\n\t\tgoto fail1;\n\n\tjournal->j_revoke = journal->j_revoke_table[1];\n\n\tspin_lock_init(&journal->j_revoke_lock);\n\n\treturn 0;\n\nfail1:\n\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[0]);\nfail0:\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "jbd2_journal_destroy_revoke_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
    "lines": "252-264",
    "snippet": "static void jbd2_journal_destroy_revoke_table(struct jbd2_revoke_table_s *table)\n{\n\tint i;\n\tstruct list_head *hash_list;\n\n\tfor (i = 0; i < table->hash_size; i++) {\n\t\thash_list = &table->hash_table[i];\n\t\tJ_ASSERT(list_empty(hash_list));\n\t}\n\n\tkfree(table->hash_table);\n\tkmem_cache_free(jbd2_revoke_table_cache, table);\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *jbd2_revoke_table_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "jbd2_revoke_table_cache",
            "table"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "table->hash_table"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "list_empty(hash_list)"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "hash_list"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *jbd2_revoke_table_cache;\n\nstatic void jbd2_journal_destroy_revoke_table(struct jbd2_revoke_table_s *table)\n{\n\tint i;\n\tstruct list_head *hash_list;\n\n\tfor (i = 0; i < table->hash_size; i++) {\n\t\thash_list = &table->hash_table[i];\n\t\tJ_ASSERT(list_empty(hash_list));\n\t}\n\n\tkfree(table->hash_table);\n\tkmem_cache_free(jbd2_revoke_table_cache, table);\n}"
  },
  {
    "function_name": "jbd2_journal_init_revoke_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
    "lines": "222-250",
    "snippet": "static struct jbd2_revoke_table_s *jbd2_journal_init_revoke_table(int hash_size)\n{\n\tint shift = 0;\n\tint tmp = hash_size;\n\tstruct jbd2_revoke_table_s *table;\n\n\ttable = kmem_cache_alloc(jbd2_revoke_table_cache, GFP_KERNEL);\n\tif (!table)\n\t\tgoto out;\n\n\twhile((tmp >>= 1UL) != 0UL)\n\t\tshift++;\n\n\ttable->hash_size = hash_size;\n\ttable->hash_shift = shift;\n\ttable->hash_table =\n\t\tkmalloc(hash_size * sizeof(struct list_head), GFP_KERNEL);\n\tif (!table->hash_table) {\n\t\tkmem_cache_free(jbd2_revoke_table_cache, table);\n\t\ttable = NULL;\n\t\tgoto out;\n\t}\n\n\tfor (tmp = 0; tmp < hash_size; tmp++)\n\t\tINIT_LIST_HEAD(&table->hash_table[tmp]);\n\nout:\n\treturn table;\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *jbd2_revoke_table_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&table->hash_table[tmp]"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "jbd2_revoke_table_cache",
            "table"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "hash_size * sizeof(struct list_head)",
            "GFP_KERNEL"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "jbd2_revoke_table_cache",
            "GFP_KERNEL"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *jbd2_revoke_table_cache;\n\nstatic struct jbd2_revoke_table_s *jbd2_journal_init_revoke_table(int hash_size)\n{\n\tint shift = 0;\n\tint tmp = hash_size;\n\tstruct jbd2_revoke_table_s *table;\n\n\ttable = kmem_cache_alloc(jbd2_revoke_table_cache, GFP_KERNEL);\n\tif (!table)\n\t\tgoto out;\n\n\twhile((tmp >>= 1UL) != 0UL)\n\t\tshift++;\n\n\ttable->hash_size = hash_size;\n\ttable->hash_shift = shift;\n\ttable->hash_table =\n\t\tkmalloc(hash_size * sizeof(struct list_head), GFP_KERNEL);\n\tif (!table->hash_table) {\n\t\tkmem_cache_free(jbd2_revoke_table_cache, table);\n\t\ttable = NULL;\n\t\tgoto out;\n\t}\n\n\tfor (tmp = 0; tmp < hash_size; tmp++)\n\t\tINIT_LIST_HEAD(&table->hash_table[tmp]);\n\nout:\n\treturn table;\n}"
  },
  {
    "function_name": "jbd2_journal_init_revoke_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
    "lines": "201-220",
    "snippet": "int __init jbd2_journal_init_revoke_caches(void)\n{\n\tJ_ASSERT(!jbd2_revoke_record_cache);\n\tJ_ASSERT(!jbd2_revoke_table_cache);\n\n\tjbd2_revoke_record_cache = KMEM_CACHE(jbd2_revoke_record_s,\n\t\t\t\t\tSLAB_HWCACHE_ALIGN|SLAB_TEMPORARY);\n\tif (!jbd2_revoke_record_cache)\n\t\tgoto record_cache_failure;\n\n\tjbd2_revoke_table_cache = KMEM_CACHE(jbd2_revoke_table_s,\n\t\t\t\t\t     SLAB_TEMPORARY);\n\tif (!jbd2_revoke_table_cache)\n\t\tgoto table_cache_failure;\n\treturn 0;\ntable_cache_failure:\n\tjbd2_journal_destroy_revoke_caches();\nrecord_cache_failure:\n\t\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *jbd2_revoke_record_cache;",
      "static struct kmem_cache *jbd2_revoke_table_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_journal_destroy_revoke_caches",
          "args": [],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_destroy_revoke_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "189-199",
          "snippet": "void jbd2_journal_destroy_revoke_caches(void)\n{\n\tif (jbd2_revoke_record_cache) {\n\t\tkmem_cache_destroy(jbd2_revoke_record_cache);\n\t\tjbd2_revoke_record_cache = NULL;\n\t}\n\tif (jbd2_revoke_table_cache) {\n\t\tkmem_cache_destroy(jbd2_revoke_table_cache);\n\t\tjbd2_revoke_table_cache = NULL;\n\t}\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *jbd2_revoke_record_cache;",
            "static struct kmem_cache *jbd2_revoke_table_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *jbd2_revoke_record_cache;\nstatic struct kmem_cache *jbd2_revoke_table_cache;\n\nvoid jbd2_journal_destroy_revoke_caches(void)\n{\n\tif (jbd2_revoke_record_cache) {\n\t\tkmem_cache_destroy(jbd2_revoke_record_cache);\n\t\tjbd2_revoke_record_cache = NULL;\n\t}\n\tif (jbd2_revoke_table_cache) {\n\t\tkmem_cache_destroy(jbd2_revoke_table_cache);\n\t\tjbd2_revoke_table_cache = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "jbd2_revoke_table_s",
            "SLAB_TEMPORARY"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "jbd2_revoke_record_s",
            "SLAB_HWCACHE_ALIGN|SLAB_TEMPORARY"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "!jbd2_revoke_table_cache"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "!jbd2_revoke_record_cache"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *jbd2_revoke_record_cache;\nstatic struct kmem_cache *jbd2_revoke_table_cache;\n\nint __init jbd2_journal_init_revoke_caches(void)\n{\n\tJ_ASSERT(!jbd2_revoke_record_cache);\n\tJ_ASSERT(!jbd2_revoke_table_cache);\n\n\tjbd2_revoke_record_cache = KMEM_CACHE(jbd2_revoke_record_s,\n\t\t\t\t\tSLAB_HWCACHE_ALIGN|SLAB_TEMPORARY);\n\tif (!jbd2_revoke_record_cache)\n\t\tgoto record_cache_failure;\n\n\tjbd2_revoke_table_cache = KMEM_CACHE(jbd2_revoke_table_s,\n\t\t\t\t\t     SLAB_TEMPORARY);\n\tif (!jbd2_revoke_table_cache)\n\t\tgoto table_cache_failure;\n\treturn 0;\ntable_cache_failure:\n\tjbd2_journal_destroy_revoke_caches();\nrecord_cache_failure:\n\t\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "jbd2_journal_destroy_revoke_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
    "lines": "189-199",
    "snippet": "void jbd2_journal_destroy_revoke_caches(void)\n{\n\tif (jbd2_revoke_record_cache) {\n\t\tkmem_cache_destroy(jbd2_revoke_record_cache);\n\t\tjbd2_revoke_record_cache = NULL;\n\t}\n\tif (jbd2_revoke_table_cache) {\n\t\tkmem_cache_destroy(jbd2_revoke_table_cache);\n\t\tjbd2_revoke_table_cache = NULL;\n\t}\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *jbd2_revoke_record_cache;",
      "static struct kmem_cache *jbd2_revoke_table_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "jbd2_revoke_table_cache"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "jbd2_revoke_record_cache"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *jbd2_revoke_record_cache;\nstatic struct kmem_cache *jbd2_revoke_table_cache;\n\nvoid jbd2_journal_destroy_revoke_caches(void)\n{\n\tif (jbd2_revoke_record_cache) {\n\t\tkmem_cache_destroy(jbd2_revoke_record_cache);\n\t\tjbd2_revoke_record_cache = NULL;\n\t}\n\tif (jbd2_revoke_table_cache) {\n\t\tkmem_cache_destroy(jbd2_revoke_table_cache);\n\t\tjbd2_revoke_table_cache = NULL;\n\t}\n}"
  },
  {
    "function_name": "find_revoke_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
    "lines": "168-187",
    "snippet": "static struct jbd2_revoke_record_s *find_revoke_record(journal_t *journal,\n\t\t\t\t\t\t      unsigned long long blocknr)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd2_revoke_record_s *record;\n\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\n\tspin_lock(&journal->j_revoke_lock);\n\trecord = (struct jbd2_revoke_record_s *) hash_list->next;\n\twhile (&(record->hash) != hash_list) {\n\t\tif (record->blocknr == blocknr) {\n\t\t\tspin_unlock(&journal->j_revoke_lock);\n\t\t\treturn record;\n\t\t}\n\t\trecord = (struct jbd2_revoke_record_s *) record->hash.next;\n\t}\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_revoke_lock"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_revoke_lock"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "journal",
            "blocknr"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "134-137",
          "snippet": "static inline int hash(journal_t *journal, unsigned long long block)\n{\n\treturn hash_64(block, journal->j_revoke->hash_shift);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic inline int hash(journal_t *journal, unsigned long long block)\n{\n\treturn hash_64(block, journal->j_revoke->hash_shift);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct jbd2_revoke_record_s *find_revoke_record(journal_t *journal,\n\t\t\t\t\t\t      unsigned long long blocknr)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd2_revoke_record_s *record;\n\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\n\tspin_lock(&journal->j_revoke_lock);\n\trecord = (struct jbd2_revoke_record_s *) hash_list->next;\n\twhile (&(record->hash) != hash_list) {\n\t\tif (record->blocknr == blocknr) {\n\t\t\tspin_unlock(&journal->j_revoke_lock);\n\t\t\treturn record;\n\t\t}\n\t\trecord = (struct jbd2_revoke_record_s *) record->hash.next;\n\t}\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn NULL;\n}"
  },
  {
    "function_name": "insert_revoke_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
    "lines": "139-164",
    "snippet": "static int insert_revoke_hash(journal_t *journal, unsigned long long blocknr,\n\t\t\t      tid_t seq)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd2_revoke_record_s *record;\n\nrepeat:\n\trecord = kmem_cache_alloc(jbd2_revoke_record_cache, GFP_NOFS);\n\tif (!record)\n\t\tgoto oom;\n\n\trecord->sequence = seq;\n\trecord->blocknr = blocknr;\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\tspin_lock(&journal->j_revoke_lock);\n\tlist_add(&record->hash, hash_list);\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn 0;\n\noom:\n\tif (!journal_oom_retry)\n\t\treturn -ENOMEM;\n\tjbd_debug(1, \"ENOMEM in %s, retrying\\n\", __func__);\n\tyield();\n\tgoto repeat;\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *jbd2_revoke_record_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "yield",
          "args": [],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"ENOMEM in %s, retrying\\n\"",
            "__func__"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_revoke_lock"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&record->hash",
            "hash_list"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "__blist_add_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "1689-1702",
          "snippet": "static inline void\n__blist_add_buffer(struct journal_head **list, struct journal_head *jh)\n{\n\tif (!*list) {\n\t\tjh->b_tnext = jh->b_tprev = jh;\n\t\t*list = jh;\n\t} else {\n\t\t/* Insert at the tail of the list to preserve order */\n\t\tstruct journal_head *first = *list, *last = first->b_tprev;\n\t\tjh->b_tprev = last;\n\t\tjh->b_tnext = first;\n\t\tlast->b_tnext = first->b_tprev = jh;\n\t}\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);",
            "static void __jbd2_journal_unfile_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);\nstatic void __jbd2_journal_unfile_buffer(struct journal_head *jh);\n\nstatic inline void\n__blist_add_buffer(struct journal_head **list, struct journal_head *jh)\n{\n\tif (!*list) {\n\t\tjh->b_tnext = jh->b_tprev = jh;\n\t\t*list = jh;\n\t} else {\n\t\t/* Insert at the tail of the list to preserve order */\n\t\tstruct journal_head *first = *list, *last = first->b_tprev;\n\t\tjh->b_tprev = last;\n\t\tjh->b_tnext = first;\n\t\tlast->b_tnext = first->b_tprev = jh;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_revoke_lock"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "journal",
            "blocknr"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "134-137",
          "snippet": "static inline int hash(journal_t *journal, unsigned long long block)\n{\n\treturn hash_64(block, journal->j_revoke->hash_shift);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic inline int hash(journal_t *journal, unsigned long long block)\n{\n\treturn hash_64(block, journal->j_revoke->hash_shift);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "jbd2_revoke_record_cache",
            "GFP_NOFS"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *jbd2_revoke_record_cache;\n\nstatic int insert_revoke_hash(journal_t *journal, unsigned long long blocknr,\n\t\t\t      tid_t seq)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd2_revoke_record_s *record;\n\nrepeat:\n\trecord = kmem_cache_alloc(jbd2_revoke_record_cache, GFP_NOFS);\n\tif (!record)\n\t\tgoto oom;\n\n\trecord->sequence = seq;\n\trecord->blocknr = blocknr;\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\tspin_lock(&journal->j_revoke_lock);\n\tlist_add(&record->hash, hash_list);\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn 0;\n\noom:\n\tif (!journal_oom_retry)\n\t\treturn -ENOMEM;\n\tjbd_debug(1, \"ENOMEM in %s, retrying\\n\", __func__);\n\tyield();\n\tgoto repeat;\n}"
  },
  {
    "function_name": "hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
    "lines": "134-137",
    "snippet": "static inline int hash(journal_t *journal, unsigned long long block)\n{\n\treturn hash_64(block, journal->j_revoke->hash_shift);\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_64",
          "args": [
            "block",
            "journal->j_revoke->hash_shift"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic inline int hash(journal_t *journal, unsigned long long block)\n{\n\treturn hash_64(block, journal->j_revoke->hash_shift);\n}"
  }
]