[
  {
    "function_name": "exit_ceph",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
    "lines": "1047-1054",
    "snippet": "static void __exit exit_ceph(void)\n{\n\tdout(\"exit_ceph\\n\");\n\tunregister_filesystem(&ceph_fs_type);\n\tceph_snap_exit();\n\tceph_xattr_exit();\n\tdestroy_caches();\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/mon_client.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/string.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/in6.h>",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type ceph_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ceph\",\n\t.mount\t\t= ceph_mount,\n\t.kill_sb\t= ceph_kill_sb,\n\t.fs_flags\t= FS_RENAME_DOES_D_MOVE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_caches",
          "args": [],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "670-684",
          "snippet": "static void destroy_caches(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\n\tkmem_cache_destroy(ceph_inode_cachep);\n\tkmem_cache_destroy(ceph_cap_cachep);\n\tkmem_cache_destroy(ceph_dentry_cachep);\n\tkmem_cache_destroy(ceph_file_cachep);\n\n\tceph_fscache_unregister();\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/string.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *ceph_inode_cachep;",
            "struct kmem_cache *ceph_cap_cachep;",
            "struct kmem_cache *ceph_dentry_cachep;",
            "struct kmem_cache *ceph_file_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct kmem_cache *ceph_inode_cachep;\nstruct kmem_cache *ceph_cap_cachep;\nstruct kmem_cache *ceph_dentry_cachep;\nstruct kmem_cache *ceph_file_cachep;\n\nstatic void destroy_caches(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\n\tkmem_cache_destroy(ceph_inode_cachep);\n\tkmem_cache_destroy(ceph_cap_cachep);\n\tkmem_cache_destroy(ceph_dentry_cachep);\n\tkmem_cache_destroy(ceph_file_cachep);\n\n\tceph_fscache_unregister();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_xattr_exit",
          "args": [],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_xattr_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "316-320",
          "snippet": "void ceph_xattr_exit(void)\n{\n\tceph_dir_vxattrs_name_size = 0;\n\tceph_file_vxattrs_name_size = 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t ceph_dir_vxattrs_name_size;",
            "static size_t ceph_file_vxattrs_name_size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic size_t ceph_dir_vxattrs_name_size;\nstatic size_t ceph_file_vxattrs_name_size;\n\nvoid ceph_xattr_exit(void)\n{\n\tceph_dir_vxattrs_name_size = 0;\n\tceph_file_vxattrs_name_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_snap_exit",
          "args": [],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_snap_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "974-977",
          "snippet": "void ceph_snap_exit(void)\n{\n\tceph_put_snap_context(empty_snapc);\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ceph_snap_context *empty_snapc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_snap_context *empty_snapc;\n\nvoid ceph_snap_exit(void)\n{\n\tceph_put_snap_context(empty_snapc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&ceph_fs_type"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"exit_ceph\\n\""
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct file_system_type ceph_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ceph\",\n\t.mount\t\t= ceph_mount,\n\t.kill_sb\t= ceph_kill_sb,\n\t.fs_flags\t= FS_RENAME_DOES_D_MOVE,\n};\n\nstatic void __exit exit_ceph(void)\n{\n\tdout(\"exit_ceph\\n\");\n\tunregister_filesystem(&ceph_fs_type);\n\tceph_snap_exit();\n\tceph_xattr_exit();\n\tdestroy_caches();\n}"
  },
  {
    "function_name": "init_ceph",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
    "lines": "1019-1045",
    "snippet": "static int __init init_ceph(void)\n{\n\tint ret = init_caches();\n\tif (ret)\n\t\tgoto out;\n\n\tceph_flock_init();\n\tceph_xattr_init();\n\tret = ceph_snap_init();\n\tif (ret)\n\t\tgoto out_xattr;\n\tret = register_filesystem(&ceph_fs_type);\n\tif (ret)\n\t\tgoto out_snap;\n\n\tpr_info(\"loaded (mds proto %d)\\n\", CEPH_MDSC_PROTOCOL);\n\n\treturn 0;\n\nout_snap:\n\tceph_snap_exit();\nout_xattr:\n\tceph_xattr_exit();\n\tdestroy_caches();\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/mon_client.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/string.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/in6.h>",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type ceph_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ceph\",\n\t.mount\t\t= ceph_mount,\n\t.kill_sb\t= ceph_kill_sb,\n\t.fs_flags\t= FS_RENAME_DOES_D_MOVE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_caches",
          "args": [],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "670-684",
          "snippet": "static void destroy_caches(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\n\tkmem_cache_destroy(ceph_inode_cachep);\n\tkmem_cache_destroy(ceph_cap_cachep);\n\tkmem_cache_destroy(ceph_dentry_cachep);\n\tkmem_cache_destroy(ceph_file_cachep);\n\n\tceph_fscache_unregister();\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/string.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *ceph_inode_cachep;",
            "struct kmem_cache *ceph_cap_cachep;",
            "struct kmem_cache *ceph_dentry_cachep;",
            "struct kmem_cache *ceph_file_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct kmem_cache *ceph_inode_cachep;\nstruct kmem_cache *ceph_cap_cachep;\nstruct kmem_cache *ceph_dentry_cachep;\nstruct kmem_cache *ceph_file_cachep;\n\nstatic void destroy_caches(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\n\tkmem_cache_destroy(ceph_inode_cachep);\n\tkmem_cache_destroy(ceph_cap_cachep);\n\tkmem_cache_destroy(ceph_dentry_cachep);\n\tkmem_cache_destroy(ceph_file_cachep);\n\n\tceph_fscache_unregister();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_xattr_exit",
          "args": [],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_xattr_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "316-320",
          "snippet": "void ceph_xattr_exit(void)\n{\n\tceph_dir_vxattrs_name_size = 0;\n\tceph_file_vxattrs_name_size = 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t ceph_dir_vxattrs_name_size;",
            "static size_t ceph_file_vxattrs_name_size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic size_t ceph_dir_vxattrs_name_size;\nstatic size_t ceph_file_vxattrs_name_size;\n\nvoid ceph_xattr_exit(void)\n{\n\tceph_dir_vxattrs_name_size = 0;\n\tceph_file_vxattrs_name_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_snap_exit",
          "args": [],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_snap_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "974-977",
          "snippet": "void ceph_snap_exit(void)\n{\n\tceph_put_snap_context(empty_snapc);\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ceph_snap_context *empty_snapc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_snap_context *empty_snapc;\n\nvoid ceph_snap_exit(void)\n{\n\tceph_put_snap_context(empty_snapc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"loaded (mds proto %d)\\n\"",
            "CEPH_MDSC_PROTOCOL"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&ceph_fs_type"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_snap_init",
          "args": [],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_snap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "965-972",
          "snippet": "int __init ceph_snap_init(void)\n{\n\tempty_snapc = ceph_create_snap_context(0, GFP_NOFS);\n\tif (!empty_snapc)\n\t\treturn -ENOMEM;\n\tempty_snapc->seq = 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ceph_snap_context *empty_snapc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_snap_context *empty_snapc;\n\nint __init ceph_snap_init(void)\n{\n\tempty_snapc = ceph_create_snap_context(0, GFP_NOFS);\n\tif (!empty_snapc)\n\t\treturn -ENOMEM;\n\tempty_snapc->seq = 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_xattr_init",
          "args": [],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_xattr_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "310-314",
          "snippet": "void __init ceph_xattr_init(void)\n{\n\tceph_dir_vxattrs_name_size = vxattrs_name_size(ceph_dir_vxattrs);\n\tceph_file_vxattrs_name_size = vxattrs_name_size(ceph_file_vxattrs);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ceph_vxattr ceph_dir_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.dir.layout\",\n\t\t.name_size = sizeof(\"ceph.dir.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(dir, layout, object_size),\n\tXATTR_LAYOUT_FIELD(dir, layout, pool),\n\tXATTR_NAME_CEPH(dir, entries),\n\tXATTR_NAME_CEPH(dir, files),\n\tXATTR_NAME_CEPH(dir, subdirs),\n\tXATTR_NAME_CEPH(dir, rentries),\n\tXATTR_NAME_CEPH(dir, rfiles),\n\tXATTR_NAME_CEPH(dir, rsubdirs),\n\tXATTR_NAME_CEPH(dir, rbytes),\n\tXATTR_NAME_CEPH(dir, rctime),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};",
            "static size_t ceph_dir_vxattrs_name_size;",
            "static struct ceph_vxattr ceph_file_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.file.layout\",\n\t\t.name_size = sizeof(\"ceph.file.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(file, layout, object_size),\n\tXATTR_LAYOUT_FIELD(file, layout, pool),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};",
            "static size_t ceph_file_vxattrs_name_size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_vxattr ceph_dir_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.dir.layout\",\n\t\t.name_size = sizeof(\"ceph.dir.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(dir, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(dir, layout, object_size),\n\tXATTR_LAYOUT_FIELD(dir, layout, pool),\n\tXATTR_NAME_CEPH(dir, entries),\n\tXATTR_NAME_CEPH(dir, files),\n\tXATTR_NAME_CEPH(dir, subdirs),\n\tXATTR_NAME_CEPH(dir, rentries),\n\tXATTR_NAME_CEPH(dir, rfiles),\n\tXATTR_NAME_CEPH(dir, rsubdirs),\n\tXATTR_NAME_CEPH(dir, rbytes),\n\tXATTR_NAME_CEPH(dir, rctime),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};\nstatic size_t ceph_dir_vxattrs_name_size;\nstatic struct ceph_vxattr ceph_file_vxattrs[] = {\n\t{\n\t\t.name = \"ceph.file.layout\",\n\t\t.name_size = sizeof(\"ceph.file.layout\"),\n\t\t.getxattr_cb = ceph_vxattrcb_layout,\n\t\t.readonly = false,\n\t\t.hidden = true,\n\t\t.exists_cb = ceph_vxattrcb_layout_exists,\n\t},\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_unit),\n\tXATTR_LAYOUT_FIELD(file, layout, stripe_count),\n\tXATTR_LAYOUT_FIELD(file, layout, object_size),\n\tXATTR_LAYOUT_FIELD(file, layout, pool),\n\t{ .name = NULL, 0 }\t/* Required table terminator */\n};\nstatic size_t ceph_file_vxattrs_name_size;\n\nvoid __init ceph_xattr_init(void)\n{\n\tceph_dir_vxattrs_name_size = vxattrs_name_size(ceph_dir_vxattrs);\n\tceph_file_vxattrs_name_size = vxattrs_name_size(ceph_file_vxattrs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_flock_init",
          "args": [],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_flock_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/locks.c",
          "lines": "27-30",
          "snippet": "void __init ceph_flock_init(void)\n{\n\tget_random_bytes(&lock_secret, sizeof(lock_secret));\n}",
          "includes": [
            "#include <linux/ceph/pagelist.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 lock_secret;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/pagelist.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic u64 lock_secret;\n\nvoid __init ceph_flock_init(void)\n{\n\tget_random_bytes(&lock_secret, sizeof(lock_secret));\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_caches",
          "args": [],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "init_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "630-668",
          "snippet": "static int __init init_caches(void)\n{\n\tint error = -ENOMEM;\n\n\tceph_inode_cachep = kmem_cache_create(\"ceph_inode_info\",\n\t\t\t\t      sizeof(struct ceph_inode_info),\n\t\t\t\t      __alignof__(struct ceph_inode_info),\n\t\t\t\t      (SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD),\n\t\t\t\t      ceph_inode_init_once);\n\tif (ceph_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\tceph_cap_cachep = KMEM_CACHE(ceph_cap,\n\t\t\t\t     SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD);\n\tif (ceph_cap_cachep == NULL)\n\t\tgoto bad_cap;\n\n\tceph_dentry_cachep = KMEM_CACHE(ceph_dentry_info,\n\t\t\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD);\n\tif (ceph_dentry_cachep == NULL)\n\t\tgoto bad_dentry;\n\n\tceph_file_cachep = KMEM_CACHE(ceph_file_info,\n\t\t\t\t      SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD);\n\tif (ceph_file_cachep == NULL)\n\t\tgoto bad_file;\n\n\tif ((error = ceph_fscache_register()))\n\t\tgoto bad_file;\n\n\treturn 0;\nbad_file:\n\tkmem_cache_destroy(ceph_dentry_cachep);\nbad_dentry:\n\tkmem_cache_destroy(ceph_cap_cachep);\nbad_cap:\n\tkmem_cache_destroy(ceph_inode_cachep);\n\treturn error;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/string.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *ceph_inode_cachep;",
            "struct kmem_cache *ceph_cap_cachep;",
            "struct kmem_cache *ceph_dentry_cachep;",
            "struct kmem_cache *ceph_file_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct kmem_cache *ceph_inode_cachep;\nstruct kmem_cache *ceph_cap_cachep;\nstruct kmem_cache *ceph_dentry_cachep;\nstruct kmem_cache *ceph_file_cachep;\n\nstatic int __init init_caches(void)\n{\n\tint error = -ENOMEM;\n\n\tceph_inode_cachep = kmem_cache_create(\"ceph_inode_info\",\n\t\t\t\t      sizeof(struct ceph_inode_info),\n\t\t\t\t      __alignof__(struct ceph_inode_info),\n\t\t\t\t      (SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD),\n\t\t\t\t      ceph_inode_init_once);\n\tif (ceph_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\tceph_cap_cachep = KMEM_CACHE(ceph_cap,\n\t\t\t\t     SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD);\n\tif (ceph_cap_cachep == NULL)\n\t\tgoto bad_cap;\n\n\tceph_dentry_cachep = KMEM_CACHE(ceph_dentry_info,\n\t\t\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD);\n\tif (ceph_dentry_cachep == NULL)\n\t\tgoto bad_dentry;\n\n\tceph_file_cachep = KMEM_CACHE(ceph_file_info,\n\t\t\t\t      SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD);\n\tif (ceph_file_cachep == NULL)\n\t\tgoto bad_file;\n\n\tif ((error = ceph_fscache_register()))\n\t\tgoto bad_file;\n\n\treturn 0;\nbad_file:\n\tkmem_cache_destroy(ceph_dentry_cachep);\nbad_dentry:\n\tkmem_cache_destroy(ceph_cap_cachep);\nbad_cap:\n\tkmem_cache_destroy(ceph_inode_cachep);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct file_system_type ceph_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ceph\",\n\t.mount\t\t= ceph_mount,\n\t.kill_sb\t= ceph_kill_sb,\n\t.fs_flags\t= FS_RENAME_DOES_D_MOVE,\n};\n\nstatic int __init init_ceph(void)\n{\n\tint ret = init_caches();\n\tif (ret)\n\t\tgoto out;\n\n\tceph_flock_init();\n\tceph_xattr_init();\n\tret = ceph_snap_init();\n\tif (ret)\n\t\tgoto out_xattr;\n\tret = register_filesystem(&ceph_fs_type);\n\tif (ret)\n\t\tgoto out_snap;\n\n\tpr_info(\"loaded (mds proto %d)\\n\", CEPH_MDSC_PROTOCOL);\n\n\treturn 0;\n\nout_snap:\n\tceph_snap_exit();\nout_xattr:\n\tceph_xattr_exit();\n\tdestroy_caches();\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ceph_kill_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
    "lines": "995-1008",
    "snippet": "static void ceph_kill_sb(struct super_block *s)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(s);\n\tdev_t dev = s->s_dev;\n\n\tdout(\"kill_sb %p\\n\", s);\n\n\tceph_mdsc_pre_umount(fsc->mdsc);\n\tgeneric_shutdown_super(s);\n\tceph_mdsc_destroy(fsc);\n\n\tdestroy_fs_client(fsc);\n\tfree_anon_bdev(dev);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/mon_client.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/string.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/in6.h>",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_anon_bdev",
          "args": [
            "dev"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_fs_client",
          "args": [
            "fsc"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_fs_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "592-614",
          "snippet": "static void destroy_fs_client(struct ceph_fs_client *fsc)\n{\n\tdout(\"destroy_fs_client %p\\n\", fsc);\n\n\tceph_fscache_unregister_fs(fsc);\n\n\tdestroy_workqueue(fsc->wb_wq);\n\tdestroy_workqueue(fsc->pg_inv_wq);\n\tdestroy_workqueue(fsc->trunc_wq);\n\n\tbdi_destroy(&fsc->backing_dev_info);\n\n\tmempool_destroy(fsc->wb_pagevec_pool);\n\n\tdestroy_mount_options(fsc->mount_options);\n\n\tceph_fs_debugfs_cleanup(fsc);\n\n\tceph_destroy_client(fsc->client);\n\n\tkfree(fsc);\n\tdout(\"destroy_fs_client %p done\\n\", fsc);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/string.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void destroy_fs_client(struct ceph_fs_client *fsc)\n{\n\tdout(\"destroy_fs_client %p\\n\", fsc);\n\n\tceph_fscache_unregister_fs(fsc);\n\n\tdestroy_workqueue(fsc->wb_wq);\n\tdestroy_workqueue(fsc->pg_inv_wq);\n\tdestroy_workqueue(fsc->trunc_wq);\n\n\tbdi_destroy(&fsc->backing_dev_info);\n\n\tmempool_destroy(fsc->wb_pagevec_pool);\n\n\tdestroy_mount_options(fsc->mount_options);\n\n\tceph_fs_debugfs_cleanup(fsc);\n\n\tceph_destroy_client(fsc->client);\n\n\tkfree(fsc);\n\tdout(\"destroy_fs_client %p done\\n\", fsc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_destroy",
          "args": [
            "fsc"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "3583-3596",
          "snippet": "void ceph_mdsc_destroy(struct ceph_fs_client *fsc)\n{\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\n\tdout(\"mdsc_destroy %p\\n\", mdsc);\n\tceph_mdsc_stop(mdsc);\n\n\t/* flush out any connection work with references to us */\n\tceph_msgr_flush();\n\n\tfsc->mdsc = NULL;\n\tkfree(mdsc);\n\tdout(\"mdsc_destroy %p done\\n\", mdsc);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_mdsc_destroy(struct ceph_fs_client *fsc)\n{\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\n\tdout(\"mdsc_destroy %p\\n\", mdsc);\n\tceph_mdsc_stop(mdsc);\n\n\t/* flush out any connection work with references to us */\n\tceph_msgr_flush();\n\n\tfsc->mdsc = NULL;\n\tkfree(mdsc);\n\tdout(\"mdsc_destroy %p done\\n\", mdsc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_shutdown_super",
          "args": [
            "s"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_pre_umount",
          "args": [
            "fsc->mdsc"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_pre_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "3424-3438",
          "snippet": "void ceph_mdsc_pre_umount(struct ceph_mds_client *mdsc)\n{\n\tdout(\"pre_umount\\n\");\n\tmdsc->stopping = 1;\n\n\tdrop_leases(mdsc);\n\tceph_flush_dirty_caps(mdsc);\n\twait_requests(mdsc);\n\n\t/*\n\t * wait for reply handlers to drop their request refs and\n\t * their inode/dcache refs\n\t */\n\tceph_msgr_flush();\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_mdsc_pre_umount(struct ceph_mds_client *mdsc)\n{\n\tdout(\"pre_umount\\n\");\n\tmdsc->stopping = 1;\n\n\tdrop_leases(mdsc);\n\tceph_flush_dirty_caps(mdsc);\n\twait_requests(mdsc);\n\n\t/*\n\t * wait for reply handlers to drop their request refs and\n\t * their inode/dcache refs\n\t */\n\tceph_msgr_flush();\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"kill_sb %p\\n\"",
            "s"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "s"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void ceph_kill_sb(struct super_block *s)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(s);\n\tdev_t dev = s->s_dev;\n\n\tdout(\"kill_sb %p\\n\", s);\n\n\tceph_mdsc_pre_umount(fsc->mdsc);\n\tgeneric_shutdown_super(s);\n\tceph_mdsc_destroy(fsc);\n\n\tdestroy_fs_client(fsc);\n\tfree_anon_bdev(dev);\n}"
  },
  {
    "function_name": "ceph_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
    "lines": "915-993",
    "snippet": "static struct dentry *ceph_mount(struct file_system_type *fs_type,\n\t\t       int flags, const char *dev_name, void *data)\n{\n\tstruct super_block *sb;\n\tstruct ceph_fs_client *fsc;\n\tstruct dentry *res;\n\tint err;\n\tint (*compare_super)(struct super_block *, void *) = ceph_compare_super;\n\tconst char *path = NULL;\n\tstruct ceph_mount_options *fsopt = NULL;\n\tstruct ceph_options *opt = NULL;\n\n\tdout(\"ceph_mount\\n\");\n\n#ifdef CONFIG_CEPH_FS_POSIX_ACL\n\tflags |= MS_POSIXACL;\n#endif\n\terr = parse_mount_options(&fsopt, &opt, flags, data, dev_name, &path);\n\tif (err < 0) {\n\t\tres = ERR_PTR(err);\n\t\tgoto out_final;\n\t}\n\n\t/* create client (which we may/may not use) */\n\tfsc = create_fs_client(fsopt, opt);\n\tif (IS_ERR(fsc)) {\n\t\tres = ERR_CAST(fsc);\n\t\tdestroy_mount_options(fsopt);\n\t\tceph_destroy_options(opt);\n\t\tgoto out_final;\n\t}\n\n\terr = ceph_mdsc_init(fsc);\n\tif (err < 0) {\n\t\tres = ERR_PTR(err);\n\t\tgoto out;\n\t}\n\n\tif (ceph_test_opt(fsc->client, NOSHARE))\n\t\tcompare_super = NULL;\n\tsb = sget(fs_type, compare_super, ceph_set_super, flags, fsc);\n\tif (IS_ERR(sb)) {\n\t\tres = ERR_CAST(sb);\n\t\tgoto out;\n\t}\n\n\tif (ceph_sb_to_client(sb) != fsc) {\n\t\tceph_mdsc_destroy(fsc);\n\t\tdestroy_fs_client(fsc);\n\t\tfsc = ceph_sb_to_client(sb);\n\t\tdout(\"get_sb got existing client %p\\n\", fsc);\n\t} else {\n\t\tdout(\"get_sb using new client %p\\n\", fsc);\n\t\terr = ceph_register_bdi(sb, fsc);\n\t\tif (err < 0) {\n\t\t\tres = ERR_PTR(err);\n\t\t\tgoto out_splat;\n\t\t}\n\t}\n\n\tres = ceph_real_mount(fsc, path);\n\tif (IS_ERR(res))\n\t\tgoto out_splat;\n\tdout(\"root %p inode %p ino %llx.%llx\\n\", res,\n\t     res->d_inode, ceph_vinop(res->d_inode));\n\treturn res;\n\nout_splat:\n\tceph_mdsc_close_sessions(fsc->mdsc);\n\tdeactivate_locked_super(sb);\n\tgoto out_final;\n\nout:\n\tceph_mdsc_destroy(fsc);\n\tdestroy_fs_client(fsc);\nout_final:\n\tdout(\"ceph_mount fail %ld\\n\", PTR_ERR(res));\n\treturn res;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/mon_client.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/string.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/in6.h>",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"ceph_mount fail %ld\\n\"",
            "PTR_ERR(res)"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "res"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_fs_client",
          "args": [
            "fsc"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_fs_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "592-614",
          "snippet": "static void destroy_fs_client(struct ceph_fs_client *fsc)\n{\n\tdout(\"destroy_fs_client %p\\n\", fsc);\n\n\tceph_fscache_unregister_fs(fsc);\n\n\tdestroy_workqueue(fsc->wb_wq);\n\tdestroy_workqueue(fsc->pg_inv_wq);\n\tdestroy_workqueue(fsc->trunc_wq);\n\n\tbdi_destroy(&fsc->backing_dev_info);\n\n\tmempool_destroy(fsc->wb_pagevec_pool);\n\n\tdestroy_mount_options(fsc->mount_options);\n\n\tceph_fs_debugfs_cleanup(fsc);\n\n\tceph_destroy_client(fsc->client);\n\n\tkfree(fsc);\n\tdout(\"destroy_fs_client %p done\\n\", fsc);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/string.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void destroy_fs_client(struct ceph_fs_client *fsc)\n{\n\tdout(\"destroy_fs_client %p\\n\", fsc);\n\n\tceph_fscache_unregister_fs(fsc);\n\n\tdestroy_workqueue(fsc->wb_wq);\n\tdestroy_workqueue(fsc->pg_inv_wq);\n\tdestroy_workqueue(fsc->trunc_wq);\n\n\tbdi_destroy(&fsc->backing_dev_info);\n\n\tmempool_destroy(fsc->wb_pagevec_pool);\n\n\tdestroy_mount_options(fsc->mount_options);\n\n\tceph_fs_debugfs_cleanup(fsc);\n\n\tceph_destroy_client(fsc->client);\n\n\tkfree(fsc);\n\tdout(\"destroy_fs_client %p done\\n\", fsc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_destroy",
          "args": [
            "fsc"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "3583-3596",
          "snippet": "void ceph_mdsc_destroy(struct ceph_fs_client *fsc)\n{\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\n\tdout(\"mdsc_destroy %p\\n\", mdsc);\n\tceph_mdsc_stop(mdsc);\n\n\t/* flush out any connection work with references to us */\n\tceph_msgr_flush();\n\n\tfsc->mdsc = NULL;\n\tkfree(mdsc);\n\tdout(\"mdsc_destroy %p done\\n\", mdsc);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_mdsc_destroy(struct ceph_fs_client *fsc)\n{\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\n\tdout(\"mdsc_destroy %p\\n\", mdsc);\n\tceph_mdsc_stop(mdsc);\n\n\t/* flush out any connection work with references to us */\n\tceph_msgr_flush();\n\n\tfsc->mdsc = NULL;\n\tkfree(mdsc);\n\tdout(\"mdsc_destroy %p done\\n\", mdsc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "deactivate_locked_super",
          "args": [
            "sb"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_close_sessions",
          "args": [
            "fsc->mdsc"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_close_sessions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "3521-3571",
          "snippet": "void ceph_mdsc_close_sessions(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_mds_session *session;\n\tint i;\n\tstruct ceph_fs_client *fsc = mdsc->fsc;\n\tunsigned long timeout = fsc->client->options->mount_timeout * HZ;\n\n\tdout(\"close_sessions\\n\");\n\n\t/* close sessions */\n\tmutex_lock(&mdsc->mutex);\n\tfor (i = 0; i < mdsc->max_sessions; i++) {\n\t\tsession = __ceph_lookup_mds_session(mdsc, i);\n\t\tif (!session)\n\t\t\tcontinue;\n\t\tmutex_unlock(&mdsc->mutex);\n\t\tmutex_lock(&session->s_mutex);\n\t\t__close_session(mdsc, session);\n\t\tmutex_unlock(&session->s_mutex);\n\t\tceph_put_mds_session(session);\n\t\tmutex_lock(&mdsc->mutex);\n\t}\n\tmutex_unlock(&mdsc->mutex);\n\n\tdout(\"waiting for sessions to close\\n\");\n\twait_event_timeout(mdsc->session_close_wq, done_closing_sessions(mdsc),\n\t\t\t   timeout);\n\n\t/* tear down remaining sessions */\n\tmutex_lock(&mdsc->mutex);\n\tfor (i = 0; i < mdsc->max_sessions; i++) {\n\t\tif (mdsc->sessions[i]) {\n\t\t\tsession = get_session(mdsc->sessions[i]);\n\t\t\t__unregister_session(mdsc, session);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tmutex_lock(&session->s_mutex);\n\t\t\tremove_session_caps(session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tceph_put_mds_session(session);\n\t\t\tmutex_lock(&mdsc->mutex);\n\t\t}\n\t}\n\tWARN_ON(!list_empty(&mdsc->cap_delay_list));\n\tmutex_unlock(&mdsc->mutex);\n\n\tceph_cleanup_empty_realms(mdsc);\n\n\tcancel_delayed_work_sync(&mdsc->delayed_work); /* cancel timer */\n\n\tdout(\"stopped\\n\");\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_mdsc_close_sessions(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_mds_session *session;\n\tint i;\n\tstruct ceph_fs_client *fsc = mdsc->fsc;\n\tunsigned long timeout = fsc->client->options->mount_timeout * HZ;\n\n\tdout(\"close_sessions\\n\");\n\n\t/* close sessions */\n\tmutex_lock(&mdsc->mutex);\n\tfor (i = 0; i < mdsc->max_sessions; i++) {\n\t\tsession = __ceph_lookup_mds_session(mdsc, i);\n\t\tif (!session)\n\t\t\tcontinue;\n\t\tmutex_unlock(&mdsc->mutex);\n\t\tmutex_lock(&session->s_mutex);\n\t\t__close_session(mdsc, session);\n\t\tmutex_unlock(&session->s_mutex);\n\t\tceph_put_mds_session(session);\n\t\tmutex_lock(&mdsc->mutex);\n\t}\n\tmutex_unlock(&mdsc->mutex);\n\n\tdout(\"waiting for sessions to close\\n\");\n\twait_event_timeout(mdsc->session_close_wq, done_closing_sessions(mdsc),\n\t\t\t   timeout);\n\n\t/* tear down remaining sessions */\n\tmutex_lock(&mdsc->mutex);\n\tfor (i = 0; i < mdsc->max_sessions; i++) {\n\t\tif (mdsc->sessions[i]) {\n\t\t\tsession = get_session(mdsc->sessions[i]);\n\t\t\t__unregister_session(mdsc, session);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tmutex_lock(&session->s_mutex);\n\t\t\tremove_session_caps(session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tceph_put_mds_session(session);\n\t\t\tmutex_lock(&mdsc->mutex);\n\t\t}\n\t}\n\tWARN_ON(!list_empty(&mdsc->cap_delay_list));\n\tmutex_unlock(&mdsc->mutex);\n\n\tceph_cleanup_empty_realms(mdsc);\n\n\tcancel_delayed_work_sync(&mdsc->delayed_work); /* cancel timer */\n\n\tdout(\"stopped\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"root %p inode %p ino %llx.%llx\\n\"",
            "res",
            "res->d_inode",
            "ceph_vinop(res->d_inode)"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "res->d_inode"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "res"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_real_mount",
          "args": [
            "fsc",
            "path"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "770-828",
          "snippet": "static struct dentry *ceph_real_mount(struct ceph_fs_client *fsc,\n\t\t      const char *path)\n{\n\tint err;\n\tunsigned long started = jiffies;  /* note the start time */\n\tstruct dentry *root;\n\tint first = 0;   /* first vfsmount for this super_block */\n\n\tdout(\"mount start\\n\");\n\tmutex_lock(&fsc->client->mount_mutex);\n\n\terr = __ceph_open_session(fsc->client, started);\n\tif (err < 0)\n\t\tgoto out;\n\n\tdout(\"mount opening root\\n\");\n\troot = open_root_dentry(fsc, \"\", started);\n\tif (IS_ERR(root)) {\n\t\terr = PTR_ERR(root);\n\t\tgoto out;\n\t}\n\tif (fsc->sb->s_root) {\n\t\tdput(root);\n\t} else {\n\t\tfsc->sb->s_root = root;\n\t\tfirst = 1;\n\n\t\terr = ceph_fs_debugfs_init(fsc);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\t}\n\n\tif (path[0] == 0) {\n\t\tdget(root);\n\t} else {\n\t\tdout(\"mount opening base mountpoint\\n\");\n\t\troot = open_root_dentry(fsc, path, started);\n\t\tif (IS_ERR(root)) {\n\t\t\terr = PTR_ERR(root);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfsc->mount_state = CEPH_MOUNT_MOUNTED;\n\tdout(\"mount success\\n\");\n\tmutex_unlock(&fsc->client->mount_mutex);\n\treturn root;\n\nout:\n\tmutex_unlock(&fsc->client->mount_mutex);\n\treturn ERR_PTR(err);\n\nfail:\n\tif (first) {\n\t\tdput(fsc->sb->s_root);\n\t\tfsc->sb->s_root = NULL;\n\t}\n\tgoto out;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/string.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct dentry *ceph_real_mount(struct ceph_fs_client *fsc,\n\t\t      const char *path)\n{\n\tint err;\n\tunsigned long started = jiffies;  /* note the start time */\n\tstruct dentry *root;\n\tint first = 0;   /* first vfsmount for this super_block */\n\n\tdout(\"mount start\\n\");\n\tmutex_lock(&fsc->client->mount_mutex);\n\n\terr = __ceph_open_session(fsc->client, started);\n\tif (err < 0)\n\t\tgoto out;\n\n\tdout(\"mount opening root\\n\");\n\troot = open_root_dentry(fsc, \"\", started);\n\tif (IS_ERR(root)) {\n\t\terr = PTR_ERR(root);\n\t\tgoto out;\n\t}\n\tif (fsc->sb->s_root) {\n\t\tdput(root);\n\t} else {\n\t\tfsc->sb->s_root = root;\n\t\tfirst = 1;\n\n\t\terr = ceph_fs_debugfs_init(fsc);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\t}\n\n\tif (path[0] == 0) {\n\t\tdget(root);\n\t} else {\n\t\tdout(\"mount opening base mountpoint\\n\");\n\t\troot = open_root_dentry(fsc, path, started);\n\t\tif (IS_ERR(root)) {\n\t\t\terr = PTR_ERR(root);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfsc->mount_state = CEPH_MOUNT_MOUNTED;\n\tdout(\"mount success\\n\");\n\tmutex_unlock(&fsc->client->mount_mutex);\n\treturn root;\n\nout:\n\tmutex_unlock(&fsc->client->mount_mutex);\n\treturn ERR_PTR(err);\n\nfail:\n\tif (first) {\n\t\tdput(fsc->sb->s_root);\n\t\tfsc->sb->s_root = NULL;\n\t}\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_register_bdi",
          "args": [
            "sb",
            "fsc"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_register_bdi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "894-913",
          "snippet": "static int ceph_register_bdi(struct super_block *sb,\n\t\t\t     struct ceph_fs_client *fsc)\n{\n\tint err;\n\n\t/* set ra_pages based on rasize mount option? */\n\tif (fsc->mount_options->rasize >= PAGE_CACHE_SIZE)\n\t\tfsc->backing_dev_info.ra_pages =\n\t\t\t(fsc->mount_options->rasize + PAGE_CACHE_SIZE - 1)\n\t\t\t>> PAGE_SHIFT;\n\telse\n\t\tfsc->backing_dev_info.ra_pages =\n\t\t\tVM_MAX_READAHEAD * 1024 / PAGE_CACHE_SIZE;\n\n\terr = bdi_register(&fsc->backing_dev_info, NULL, \"ceph-%ld\",\n\t\t\t   atomic_long_inc_return(&bdi_seq));\n\tif (!err)\n\t\tsb->s_bdi = &fsc->backing_dev_info;\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/string.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_long_t bdi_seq = ATOMIC_LONG_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic atomic_long_t bdi_seq = ATOMIC_LONG_INIT(0);\n\nstatic int ceph_register_bdi(struct super_block *sb,\n\t\t\t     struct ceph_fs_client *fsc)\n{\n\tint err;\n\n\t/* set ra_pages based on rasize mount option? */\n\tif (fsc->mount_options->rasize >= PAGE_CACHE_SIZE)\n\t\tfsc->backing_dev_info.ra_pages =\n\t\t\t(fsc->mount_options->rasize + PAGE_CACHE_SIZE - 1)\n\t\t\t>> PAGE_SHIFT;\n\telse\n\t\tfsc->backing_dev_info.ra_pages =\n\t\t\tVM_MAX_READAHEAD * 1024 / PAGE_CACHE_SIZE;\n\n\terr = bdi_register(&fsc->backing_dev_info, NULL, \"ceph-%ld\",\n\t\t\t   atomic_long_inc_return(&bdi_seq));\n\tif (!err)\n\t\tsb->s_bdi = &fsc->backing_dev_info;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"get_sb using new client %p\\n\"",
            "fsc"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"get_sb got existing client %p\\n\"",
            "fsc"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "sb"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "sb"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sb"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sget",
          "args": [
            "fs_type",
            "compare_super",
            "ceph_set_super",
            "flags",
            "fsc"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_test_opt",
          "args": [
            "fsc->client",
            "NOSHARE"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_init",
          "args": [
            "fsc"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "3340-3389",
          "snippet": "int ceph_mdsc_init(struct ceph_fs_client *fsc)\n\n{\n\tstruct ceph_mds_client *mdsc;\n\n\tmdsc = kzalloc(sizeof(struct ceph_mds_client), GFP_NOFS);\n\tif (!mdsc)\n\t\treturn -ENOMEM;\n\tmdsc->fsc = fsc;\n\tfsc->mdsc = mdsc;\n\tmutex_init(&mdsc->mutex);\n\tmdsc->mdsmap = kzalloc(sizeof(*mdsc->mdsmap), GFP_NOFS);\n\tif (mdsc->mdsmap == NULL) {\n\t\tkfree(mdsc);\n\t\treturn -ENOMEM;\n\t}\n\n\tinit_completion(&mdsc->safe_umount_waiters);\n\tinit_waitqueue_head(&mdsc->session_close_wq);\n\tINIT_LIST_HEAD(&mdsc->waiting_for_map);\n\tmdsc->sessions = NULL;\n\tatomic_set(&mdsc->num_sessions, 0);\n\tmdsc->max_sessions = 0;\n\tmdsc->stopping = 0;\n\tinit_rwsem(&mdsc->snap_rwsem);\n\tmdsc->snap_realms = RB_ROOT;\n\tINIT_LIST_HEAD(&mdsc->snap_empty);\n\tspin_lock_init(&mdsc->snap_empty_lock);\n\tmdsc->last_tid = 0;\n\tmdsc->request_tree = RB_ROOT;\n\tINIT_DELAYED_WORK(&mdsc->delayed_work, delayed_work);\n\tmdsc->last_renew_caps = jiffies;\n\tINIT_LIST_HEAD(&mdsc->cap_delay_list);\n\tspin_lock_init(&mdsc->cap_delay_lock);\n\tINIT_LIST_HEAD(&mdsc->snap_flush_list);\n\tspin_lock_init(&mdsc->snap_flush_lock);\n\tmdsc->cap_flush_seq = 0;\n\tINIT_LIST_HEAD(&mdsc->cap_dirty);\n\tINIT_LIST_HEAD(&mdsc->cap_dirty_migrating);\n\tmdsc->num_cap_flushing = 0;\n\tspin_lock_init(&mdsc->cap_dirty_lock);\n\tinit_waitqueue_head(&mdsc->cap_flushing_wq);\n\tspin_lock_init(&mdsc->dentry_lru_lock);\n\tINIT_LIST_HEAD(&mdsc->dentry_lru);\n\n\tceph_caps_init(mdsc);\n\tceph_adjust_min_caps(mdsc, fsc->min_caps);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_mdsc_init(struct ceph_fs_client *fsc)\n\n{\n\tstruct ceph_mds_client *mdsc;\n\n\tmdsc = kzalloc(sizeof(struct ceph_mds_client), GFP_NOFS);\n\tif (!mdsc)\n\t\treturn -ENOMEM;\n\tmdsc->fsc = fsc;\n\tfsc->mdsc = mdsc;\n\tmutex_init(&mdsc->mutex);\n\tmdsc->mdsmap = kzalloc(sizeof(*mdsc->mdsmap), GFP_NOFS);\n\tif (mdsc->mdsmap == NULL) {\n\t\tkfree(mdsc);\n\t\treturn -ENOMEM;\n\t}\n\n\tinit_completion(&mdsc->safe_umount_waiters);\n\tinit_waitqueue_head(&mdsc->session_close_wq);\n\tINIT_LIST_HEAD(&mdsc->waiting_for_map);\n\tmdsc->sessions = NULL;\n\tatomic_set(&mdsc->num_sessions, 0);\n\tmdsc->max_sessions = 0;\n\tmdsc->stopping = 0;\n\tinit_rwsem(&mdsc->snap_rwsem);\n\tmdsc->snap_realms = RB_ROOT;\n\tINIT_LIST_HEAD(&mdsc->snap_empty);\n\tspin_lock_init(&mdsc->snap_empty_lock);\n\tmdsc->last_tid = 0;\n\tmdsc->request_tree = RB_ROOT;\n\tINIT_DELAYED_WORK(&mdsc->delayed_work, delayed_work);\n\tmdsc->last_renew_caps = jiffies;\n\tINIT_LIST_HEAD(&mdsc->cap_delay_list);\n\tspin_lock_init(&mdsc->cap_delay_lock);\n\tINIT_LIST_HEAD(&mdsc->snap_flush_list);\n\tspin_lock_init(&mdsc->snap_flush_lock);\n\tmdsc->cap_flush_seq = 0;\n\tINIT_LIST_HEAD(&mdsc->cap_dirty);\n\tINIT_LIST_HEAD(&mdsc->cap_dirty_migrating);\n\tmdsc->num_cap_flushing = 0;\n\tspin_lock_init(&mdsc->cap_dirty_lock);\n\tinit_waitqueue_head(&mdsc->cap_flushing_wq);\n\tspin_lock_init(&mdsc->dentry_lru_lock);\n\tINIT_LIST_HEAD(&mdsc->dentry_lru);\n\n\tceph_caps_init(mdsc);\n\tceph_adjust_min_caps(mdsc, fsc->min_caps);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_destroy_options",
          "args": [
            "opt"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_mount_options",
          "args": [
            "fsopt"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_mount_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "285-290",
          "snippet": "static void destroy_mount_options(struct ceph_mount_options *args)\n{\n\tdout(\"destroy_mount_options %p\\n\", args);\n\tkfree(args->snapdir_name);\n\tkfree(args);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/string.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void destroy_mount_options(struct ceph_mount_options *args)\n{\n\tdout(\"destroy_mount_options %p\\n\", args);\n\tkfree(args->snapdir_name);\n\tkfree(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "fsc"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fsc"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_fs_client",
          "args": [
            "fsopt",
            "opt"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "create_fs_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "505-590",
          "snippet": "static struct ceph_fs_client *create_fs_client(struct ceph_mount_options *fsopt,\n\t\t\t\t\tstruct ceph_options *opt)\n{\n\tstruct ceph_fs_client *fsc;\n\tconst u64 supported_features =\n\t\tCEPH_FEATURE_FLOCK |\n\t\tCEPH_FEATURE_DIRLAYOUTHASH |\n\t\tCEPH_FEATURE_MDS_INLINE_DATA;\n\tconst u64 required_features = 0;\n\tint page_count;\n\tsize_t size;\n\tint err = -ENOMEM;\n\n\tfsc = kzalloc(sizeof(*fsc), GFP_KERNEL);\n\tif (!fsc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfsc->client = ceph_create_client(opt, fsc, supported_features,\n\t\t\t\t\t required_features);\n\tif (IS_ERR(fsc->client)) {\n\t\terr = PTR_ERR(fsc->client);\n\t\tgoto fail;\n\t}\n\tfsc->client->extra_mon_dispatch = extra_mon_dispatch;\n\tfsc->client->monc.want_mdsmap = 1;\n\n\tfsc->mount_options = fsopt;\n\n\tfsc->sb = NULL;\n\tfsc->mount_state = CEPH_MOUNT_MOUNTING;\n\n\tatomic_long_set(&fsc->writeback_count, 0);\n\n\terr = bdi_init(&fsc->backing_dev_info);\n\tif (err < 0)\n\t\tgoto fail_client;\n\n\terr = -ENOMEM;\n\t/*\n\t * The number of concurrent works can be high but they don't need\n\t * to be processed in parallel, limit concurrency.\n\t */\n\tfsc->wb_wq = alloc_workqueue(\"ceph-writeback\", 0, 1);\n\tif (fsc->wb_wq == NULL)\n\t\tgoto fail_bdi;\n\tfsc->pg_inv_wq = alloc_workqueue(\"ceph-pg-invalid\", 0, 1);\n\tif (fsc->pg_inv_wq == NULL)\n\t\tgoto fail_wb_wq;\n\tfsc->trunc_wq = alloc_workqueue(\"ceph-trunc\", 0, 1);\n\tif (fsc->trunc_wq == NULL)\n\t\tgoto fail_pg_inv_wq;\n\n\t/* set up mempools */\n\terr = -ENOMEM;\n\tpage_count = fsc->mount_options->wsize >> PAGE_CACHE_SHIFT;\n\tsize = sizeof (struct page *) * (page_count ? page_count : 1);\n\tfsc->wb_pagevec_pool = mempool_create_kmalloc_pool(10, size);\n\tif (!fsc->wb_pagevec_pool)\n\t\tgoto fail_trunc_wq;\n\n\t/* setup fscache */\n\tif ((fsopt->flags & CEPH_MOUNT_OPT_FSCACHE) &&\n\t    (ceph_fscache_register_fs(fsc) != 0))\n\t\tgoto fail_fscache;\n\n\t/* caps */\n\tfsc->min_caps = fsopt->max_readdir;\n\n\treturn fsc;\n\nfail_fscache:\n\tceph_fscache_unregister_fs(fsc);\nfail_trunc_wq:\n\tdestroy_workqueue(fsc->trunc_wq);\nfail_pg_inv_wq:\n\tdestroy_workqueue(fsc->pg_inv_wq);\nfail_wb_wq:\n\tdestroy_workqueue(fsc->wb_wq);\nfail_bdi:\n\tbdi_destroy(&fsc->backing_dev_info);\nfail_client:\n\tceph_destroy_client(fsc->client);\nfail:\n\tkfree(fsc);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/string.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_fs_client *create_fs_client(struct ceph_mount_options *fsopt,\n\t\t\t\t\tstruct ceph_options *opt)\n{\n\tstruct ceph_fs_client *fsc;\n\tconst u64 supported_features =\n\t\tCEPH_FEATURE_FLOCK |\n\t\tCEPH_FEATURE_DIRLAYOUTHASH |\n\t\tCEPH_FEATURE_MDS_INLINE_DATA;\n\tconst u64 required_features = 0;\n\tint page_count;\n\tsize_t size;\n\tint err = -ENOMEM;\n\n\tfsc = kzalloc(sizeof(*fsc), GFP_KERNEL);\n\tif (!fsc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfsc->client = ceph_create_client(opt, fsc, supported_features,\n\t\t\t\t\t required_features);\n\tif (IS_ERR(fsc->client)) {\n\t\terr = PTR_ERR(fsc->client);\n\t\tgoto fail;\n\t}\n\tfsc->client->extra_mon_dispatch = extra_mon_dispatch;\n\tfsc->client->monc.want_mdsmap = 1;\n\n\tfsc->mount_options = fsopt;\n\n\tfsc->sb = NULL;\n\tfsc->mount_state = CEPH_MOUNT_MOUNTING;\n\n\tatomic_long_set(&fsc->writeback_count, 0);\n\n\terr = bdi_init(&fsc->backing_dev_info);\n\tif (err < 0)\n\t\tgoto fail_client;\n\n\terr = -ENOMEM;\n\t/*\n\t * The number of concurrent works can be high but they don't need\n\t * to be processed in parallel, limit concurrency.\n\t */\n\tfsc->wb_wq = alloc_workqueue(\"ceph-writeback\", 0, 1);\n\tif (fsc->wb_wq == NULL)\n\t\tgoto fail_bdi;\n\tfsc->pg_inv_wq = alloc_workqueue(\"ceph-pg-invalid\", 0, 1);\n\tif (fsc->pg_inv_wq == NULL)\n\t\tgoto fail_wb_wq;\n\tfsc->trunc_wq = alloc_workqueue(\"ceph-trunc\", 0, 1);\n\tif (fsc->trunc_wq == NULL)\n\t\tgoto fail_pg_inv_wq;\n\n\t/* set up mempools */\n\terr = -ENOMEM;\n\tpage_count = fsc->mount_options->wsize >> PAGE_CACHE_SHIFT;\n\tsize = sizeof (struct page *) * (page_count ? page_count : 1);\n\tfsc->wb_pagevec_pool = mempool_create_kmalloc_pool(10, size);\n\tif (!fsc->wb_pagevec_pool)\n\t\tgoto fail_trunc_wq;\n\n\t/* setup fscache */\n\tif ((fsopt->flags & CEPH_MOUNT_OPT_FSCACHE) &&\n\t    (ceph_fscache_register_fs(fsc) != 0))\n\t\tgoto fail_fscache;\n\n\t/* caps */\n\tfsc->min_caps = fsopt->max_readdir;\n\n\treturn fsc;\n\nfail_fscache:\n\tceph_fscache_unregister_fs(fsc);\nfail_trunc_wq:\n\tdestroy_workqueue(fsc->trunc_wq);\nfail_pg_inv_wq:\n\tdestroy_workqueue(fsc->pg_inv_wq);\nfail_wb_wq:\n\tdestroy_workqueue(fsc->wb_wq);\nfail_bdi:\n\tbdi_destroy(&fsc->backing_dev_info);\nfail_client:\n\tceph_destroy_client(fsc->client);\nfail:\n\tkfree(fsc);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_mount_options",
          "args": [
            "&fsopt",
            "&opt",
            "flags",
            "data",
            "dev_name",
            "&path"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "parse_mount_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "323-398",
          "snippet": "static int parse_mount_options(struct ceph_mount_options **pfsopt,\n\t\t\t       struct ceph_options **popt,\n\t\t\t       int flags, char *options,\n\t\t\t       const char *dev_name,\n\t\t\t       const char **path)\n{\n\tstruct ceph_mount_options *fsopt;\n\tconst char *dev_name_end;\n\tint err;\n\n\tif (!dev_name || !*dev_name)\n\t\treturn -EINVAL;\n\n\tfsopt = kzalloc(sizeof(*fsopt), GFP_KERNEL);\n\tif (!fsopt)\n\t\treturn -ENOMEM;\n\n\tdout(\"parse_mount_options %p, dev_name '%s'\\n\", fsopt, dev_name);\n\n\tfsopt->sb_flags = flags;\n\tfsopt->flags = CEPH_MOUNT_OPT_DEFAULT;\n\n\tfsopt->rsize = CEPH_RSIZE_DEFAULT;\n\tfsopt->rasize = CEPH_RASIZE_DEFAULT;\n\tfsopt->snapdir_name = kstrdup(CEPH_SNAPDIRNAME_DEFAULT, GFP_KERNEL);\n\tfsopt->caps_wanted_delay_min = CEPH_CAPS_WANTED_DELAY_MIN_DEFAULT;\n\tfsopt->caps_wanted_delay_max = CEPH_CAPS_WANTED_DELAY_MAX_DEFAULT;\n\tfsopt->cap_release_safety = CEPH_CAP_RELEASE_SAFETY_DEFAULT;\n\tfsopt->max_readdir = CEPH_MAX_READDIR_DEFAULT;\n\tfsopt->max_readdir_bytes = CEPH_MAX_READDIR_BYTES_DEFAULT;\n\tfsopt->congestion_kb = default_congestion_kb();\n\n\t/*\n\t * Distinguish the server list from the path in \"dev_name\".\n\t * Internally we do not include the leading '/' in the path.\n\t *\n\t * \"dev_name\" will look like:\n\t *     <server_spec>[,<server_spec>...]:[<path>]\n\t * where\n\t *     <server_spec> is <ip>[:<port>]\n\t *     <path> is optional, but if present must begin with '/'\n\t */\n\tdev_name_end = strchr(dev_name, '/');\n\tif (dev_name_end) {\n\t\t/* skip over leading '/' for path */\n\t\t*path = dev_name_end + 1;\n\t} else {\n\t\t/* path is empty */\n\t\tdev_name_end = dev_name + strlen(dev_name);\n\t\t*path = dev_name_end;\n\t}\n\terr = -EINVAL;\n\tdev_name_end--;\t\t/* back up to ':' separator */\n\tif (dev_name_end < dev_name || *dev_name_end != ':') {\n\t\tpr_err(\"device name is missing path (no : separator in %s)\\n\",\n\t\t\t\tdev_name);\n\t\tgoto out;\n\t}\n\tdout(\"device name '%.*s'\\n\", (int)(dev_name_end - dev_name), dev_name);\n\tdout(\"server path '%s'\\n\", *path);\n\n\t*popt = ceph_parse_options(options, dev_name, dev_name_end,\n\t\t\t\t parse_fsopt_token, (void *)fsopt);\n\tif (IS_ERR(*popt)) {\n\t\terr = PTR_ERR(*popt);\n\t\tgoto out;\n\t}\n\n\t/* success */\n\t*pfsopt = fsopt;\n\treturn 0;\n\nout:\n\tdestroy_mount_options(fsopt);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/string.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int parse_mount_options(struct ceph_mount_options **pfsopt,\n\t\t\t       struct ceph_options **popt,\n\t\t\t       int flags, char *options,\n\t\t\t       const char *dev_name,\n\t\t\t       const char **path)\n{\n\tstruct ceph_mount_options *fsopt;\n\tconst char *dev_name_end;\n\tint err;\n\n\tif (!dev_name || !*dev_name)\n\t\treturn -EINVAL;\n\n\tfsopt = kzalloc(sizeof(*fsopt), GFP_KERNEL);\n\tif (!fsopt)\n\t\treturn -ENOMEM;\n\n\tdout(\"parse_mount_options %p, dev_name '%s'\\n\", fsopt, dev_name);\n\n\tfsopt->sb_flags = flags;\n\tfsopt->flags = CEPH_MOUNT_OPT_DEFAULT;\n\n\tfsopt->rsize = CEPH_RSIZE_DEFAULT;\n\tfsopt->rasize = CEPH_RASIZE_DEFAULT;\n\tfsopt->snapdir_name = kstrdup(CEPH_SNAPDIRNAME_DEFAULT, GFP_KERNEL);\n\tfsopt->caps_wanted_delay_min = CEPH_CAPS_WANTED_DELAY_MIN_DEFAULT;\n\tfsopt->caps_wanted_delay_max = CEPH_CAPS_WANTED_DELAY_MAX_DEFAULT;\n\tfsopt->cap_release_safety = CEPH_CAP_RELEASE_SAFETY_DEFAULT;\n\tfsopt->max_readdir = CEPH_MAX_READDIR_DEFAULT;\n\tfsopt->max_readdir_bytes = CEPH_MAX_READDIR_BYTES_DEFAULT;\n\tfsopt->congestion_kb = default_congestion_kb();\n\n\t/*\n\t * Distinguish the server list from the path in \"dev_name\".\n\t * Internally we do not include the leading '/' in the path.\n\t *\n\t * \"dev_name\" will look like:\n\t *     <server_spec>[,<server_spec>...]:[<path>]\n\t * where\n\t *     <server_spec> is <ip>[:<port>]\n\t *     <path> is optional, but if present must begin with '/'\n\t */\n\tdev_name_end = strchr(dev_name, '/');\n\tif (dev_name_end) {\n\t\t/* skip over leading '/' for path */\n\t\t*path = dev_name_end + 1;\n\t} else {\n\t\t/* path is empty */\n\t\tdev_name_end = dev_name + strlen(dev_name);\n\t\t*path = dev_name_end;\n\t}\n\terr = -EINVAL;\n\tdev_name_end--;\t\t/* back up to ':' separator */\n\tif (dev_name_end < dev_name || *dev_name_end != ':') {\n\t\tpr_err(\"device name is missing path (no : separator in %s)\\n\",\n\t\t\t\tdev_name);\n\t\tgoto out;\n\t}\n\tdout(\"device name '%.*s'\\n\", (int)(dev_name_end - dev_name), dev_name);\n\tdout(\"server path '%s'\\n\", *path);\n\n\t*popt = ceph_parse_options(options, dev_name, dev_name_end,\n\t\t\t\t parse_fsopt_token, (void *)fsopt);\n\tif (IS_ERR(*popt)) {\n\t\terr = PTR_ERR(*popt);\n\t\tgoto out;\n\t}\n\n\t/* success */\n\t*pfsopt = fsopt;\n\treturn 0;\n\nout:\n\tdestroy_mount_options(fsopt);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"ceph_mount\\n\""
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct dentry *ceph_mount(struct file_system_type *fs_type,\n\t\t       int flags, const char *dev_name, void *data)\n{\n\tstruct super_block *sb;\n\tstruct ceph_fs_client *fsc;\n\tstruct dentry *res;\n\tint err;\n\tint (*compare_super)(struct super_block *, void *) = ceph_compare_super;\n\tconst char *path = NULL;\n\tstruct ceph_mount_options *fsopt = NULL;\n\tstruct ceph_options *opt = NULL;\n\n\tdout(\"ceph_mount\\n\");\n\n#ifdef CONFIG_CEPH_FS_POSIX_ACL\n\tflags |= MS_POSIXACL;\n#endif\n\terr = parse_mount_options(&fsopt, &opt, flags, data, dev_name, &path);\n\tif (err < 0) {\n\t\tres = ERR_PTR(err);\n\t\tgoto out_final;\n\t}\n\n\t/* create client (which we may/may not use) */\n\tfsc = create_fs_client(fsopt, opt);\n\tif (IS_ERR(fsc)) {\n\t\tres = ERR_CAST(fsc);\n\t\tdestroy_mount_options(fsopt);\n\t\tceph_destroy_options(opt);\n\t\tgoto out_final;\n\t}\n\n\terr = ceph_mdsc_init(fsc);\n\tif (err < 0) {\n\t\tres = ERR_PTR(err);\n\t\tgoto out;\n\t}\n\n\tif (ceph_test_opt(fsc->client, NOSHARE))\n\t\tcompare_super = NULL;\n\tsb = sget(fs_type, compare_super, ceph_set_super, flags, fsc);\n\tif (IS_ERR(sb)) {\n\t\tres = ERR_CAST(sb);\n\t\tgoto out;\n\t}\n\n\tif (ceph_sb_to_client(sb) != fsc) {\n\t\tceph_mdsc_destroy(fsc);\n\t\tdestroy_fs_client(fsc);\n\t\tfsc = ceph_sb_to_client(sb);\n\t\tdout(\"get_sb got existing client %p\\n\", fsc);\n\t} else {\n\t\tdout(\"get_sb using new client %p\\n\", fsc);\n\t\terr = ceph_register_bdi(sb, fsc);\n\t\tif (err < 0) {\n\t\t\tres = ERR_PTR(err);\n\t\t\tgoto out_splat;\n\t\t}\n\t}\n\n\tres = ceph_real_mount(fsc, path);\n\tif (IS_ERR(res))\n\t\tgoto out_splat;\n\tdout(\"root %p inode %p ino %llx.%llx\\n\", res,\n\t     res->d_inode, ceph_vinop(res->d_inode));\n\treturn res;\n\nout_splat:\n\tceph_mdsc_close_sessions(fsc->mdsc);\n\tdeactivate_locked_super(sb);\n\tgoto out_final;\n\nout:\n\tceph_mdsc_destroy(fsc);\n\tdestroy_fs_client(fsc);\nout_final:\n\tdout(\"ceph_mount fail %ld\\n\", PTR_ERR(res));\n\treturn res;\n}"
  },
  {
    "function_name": "ceph_register_bdi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
    "lines": "894-913",
    "snippet": "static int ceph_register_bdi(struct super_block *sb,\n\t\t\t     struct ceph_fs_client *fsc)\n{\n\tint err;\n\n\t/* set ra_pages based on rasize mount option? */\n\tif (fsc->mount_options->rasize >= PAGE_CACHE_SIZE)\n\t\tfsc->backing_dev_info.ra_pages =\n\t\t\t(fsc->mount_options->rasize + PAGE_CACHE_SIZE - 1)\n\t\t\t>> PAGE_SHIFT;\n\telse\n\t\tfsc->backing_dev_info.ra_pages =\n\t\t\tVM_MAX_READAHEAD * 1024 / PAGE_CACHE_SIZE;\n\n\terr = bdi_register(&fsc->backing_dev_info, NULL, \"ceph-%ld\",\n\t\t\t   atomic_long_inc_return(&bdi_seq));\n\tif (!err)\n\t\tsb->s_bdi = &fsc->backing_dev_info;\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/mon_client.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/string.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/in6.h>",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_long_t bdi_seq = ATOMIC_LONG_INIT(0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdi_register",
          "args": [
            "&fsc->backing_dev_info",
            "NULL",
            "\"ceph-%ld\"",
            "atomic_long_inc_return(&bdi_seq)"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_inc_return",
          "args": [
            "&bdi_seq"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic atomic_long_t bdi_seq = ATOMIC_LONG_INIT(0);\n\nstatic int ceph_register_bdi(struct super_block *sb,\n\t\t\t     struct ceph_fs_client *fsc)\n{\n\tint err;\n\n\t/* set ra_pages based on rasize mount option? */\n\tif (fsc->mount_options->rasize >= PAGE_CACHE_SIZE)\n\t\tfsc->backing_dev_info.ra_pages =\n\t\t\t(fsc->mount_options->rasize + PAGE_CACHE_SIZE - 1)\n\t\t\t>> PAGE_SHIFT;\n\telse\n\t\tfsc->backing_dev_info.ra_pages =\n\t\t\tVM_MAX_READAHEAD * 1024 / PAGE_CACHE_SIZE;\n\n\terr = bdi_register(&fsc->backing_dev_info, NULL, \"ceph-%ld\",\n\t\t\t   atomic_long_inc_return(&bdi_seq));\n\tif (!err)\n\t\tsb->s_bdi = &fsc->backing_dev_info;\n\treturn err;\n}"
  },
  {
    "function_name": "ceph_compare_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
    "lines": "864-887",
    "snippet": "static int ceph_compare_super(struct super_block *sb, void *data)\n{\n\tstruct ceph_fs_client *new = data;\n\tstruct ceph_mount_options *fsopt = new->mount_options;\n\tstruct ceph_options *opt = new->client->options;\n\tstruct ceph_fs_client *other = ceph_sb_to_client(sb);\n\n\tdout(\"ceph_compare_super %p\\n\", sb);\n\n\tif (compare_mount_options(fsopt, opt, other)) {\n\t\tdout(\"monitor(s)/mount options don't match\\n\");\n\t\treturn 0;\n\t}\n\tif ((opt->flags & CEPH_OPT_FSID) &&\n\t    ceph_fsid_compare(&opt->fsid, &other->client->fsid)) {\n\t\tdout(\"fsid doesn't match\\n\");\n\t\treturn 0;\n\t}\n\tif (fsopt->sb_flags != other->mount_options->sb_flags) {\n\t\tdout(\"flags differ\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/mon_client.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/string.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/in6.h>",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"flags differ\\n\""
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"fsid doesn't match\\n\""
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_fsid_compare",
          "args": [
            "&opt->fsid",
            "&other->client->fsid"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"monitor(s)/mount options don't match\\n\""
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compare_mount_options",
          "args": [
            "fsopt",
            "opt",
            "other"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "compare_mount_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "303-321",
          "snippet": "static int compare_mount_options(struct ceph_mount_options *new_fsopt,\n\t\t\t\t struct ceph_options *new_opt,\n\t\t\t\t struct ceph_fs_client *fsc)\n{\n\tstruct ceph_mount_options *fsopt1 = new_fsopt;\n\tstruct ceph_mount_options *fsopt2 = fsc->mount_options;\n\tint ofs = offsetof(struct ceph_mount_options, snapdir_name);\n\tint ret;\n\n\tret = memcmp(fsopt1, fsopt2, ofs);\n\tif (ret)\n\t\treturn ret;\n\n\tret = strcmp_null(fsopt1->snapdir_name, fsopt2->snapdir_name);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ceph_compare_options(new_opt, fsc->client);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/string.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int compare_mount_options(struct ceph_mount_options *new_fsopt,\n\t\t\t\t struct ceph_options *new_opt,\n\t\t\t\t struct ceph_fs_client *fsc)\n{\n\tstruct ceph_mount_options *fsopt1 = new_fsopt;\n\tstruct ceph_mount_options *fsopt2 = fsc->mount_options;\n\tint ofs = offsetof(struct ceph_mount_options, snapdir_name);\n\tint ret;\n\n\tret = memcmp(fsopt1, fsopt2, ofs);\n\tif (ret)\n\t\treturn ret;\n\n\tret = strcmp_null(fsopt1->snapdir_name, fsopt2->snapdir_name);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ceph_compare_options(new_opt, fsc->client);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"ceph_compare_super %p\\n\"",
            "sb"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "sb"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_compare_super(struct super_block *sb, void *data)\n{\n\tstruct ceph_fs_client *new = data;\n\tstruct ceph_mount_options *fsopt = new->mount_options;\n\tstruct ceph_options *opt = new->client->options;\n\tstruct ceph_fs_client *other = ceph_sb_to_client(sb);\n\n\tdout(\"ceph_compare_super %p\\n\", sb);\n\n\tif (compare_mount_options(fsopt, opt, other)) {\n\t\tdout(\"monitor(s)/mount options don't match\\n\");\n\t\treturn 0;\n\t}\n\tif ((opt->flags & CEPH_OPT_FSID) &&\n\t    ceph_fsid_compare(&opt->fsid, &other->client->fsid)) {\n\t\tdout(\"fsid doesn't match\\n\");\n\t\treturn 0;\n\t}\n\tif (fsopt->sb_flags != other->mount_options->sb_flags) {\n\t\tdout(\"flags differ\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "ceph_set_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
    "lines": "830-859",
    "snippet": "static int ceph_set_super(struct super_block *s, void *data)\n{\n\tstruct ceph_fs_client *fsc = data;\n\tint ret;\n\n\tdout(\"set_super %p data %p\\n\", s, data);\n\n\ts->s_flags = fsc->mount_options->sb_flags;\n\ts->s_maxbytes = 1ULL << 40;  /* temp value until we get mdsmap */\n\n\ts->s_xattr = ceph_xattr_handlers;\n\ts->s_fs_info = fsc;\n\tfsc->sb = s;\n\n\ts->s_op = &ceph_super_ops;\n\ts->s_export_op = &ceph_export_ops;\n\n\ts->s_time_gran = 1000;  /* 1000 ns == 1 us */\n\n\tret = set_anon_super(s, NULL);  /* what is that second arg for? */\n\tif (ret != 0)\n\t\tgoto fail;\n\n\treturn ret;\n\nfail:\n\ts->s_fs_info = NULL;\n\tfsc->sb = NULL;\n\treturn ret;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/mon_client.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/string.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/in6.h>",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct super_operations ceph_super_ops = {\n\t.alloc_inode\t= ceph_alloc_inode,\n\t.destroy_inode\t= ceph_destroy_inode,\n\t.write_inode    = ceph_write_inode,\n\t.drop_inode\t= ceph_drop_inode,\n\t.sync_fs        = ceph_sync_fs,\n\t.put_super\t= ceph_put_super,\n\t.show_options   = ceph_show_options,\n\t.statfs\t\t= ceph_statfs,\n\t.umount_begin   = ceph_umount_begin,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_anon_super",
          "args": [
            "s",
            "NULL"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"set_super %p data %p\\n\"",
            "s",
            "data"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic const struct super_operations ceph_super_ops = {\n\t.alloc_inode\t= ceph_alloc_inode,\n\t.destroy_inode\t= ceph_destroy_inode,\n\t.write_inode    = ceph_write_inode,\n\t.drop_inode\t= ceph_drop_inode,\n\t.sync_fs        = ceph_sync_fs,\n\t.put_super\t= ceph_put_super,\n\t.show_options   = ceph_show_options,\n\t.statfs\t\t= ceph_statfs,\n\t.umount_begin   = ceph_umount_begin,\n};\n\nstatic int ceph_set_super(struct super_block *s, void *data)\n{\n\tstruct ceph_fs_client *fsc = data;\n\tint ret;\n\n\tdout(\"set_super %p data %p\\n\", s, data);\n\n\ts->s_flags = fsc->mount_options->sb_flags;\n\ts->s_maxbytes = 1ULL << 40;  /* temp value until we get mdsmap */\n\n\ts->s_xattr = ceph_xattr_handlers;\n\ts->s_fs_info = fsc;\n\tfsc->sb = s;\n\n\ts->s_op = &ceph_super_ops;\n\ts->s_export_op = &ceph_export_ops;\n\n\ts->s_time_gran = 1000;  /* 1000 ns == 1 us */\n\n\tret = set_anon_super(s, NULL);  /* what is that second arg for? */\n\tif (ret != 0)\n\t\tgoto fail;\n\n\treturn ret;\n\nfail:\n\ts->s_fs_info = NULL;\n\tfsc->sb = NULL;\n\treturn ret;\n}"
  },
  {
    "function_name": "ceph_real_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
    "lines": "770-828",
    "snippet": "static struct dentry *ceph_real_mount(struct ceph_fs_client *fsc,\n\t\t      const char *path)\n{\n\tint err;\n\tunsigned long started = jiffies;  /* note the start time */\n\tstruct dentry *root;\n\tint first = 0;   /* first vfsmount for this super_block */\n\n\tdout(\"mount start\\n\");\n\tmutex_lock(&fsc->client->mount_mutex);\n\n\terr = __ceph_open_session(fsc->client, started);\n\tif (err < 0)\n\t\tgoto out;\n\n\tdout(\"mount opening root\\n\");\n\troot = open_root_dentry(fsc, \"\", started);\n\tif (IS_ERR(root)) {\n\t\terr = PTR_ERR(root);\n\t\tgoto out;\n\t}\n\tif (fsc->sb->s_root) {\n\t\tdput(root);\n\t} else {\n\t\tfsc->sb->s_root = root;\n\t\tfirst = 1;\n\n\t\terr = ceph_fs_debugfs_init(fsc);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\t}\n\n\tif (path[0] == 0) {\n\t\tdget(root);\n\t} else {\n\t\tdout(\"mount opening base mountpoint\\n\");\n\t\troot = open_root_dentry(fsc, path, started);\n\t\tif (IS_ERR(root)) {\n\t\t\terr = PTR_ERR(root);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfsc->mount_state = CEPH_MOUNT_MOUNTED;\n\tdout(\"mount success\\n\");\n\tmutex_unlock(&fsc->client->mount_mutex);\n\treturn root;\n\nout:\n\tmutex_unlock(&fsc->client->mount_mutex);\n\treturn ERR_PTR(err);\n\nfail:\n\tif (first) {\n\t\tdput(fsc->sb->s_root);\n\t\tfsc->sb->s_root = NULL;\n\t}\n\tgoto out;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/mon_client.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/string.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/in6.h>",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "fsc->sb->s_root"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fsc->client->mount_mutex"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fsc->client->mount_mutex"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"mount success\\n\""
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "root"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_root_dentry",
          "args": [
            "fsc",
            "path",
            "started"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "open_root_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "718-762",
          "snippet": "static struct dentry *open_root_dentry(struct ceph_fs_client *fsc,\n\t\t\t\t       const char *path,\n\t\t\t\t       unsigned long started)\n{\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req = NULL;\n\tint err;\n\tstruct dentry *root;\n\n\t/* open dir */\n\tdout(\"open_root_inode opening '%s'\\n\", path);\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_GETATTR, USE_ANY_MDS);\n\tif (IS_ERR(req))\n\t\treturn ERR_CAST(req);\n\treq->r_path1 = kstrdup(path, GFP_NOFS);\n\treq->r_ino1.ino = CEPH_INO_ROOT;\n\treq->r_ino1.snap = CEPH_NOSNAP;\n\treq->r_started = started;\n\treq->r_timeout = fsc->client->options->mount_timeout * HZ;\n\treq->r_args.getattr.mask = cpu_to_le32(CEPH_STAT_CAP_INODE);\n\treq->r_num_caps = 2;\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tif (err == 0) {\n\t\tstruct inode *inode = req->r_target_inode;\n\t\treq->r_target_inode = NULL;\n\t\tdout(\"open_root_inode success\\n\");\n\t\tif (ceph_ino(inode) == CEPH_INO_ROOT &&\n\t\t    fsc->sb->s_root == NULL) {\n\t\t\troot = d_make_root(inode);\n\t\t\tif (!root) {\n\t\t\t\troot = ERR_PTR(-ENOMEM);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\troot = d_obtain_root(inode);\n\t\t}\n\t\tceph_init_dentry(root);\n\t\tdout(\"open_root_inode success, root dentry is %p\\n\", root);\n\t} else {\n\t\troot = ERR_PTR(err);\n\t}\nout:\n\tceph_mdsc_put_request(req);\n\treturn root;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/string.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct dentry *open_root_dentry(struct ceph_fs_client *fsc,\n\t\t\t\t       const char *path,\n\t\t\t\t       unsigned long started)\n{\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req = NULL;\n\tint err;\n\tstruct dentry *root;\n\n\t/* open dir */\n\tdout(\"open_root_inode opening '%s'\\n\", path);\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_GETATTR, USE_ANY_MDS);\n\tif (IS_ERR(req))\n\t\treturn ERR_CAST(req);\n\treq->r_path1 = kstrdup(path, GFP_NOFS);\n\treq->r_ino1.ino = CEPH_INO_ROOT;\n\treq->r_ino1.snap = CEPH_NOSNAP;\n\treq->r_started = started;\n\treq->r_timeout = fsc->client->options->mount_timeout * HZ;\n\treq->r_args.getattr.mask = cpu_to_le32(CEPH_STAT_CAP_INODE);\n\treq->r_num_caps = 2;\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tif (err == 0) {\n\t\tstruct inode *inode = req->r_target_inode;\n\t\treq->r_target_inode = NULL;\n\t\tdout(\"open_root_inode success\\n\");\n\t\tif (ceph_ino(inode) == CEPH_INO_ROOT &&\n\t\t    fsc->sb->s_root == NULL) {\n\t\t\troot = d_make_root(inode);\n\t\t\tif (!root) {\n\t\t\t\troot = ERR_PTR(-ENOMEM);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\troot = d_obtain_root(inode);\n\t\t}\n\t\tceph_init_dentry(root);\n\t\tdout(\"open_root_inode success, root dentry is %p\\n\", root);\n\t} else {\n\t\troot = ERR_PTR(err);\n\t}\nout:\n\tceph_mdsc_put_request(req);\n\treturn root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"mount opening base mountpoint\\n\""
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "root"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_fs_debugfs_init",
          "args": [
            "fsc"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fs_debugfs_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/debugfs.c",
          "lines": "312-315",
          "snippet": "int ceph_fs_debugfs_init(struct ceph_fs_client *fsc)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/device.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/libceph.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_fs_debugfs_init(struct ceph_fs_client *fsc)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "root"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"mount opening root\\n\""
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_open_session",
          "args": [
            "fsc->client",
            "started"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fsc->client->mount_mutex"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"mount start\\n\""
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct dentry *ceph_real_mount(struct ceph_fs_client *fsc,\n\t\t      const char *path)\n{\n\tint err;\n\tunsigned long started = jiffies;  /* note the start time */\n\tstruct dentry *root;\n\tint first = 0;   /* first vfsmount for this super_block */\n\n\tdout(\"mount start\\n\");\n\tmutex_lock(&fsc->client->mount_mutex);\n\n\terr = __ceph_open_session(fsc->client, started);\n\tif (err < 0)\n\t\tgoto out;\n\n\tdout(\"mount opening root\\n\");\n\troot = open_root_dentry(fsc, \"\", started);\n\tif (IS_ERR(root)) {\n\t\terr = PTR_ERR(root);\n\t\tgoto out;\n\t}\n\tif (fsc->sb->s_root) {\n\t\tdput(root);\n\t} else {\n\t\tfsc->sb->s_root = root;\n\t\tfirst = 1;\n\n\t\terr = ceph_fs_debugfs_init(fsc);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\t}\n\n\tif (path[0] == 0) {\n\t\tdget(root);\n\t} else {\n\t\tdout(\"mount opening base mountpoint\\n\");\n\t\troot = open_root_dentry(fsc, path, started);\n\t\tif (IS_ERR(root)) {\n\t\t\terr = PTR_ERR(root);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfsc->mount_state = CEPH_MOUNT_MOUNTED;\n\tdout(\"mount success\\n\");\n\tmutex_unlock(&fsc->client->mount_mutex);\n\treturn root;\n\nout:\n\tmutex_unlock(&fsc->client->mount_mutex);\n\treturn ERR_PTR(err);\n\nfail:\n\tif (first) {\n\t\tdput(fsc->sb->s_root);\n\t\tfsc->sb->s_root = NULL;\n\t}\n\tgoto out;\n}"
  },
  {
    "function_name": "open_root_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
    "lines": "718-762",
    "snippet": "static struct dentry *open_root_dentry(struct ceph_fs_client *fsc,\n\t\t\t\t       const char *path,\n\t\t\t\t       unsigned long started)\n{\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req = NULL;\n\tint err;\n\tstruct dentry *root;\n\n\t/* open dir */\n\tdout(\"open_root_inode opening '%s'\\n\", path);\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_GETATTR, USE_ANY_MDS);\n\tif (IS_ERR(req))\n\t\treturn ERR_CAST(req);\n\treq->r_path1 = kstrdup(path, GFP_NOFS);\n\treq->r_ino1.ino = CEPH_INO_ROOT;\n\treq->r_ino1.snap = CEPH_NOSNAP;\n\treq->r_started = started;\n\treq->r_timeout = fsc->client->options->mount_timeout * HZ;\n\treq->r_args.getattr.mask = cpu_to_le32(CEPH_STAT_CAP_INODE);\n\treq->r_num_caps = 2;\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tif (err == 0) {\n\t\tstruct inode *inode = req->r_target_inode;\n\t\treq->r_target_inode = NULL;\n\t\tdout(\"open_root_inode success\\n\");\n\t\tif (ceph_ino(inode) == CEPH_INO_ROOT &&\n\t\t    fsc->sb->s_root == NULL) {\n\t\t\troot = d_make_root(inode);\n\t\t\tif (!root) {\n\t\t\t\troot = ERR_PTR(-ENOMEM);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\troot = d_obtain_root(inode);\n\t\t}\n\t\tceph_init_dentry(root);\n\t\tdout(\"open_root_inode success, root dentry is %p\\n\", root);\n\t} else {\n\t\troot = ERR_PTR(err);\n\t}\nout:\n\tceph_mdsc_put_request(req);\n\treturn root;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/mon_client.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/string.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/in6.h>",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_mdsc_put_request",
          "args": [
            "req"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.h",
          "lines": "377-380",
          "snippet": "static inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}",
          "includes": [
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mdsmap.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kref.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/auth.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/types.h>\n#include <linux/spinlock.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kref.h>\n#include <linux/completion.h>\n\nstatic inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"open_root_inode success, root dentry is %p\\n\"",
            "root"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_init_dentry",
          "args": [
            "root"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_init_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/dir.c",
          "lines": "34-69",
          "snippet": "int ceph_init_dentry(struct dentry *dentry)\n{\n\tstruct ceph_dentry_info *di;\n\n\tif (dentry->d_fsdata)\n\t\treturn 0;\n\n\tdi = kmem_cache_alloc(ceph_dentry_cachep, GFP_NOFS | __GFP_ZERO);\n\tif (!di)\n\t\treturn -ENOMEM;          /* oh well */\n\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_fsdata) {\n\t\t/* lost a race */\n\t\tkmem_cache_free(ceph_dentry_cachep, di);\n\t\tgoto out_unlock;\n\t}\n\n\tif (ceph_snap(dentry->d_parent->d_inode) == CEPH_NOSNAP)\n\t\td_set_d_op(dentry, &ceph_dentry_ops);\n\telse if (ceph_snap(dentry->d_parent->d_inode) == CEPH_SNAPDIR)\n\t\td_set_d_op(dentry, &ceph_snapdir_dentry_ops);\n\telse\n\t\td_set_d_op(dentry, &ceph_snap_dentry_ops);\n\n\tdi->dentry = dentry;\n\tdi->lease_session = NULL;\n\tdentry->d_time = jiffies;\n\t/* avoid reordering d_fsdata setup so that the check above is safe */\n\tsmp_mb();\n\tdentry->d_fsdata = di;\n\tceph_dentry_lru_add(dentry);\nout_unlock:\n\tspin_unlock(&dentry->d_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct dentry_operations ceph_dentry_ops;",
            "const struct dentry_operations ceph_dentry_ops = {\n\t.d_revalidate = ceph_d_revalidate,\n\t.d_release = ceph_d_release,\n\t.d_prune = ceph_d_prune,\n};",
            "const struct dentry_operations ceph_snapdir_dentry_ops = {\n\t.d_revalidate = ceph_snapdir_d_revalidate,\n\t.d_release = ceph_d_release,\n};",
            "const struct dentry_operations ceph_snap_dentry_ops = {\n\t.d_release = ceph_d_release,\n\t.d_prune = ceph_d_prune,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/fs_struct.h>\n#include <linux/spinlock.h>\n#include <linux/ceph/ceph_debug.h>\n\nconst struct dentry_operations ceph_dentry_ops;\nconst struct dentry_operations ceph_dentry_ops = {\n\t.d_revalidate = ceph_d_revalidate,\n\t.d_release = ceph_d_release,\n\t.d_prune = ceph_d_prune,\n};\nconst struct dentry_operations ceph_snapdir_dentry_ops = {\n\t.d_revalidate = ceph_snapdir_d_revalidate,\n\t.d_release = ceph_d_release,\n};\nconst struct dentry_operations ceph_snap_dentry_ops = {\n\t.d_release = ceph_d_release,\n\t.d_prune = ceph_d_prune,\n};\n\nint ceph_init_dentry(struct dentry *dentry)\n{\n\tstruct ceph_dentry_info *di;\n\n\tif (dentry->d_fsdata)\n\t\treturn 0;\n\n\tdi = kmem_cache_alloc(ceph_dentry_cachep, GFP_NOFS | __GFP_ZERO);\n\tif (!di)\n\t\treturn -ENOMEM;          /* oh well */\n\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_fsdata) {\n\t\t/* lost a race */\n\t\tkmem_cache_free(ceph_dentry_cachep, di);\n\t\tgoto out_unlock;\n\t}\n\n\tif (ceph_snap(dentry->d_parent->d_inode) == CEPH_NOSNAP)\n\t\td_set_d_op(dentry, &ceph_dentry_ops);\n\telse if (ceph_snap(dentry->d_parent->d_inode) == CEPH_SNAPDIR)\n\t\td_set_d_op(dentry, &ceph_snapdir_dentry_ops);\n\telse\n\t\td_set_d_op(dentry, &ceph_snap_dentry_ops);\n\n\tdi->dentry = dentry;\n\tdi->lease_session = NULL;\n\tdentry->d_time = jiffies;\n\t/* avoid reordering d_fsdata setup so that the check above is safe */\n\tsmp_mb();\n\tdentry->d_fsdata = di;\n\tceph_dentry_lru_add(dentry);\nout_unlock:\n\tspin_unlock(&dentry->d_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_obtain_root",
          "args": [
            "inode"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1998-2001",
          "snippet": "struct dentry *d_obtain_root(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_obtain_root(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "inode"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_ino",
          "args": [
            "inode"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "624-628",
          "snippet": "static void ceph_inode_init_once(void *foo)\n{\n\tstruct ceph_inode_info *ci = foo;\n\tinode_init_once(&ci->vfs_inode);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/string.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void ceph_inode_init_once(void *foo)\n{\n\tstruct ceph_inode_info *ci = foo;\n\tinode_init_once(&ci->vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"open_root_inode success\\n\""
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_do_request",
          "args": [
            "mdsc",
            "NULL",
            "req"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_do_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2212-2284",
          "snippet": "int ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nint ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "CEPH_STAT_CAP_INODE"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "path",
            "GFP_NOFS"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "req"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_create_request",
          "args": [
            "mdsc",
            "CEPH_MDS_OP_GETATTR",
            "USE_ANY_MDS"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_create_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1640-1665",
          "snippet": "struct ceph_mds_request *\nceph_mdsc_create_request(struct ceph_mds_client *mdsc, int op, int mode)\n{\n\tstruct ceph_mds_request *req = kzalloc(sizeof(*req), GFP_NOFS);\n\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&req->r_fill_mutex);\n\treq->r_mdsc = mdsc;\n\treq->r_started = jiffies;\n\treq->r_resend_mds = -1;\n\tINIT_LIST_HEAD(&req->r_unsafe_dir_item);\n\treq->r_fmode = -1;\n\tkref_init(&req->r_kref);\n\tINIT_LIST_HEAD(&req->r_wait);\n\tinit_completion(&req->r_completion);\n\tinit_completion(&req->r_safe_completion);\n\tINIT_LIST_HEAD(&req->r_unsafe_item);\n\n\treq->r_stamp = CURRENT_TIME;\n\n\treq->r_op = op;\n\treq->r_direct_mode = mode;\n\treturn req;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_mds_request *\nceph_mdsc_create_request(struct ceph_mds_client *mdsc, int op, int mode)\n{\n\tstruct ceph_mds_request *req = kzalloc(sizeof(*req), GFP_NOFS);\n\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&req->r_fill_mutex);\n\treq->r_mdsc = mdsc;\n\treq->r_started = jiffies;\n\treq->r_resend_mds = -1;\n\tINIT_LIST_HEAD(&req->r_unsafe_dir_item);\n\treq->r_fmode = -1;\n\tkref_init(&req->r_kref);\n\tINIT_LIST_HEAD(&req->r_wait);\n\tinit_completion(&req->r_completion);\n\tinit_completion(&req->r_safe_completion);\n\tINIT_LIST_HEAD(&req->r_unsafe_item);\n\n\treq->r_stamp = CURRENT_TIME;\n\n\treq->r_op = op;\n\treq->r_direct_mode = mode;\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"open_root_inode opening '%s'\\n\"",
            "path"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct dentry *open_root_dentry(struct ceph_fs_client *fsc,\n\t\t\t\t       const char *path,\n\t\t\t\t       unsigned long started)\n{\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req = NULL;\n\tint err;\n\tstruct dentry *root;\n\n\t/* open dir */\n\tdout(\"open_root_inode opening '%s'\\n\", path);\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_GETATTR, USE_ANY_MDS);\n\tif (IS_ERR(req))\n\t\treturn ERR_CAST(req);\n\treq->r_path1 = kstrdup(path, GFP_NOFS);\n\treq->r_ino1.ino = CEPH_INO_ROOT;\n\treq->r_ino1.snap = CEPH_NOSNAP;\n\treq->r_started = started;\n\treq->r_timeout = fsc->client->options->mount_timeout * HZ;\n\treq->r_args.getattr.mask = cpu_to_le32(CEPH_STAT_CAP_INODE);\n\treq->r_num_caps = 2;\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tif (err == 0) {\n\t\tstruct inode *inode = req->r_target_inode;\n\t\treq->r_target_inode = NULL;\n\t\tdout(\"open_root_inode success\\n\");\n\t\tif (ceph_ino(inode) == CEPH_INO_ROOT &&\n\t\t    fsc->sb->s_root == NULL) {\n\t\t\troot = d_make_root(inode);\n\t\t\tif (!root) {\n\t\t\t\troot = ERR_PTR(-ENOMEM);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\troot = d_obtain_root(inode);\n\t\t}\n\t\tceph_init_dentry(root);\n\t\tdout(\"open_root_inode success, root dentry is %p\\n\", root);\n\t} else {\n\t\troot = ERR_PTR(err);\n\t}\nout:\n\tceph_mdsc_put_request(req);\n\treturn root;\n}"
  },
  {
    "function_name": "ceph_umount_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
    "lines": "691-700",
    "snippet": "static void ceph_umount_begin(struct super_block *sb)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(sb);\n\n\tdout(\"ceph_umount_begin - starting forced umount\\n\");\n\tif (!fsc)\n\t\treturn;\n\tfsc->mount_state = CEPH_MOUNT_SHUTDOWN;\n\treturn;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/mon_client.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/string.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/in6.h>",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"ceph_umount_begin - starting forced umount\\n\""
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "sb"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void ceph_umount_begin(struct super_block *sb)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(sb);\n\n\tdout(\"ceph_umount_begin - starting forced umount\\n\");\n\tif (!fsc)\n\t\treturn;\n\tfsc->mount_state = CEPH_MOUNT_SHUTDOWN;\n\treturn;\n}"
  },
  {
    "function_name": "destroy_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
    "lines": "670-684",
    "snippet": "static void destroy_caches(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\n\tkmem_cache_destroy(ceph_inode_cachep);\n\tkmem_cache_destroy(ceph_cap_cachep);\n\tkmem_cache_destroy(ceph_dentry_cachep);\n\tkmem_cache_destroy(ceph_file_cachep);\n\n\tceph_fscache_unregister();\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/mon_client.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/string.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/in6.h>",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *ceph_inode_cachep;",
      "struct kmem_cache *ceph_cap_cachep;",
      "struct kmem_cache *ceph_dentry_cachep;",
      "struct kmem_cache *ceph_file_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_fscache_unregister",
          "args": [],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fscache_unregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
          "lines": "62-65",
          "snippet": "void ceph_fscache_unregister(void)\n{\n\tfscache_unregister_netfs(&ceph_cache_netfs);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"super.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct fscache_netfs ceph_cache_netfs = {\n\t.name\t\t= \"ceph\",\n\t.version\t= 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nstruct fscache_netfs ceph_cache_netfs = {\n\t.name\t\t= \"ceph\",\n\t.version\t= 0,\n};\n\nvoid ceph_fscache_unregister(void)\n{\n\tfscache_unregister_netfs(&ceph_cache_netfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ceph_file_cachep"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ceph_dentry_cachep"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ceph_cap_cachep"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ceph_inode_cachep"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct kmem_cache *ceph_inode_cachep;\nstruct kmem_cache *ceph_cap_cachep;\nstruct kmem_cache *ceph_dentry_cachep;\nstruct kmem_cache *ceph_file_cachep;\n\nstatic void destroy_caches(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\n\tkmem_cache_destroy(ceph_inode_cachep);\n\tkmem_cache_destroy(ceph_cap_cachep);\n\tkmem_cache_destroy(ceph_dentry_cachep);\n\tkmem_cache_destroy(ceph_file_cachep);\n\n\tceph_fscache_unregister();\n}"
  },
  {
    "function_name": "init_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
    "lines": "630-668",
    "snippet": "static int __init init_caches(void)\n{\n\tint error = -ENOMEM;\n\n\tceph_inode_cachep = kmem_cache_create(\"ceph_inode_info\",\n\t\t\t\t      sizeof(struct ceph_inode_info),\n\t\t\t\t      __alignof__(struct ceph_inode_info),\n\t\t\t\t      (SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD),\n\t\t\t\t      ceph_inode_init_once);\n\tif (ceph_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\tceph_cap_cachep = KMEM_CACHE(ceph_cap,\n\t\t\t\t     SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD);\n\tif (ceph_cap_cachep == NULL)\n\t\tgoto bad_cap;\n\n\tceph_dentry_cachep = KMEM_CACHE(ceph_dentry_info,\n\t\t\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD);\n\tif (ceph_dentry_cachep == NULL)\n\t\tgoto bad_dentry;\n\n\tceph_file_cachep = KMEM_CACHE(ceph_file_info,\n\t\t\t\t      SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD);\n\tif (ceph_file_cachep == NULL)\n\t\tgoto bad_file;\n\n\tif ((error = ceph_fscache_register()))\n\t\tgoto bad_file;\n\n\treturn 0;\nbad_file:\n\tkmem_cache_destroy(ceph_dentry_cachep);\nbad_dentry:\n\tkmem_cache_destroy(ceph_cap_cachep);\nbad_cap:\n\tkmem_cache_destroy(ceph_inode_cachep);\n\treturn error;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/mon_client.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/string.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/in6.h>",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *ceph_inode_cachep;",
      "struct kmem_cache *ceph_cap_cachep;",
      "struct kmem_cache *ceph_dentry_cachep;",
      "struct kmem_cache *ceph_file_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ceph_inode_cachep"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ceph_cap_cachep"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ceph_dentry_cachep"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_fscache_register",
          "args": [],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fscache_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
          "lines": "57-60",
          "snippet": "int ceph_fscache_register(void)\n{\n\treturn fscache_register_netfs(&ceph_cache_netfs);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"super.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct fscache_netfs ceph_cache_netfs = {\n\t.name\t\t= \"ceph\",\n\t.version\t= 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nstruct fscache_netfs ceph_cache_netfs = {\n\t.name\t\t= \"ceph\",\n\t.version\t= 0,\n};\n\nint ceph_fscache_register(void)\n{\n\treturn fscache_register_netfs(&ceph_cache_netfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "ceph_file_info",
            "SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "ceph_dentry_info",
            "SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "ceph_cap",
            "SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"ceph_inode_info\"",
            "sizeof(struct ceph_inode_info)",
            "__alignof__(struct ceph_inode_info)",
            "(SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD)",
            "ceph_inode_init_once"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct kmem_cache *ceph_inode_cachep;\nstruct kmem_cache *ceph_cap_cachep;\nstruct kmem_cache *ceph_dentry_cachep;\nstruct kmem_cache *ceph_file_cachep;\n\nstatic int __init init_caches(void)\n{\n\tint error = -ENOMEM;\n\n\tceph_inode_cachep = kmem_cache_create(\"ceph_inode_info\",\n\t\t\t\t      sizeof(struct ceph_inode_info),\n\t\t\t\t      __alignof__(struct ceph_inode_info),\n\t\t\t\t      (SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD),\n\t\t\t\t      ceph_inode_init_once);\n\tif (ceph_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\tceph_cap_cachep = KMEM_CACHE(ceph_cap,\n\t\t\t\t     SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD);\n\tif (ceph_cap_cachep == NULL)\n\t\tgoto bad_cap;\n\n\tceph_dentry_cachep = KMEM_CACHE(ceph_dentry_info,\n\t\t\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD);\n\tif (ceph_dentry_cachep == NULL)\n\t\tgoto bad_dentry;\n\n\tceph_file_cachep = KMEM_CACHE(ceph_file_info,\n\t\t\t\t      SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD);\n\tif (ceph_file_cachep == NULL)\n\t\tgoto bad_file;\n\n\tif ((error = ceph_fscache_register()))\n\t\tgoto bad_file;\n\n\treturn 0;\nbad_file:\n\tkmem_cache_destroy(ceph_dentry_cachep);\nbad_dentry:\n\tkmem_cache_destroy(ceph_cap_cachep);\nbad_cap:\n\tkmem_cache_destroy(ceph_inode_cachep);\n\treturn error;\n}"
  },
  {
    "function_name": "ceph_inode_init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
    "lines": "624-628",
    "snippet": "static void ceph_inode_init_once(void *foo)\n{\n\tstruct ceph_inode_info *ci = foo;\n\tinode_init_once(&ci->vfs_inode);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/mon_client.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/string.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/in6.h>",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&ci->vfs_inode"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "624-628",
          "snippet": "static void ceph_inode_init_once(void *foo)\n{\n\tstruct ceph_inode_info *ci = foo;\n\tinode_init_once(&ci->vfs_inode);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void ceph_inode_init_once(void *foo)\n{\n\tstruct ceph_inode_info *ci = foo;\n\tinode_init_once(&ci->vfs_inode);\n}"
  },
  {
    "function_name": "destroy_fs_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
    "lines": "592-614",
    "snippet": "static void destroy_fs_client(struct ceph_fs_client *fsc)\n{\n\tdout(\"destroy_fs_client %p\\n\", fsc);\n\n\tceph_fscache_unregister_fs(fsc);\n\n\tdestroy_workqueue(fsc->wb_wq);\n\tdestroy_workqueue(fsc->pg_inv_wq);\n\tdestroy_workqueue(fsc->trunc_wq);\n\n\tbdi_destroy(&fsc->backing_dev_info);\n\n\tmempool_destroy(fsc->wb_pagevec_pool);\n\n\tdestroy_mount_options(fsc->mount_options);\n\n\tceph_fs_debugfs_cleanup(fsc);\n\n\tceph_destroy_client(fsc->client);\n\n\tkfree(fsc);\n\tdout(\"destroy_fs_client %p done\\n\", fsc);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/mon_client.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/string.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/in6.h>",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"destroy_fs_client %p done\\n\"",
            "fsc"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fsc"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_destroy_client",
          "args": [
            "fsc->client"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_fs_debugfs_cleanup",
          "args": [
            "fsc"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fs_debugfs_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/debugfs.c",
          "lines": "317-319",
          "snippet": "void ceph_fs_debugfs_cleanup(struct ceph_fs_client *fsc)\n{\n}",
          "includes": [
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/device.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/libceph.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_fs_debugfs_cleanup(struct ceph_fs_client *fsc)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_mount_options",
          "args": [
            "fsc->mount_options"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_mount_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "285-290",
          "snippet": "static void destroy_mount_options(struct ceph_mount_options *args)\n{\n\tdout(\"destroy_mount_options %p\\n\", args);\n\tkfree(args->snapdir_name);\n\tkfree(args);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/string.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void destroy_mount_options(struct ceph_mount_options *args)\n{\n\tdout(\"destroy_mount_options %p\\n\", args);\n\tkfree(args->snapdir_name);\n\tkfree(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mempool_destroy",
          "args": [
            "fsc->wb_pagevec_pool"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_mempool_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "730-734",
          "snippet": "static inline void logfs_mempool_destroy(mempool_t *pool)\n{\n\tif (pool)\n\t\tmempool_destroy(pool);\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline void logfs_mempool_destroy(mempool_t *pool)\n{\n\tif (pool)\n\t\tmempool_destroy(pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdi_destroy",
          "args": [
            "&fsc->backing_dev_info"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_bdi_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "372-376",
          "snippet": "static void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "fsc->trunc_wq"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_fscache_unregister_fs",
          "args": [
            "fsc"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fscache_unregister_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
          "lines": "335-342",
          "snippet": "void ceph_fscache_unregister_fs(struct ceph_fs_client* fsc)\n{\n\tif (fsc->revalidate_wq)\n\t\tdestroy_workqueue(fsc->revalidate_wq);\n\n\tfscache_relinquish_cookie(fsc->fscache, 0);\n\tfsc->fscache = NULL;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"super.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nvoid ceph_fscache_unregister_fs(struct ceph_fs_client* fsc)\n{\n\tif (fsc->revalidate_wq)\n\t\tdestroy_workqueue(fsc->revalidate_wq);\n\n\tfscache_relinquish_cookie(fsc->fscache, 0);\n\tfsc->fscache = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"destroy_fs_client %p\\n\"",
            "fsc"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void destroy_fs_client(struct ceph_fs_client *fsc)\n{\n\tdout(\"destroy_fs_client %p\\n\", fsc);\n\n\tceph_fscache_unregister_fs(fsc);\n\n\tdestroy_workqueue(fsc->wb_wq);\n\tdestroy_workqueue(fsc->pg_inv_wq);\n\tdestroy_workqueue(fsc->trunc_wq);\n\n\tbdi_destroy(&fsc->backing_dev_info);\n\n\tmempool_destroy(fsc->wb_pagevec_pool);\n\n\tdestroy_mount_options(fsc->mount_options);\n\n\tceph_fs_debugfs_cleanup(fsc);\n\n\tceph_destroy_client(fsc->client);\n\n\tkfree(fsc);\n\tdout(\"destroy_fs_client %p done\\n\", fsc);\n}"
  },
  {
    "function_name": "create_fs_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
    "lines": "505-590",
    "snippet": "static struct ceph_fs_client *create_fs_client(struct ceph_mount_options *fsopt,\n\t\t\t\t\tstruct ceph_options *opt)\n{\n\tstruct ceph_fs_client *fsc;\n\tconst u64 supported_features =\n\t\tCEPH_FEATURE_FLOCK |\n\t\tCEPH_FEATURE_DIRLAYOUTHASH |\n\t\tCEPH_FEATURE_MDS_INLINE_DATA;\n\tconst u64 required_features = 0;\n\tint page_count;\n\tsize_t size;\n\tint err = -ENOMEM;\n\n\tfsc = kzalloc(sizeof(*fsc), GFP_KERNEL);\n\tif (!fsc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfsc->client = ceph_create_client(opt, fsc, supported_features,\n\t\t\t\t\t required_features);\n\tif (IS_ERR(fsc->client)) {\n\t\terr = PTR_ERR(fsc->client);\n\t\tgoto fail;\n\t}\n\tfsc->client->extra_mon_dispatch = extra_mon_dispatch;\n\tfsc->client->monc.want_mdsmap = 1;\n\n\tfsc->mount_options = fsopt;\n\n\tfsc->sb = NULL;\n\tfsc->mount_state = CEPH_MOUNT_MOUNTING;\n\n\tatomic_long_set(&fsc->writeback_count, 0);\n\n\terr = bdi_init(&fsc->backing_dev_info);\n\tif (err < 0)\n\t\tgoto fail_client;\n\n\terr = -ENOMEM;\n\t/*\n\t * The number of concurrent works can be high but they don't need\n\t * to be processed in parallel, limit concurrency.\n\t */\n\tfsc->wb_wq = alloc_workqueue(\"ceph-writeback\", 0, 1);\n\tif (fsc->wb_wq == NULL)\n\t\tgoto fail_bdi;\n\tfsc->pg_inv_wq = alloc_workqueue(\"ceph-pg-invalid\", 0, 1);\n\tif (fsc->pg_inv_wq == NULL)\n\t\tgoto fail_wb_wq;\n\tfsc->trunc_wq = alloc_workqueue(\"ceph-trunc\", 0, 1);\n\tif (fsc->trunc_wq == NULL)\n\t\tgoto fail_pg_inv_wq;\n\n\t/* set up mempools */\n\terr = -ENOMEM;\n\tpage_count = fsc->mount_options->wsize >> PAGE_CACHE_SHIFT;\n\tsize = sizeof (struct page *) * (page_count ? page_count : 1);\n\tfsc->wb_pagevec_pool = mempool_create_kmalloc_pool(10, size);\n\tif (!fsc->wb_pagevec_pool)\n\t\tgoto fail_trunc_wq;\n\n\t/* setup fscache */\n\tif ((fsopt->flags & CEPH_MOUNT_OPT_FSCACHE) &&\n\t    (ceph_fscache_register_fs(fsc) != 0))\n\t\tgoto fail_fscache;\n\n\t/* caps */\n\tfsc->min_caps = fsopt->max_readdir;\n\n\treturn fsc;\n\nfail_fscache:\n\tceph_fscache_unregister_fs(fsc);\nfail_trunc_wq:\n\tdestroy_workqueue(fsc->trunc_wq);\nfail_pg_inv_wq:\n\tdestroy_workqueue(fsc->pg_inv_wq);\nfail_wb_wq:\n\tdestroy_workqueue(fsc->wb_wq);\nfail_bdi:\n\tbdi_destroy(&fsc->backing_dev_info);\nfail_client:\n\tceph_destroy_client(fsc->client);\nfail:\n\tkfree(fsc);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/mon_client.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/string.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/in6.h>",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fsc"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_destroy_client",
          "args": [
            "fsc->client"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_destroy",
          "args": [
            "&fsc->backing_dev_info"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_bdi_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "372-376",
          "snippet": "static void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "fsc->wb_wq"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_fscache_unregister_fs",
          "args": [
            "fsc"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fscache_unregister_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
          "lines": "335-342",
          "snippet": "void ceph_fscache_unregister_fs(struct ceph_fs_client* fsc)\n{\n\tif (fsc->revalidate_wq)\n\t\tdestroy_workqueue(fsc->revalidate_wq);\n\n\tfscache_relinquish_cookie(fsc->fscache, 0);\n\tfsc->fscache = NULL;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"super.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nvoid ceph_fscache_unregister_fs(struct ceph_fs_client* fsc)\n{\n\tif (fsc->revalidate_wq)\n\t\tdestroy_workqueue(fsc->revalidate_wq);\n\n\tfscache_relinquish_cookie(fsc->fscache, 0);\n\tfsc->fscache = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_fscache_register_fs",
          "args": [
            "fsc"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fscache_register_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
          "lines": "67-83",
          "snippet": "int ceph_fscache_register_fs(struct ceph_fs_client* fsc)\n{\n\tfsc->fscache = fscache_acquire_cookie(ceph_cache_netfs.primary_index,\n\t\t\t\t\t      &ceph_fscache_fsid_object_def,\n\t\t\t\t\t      fsc, true);\n\n\tif (fsc->fscache == NULL) {\n\t\tpr_err(\"Unable to resgister fsid: %p fscache cookie\", fsc);\n\t\treturn 0;\n\t}\n\n\tfsc->revalidate_wq = alloc_workqueue(\"ceph-revalidate\", 0, 1);\n\tif (fsc->revalidate_wq == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"super.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct fscache_netfs ceph_cache_netfs = {\n\t.name\t\t= \"ceph\",\n\t.version\t= 0,\n};",
            "static const struct fscache_cookie_def ceph_fscache_fsid_object_def = {\n\t.name\t\t= \"CEPH.fsid\",\n\t.type\t\t= FSCACHE_COOKIE_TYPE_INDEX,\n\t.get_key\t= ceph_fscache_session_get_key,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nstruct fscache_netfs ceph_cache_netfs = {\n\t.name\t\t= \"ceph\",\n\t.version\t= 0,\n};\nstatic const struct fscache_cookie_def ceph_fscache_fsid_object_def = {\n\t.name\t\t= \"CEPH.fsid\",\n\t.type\t\t= FSCACHE_COOKIE_TYPE_INDEX,\n\t.get_key\t= ceph_fscache_session_get_key,\n};\n\nint ceph_fscache_register_fs(struct ceph_fs_client* fsc)\n{\n\tfsc->fscache = fscache_acquire_cookie(ceph_cache_netfs.primary_index,\n\t\t\t\t\t      &ceph_fscache_fsid_object_def,\n\t\t\t\t\t      fsc, true);\n\n\tif (fsc->fscache == NULL) {\n\t\tpr_err(\"Unable to resgister fsid: %p fscache cookie\", fsc);\n\t\treturn 0;\n\t}\n\n\tfsc->revalidate_wq = alloc_workqueue(\"ceph-revalidate\", 0, 1);\n\tif (fsc->revalidate_wq == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mempool_create_kmalloc_pool",
          "args": [
            "10",
            "size"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"ceph-trunc\"",
            "0",
            "1"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"ceph-pg-invalid\"",
            "0",
            "1"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"ceph-writeback\"",
            "0",
            "1"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_init",
          "args": [
            "&fsc->backing_dev_info"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_set",
          "args": [
            "&fsc->writeback_count",
            "0"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fsc->client"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fsc->client"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_create_client",
          "args": [
            "opt",
            "fsc",
            "supported_features",
            "required_features"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*fsc)",
            "GFP_KERNEL"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_fs_client *create_fs_client(struct ceph_mount_options *fsopt,\n\t\t\t\t\tstruct ceph_options *opt)\n{\n\tstruct ceph_fs_client *fsc;\n\tconst u64 supported_features =\n\t\tCEPH_FEATURE_FLOCK |\n\t\tCEPH_FEATURE_DIRLAYOUTHASH |\n\t\tCEPH_FEATURE_MDS_INLINE_DATA;\n\tconst u64 required_features = 0;\n\tint page_count;\n\tsize_t size;\n\tint err = -ENOMEM;\n\n\tfsc = kzalloc(sizeof(*fsc), GFP_KERNEL);\n\tif (!fsc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfsc->client = ceph_create_client(opt, fsc, supported_features,\n\t\t\t\t\t required_features);\n\tif (IS_ERR(fsc->client)) {\n\t\terr = PTR_ERR(fsc->client);\n\t\tgoto fail;\n\t}\n\tfsc->client->extra_mon_dispatch = extra_mon_dispatch;\n\tfsc->client->monc.want_mdsmap = 1;\n\n\tfsc->mount_options = fsopt;\n\n\tfsc->sb = NULL;\n\tfsc->mount_state = CEPH_MOUNT_MOUNTING;\n\n\tatomic_long_set(&fsc->writeback_count, 0);\n\n\terr = bdi_init(&fsc->backing_dev_info);\n\tif (err < 0)\n\t\tgoto fail_client;\n\n\terr = -ENOMEM;\n\t/*\n\t * The number of concurrent works can be high but they don't need\n\t * to be processed in parallel, limit concurrency.\n\t */\n\tfsc->wb_wq = alloc_workqueue(\"ceph-writeback\", 0, 1);\n\tif (fsc->wb_wq == NULL)\n\t\tgoto fail_bdi;\n\tfsc->pg_inv_wq = alloc_workqueue(\"ceph-pg-invalid\", 0, 1);\n\tif (fsc->pg_inv_wq == NULL)\n\t\tgoto fail_wb_wq;\n\tfsc->trunc_wq = alloc_workqueue(\"ceph-trunc\", 0, 1);\n\tif (fsc->trunc_wq == NULL)\n\t\tgoto fail_pg_inv_wq;\n\n\t/* set up mempools */\n\terr = -ENOMEM;\n\tpage_count = fsc->mount_options->wsize >> PAGE_CACHE_SHIFT;\n\tsize = sizeof (struct page *) * (page_count ? page_count : 1);\n\tfsc->wb_pagevec_pool = mempool_create_kmalloc_pool(10, size);\n\tif (!fsc->wb_pagevec_pool)\n\t\tgoto fail_trunc_wq;\n\n\t/* setup fscache */\n\tif ((fsopt->flags & CEPH_MOUNT_OPT_FSCACHE) &&\n\t    (ceph_fscache_register_fs(fsc) != 0))\n\t\tgoto fail_fscache;\n\n\t/* caps */\n\tfsc->min_caps = fsopt->max_readdir;\n\n\treturn fsc;\n\nfail_fscache:\n\tceph_fscache_unregister_fs(fsc);\nfail_trunc_wq:\n\tdestroy_workqueue(fsc->trunc_wq);\nfail_pg_inv_wq:\n\tdestroy_workqueue(fsc->pg_inv_wq);\nfail_wb_wq:\n\tdestroy_workqueue(fsc->wb_wq);\nfail_bdi:\n\tbdi_destroy(&fsc->backing_dev_info);\nfail_client:\n\tceph_destroy_client(fsc->client);\nfail:\n\tkfree(fsc);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "extra_mon_dispatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
    "lines": "487-500",
    "snippet": "static int extra_mon_dispatch(struct ceph_client *client, struct ceph_msg *msg)\n{\n\tstruct ceph_fs_client *fsc = client->private;\n\tint type = le16_to_cpu(msg->hdr.type);\n\n\tswitch (type) {\n\tcase CEPH_MSG_MDS_MAP:\n\t\tceph_mdsc_handle_map(fsc->mdsc, msg);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -1;\n\t}\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/mon_client.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/string.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/in6.h>",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_mdsc_handle_map",
          "args": [
            "fsc->mdsc",
            "msg"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_handle_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "3602-3658",
          "snippet": "void ceph_mdsc_handle_map(struct ceph_mds_client *mdsc, struct ceph_msg *msg)\n{\n\tu32 epoch;\n\tu32 maplen;\n\tvoid *p = msg->front.iov_base;\n\tvoid *end = p + msg->front.iov_len;\n\tstruct ceph_mdsmap *newmap, *oldmap;\n\tstruct ceph_fsid fsid;\n\tint err = -EINVAL;\n\n\tceph_decode_need(&p, end, sizeof(fsid)+2*sizeof(u32), bad);\n\tceph_decode_copy(&p, &fsid, sizeof(fsid));\n\tif (ceph_check_fsid(mdsc->fsc->client, &fsid) < 0)\n\t\treturn;\n\tepoch = ceph_decode_32(&p);\n\tmaplen = ceph_decode_32(&p);\n\tdout(\"handle_map epoch %u len %d\\n\", epoch, (int)maplen);\n\n\t/* do we need it? */\n\tceph_monc_got_mdsmap(&mdsc->fsc->client->monc, epoch);\n\tmutex_lock(&mdsc->mutex);\n\tif (mdsc->mdsmap && epoch <= mdsc->mdsmap->m_epoch) {\n\t\tdout(\"handle_map epoch %u <= our %u\\n\",\n\t\t     epoch, mdsc->mdsmap->m_epoch);\n\t\tmutex_unlock(&mdsc->mutex);\n\t\treturn;\n\t}\n\n\tnewmap = ceph_mdsmap_decode(&p, end);\n\tif (IS_ERR(newmap)) {\n\t\terr = PTR_ERR(newmap);\n\t\tgoto bad_unlock;\n\t}\n\n\t/* swap into place */\n\tif (mdsc->mdsmap) {\n\t\toldmap = mdsc->mdsmap;\n\t\tmdsc->mdsmap = newmap;\n\t\tcheck_new_map(mdsc, newmap, oldmap);\n\t\tceph_mdsmap_destroy(oldmap);\n\t} else {\n\t\tmdsc->mdsmap = newmap;  /* first mds map */\n\t}\n\tmdsc->fsc->sb->s_maxbytes = mdsc->mdsmap->m_max_file_size;\n\n\t__wake_requests(mdsc, &mdsc->waiting_for_map);\n\n\tmutex_unlock(&mdsc->mutex);\n\tschedule_delayed(mdsc);\n\treturn;\n\nbad_unlock:\n\tmutex_unlock(&mdsc->mutex);\nbad:\n\tpr_err(\"error decoding mdsmap %d\\n\", err);\n\treturn;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_mdsc_handle_map(struct ceph_mds_client *mdsc, struct ceph_msg *msg)\n{\n\tu32 epoch;\n\tu32 maplen;\n\tvoid *p = msg->front.iov_base;\n\tvoid *end = p + msg->front.iov_len;\n\tstruct ceph_mdsmap *newmap, *oldmap;\n\tstruct ceph_fsid fsid;\n\tint err = -EINVAL;\n\n\tceph_decode_need(&p, end, sizeof(fsid)+2*sizeof(u32), bad);\n\tceph_decode_copy(&p, &fsid, sizeof(fsid));\n\tif (ceph_check_fsid(mdsc->fsc->client, &fsid) < 0)\n\t\treturn;\n\tepoch = ceph_decode_32(&p);\n\tmaplen = ceph_decode_32(&p);\n\tdout(\"handle_map epoch %u len %d\\n\", epoch, (int)maplen);\n\n\t/* do we need it? */\n\tceph_monc_got_mdsmap(&mdsc->fsc->client->monc, epoch);\n\tmutex_lock(&mdsc->mutex);\n\tif (mdsc->mdsmap && epoch <= mdsc->mdsmap->m_epoch) {\n\t\tdout(\"handle_map epoch %u <= our %u\\n\",\n\t\t     epoch, mdsc->mdsmap->m_epoch);\n\t\tmutex_unlock(&mdsc->mutex);\n\t\treturn;\n\t}\n\n\tnewmap = ceph_mdsmap_decode(&p, end);\n\tif (IS_ERR(newmap)) {\n\t\terr = PTR_ERR(newmap);\n\t\tgoto bad_unlock;\n\t}\n\n\t/* swap into place */\n\tif (mdsc->mdsmap) {\n\t\toldmap = mdsc->mdsmap;\n\t\tmdsc->mdsmap = newmap;\n\t\tcheck_new_map(mdsc, newmap, oldmap);\n\t\tceph_mdsmap_destroy(oldmap);\n\t} else {\n\t\tmdsc->mdsmap = newmap;  /* first mds map */\n\t}\n\tmdsc->fsc->sb->s_maxbytes = mdsc->mdsmap->m_max_file_size;\n\n\t__wake_requests(mdsc, &mdsc->waiting_for_map);\n\n\tmutex_unlock(&mdsc->mutex);\n\tschedule_delayed(mdsc);\n\treturn;\n\nbad_unlock:\n\tmutex_unlock(&mdsc->mutex);\nbad:\n\tpr_err(\"error decoding mdsmap %d\\n\", err);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "msg->hdr.type"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int extra_mon_dispatch(struct ceph_client *client, struct ceph_msg *msg)\n{\n\tstruct ceph_fs_client *fsc = client->private;\n\tint type = le16_to_cpu(msg->hdr.type);\n\n\tswitch (type) {\n\tcase CEPH_MSG_MDS_MAP:\n\t\tceph_mdsc_handle_map(fsc->mdsc, msg);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -1;\n\t}\n}"
  },
  {
    "function_name": "ceph_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
    "lines": "405-481",
    "snippet": "static int ceph_show_options(struct seq_file *m, struct dentry *root)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(root->d_sb);\n\tstruct ceph_mount_options *fsopt = fsc->mount_options;\n\tstruct ceph_options *opt = fsc->client->options;\n\n\tif (opt->flags & CEPH_OPT_FSID)\n\t\tseq_printf(m, \",fsid=%pU\", &opt->fsid);\n\tif (opt->flags & CEPH_OPT_NOSHARE)\n\t\tseq_puts(m, \",noshare\");\n\tif (opt->flags & CEPH_OPT_NOCRC)\n\t\tseq_puts(m, \",nocrc\");\n\tif (opt->flags & CEPH_OPT_NOMSGAUTH)\n\t\tseq_puts(m, \",nocephx_require_signatures\");\n\tif ((opt->flags & CEPH_OPT_TCP_NODELAY) == 0)\n\t\tseq_puts(m, \",notcp_nodelay\");\n\n\tif (opt->name)\n\t\tseq_printf(m, \",name=%s\", opt->name);\n\tif (opt->key)\n\t\tseq_puts(m, \",secret=<hidden>\");\n\n\tif (opt->mount_timeout != CEPH_MOUNT_TIMEOUT_DEFAULT)\n\t\tseq_printf(m, \",mount_timeout=%d\", opt->mount_timeout);\n\tif (opt->osd_idle_ttl != CEPH_OSD_IDLE_TTL_DEFAULT)\n\t\tseq_printf(m, \",osd_idle_ttl=%d\", opt->osd_idle_ttl);\n\tif (opt->osd_keepalive_timeout != CEPH_OSD_KEEPALIVE_DEFAULT)\n\t\tseq_printf(m, \",osdkeepalivetimeout=%d\",\n\t\t\t   opt->osd_keepalive_timeout);\n\n\tif (fsopt->flags & CEPH_MOUNT_OPT_DIRSTAT)\n\t\tseq_puts(m, \",dirstat\");\n\tif ((fsopt->flags & CEPH_MOUNT_OPT_RBYTES) == 0)\n\t\tseq_puts(m, \",norbytes\");\n\tif (fsopt->flags & CEPH_MOUNT_OPT_NOASYNCREADDIR)\n\t\tseq_puts(m, \",noasyncreaddir\");\n\tif (fsopt->flags & CEPH_MOUNT_OPT_DCACHE)\n\t\tseq_puts(m, \",dcache\");\n\telse\n\t\tseq_puts(m, \",nodcache\");\n\tif (fsopt->flags & CEPH_MOUNT_OPT_FSCACHE)\n\t\tseq_puts(m, \",fsc\");\n\telse\n\t\tseq_puts(m, \",nofsc\");\n\n#ifdef CONFIG_CEPH_FS_POSIX_ACL\n\tif (fsopt->sb_flags & MS_POSIXACL)\n\t\tseq_puts(m, \",acl\");\n\telse\n\t\tseq_puts(m, \",noacl\");\n#endif\n\n\tif (fsopt->wsize)\n\t\tseq_printf(m, \",wsize=%d\", fsopt->wsize);\n\tif (fsopt->rsize != CEPH_RSIZE_DEFAULT)\n\t\tseq_printf(m, \",rsize=%d\", fsopt->rsize);\n\tif (fsopt->rasize != CEPH_RASIZE_DEFAULT)\n\t\tseq_printf(m, \",rasize=%d\", fsopt->rasize);\n\tif (fsopt->congestion_kb != default_congestion_kb())\n\t\tseq_printf(m, \",write_congestion_kb=%d\", fsopt->congestion_kb);\n\tif (fsopt->caps_wanted_delay_min != CEPH_CAPS_WANTED_DELAY_MIN_DEFAULT)\n\t\tseq_printf(m, \",caps_wanted_delay_min=%d\",\n\t\t\t fsopt->caps_wanted_delay_min);\n\tif (fsopt->caps_wanted_delay_max != CEPH_CAPS_WANTED_DELAY_MAX_DEFAULT)\n\t\tseq_printf(m, \",caps_wanted_delay_max=%d\",\n\t\t\t   fsopt->caps_wanted_delay_max);\n\tif (fsopt->cap_release_safety != CEPH_CAP_RELEASE_SAFETY_DEFAULT)\n\t\tseq_printf(m, \",cap_release_safety=%d\",\n\t\t\t   fsopt->cap_release_safety);\n\tif (fsopt->max_readdir != CEPH_MAX_READDIR_DEFAULT)\n\t\tseq_printf(m, \",readdir_max_entries=%d\", fsopt->max_readdir);\n\tif (fsopt->max_readdir_bytes != CEPH_MAX_READDIR_BYTES_DEFAULT)\n\t\tseq_printf(m, \",readdir_max_bytes=%d\", fsopt->max_readdir_bytes);\n\tif (strcmp(fsopt->snapdir_name, CEPH_SNAPDIRNAME_DEFAULT))\n\t\tseq_printf(m, \",snapdirname=%s\", fsopt->snapdir_name);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/mon_client.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/string.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/in6.h>",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\",snapdirname=%s\"",
            "fsopt->snapdir_name"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "fsopt->snapdir_name",
            "CEPH_SNAPDIRNAME_DEFAULT"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "292-301",
          "snippet": "static int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/string.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "default_congestion_kb",
          "args": [],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "default_congestion_kb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "657-684",
          "snippet": "static inline int default_congestion_kb(void)\n{\n\tint congestion_kb;\n\n\t/*\n\t * Copied from NFS\n\t *\n\t * congestion size, scale with available memory.\n\t *\n\t *  64MB:    8192k\n\t * 128MB:   11585k\n\t * 256MB:   16384k\n\t * 512MB:   23170k\n\t *   1GB:   32768k\n\t *   2GB:   46340k\n\t *   4GB:   65536k\n\t *   8GB:   92681k\n\t *  16GB:  131072k\n\t *\n\t * This allows larger machines to have larger/more transfers.\n\t * Limit the default to 256M\n\t */\n\tcongestion_kb = (16*int_sqrt(totalram_pages)) << (PAGE_SHIFT-10);\n\tif (congestion_kb > 256*1024)\n\t\tcongestion_kb = 256*1024;\n\n\treturn congestion_kb;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline int default_congestion_kb(void)\n{\n\tint congestion_kb;\n\n\t/*\n\t * Copied from NFS\n\t *\n\t * congestion size, scale with available memory.\n\t *\n\t *  64MB:    8192k\n\t * 128MB:   11585k\n\t * 256MB:   16384k\n\t * 512MB:   23170k\n\t *   1GB:   32768k\n\t *   2GB:   46340k\n\t *   4GB:   65536k\n\t *   8GB:   92681k\n\t *  16GB:  131072k\n\t *\n\t * This allows larger machines to have larger/more transfers.\n\t * Limit the default to 256M\n\t */\n\tcongestion_kb = (16*int_sqrt(totalram_pages)) << (PAGE_SHIFT-10);\n\tif (congestion_kb > 256*1024)\n\t\tcongestion_kb = 256*1024;\n\n\treturn congestion_kb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\",noacl\""
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "root->d_sb"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_show_options(struct seq_file *m, struct dentry *root)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(root->d_sb);\n\tstruct ceph_mount_options *fsopt = fsc->mount_options;\n\tstruct ceph_options *opt = fsc->client->options;\n\n\tif (opt->flags & CEPH_OPT_FSID)\n\t\tseq_printf(m, \",fsid=%pU\", &opt->fsid);\n\tif (opt->flags & CEPH_OPT_NOSHARE)\n\t\tseq_puts(m, \",noshare\");\n\tif (opt->flags & CEPH_OPT_NOCRC)\n\t\tseq_puts(m, \",nocrc\");\n\tif (opt->flags & CEPH_OPT_NOMSGAUTH)\n\t\tseq_puts(m, \",nocephx_require_signatures\");\n\tif ((opt->flags & CEPH_OPT_TCP_NODELAY) == 0)\n\t\tseq_puts(m, \",notcp_nodelay\");\n\n\tif (opt->name)\n\t\tseq_printf(m, \",name=%s\", opt->name);\n\tif (opt->key)\n\t\tseq_puts(m, \",secret=<hidden>\");\n\n\tif (opt->mount_timeout != CEPH_MOUNT_TIMEOUT_DEFAULT)\n\t\tseq_printf(m, \",mount_timeout=%d\", opt->mount_timeout);\n\tif (opt->osd_idle_ttl != CEPH_OSD_IDLE_TTL_DEFAULT)\n\t\tseq_printf(m, \",osd_idle_ttl=%d\", opt->osd_idle_ttl);\n\tif (opt->osd_keepalive_timeout != CEPH_OSD_KEEPALIVE_DEFAULT)\n\t\tseq_printf(m, \",osdkeepalivetimeout=%d\",\n\t\t\t   opt->osd_keepalive_timeout);\n\n\tif (fsopt->flags & CEPH_MOUNT_OPT_DIRSTAT)\n\t\tseq_puts(m, \",dirstat\");\n\tif ((fsopt->flags & CEPH_MOUNT_OPT_RBYTES) == 0)\n\t\tseq_puts(m, \",norbytes\");\n\tif (fsopt->flags & CEPH_MOUNT_OPT_NOASYNCREADDIR)\n\t\tseq_puts(m, \",noasyncreaddir\");\n\tif (fsopt->flags & CEPH_MOUNT_OPT_DCACHE)\n\t\tseq_puts(m, \",dcache\");\n\telse\n\t\tseq_puts(m, \",nodcache\");\n\tif (fsopt->flags & CEPH_MOUNT_OPT_FSCACHE)\n\t\tseq_puts(m, \",fsc\");\n\telse\n\t\tseq_puts(m, \",nofsc\");\n\n#ifdef CONFIG_CEPH_FS_POSIX_ACL\n\tif (fsopt->sb_flags & MS_POSIXACL)\n\t\tseq_puts(m, \",acl\");\n\telse\n\t\tseq_puts(m, \",noacl\");\n#endif\n\n\tif (fsopt->wsize)\n\t\tseq_printf(m, \",wsize=%d\", fsopt->wsize);\n\tif (fsopt->rsize != CEPH_RSIZE_DEFAULT)\n\t\tseq_printf(m, \",rsize=%d\", fsopt->rsize);\n\tif (fsopt->rasize != CEPH_RASIZE_DEFAULT)\n\t\tseq_printf(m, \",rasize=%d\", fsopt->rasize);\n\tif (fsopt->congestion_kb != default_congestion_kb())\n\t\tseq_printf(m, \",write_congestion_kb=%d\", fsopt->congestion_kb);\n\tif (fsopt->caps_wanted_delay_min != CEPH_CAPS_WANTED_DELAY_MIN_DEFAULT)\n\t\tseq_printf(m, \",caps_wanted_delay_min=%d\",\n\t\t\t fsopt->caps_wanted_delay_min);\n\tif (fsopt->caps_wanted_delay_max != CEPH_CAPS_WANTED_DELAY_MAX_DEFAULT)\n\t\tseq_printf(m, \",caps_wanted_delay_max=%d\",\n\t\t\t   fsopt->caps_wanted_delay_max);\n\tif (fsopt->cap_release_safety != CEPH_CAP_RELEASE_SAFETY_DEFAULT)\n\t\tseq_printf(m, \",cap_release_safety=%d\",\n\t\t\t   fsopt->cap_release_safety);\n\tif (fsopt->max_readdir != CEPH_MAX_READDIR_DEFAULT)\n\t\tseq_printf(m, \",readdir_max_entries=%d\", fsopt->max_readdir);\n\tif (fsopt->max_readdir_bytes != CEPH_MAX_READDIR_BYTES_DEFAULT)\n\t\tseq_printf(m, \",readdir_max_bytes=%d\", fsopt->max_readdir_bytes);\n\tif (strcmp(fsopt->snapdir_name, CEPH_SNAPDIRNAME_DEFAULT))\n\t\tseq_printf(m, \",snapdirname=%s\", fsopt->snapdir_name);\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_mount_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
    "lines": "323-398",
    "snippet": "static int parse_mount_options(struct ceph_mount_options **pfsopt,\n\t\t\t       struct ceph_options **popt,\n\t\t\t       int flags, char *options,\n\t\t\t       const char *dev_name,\n\t\t\t       const char **path)\n{\n\tstruct ceph_mount_options *fsopt;\n\tconst char *dev_name_end;\n\tint err;\n\n\tif (!dev_name || !*dev_name)\n\t\treturn -EINVAL;\n\n\tfsopt = kzalloc(sizeof(*fsopt), GFP_KERNEL);\n\tif (!fsopt)\n\t\treturn -ENOMEM;\n\n\tdout(\"parse_mount_options %p, dev_name '%s'\\n\", fsopt, dev_name);\n\n\tfsopt->sb_flags = flags;\n\tfsopt->flags = CEPH_MOUNT_OPT_DEFAULT;\n\n\tfsopt->rsize = CEPH_RSIZE_DEFAULT;\n\tfsopt->rasize = CEPH_RASIZE_DEFAULT;\n\tfsopt->snapdir_name = kstrdup(CEPH_SNAPDIRNAME_DEFAULT, GFP_KERNEL);\n\tfsopt->caps_wanted_delay_min = CEPH_CAPS_WANTED_DELAY_MIN_DEFAULT;\n\tfsopt->caps_wanted_delay_max = CEPH_CAPS_WANTED_DELAY_MAX_DEFAULT;\n\tfsopt->cap_release_safety = CEPH_CAP_RELEASE_SAFETY_DEFAULT;\n\tfsopt->max_readdir = CEPH_MAX_READDIR_DEFAULT;\n\tfsopt->max_readdir_bytes = CEPH_MAX_READDIR_BYTES_DEFAULT;\n\tfsopt->congestion_kb = default_congestion_kb();\n\n\t/*\n\t * Distinguish the server list from the path in \"dev_name\".\n\t * Internally we do not include the leading '/' in the path.\n\t *\n\t * \"dev_name\" will look like:\n\t *     <server_spec>[,<server_spec>...]:[<path>]\n\t * where\n\t *     <server_spec> is <ip>[:<port>]\n\t *     <path> is optional, but if present must begin with '/'\n\t */\n\tdev_name_end = strchr(dev_name, '/');\n\tif (dev_name_end) {\n\t\t/* skip over leading '/' for path */\n\t\t*path = dev_name_end + 1;\n\t} else {\n\t\t/* path is empty */\n\t\tdev_name_end = dev_name + strlen(dev_name);\n\t\t*path = dev_name_end;\n\t}\n\terr = -EINVAL;\n\tdev_name_end--;\t\t/* back up to ':' separator */\n\tif (dev_name_end < dev_name || *dev_name_end != ':') {\n\t\tpr_err(\"device name is missing path (no : separator in %s)\\n\",\n\t\t\t\tdev_name);\n\t\tgoto out;\n\t}\n\tdout(\"device name '%.*s'\\n\", (int)(dev_name_end - dev_name), dev_name);\n\tdout(\"server path '%s'\\n\", *path);\n\n\t*popt = ceph_parse_options(options, dev_name, dev_name_end,\n\t\t\t\t parse_fsopt_token, (void *)fsopt);\n\tif (IS_ERR(*popt)) {\n\t\terr = PTR_ERR(*popt);\n\t\tgoto out;\n\t}\n\n\t/* success */\n\t*pfsopt = fsopt;\n\treturn 0;\n\nout:\n\tdestroy_mount_options(fsopt);\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/mon_client.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/string.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/in6.h>",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_mount_options",
          "args": [
            "fsopt"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_mount_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "285-290",
          "snippet": "static void destroy_mount_options(struct ceph_mount_options *args)\n{\n\tdout(\"destroy_mount_options %p\\n\", args);\n\tkfree(args->snapdir_name);\n\tkfree(args);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/string.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void destroy_mount_options(struct ceph_mount_options *args)\n{\n\tdout(\"destroy_mount_options %p\\n\", args);\n\tkfree(args->snapdir_name);\n\tkfree(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "*popt"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "*popt"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_parse_options",
          "args": [
            "options",
            "dev_name",
            "dev_name_end",
            "parse_fsopt_token",
            "(void *)fsopt"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"server path '%s'\\n\"",
            "*path"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"device name '%.*s'\\n\"",
            "(int)(dev_name_end - dev_name)",
            "dev_name"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"device name is missing path (no : separator in %s)\\n\"",
            "dev_name"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dev_name"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "dev_name",
            "'/'"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "default_congestion_kb",
          "args": [],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "default_congestion_kb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "657-684",
          "snippet": "static inline int default_congestion_kb(void)\n{\n\tint congestion_kb;\n\n\t/*\n\t * Copied from NFS\n\t *\n\t * congestion size, scale with available memory.\n\t *\n\t *  64MB:    8192k\n\t * 128MB:   11585k\n\t * 256MB:   16384k\n\t * 512MB:   23170k\n\t *   1GB:   32768k\n\t *   2GB:   46340k\n\t *   4GB:   65536k\n\t *   8GB:   92681k\n\t *  16GB:  131072k\n\t *\n\t * This allows larger machines to have larger/more transfers.\n\t * Limit the default to 256M\n\t */\n\tcongestion_kb = (16*int_sqrt(totalram_pages)) << (PAGE_SHIFT-10);\n\tif (congestion_kb > 256*1024)\n\t\tcongestion_kb = 256*1024;\n\n\treturn congestion_kb;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline int default_congestion_kb(void)\n{\n\tint congestion_kb;\n\n\t/*\n\t * Copied from NFS\n\t *\n\t * congestion size, scale with available memory.\n\t *\n\t *  64MB:    8192k\n\t * 128MB:   11585k\n\t * 256MB:   16384k\n\t * 512MB:   23170k\n\t *   1GB:   32768k\n\t *   2GB:   46340k\n\t *   4GB:   65536k\n\t *   8GB:   92681k\n\t *  16GB:  131072k\n\t *\n\t * This allows larger machines to have larger/more transfers.\n\t * Limit the default to 256M\n\t */\n\tcongestion_kb = (16*int_sqrt(totalram_pages)) << (PAGE_SHIFT-10);\n\tif (congestion_kb > 256*1024)\n\t\tcongestion_kb = 256*1024;\n\n\treturn congestion_kb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "CEPH_SNAPDIRNAME_DEFAULT",
            "GFP_KERNEL"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"parse_mount_options %p, dev_name '%s'\\n\"",
            "fsopt",
            "dev_name"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*fsopt)",
            "GFP_KERNEL"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int parse_mount_options(struct ceph_mount_options **pfsopt,\n\t\t\t       struct ceph_options **popt,\n\t\t\t       int flags, char *options,\n\t\t\t       const char *dev_name,\n\t\t\t       const char **path)\n{\n\tstruct ceph_mount_options *fsopt;\n\tconst char *dev_name_end;\n\tint err;\n\n\tif (!dev_name || !*dev_name)\n\t\treturn -EINVAL;\n\n\tfsopt = kzalloc(sizeof(*fsopt), GFP_KERNEL);\n\tif (!fsopt)\n\t\treturn -ENOMEM;\n\n\tdout(\"parse_mount_options %p, dev_name '%s'\\n\", fsopt, dev_name);\n\n\tfsopt->sb_flags = flags;\n\tfsopt->flags = CEPH_MOUNT_OPT_DEFAULT;\n\n\tfsopt->rsize = CEPH_RSIZE_DEFAULT;\n\tfsopt->rasize = CEPH_RASIZE_DEFAULT;\n\tfsopt->snapdir_name = kstrdup(CEPH_SNAPDIRNAME_DEFAULT, GFP_KERNEL);\n\tfsopt->caps_wanted_delay_min = CEPH_CAPS_WANTED_DELAY_MIN_DEFAULT;\n\tfsopt->caps_wanted_delay_max = CEPH_CAPS_WANTED_DELAY_MAX_DEFAULT;\n\tfsopt->cap_release_safety = CEPH_CAP_RELEASE_SAFETY_DEFAULT;\n\tfsopt->max_readdir = CEPH_MAX_READDIR_DEFAULT;\n\tfsopt->max_readdir_bytes = CEPH_MAX_READDIR_BYTES_DEFAULT;\n\tfsopt->congestion_kb = default_congestion_kb();\n\n\t/*\n\t * Distinguish the server list from the path in \"dev_name\".\n\t * Internally we do not include the leading '/' in the path.\n\t *\n\t * \"dev_name\" will look like:\n\t *     <server_spec>[,<server_spec>...]:[<path>]\n\t * where\n\t *     <server_spec> is <ip>[:<port>]\n\t *     <path> is optional, but if present must begin with '/'\n\t */\n\tdev_name_end = strchr(dev_name, '/');\n\tif (dev_name_end) {\n\t\t/* skip over leading '/' for path */\n\t\t*path = dev_name_end + 1;\n\t} else {\n\t\t/* path is empty */\n\t\tdev_name_end = dev_name + strlen(dev_name);\n\t\t*path = dev_name_end;\n\t}\n\terr = -EINVAL;\n\tdev_name_end--;\t\t/* back up to ':' separator */\n\tif (dev_name_end < dev_name || *dev_name_end != ':') {\n\t\tpr_err(\"device name is missing path (no : separator in %s)\\n\",\n\t\t\t\tdev_name);\n\t\tgoto out;\n\t}\n\tdout(\"device name '%.*s'\\n\", (int)(dev_name_end - dev_name), dev_name);\n\tdout(\"server path '%s'\\n\", *path);\n\n\t*popt = ceph_parse_options(options, dev_name, dev_name_end,\n\t\t\t\t parse_fsopt_token, (void *)fsopt);\n\tif (IS_ERR(*popt)) {\n\t\terr = PTR_ERR(*popt);\n\t\tgoto out;\n\t}\n\n\t/* success */\n\t*pfsopt = fsopt;\n\treturn 0;\n\nout:\n\tdestroy_mount_options(fsopt);\n\treturn err;\n}"
  },
  {
    "function_name": "compare_mount_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
    "lines": "303-321",
    "snippet": "static int compare_mount_options(struct ceph_mount_options *new_fsopt,\n\t\t\t\t struct ceph_options *new_opt,\n\t\t\t\t struct ceph_fs_client *fsc)\n{\n\tstruct ceph_mount_options *fsopt1 = new_fsopt;\n\tstruct ceph_mount_options *fsopt2 = fsc->mount_options;\n\tint ofs = offsetof(struct ceph_mount_options, snapdir_name);\n\tint ret;\n\n\tret = memcmp(fsopt1, fsopt2, ofs);\n\tif (ret)\n\t\treturn ret;\n\n\tret = strcmp_null(fsopt1->snapdir_name, fsopt2->snapdir_name);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ceph_compare_options(new_opt, fsc->client);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/mon_client.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/string.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/in6.h>",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_compare_options",
          "args": [
            "new_opt",
            "fsc->client"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp_null",
          "args": [
            "fsopt1->snapdir_name",
            "fsopt2->snapdir_name"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "292-301",
          "snippet": "static int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/string.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "fsopt1",
            "fsopt2",
            "ofs"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int compare_mount_options(struct ceph_mount_options *new_fsopt,\n\t\t\t\t struct ceph_options *new_opt,\n\t\t\t\t struct ceph_fs_client *fsc)\n{\n\tstruct ceph_mount_options *fsopt1 = new_fsopt;\n\tstruct ceph_mount_options *fsopt2 = fsc->mount_options;\n\tint ofs = offsetof(struct ceph_mount_options, snapdir_name);\n\tint ret;\n\n\tret = memcmp(fsopt1, fsopt2, ofs);\n\tif (ret)\n\t\treturn ret;\n\n\tret = strcmp_null(fsopt1->snapdir_name, fsopt2->snapdir_name);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ceph_compare_options(new_opt, fsc->client);\n}"
  },
  {
    "function_name": "strcmp_null",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
    "lines": "292-301",
    "snippet": "static int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/mon_client.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/string.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/in6.h>",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s1",
            "s2"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "292-301",
          "snippet": "static int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}"
  },
  {
    "function_name": "destroy_mount_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
    "lines": "285-290",
    "snippet": "static void destroy_mount_options(struct ceph_mount_options *args)\n{\n\tdout(\"destroy_mount_options %p\\n\", args);\n\tkfree(args->snapdir_name);\n\tkfree(args);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/mon_client.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/string.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/in6.h>",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "args"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "args->snapdir_name"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"destroy_mount_options %p\\n\"",
            "args"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void destroy_mount_options(struct ceph_mount_options *args)\n{\n\tdout(\"destroy_mount_options %p\\n\", args);\n\tkfree(args->snapdir_name);\n\tkfree(args);\n}"
  },
  {
    "function_name": "parse_fsopt_token",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
    "lines": "175-283",
    "snippet": "static int parse_fsopt_token(char *c, void *private)\n{\n\tstruct ceph_mount_options *fsopt = private;\n\tsubstring_t argstr[MAX_OPT_ARGS];\n\tint token, intval, ret;\n\n\ttoken = match_token((char *)c, fsopt_tokens, argstr);\n\tif (token < 0)\n\t\treturn -EINVAL;\n\n\tif (token < Opt_last_int) {\n\t\tret = match_int(&argstr[0], &intval);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"bad mount option arg (not int) \"\n\t\t\t       \"at '%s'\\n\", c);\n\t\t\treturn ret;\n\t\t}\n\t\tdout(\"got int token %d val %d\\n\", token, intval);\n\t} else if (token > Opt_last_int && token < Opt_last_string) {\n\t\tdout(\"got string token %d val %s\\n\", token,\n\t\t     argstr[0].from);\n\t} else {\n\t\tdout(\"got token %d\\n\", token);\n\t}\n\n\tswitch (token) {\n\tcase Opt_snapdirname:\n\t\tkfree(fsopt->snapdir_name);\n\t\tfsopt->snapdir_name = kstrndup(argstr[0].from,\n\t\t\t\t\t       argstr[0].to-argstr[0].from,\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!fsopt->snapdir_name)\n\t\t\treturn -ENOMEM;\n\t\tbreak;\n\n\t\t/* misc */\n\tcase Opt_wsize:\n\t\tfsopt->wsize = intval;\n\t\tbreak;\n\tcase Opt_rsize:\n\t\tfsopt->rsize = intval;\n\t\tbreak;\n\tcase Opt_rasize:\n\t\tfsopt->rasize = intval;\n\t\tbreak;\n\tcase Opt_caps_wanted_delay_min:\n\t\tfsopt->caps_wanted_delay_min = intval;\n\t\tbreak;\n\tcase Opt_caps_wanted_delay_max:\n\t\tfsopt->caps_wanted_delay_max = intval;\n\t\tbreak;\n\tcase Opt_readdir_max_entries:\n\t\tfsopt->max_readdir = intval;\n\t\tbreak;\n\tcase Opt_readdir_max_bytes:\n\t\tfsopt->max_readdir_bytes = intval;\n\t\tbreak;\n\tcase Opt_congestion_kb:\n\t\tfsopt->congestion_kb = intval;\n\t\tbreak;\n\tcase Opt_dirstat:\n\t\tfsopt->flags |= CEPH_MOUNT_OPT_DIRSTAT;\n\t\tbreak;\n\tcase Opt_nodirstat:\n\t\tfsopt->flags &= ~CEPH_MOUNT_OPT_DIRSTAT;\n\t\tbreak;\n\tcase Opt_rbytes:\n\t\tfsopt->flags |= CEPH_MOUNT_OPT_RBYTES;\n\t\tbreak;\n\tcase Opt_norbytes:\n\t\tfsopt->flags &= ~CEPH_MOUNT_OPT_RBYTES;\n\t\tbreak;\n\tcase Opt_asyncreaddir:\n\t\tfsopt->flags &= ~CEPH_MOUNT_OPT_NOASYNCREADDIR;\n\t\tbreak;\n\tcase Opt_noasyncreaddir:\n\t\tfsopt->flags |= CEPH_MOUNT_OPT_NOASYNCREADDIR;\n\t\tbreak;\n\tcase Opt_dcache:\n\t\tfsopt->flags |= CEPH_MOUNT_OPT_DCACHE;\n\t\tbreak;\n\tcase Opt_nodcache:\n\t\tfsopt->flags &= ~CEPH_MOUNT_OPT_DCACHE;\n\t\tbreak;\n\tcase Opt_ino32:\n\t\tfsopt->flags |= CEPH_MOUNT_OPT_INO32;\n\t\tbreak;\n\tcase Opt_noino32:\n\t\tfsopt->flags &= ~CEPH_MOUNT_OPT_INO32;\n\t\tbreak;\n\tcase Opt_fscache:\n\t\tfsopt->flags |= CEPH_MOUNT_OPT_FSCACHE;\n\t\tbreak;\n\tcase Opt_nofscache:\n\t\tfsopt->flags &= ~CEPH_MOUNT_OPT_FSCACHE;\n\t\tbreak;\n#ifdef CONFIG_CEPH_FS_POSIX_ACL\n\tcase Opt_acl:\n\t\tfsopt->sb_flags |= MS_POSIXACL;\n\t\tbreak;\n#endif\n\tcase Opt_noacl:\n\t\tfsopt->sb_flags &= ~MS_POSIXACL;\n\t\tbreak;\n\tdefault:\n\t\tBUG_ON(token);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/mon_client.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/string.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/in6.h>",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static match_table_t fsopt_tokens = {\n\t{Opt_wsize, \"wsize=%d\"},\n\t{Opt_rsize, \"rsize=%d\"},\n\t{Opt_rasize, \"rasize=%d\"},\n\t{Opt_caps_wanted_delay_min, \"caps_wanted_delay_min=%d\"},\n\t{Opt_caps_wanted_delay_max, \"caps_wanted_delay_max=%d\"},\n\t{Opt_cap_release_safety, \"cap_release_safety=%d\"},\n\t{Opt_readdir_max_entries, \"readdir_max_entries=%d\"},\n\t{Opt_readdir_max_bytes, \"readdir_max_bytes=%d\"},\n\t{Opt_congestion_kb, \"write_congestion_kb=%d\"},\n\t/* int args above */\n\t{Opt_snapdirname, \"snapdirname=%s\"},\n\t/* string args above */\n\t{Opt_dirstat, \"dirstat\"},\n\t{Opt_nodirstat, \"nodirstat\"},\n\t{Opt_rbytes, \"rbytes\"},\n\t{Opt_norbytes, \"norbytes\"},\n\t{Opt_asyncreaddir, \"asyncreaddir\"},\n\t{Opt_noasyncreaddir, \"noasyncreaddir\"},\n\t{Opt_dcache, \"dcache\"},\n\t{Opt_nodcache, \"nodcache\"},\n\t{Opt_ino32, \"ino32\"},\n\t{Opt_noino32, \"noino32\"},\n\t{Opt_fscache, \"fsc\"},\n\t{Opt_nofscache, \"nofsc\"},\n#ifdef CONFIG_CEPH_FS_POSIX_ACL\n\t{Opt_acl, \"acl\"},\n#endif\n\t{Opt_noacl, \"noacl\"},\n\t{-1, NULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "token"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrndup",
          "args": [
            "argstr[0].from",
            "argstr[0].to-argstr[0].from",
            "GFP_KERNEL"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fsopt->snapdir_name"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"got token %d\\n\"",
            "token"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"got string token %d val %s\\n\"",
            "token",
            "argstr[0].from"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"got int token %d val %d\\n\"",
            "token",
            "intval"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"bad mount option arg (not int) \"\n\t\t\t       \"at '%s'\\n\"",
            "c"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&argstr[0]",
            "&intval"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "(char *)c",
            "fsopt_tokens",
            "argstr"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic match_table_t fsopt_tokens = {\n\t{Opt_wsize, \"wsize=%d\"},\n\t{Opt_rsize, \"rsize=%d\"},\n\t{Opt_rasize, \"rasize=%d\"},\n\t{Opt_caps_wanted_delay_min, \"caps_wanted_delay_min=%d\"},\n\t{Opt_caps_wanted_delay_max, \"caps_wanted_delay_max=%d\"},\n\t{Opt_cap_release_safety, \"cap_release_safety=%d\"},\n\t{Opt_readdir_max_entries, \"readdir_max_entries=%d\"},\n\t{Opt_readdir_max_bytes, \"readdir_max_bytes=%d\"},\n\t{Opt_congestion_kb, \"write_congestion_kb=%d\"},\n\t/* int args above */\n\t{Opt_snapdirname, \"snapdirname=%s\"},\n\t/* string args above */\n\t{Opt_dirstat, \"dirstat\"},\n\t{Opt_nodirstat, \"nodirstat\"},\n\t{Opt_rbytes, \"rbytes\"},\n\t{Opt_norbytes, \"norbytes\"},\n\t{Opt_asyncreaddir, \"asyncreaddir\"},\n\t{Opt_noasyncreaddir, \"noasyncreaddir\"},\n\t{Opt_dcache, \"dcache\"},\n\t{Opt_nodcache, \"nodcache\"},\n\t{Opt_ino32, \"ino32\"},\n\t{Opt_noino32, \"noino32\"},\n\t{Opt_fscache, \"fsc\"},\n\t{Opt_nofscache, \"nofsc\"},\n#ifdef CONFIG_CEPH_FS_POSIX_ACL\n\t{Opt_acl, \"acl\"},\n#endif\n\t{Opt_noacl, \"noacl\"},\n\t{-1, NULL}\n};\n\nstatic int parse_fsopt_token(char *c, void *private)\n{\n\tstruct ceph_mount_options *fsopt = private;\n\tsubstring_t argstr[MAX_OPT_ARGS];\n\tint token, intval, ret;\n\n\ttoken = match_token((char *)c, fsopt_tokens, argstr);\n\tif (token < 0)\n\t\treturn -EINVAL;\n\n\tif (token < Opt_last_int) {\n\t\tret = match_int(&argstr[0], &intval);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"bad mount option arg (not int) \"\n\t\t\t       \"at '%s'\\n\", c);\n\t\t\treturn ret;\n\t\t}\n\t\tdout(\"got int token %d val %d\\n\", token, intval);\n\t} else if (token > Opt_last_int && token < Opt_last_string) {\n\t\tdout(\"got string token %d val %s\\n\", token,\n\t\t     argstr[0].from);\n\t} else {\n\t\tdout(\"got token %d\\n\", token);\n\t}\n\n\tswitch (token) {\n\tcase Opt_snapdirname:\n\t\tkfree(fsopt->snapdir_name);\n\t\tfsopt->snapdir_name = kstrndup(argstr[0].from,\n\t\t\t\t\t       argstr[0].to-argstr[0].from,\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!fsopt->snapdir_name)\n\t\t\treturn -ENOMEM;\n\t\tbreak;\n\n\t\t/* misc */\n\tcase Opt_wsize:\n\t\tfsopt->wsize = intval;\n\t\tbreak;\n\tcase Opt_rsize:\n\t\tfsopt->rsize = intval;\n\t\tbreak;\n\tcase Opt_rasize:\n\t\tfsopt->rasize = intval;\n\t\tbreak;\n\tcase Opt_caps_wanted_delay_min:\n\t\tfsopt->caps_wanted_delay_min = intval;\n\t\tbreak;\n\tcase Opt_caps_wanted_delay_max:\n\t\tfsopt->caps_wanted_delay_max = intval;\n\t\tbreak;\n\tcase Opt_readdir_max_entries:\n\t\tfsopt->max_readdir = intval;\n\t\tbreak;\n\tcase Opt_readdir_max_bytes:\n\t\tfsopt->max_readdir_bytes = intval;\n\t\tbreak;\n\tcase Opt_congestion_kb:\n\t\tfsopt->congestion_kb = intval;\n\t\tbreak;\n\tcase Opt_dirstat:\n\t\tfsopt->flags |= CEPH_MOUNT_OPT_DIRSTAT;\n\t\tbreak;\n\tcase Opt_nodirstat:\n\t\tfsopt->flags &= ~CEPH_MOUNT_OPT_DIRSTAT;\n\t\tbreak;\n\tcase Opt_rbytes:\n\t\tfsopt->flags |= CEPH_MOUNT_OPT_RBYTES;\n\t\tbreak;\n\tcase Opt_norbytes:\n\t\tfsopt->flags &= ~CEPH_MOUNT_OPT_RBYTES;\n\t\tbreak;\n\tcase Opt_asyncreaddir:\n\t\tfsopt->flags &= ~CEPH_MOUNT_OPT_NOASYNCREADDIR;\n\t\tbreak;\n\tcase Opt_noasyncreaddir:\n\t\tfsopt->flags |= CEPH_MOUNT_OPT_NOASYNCREADDIR;\n\t\tbreak;\n\tcase Opt_dcache:\n\t\tfsopt->flags |= CEPH_MOUNT_OPT_DCACHE;\n\t\tbreak;\n\tcase Opt_nodcache:\n\t\tfsopt->flags &= ~CEPH_MOUNT_OPT_DCACHE;\n\t\tbreak;\n\tcase Opt_ino32:\n\t\tfsopt->flags |= CEPH_MOUNT_OPT_INO32;\n\t\tbreak;\n\tcase Opt_noino32:\n\t\tfsopt->flags &= ~CEPH_MOUNT_OPT_INO32;\n\t\tbreak;\n\tcase Opt_fscache:\n\t\tfsopt->flags |= CEPH_MOUNT_OPT_FSCACHE;\n\t\tbreak;\n\tcase Opt_nofscache:\n\t\tfsopt->flags &= ~CEPH_MOUNT_OPT_FSCACHE;\n\t\tbreak;\n#ifdef CONFIG_CEPH_FS_POSIX_ACL\n\tcase Opt_acl:\n\t\tfsopt->sb_flags |= MS_POSIXACL;\n\t\tbreak;\n#endif\n\tcase Opt_noacl:\n\t\tfsopt->sb_flags &= ~MS_POSIXACL;\n\t\tbreak;\n\tdefault:\n\t\tBUG_ON(token);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ceph_sync_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
    "lines": "89-105",
    "snippet": "static int ceph_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(sb);\n\n\tif (!wait) {\n\t\tdout(\"sync_fs (non-blocking)\\n\");\n\t\tceph_flush_dirty_caps(fsc->mdsc);\n\t\tdout(\"sync_fs (non-blocking) done\\n\");\n\t\treturn 0;\n\t}\n\n\tdout(\"sync_fs (blocking)\\n\");\n\tceph_osdc_sync(&fsc->client->osdc);\n\tceph_mdsc_sync(fsc->mdsc);\n\tdout(\"sync_fs (blocking) done\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/mon_client.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/string.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/in6.h>",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"sync_fs (blocking) done\\n\""
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_sync",
          "args": [
            "fsc->mdsc"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "3485-3506",
          "snippet": "void ceph_mdsc_sync(struct ceph_mds_client *mdsc)\n{\n\tu64 want_tid, want_flush;\n\n\tif (mdsc->fsc->mount_state == CEPH_MOUNT_SHUTDOWN)\n\t\treturn;\n\n\tdout(\"sync\\n\");\n\tmutex_lock(&mdsc->mutex);\n\twant_tid = mdsc->last_tid;\n\tmutex_unlock(&mdsc->mutex);\n\n\tceph_flush_dirty_caps(mdsc);\n\tspin_lock(&mdsc->cap_dirty_lock);\n\twant_flush = mdsc->cap_flush_seq;\n\tspin_unlock(&mdsc->cap_dirty_lock);\n\n\tdout(\"sync want tid %lld flush_seq %lld\\n\", want_tid, want_flush);\n\n\twait_unsafe_requests(mdsc, want_tid);\n\twait_caps_flush(mdsc, want_flush);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_mdsc_sync(struct ceph_mds_client *mdsc)\n{\n\tu64 want_tid, want_flush;\n\n\tif (mdsc->fsc->mount_state == CEPH_MOUNT_SHUTDOWN)\n\t\treturn;\n\n\tdout(\"sync\\n\");\n\tmutex_lock(&mdsc->mutex);\n\twant_tid = mdsc->last_tid;\n\tmutex_unlock(&mdsc->mutex);\n\n\tceph_flush_dirty_caps(mdsc);\n\tspin_lock(&mdsc->cap_dirty_lock);\n\twant_flush = mdsc->cap_flush_seq;\n\tspin_unlock(&mdsc->cap_dirty_lock);\n\n\tdout(\"sync want tid %lld flush_seq %lld\\n\", want_tid, want_flush);\n\n\twait_unsafe_requests(mdsc, want_tid);\n\twait_caps_flush(mdsc, want_flush);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_osdc_sync",
          "args": [
            "&fsc->client->osdc"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"sync_fs (blocking)\\n\""
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"sync_fs (non-blocking) done\\n\""
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_flush_dirty_caps",
          "args": [
            "fsc->mdsc"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_flush_dirty_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "3273-3293",
          "snippet": "void ceph_flush_dirty_caps(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_inode_info *ci;\n\tstruct inode *inode;\n\n\tdout(\"flush_dirty_caps\\n\");\n\tspin_lock(&mdsc->cap_dirty_lock);\n\twhile (!list_empty(&mdsc->cap_dirty)) {\n\t\tci = list_first_entry(&mdsc->cap_dirty, struct ceph_inode_info,\n\t\t\t\t      i_dirty_item);\n\t\tinode = &ci->vfs_inode;\n\t\tihold(inode);\n\t\tdout(\"flush_dirty_caps %p\\n\", inode);\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\tceph_check_caps(ci, CHECK_CAPS_NODELAY|CHECK_CAPS_FLUSH, NULL);\n\t\tiput(inode);\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t}\n\tspin_unlock(&mdsc->cap_dirty_lock);\n\tdout(\"flush_dirty_caps done\\n\");\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_flush_dirty_caps(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_inode_info *ci;\n\tstruct inode *inode;\n\n\tdout(\"flush_dirty_caps\\n\");\n\tspin_lock(&mdsc->cap_dirty_lock);\n\twhile (!list_empty(&mdsc->cap_dirty)) {\n\t\tci = list_first_entry(&mdsc->cap_dirty, struct ceph_inode_info,\n\t\t\t\t      i_dirty_item);\n\t\tinode = &ci->vfs_inode;\n\t\tihold(inode);\n\t\tdout(\"flush_dirty_caps %p\\n\", inode);\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\tceph_check_caps(ci, CHECK_CAPS_NODELAY|CHECK_CAPS_FLUSH, NULL);\n\t\tiput(inode);\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t}\n\tspin_unlock(&mdsc->cap_dirty_lock);\n\tdout(\"flush_dirty_caps done\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"sync_fs (non-blocking)\\n\""
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "sb"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(sb);\n\n\tif (!wait) {\n\t\tdout(\"sync_fs (non-blocking)\\n\");\n\t\tceph_flush_dirty_caps(fsc->mdsc);\n\t\tdout(\"sync_fs (non-blocking) done\\n\");\n\t\treturn 0;\n\t}\n\n\tdout(\"sync_fs (blocking)\\n\");\n\tceph_osdc_sync(&fsc->client->osdc);\n\tceph_mdsc_sync(fsc->mdsc);\n\tdout(\"sync_fs (blocking) done\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "ceph_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
    "lines": "45-86",
    "snippet": "static int ceph_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(dentry->d_inode);\n\tstruct ceph_monmap *monmap = fsc->client->monc.monmap;\n\tstruct ceph_statfs st;\n\tu64 fsid;\n\tint err;\n\n\tdout(\"statfs\\n\");\n\terr = ceph_monc_do_statfs(&fsc->client->monc, &st);\n\tif (err < 0)\n\t\treturn err;\n\n\t/* fill in kstatfs */\n\tbuf->f_type = CEPH_SUPER_MAGIC;  /* ?? */\n\n\t/*\n\t * express utilization in terms of large blocks to avoid\n\t * overflow on 32-bit machines.\n\t *\n\t * NOTE: for the time being, we make bsize == frsize to humor\n\t * not-yet-ancient versions of glibc that are broken.\n\t * Someday, we will probably want to report a real block\n\t * size...  whatever that may mean for a network file system!\n\t */\n\tbuf->f_bsize = 1 << CEPH_BLOCK_SHIFT;\n\tbuf->f_frsize = 1 << CEPH_BLOCK_SHIFT;\n\tbuf->f_blocks = le64_to_cpu(st.kb) >> (CEPH_BLOCK_SHIFT-10);\n\tbuf->f_bfree = le64_to_cpu(st.kb_avail) >> (CEPH_BLOCK_SHIFT-10);\n\tbuf->f_bavail = le64_to_cpu(st.kb_avail) >> (CEPH_BLOCK_SHIFT-10);\n\n\tbuf->f_files = le64_to_cpu(st.num_objects);\n\tbuf->f_ffree = -1;\n\tbuf->f_namelen = NAME_MAX;\n\n\t/* leave fsid little-endian, regardless of host endianness */\n\tfsid = *(u64 *)(&monmap->fsid) ^ *((u64 *)&monmap->fsid + 1);\n\tbuf->f_fsid.val[0] = fsid & 0xffffffff;\n\tbuf->f_fsid.val[1] = fsid >> 32;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/mon_client.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/string.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/in6.h>",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "st.num_objects"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_monc_do_statfs",
          "args": [
            "&fsc->client->monc",
            "&st"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"statfs\\n\""
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode_to_client",
          "args": [
            "dentry->d_inode"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(dentry->d_inode);\n\tstruct ceph_monmap *monmap = fsc->client->monc.monmap;\n\tstruct ceph_statfs st;\n\tu64 fsid;\n\tint err;\n\n\tdout(\"statfs\\n\");\n\terr = ceph_monc_do_statfs(&fsc->client->monc, &st);\n\tif (err < 0)\n\t\treturn err;\n\n\t/* fill in kstatfs */\n\tbuf->f_type = CEPH_SUPER_MAGIC;  /* ?? */\n\n\t/*\n\t * express utilization in terms of large blocks to avoid\n\t * overflow on 32-bit machines.\n\t *\n\t * NOTE: for the time being, we make bsize == frsize to humor\n\t * not-yet-ancient versions of glibc that are broken.\n\t * Someday, we will probably want to report a real block\n\t * size...  whatever that may mean for a network file system!\n\t */\n\tbuf->f_bsize = 1 << CEPH_BLOCK_SHIFT;\n\tbuf->f_frsize = 1 << CEPH_BLOCK_SHIFT;\n\tbuf->f_blocks = le64_to_cpu(st.kb) >> (CEPH_BLOCK_SHIFT-10);\n\tbuf->f_bfree = le64_to_cpu(st.kb_avail) >> (CEPH_BLOCK_SHIFT-10);\n\tbuf->f_bavail = le64_to_cpu(st.kb_avail) >> (CEPH_BLOCK_SHIFT-10);\n\n\tbuf->f_files = le64_to_cpu(st.num_objects);\n\tbuf->f_ffree = -1;\n\tbuf->f_namelen = NAME_MAX;\n\n\t/* leave fsid little-endian, regardless of host endianness */\n\tfsid = *(u64 *)(&monmap->fsid) ^ *((u64 *)&monmap->fsid + 1);\n\tbuf->f_fsid.val[0] = fsid & 0xffffffff;\n\tbuf->f_fsid.val[1] = fsid >> 32;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ceph_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
    "lines": "37-43",
    "snippet": "static void ceph_put_super(struct super_block *s)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(s);\n\n\tdout(\"put_super\\n\");\n\tceph_mdsc_close_sessions(fsc->mdsc);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/mon_client.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/string.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/in6.h>",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/ctype.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_mdsc_close_sessions",
          "args": [
            "fsc->mdsc"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_close_sessions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "3521-3571",
          "snippet": "void ceph_mdsc_close_sessions(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_mds_session *session;\n\tint i;\n\tstruct ceph_fs_client *fsc = mdsc->fsc;\n\tunsigned long timeout = fsc->client->options->mount_timeout * HZ;\n\n\tdout(\"close_sessions\\n\");\n\n\t/* close sessions */\n\tmutex_lock(&mdsc->mutex);\n\tfor (i = 0; i < mdsc->max_sessions; i++) {\n\t\tsession = __ceph_lookup_mds_session(mdsc, i);\n\t\tif (!session)\n\t\t\tcontinue;\n\t\tmutex_unlock(&mdsc->mutex);\n\t\tmutex_lock(&session->s_mutex);\n\t\t__close_session(mdsc, session);\n\t\tmutex_unlock(&session->s_mutex);\n\t\tceph_put_mds_session(session);\n\t\tmutex_lock(&mdsc->mutex);\n\t}\n\tmutex_unlock(&mdsc->mutex);\n\n\tdout(\"waiting for sessions to close\\n\");\n\twait_event_timeout(mdsc->session_close_wq, done_closing_sessions(mdsc),\n\t\t\t   timeout);\n\n\t/* tear down remaining sessions */\n\tmutex_lock(&mdsc->mutex);\n\tfor (i = 0; i < mdsc->max_sessions; i++) {\n\t\tif (mdsc->sessions[i]) {\n\t\t\tsession = get_session(mdsc->sessions[i]);\n\t\t\t__unregister_session(mdsc, session);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tmutex_lock(&session->s_mutex);\n\t\t\tremove_session_caps(session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tceph_put_mds_session(session);\n\t\t\tmutex_lock(&mdsc->mutex);\n\t\t}\n\t}\n\tWARN_ON(!list_empty(&mdsc->cap_delay_list));\n\tmutex_unlock(&mdsc->mutex);\n\n\tceph_cleanup_empty_realms(mdsc);\n\n\tcancel_delayed_work_sync(&mdsc->delayed_work); /* cancel timer */\n\n\tdout(\"stopped\\n\");\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_mdsc_close_sessions(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_mds_session *session;\n\tint i;\n\tstruct ceph_fs_client *fsc = mdsc->fsc;\n\tunsigned long timeout = fsc->client->options->mount_timeout * HZ;\n\n\tdout(\"close_sessions\\n\");\n\n\t/* close sessions */\n\tmutex_lock(&mdsc->mutex);\n\tfor (i = 0; i < mdsc->max_sessions; i++) {\n\t\tsession = __ceph_lookup_mds_session(mdsc, i);\n\t\tif (!session)\n\t\t\tcontinue;\n\t\tmutex_unlock(&mdsc->mutex);\n\t\tmutex_lock(&session->s_mutex);\n\t\t__close_session(mdsc, session);\n\t\tmutex_unlock(&session->s_mutex);\n\t\tceph_put_mds_session(session);\n\t\tmutex_lock(&mdsc->mutex);\n\t}\n\tmutex_unlock(&mdsc->mutex);\n\n\tdout(\"waiting for sessions to close\\n\");\n\twait_event_timeout(mdsc->session_close_wq, done_closing_sessions(mdsc),\n\t\t\t   timeout);\n\n\t/* tear down remaining sessions */\n\tmutex_lock(&mdsc->mutex);\n\tfor (i = 0; i < mdsc->max_sessions; i++) {\n\t\tif (mdsc->sessions[i]) {\n\t\t\tsession = get_session(mdsc->sessions[i]);\n\t\t\t__unregister_session(mdsc, session);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tmutex_lock(&session->s_mutex);\n\t\t\tremove_session_caps(session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tceph_put_mds_session(session);\n\t\t\tmutex_lock(&mdsc->mutex);\n\t\t}\n\t}\n\tWARN_ON(!list_empty(&mdsc->cap_delay_list));\n\tmutex_unlock(&mdsc->mutex);\n\n\tceph_cleanup_empty_realms(mdsc);\n\n\tcancel_delayed_work_sync(&mdsc->delayed_work); /* cancel timer */\n\n\tdout(\"stopped\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"put_super\\n\""
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "s"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void ceph_put_super(struct super_block *s)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(s);\n\n\tdout(\"put_super\\n\");\n\tceph_mdsc_close_sessions(fsc->mdsc);\n}"
  }
]