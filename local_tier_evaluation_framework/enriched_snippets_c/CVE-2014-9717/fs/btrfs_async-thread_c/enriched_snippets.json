[
  {
    "function_name": "btrfs_set_work_high_priority",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
    "lines": "362-365",
    "snippet": "void btrfs_set_work_high_priority(struct btrfs_work *work)\n{\n\tset_bit(WORK_HIGH_PRIO_BIT, &work->flags);\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"async-thread.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [
      "#define WORK_HIGH_PRIO_BIT 2"
    ],
    "globals_used": [
      "static void normal_work_helper(struct btrfs_work *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "WORK_HIGH_PRIO_BIT",
            "&work->flags"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define WORK_HIGH_PRIO_BIT 2\n\nstatic void normal_work_helper(struct btrfs_work *work);\n\nvoid btrfs_set_work_high_priority(struct btrfs_work *work)\n{\n\tset_bit(WORK_HIGH_PRIO_BIT, &work->flags);\n}"
  },
  {
    "function_name": "btrfs_workqueue_set_max",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
    "lines": "353-360",
    "snippet": "void btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"async-thread.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}"
  },
  {
    "function_name": "btrfs_destroy_workqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
    "lines": "343-351",
    "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"async-thread.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "wq"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_destroy_workqueue",
          "args": [
            "wq->normal"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "335-341",
          "snippet": "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq)\n{\n\tdestroy_workqueue(wq->normal_wq);\n\ttrace_btrfs_workqueue_destroy(wq);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq)\n{\n\tdestroy_workqueue(wq->normal_wq);\n\ttrace_btrfs_workqueue_destroy(wq);\n\tkfree(wq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
  },
  {
    "function_name": "__btrfs_destroy_workqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
    "lines": "335-341",
    "snippet": "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq)\n{\n\tdestroy_workqueue(wq->normal_wq);\n\ttrace_btrfs_workqueue_destroy(wq);\n\tkfree(wq);\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"async-thread.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "wq"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_btrfs_workqueue_destroy",
          "args": [
            "wq"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "wq->normal_wq"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq)\n{\n\tdestroy_workqueue(wq->normal_wq);\n\ttrace_btrfs_workqueue_destroy(wq);\n\tkfree(wq);\n}"
  },
  {
    "function_name": "btrfs_queue_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
    "lines": "323-333",
    "snippet": "void btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"async-thread.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [
      "#define WORK_HIGH_PRIO_BIT 2"
    ],
    "globals_used": [
      "static void normal_work_helper(struct btrfs_work *work);",
      "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_queue_work",
          "args": [
            "dest_wq",
            "work"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "307-321",
          "snippet": "static inline void __btrfs_queue_work(struct __btrfs_workqueue *wq,\n\t\t\t\t      struct btrfs_work *work)\n{\n\tunsigned long flags;\n\n\twork->wq = wq;\n\tthresh_queue_hook(wq);\n\tif (work->ordered_func) {\n\t\tspin_lock_irqsave(&wq->list_lock, flags);\n\t\tlist_add_tail(&work->ordered_list, &wq->ordered_list);\n\t\tspin_unlock_irqrestore(&wq->list_lock, flags);\n\t}\n\tqueue_work(wq->normal_wq, &work->normal_work);\n\ttrace_btrfs_work_queued(work);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);",
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic void normal_work_helper(struct btrfs_work *work);\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nstatic inline void __btrfs_queue_work(struct __btrfs_workqueue *wq,\n\t\t\t\t      struct btrfs_work *work)\n{\n\tunsigned long flags;\n\n\twork->wq = wq;\n\tthresh_queue_hook(wq);\n\tif (work->ordered_func) {\n\t\tspin_lock_irqsave(&wq->list_lock, flags);\n\t\tlist_add_tail(&work->ordered_list, &wq->ordered_list);\n\t\tspin_unlock_irqrestore(&wq->list_lock, flags);\n\t}\n\tqueue_work(wq->normal_wq, &work->normal_work);\n\ttrace_btrfs_work_queued(work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "WORK_HIGH_PRIO_BIT",
            "&work->flags"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define WORK_HIGH_PRIO_BIT 2\n\nstatic void normal_work_helper(struct btrfs_work *work);\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}"
  },
  {
    "function_name": "__btrfs_queue_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
    "lines": "307-321",
    "snippet": "static inline void __btrfs_queue_work(struct __btrfs_workqueue *wq,\n\t\t\t\t      struct btrfs_work *work)\n{\n\tunsigned long flags;\n\n\twork->wq = wq;\n\tthresh_queue_hook(wq);\n\tif (work->ordered_func) {\n\t\tspin_lock_irqsave(&wq->list_lock, flags);\n\t\tlist_add_tail(&work->ordered_list, &wq->ordered_list);\n\t\tspin_unlock_irqrestore(&wq->list_lock, flags);\n\t}\n\tqueue_work(wq->normal_wq, &work->normal_work);\n\ttrace_btrfs_work_queued(work);\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"async-thread.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void normal_work_helper(struct btrfs_work *work);",
      "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_btrfs_work_queued",
          "args": [
            "work"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "wq->normal_wq",
            "&work->normal_work"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "323-333",
          "snippet": "void btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define WORK_HIGH_PRIO_BIT 2"
          ],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);",
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define WORK_HIGH_PRIO_BIT 2\n\nstatic void normal_work_helper(struct btrfs_work *work);\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&wq->list_lock",
            "flags"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&work->ordered_list",
            "&wq->ordered_list"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&wq->list_lock",
            "flags"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thresh_queue_hook",
          "args": [
            "wq"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "thresh_queue_hook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "168-173",
          "snippet": "static inline void thresh_queue_hook(struct __btrfs_workqueue *wq)\n{\n\tif (wq->thresh == NO_THRESHOLD)\n\t\treturn;\n\tatomic_inc(&wq->pending);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define NO_THRESHOLD (-1)"
          ],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define NO_THRESHOLD (-1)\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nstatic inline void thresh_queue_hook(struct __btrfs_workqueue *wq)\n{\n\tif (wq->thresh == NO_THRESHOLD)\n\t\treturn;\n\tatomic_inc(&wq->pending);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic void normal_work_helper(struct btrfs_work *work);\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nstatic inline void __btrfs_queue_work(struct __btrfs_workqueue *wq,\n\t\t\t\t      struct btrfs_work *work)\n{\n\tunsigned long flags;\n\n\twork->wq = wq;\n\tthresh_queue_hook(wq);\n\tif (work->ordered_func) {\n\t\tspin_lock_irqsave(&wq->list_lock, flags);\n\t\tlist_add_tail(&work->ordered_list, &wq->ordered_list);\n\t\tspin_unlock_irqrestore(&wq->list_lock, flags);\n\t}\n\tqueue_work(wq->normal_wq, &work->normal_work);\n\ttrace_btrfs_work_queued(work);\n}"
  },
  {
    "function_name": "btrfs_init_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
    "lines": "294-305",
    "snippet": "void btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"async-thread.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void normal_work_helper(struct btrfs_work *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&work->ordered_list"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&work->normal_work",
            "uniq_func"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic void normal_work_helper(struct btrfs_work *work);\n\nvoid btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}"
  },
  {
    "function_name": "normal_work_helper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
    "lines": "266-292",
    "snippet": "static void normal_work_helper(struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *wq;\n\tint need_order = 0;\n\n\t/*\n\t * We should not touch things inside work in the following cases:\n\t * 1) after work->func() if it has no ordered_free\n\t *    Since the struct is freed in work->func().\n\t * 2) after setting WORK_DONE_BIT\n\t *    The work may be freed in other threads almost instantly.\n\t * So we save the needed things here.\n\t */\n\tif (work->ordered_func)\n\t\tneed_order = 1;\n\twq = work->wq;\n\n\ttrace_btrfs_work_sched(work);\n\tthresh_exec_hook(wq);\n\twork->func(work);\n\tif (need_order) {\n\t\tset_bit(WORK_DONE_BIT, &work->flags);\n\t\trun_ordered_work(wq);\n\t}\n\tif (!need_order)\n\t\ttrace_btrfs_all_work_done(work);\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"async-thread.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [
      "#define WORK_DONE_BIT 0"
    ],
    "globals_used": [
      "static void normal_work_helper(struct btrfs_work *work);",
      "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_btrfs_all_work_done",
          "args": [
            "work"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_ordered_work",
          "args": [
            "wq"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "run_ordered_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "223-264",
          "snippet": "static void run_ordered_work(struct __btrfs_workqueue *wq)\n{\n\tstruct list_head *list = &wq->ordered_list;\n\tstruct btrfs_work *work;\n\tspinlock_t *lock = &wq->list_lock;\n\tunsigned long flags;\n\n\twhile (1) {\n\t\tspin_lock_irqsave(lock, flags);\n\t\tif (list_empty(list))\n\t\t\tbreak;\n\t\twork = list_entry(list->next, struct btrfs_work,\n\t\t\t\t  ordered_list);\n\t\tif (!test_bit(WORK_DONE_BIT, &work->flags))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * we are going to call the ordered done function, but\n\t\t * we leave the work item on the list as a barrier so\n\t\t * that later work items that are done don't have their\n\t\t * functions called before this one returns\n\t\t */\n\t\tif (test_and_set_bit(WORK_ORDER_DONE_BIT, &work->flags))\n\t\t\tbreak;\n\t\ttrace_btrfs_ordered_sched(work);\n\t\tspin_unlock_irqrestore(lock, flags);\n\t\twork->ordered_func(work);\n\n\t\t/* now take the lock again and drop our item from the list */\n\t\tspin_lock_irqsave(lock, flags);\n\t\tlist_del(&work->ordered_list);\n\t\tspin_unlock_irqrestore(lock, flags);\n\n\t\t/*\n\t\t * we don't want to call the ordered free functions\n\t\t * with the lock held though\n\t\t */\n\t\twork->ordered_free(work);\n\t\ttrace_btrfs_all_work_done(work);\n\t}\n\tspin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define WORK_ORDER_DONE_BIT 1",
            "#define WORK_DONE_BIT 0"
          ],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);",
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define WORK_ORDER_DONE_BIT 1\n#define WORK_DONE_BIT 0\n\nstatic void normal_work_helper(struct btrfs_work *work);\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nstatic void run_ordered_work(struct __btrfs_workqueue *wq)\n{\n\tstruct list_head *list = &wq->ordered_list;\n\tstruct btrfs_work *work;\n\tspinlock_t *lock = &wq->list_lock;\n\tunsigned long flags;\n\n\twhile (1) {\n\t\tspin_lock_irqsave(lock, flags);\n\t\tif (list_empty(list))\n\t\t\tbreak;\n\t\twork = list_entry(list->next, struct btrfs_work,\n\t\t\t\t  ordered_list);\n\t\tif (!test_bit(WORK_DONE_BIT, &work->flags))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * we are going to call the ordered done function, but\n\t\t * we leave the work item on the list as a barrier so\n\t\t * that later work items that are done don't have their\n\t\t * functions called before this one returns\n\t\t */\n\t\tif (test_and_set_bit(WORK_ORDER_DONE_BIT, &work->flags))\n\t\t\tbreak;\n\t\ttrace_btrfs_ordered_sched(work);\n\t\tspin_unlock_irqrestore(lock, flags);\n\t\twork->ordered_func(work);\n\n\t\t/* now take the lock again and drop our item from the list */\n\t\tspin_lock_irqsave(lock, flags);\n\t\tlist_del(&work->ordered_list);\n\t\tspin_unlock_irqrestore(lock, flags);\n\n\t\t/*\n\t\t * we don't want to call the ordered free functions\n\t\t * with the lock held though\n\t\t */\n\t\twork->ordered_free(work);\n\t\ttrace_btrfs_all_work_done(work);\n\t}\n\tspin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "WORK_DONE_BIT",
            "&work->flags"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "work->func",
          "args": [
            "work"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thresh_exec_hook",
          "args": [
            "wq"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "thresh_exec_hook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "180-221",
          "snippet": "static inline void thresh_exec_hook(struct __btrfs_workqueue *wq)\n{\n\tint new_max_active;\n\tlong pending;\n\tint need_change = 0;\n\n\tif (wq->thresh == NO_THRESHOLD)\n\t\treturn;\n\n\tatomic_dec(&wq->pending);\n\tspin_lock(&wq->thres_lock);\n\t/*\n\t * Use wq->count to limit the calling frequency of\n\t * workqueue_set_max_active.\n\t */\n\twq->count++;\n\twq->count %= (wq->thresh / 4);\n\tif (!wq->count)\n\t\tgoto  out;\n\tnew_max_active = wq->current_max;\n\n\t/*\n\t * pending may be changed later, but it's OK since we really\n\t * don't need it so accurate to calculate new_max_active.\n\t */\n\tpending = atomic_read(&wq->pending);\n\tif (pending > wq->thresh)\n\t\tnew_max_active++;\n\tif (pending < wq->thresh / 2)\n\t\tnew_max_active--;\n\tnew_max_active = clamp_val(new_max_active, 1, wq->max_active);\n\tif (new_max_active != wq->current_max)  {\n\t\tneed_change = 1;\n\t\twq->current_max = new_max_active;\n\t}\nout:\n\tspin_unlock(&wq->thres_lock);\n\n\tif (need_change) {\n\t\tworkqueue_set_max_active(wq->normal_wq, wq->current_max);\n\t}\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define NO_THRESHOLD (-1)"
          ],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define NO_THRESHOLD (-1)\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nstatic inline void thresh_exec_hook(struct __btrfs_workqueue *wq)\n{\n\tint new_max_active;\n\tlong pending;\n\tint need_change = 0;\n\n\tif (wq->thresh == NO_THRESHOLD)\n\t\treturn;\n\n\tatomic_dec(&wq->pending);\n\tspin_lock(&wq->thres_lock);\n\t/*\n\t * Use wq->count to limit the calling frequency of\n\t * workqueue_set_max_active.\n\t */\n\twq->count++;\n\twq->count %= (wq->thresh / 4);\n\tif (!wq->count)\n\t\tgoto  out;\n\tnew_max_active = wq->current_max;\n\n\t/*\n\t * pending may be changed later, but it's OK since we really\n\t * don't need it so accurate to calculate new_max_active.\n\t */\n\tpending = atomic_read(&wq->pending);\n\tif (pending > wq->thresh)\n\t\tnew_max_active++;\n\tif (pending < wq->thresh / 2)\n\t\tnew_max_active--;\n\tnew_max_active = clamp_val(new_max_active, 1, wq->max_active);\n\tif (new_max_active != wq->current_max)  {\n\t\tneed_change = 1;\n\t\twq->current_max = new_max_active;\n\t}\nout:\n\tspin_unlock(&wq->thres_lock);\n\n\tif (need_change) {\n\t\tworkqueue_set_max_active(wq->normal_wq, wq->current_max);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_btrfs_work_sched",
          "args": [
            "work"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define WORK_DONE_BIT 0\n\nstatic void normal_work_helper(struct btrfs_work *work);\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nstatic void normal_work_helper(struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *wq;\n\tint need_order = 0;\n\n\t/*\n\t * We should not touch things inside work in the following cases:\n\t * 1) after work->func() if it has no ordered_free\n\t *    Since the struct is freed in work->func().\n\t * 2) after setting WORK_DONE_BIT\n\t *    The work may be freed in other threads almost instantly.\n\t * So we save the needed things here.\n\t */\n\tif (work->ordered_func)\n\t\tneed_order = 1;\n\twq = work->wq;\n\n\ttrace_btrfs_work_sched(work);\n\tthresh_exec_hook(wq);\n\twork->func(work);\n\tif (need_order) {\n\t\tset_bit(WORK_DONE_BIT, &work->flags);\n\t\trun_ordered_work(wq);\n\t}\n\tif (!need_order)\n\t\ttrace_btrfs_all_work_done(work);\n}"
  },
  {
    "function_name": "run_ordered_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
    "lines": "223-264",
    "snippet": "static void run_ordered_work(struct __btrfs_workqueue *wq)\n{\n\tstruct list_head *list = &wq->ordered_list;\n\tstruct btrfs_work *work;\n\tspinlock_t *lock = &wq->list_lock;\n\tunsigned long flags;\n\n\twhile (1) {\n\t\tspin_lock_irqsave(lock, flags);\n\t\tif (list_empty(list))\n\t\t\tbreak;\n\t\twork = list_entry(list->next, struct btrfs_work,\n\t\t\t\t  ordered_list);\n\t\tif (!test_bit(WORK_DONE_BIT, &work->flags))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * we are going to call the ordered done function, but\n\t\t * we leave the work item on the list as a barrier so\n\t\t * that later work items that are done don't have their\n\t\t * functions called before this one returns\n\t\t */\n\t\tif (test_and_set_bit(WORK_ORDER_DONE_BIT, &work->flags))\n\t\t\tbreak;\n\t\ttrace_btrfs_ordered_sched(work);\n\t\tspin_unlock_irqrestore(lock, flags);\n\t\twork->ordered_func(work);\n\n\t\t/* now take the lock again and drop our item from the list */\n\t\tspin_lock_irqsave(lock, flags);\n\t\tlist_del(&work->ordered_list);\n\t\tspin_unlock_irqrestore(lock, flags);\n\n\t\t/*\n\t\t * we don't want to call the ordered free functions\n\t\t * with the lock held though\n\t\t */\n\t\twork->ordered_free(work);\n\t\ttrace_btrfs_all_work_done(work);\n\t}\n\tspin_unlock_irqrestore(lock, flags);\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"async-thread.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [
      "#define WORK_ORDER_DONE_BIT 1",
      "#define WORK_DONE_BIT 0"
    ],
    "globals_used": [
      "static void normal_work_helper(struct btrfs_work *work);",
      "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "lock",
            "flags"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_btrfs_all_work_done",
          "args": [
            "work"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work->ordered_free",
          "args": [
            "work"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "lock",
            "flags"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&work->ordered_list"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "lock",
            "flags"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work->ordered_func",
          "args": [
            "work"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "lock",
            "flags"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_btrfs_ordered_sched",
          "args": [
            "work"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "WORK_ORDER_DONE_BIT",
            "&work->flags"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "WORK_DONE_BIT",
            "&work->flags"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "list->next",
            "structbtrfs_work",
            "ordered_list"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "list"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "lock",
            "flags"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define WORK_ORDER_DONE_BIT 1\n#define WORK_DONE_BIT 0\n\nstatic void normal_work_helper(struct btrfs_work *work);\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nstatic void run_ordered_work(struct __btrfs_workqueue *wq)\n{\n\tstruct list_head *list = &wq->ordered_list;\n\tstruct btrfs_work *work;\n\tspinlock_t *lock = &wq->list_lock;\n\tunsigned long flags;\n\n\twhile (1) {\n\t\tspin_lock_irqsave(lock, flags);\n\t\tif (list_empty(list))\n\t\t\tbreak;\n\t\twork = list_entry(list->next, struct btrfs_work,\n\t\t\t\t  ordered_list);\n\t\tif (!test_bit(WORK_DONE_BIT, &work->flags))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * we are going to call the ordered done function, but\n\t\t * we leave the work item on the list as a barrier so\n\t\t * that later work items that are done don't have their\n\t\t * functions called before this one returns\n\t\t */\n\t\tif (test_and_set_bit(WORK_ORDER_DONE_BIT, &work->flags))\n\t\t\tbreak;\n\t\ttrace_btrfs_ordered_sched(work);\n\t\tspin_unlock_irqrestore(lock, flags);\n\t\twork->ordered_func(work);\n\n\t\t/* now take the lock again and drop our item from the list */\n\t\tspin_lock_irqsave(lock, flags);\n\t\tlist_del(&work->ordered_list);\n\t\tspin_unlock_irqrestore(lock, flags);\n\n\t\t/*\n\t\t * we don't want to call the ordered free functions\n\t\t * with the lock held though\n\t\t */\n\t\twork->ordered_free(work);\n\t\ttrace_btrfs_all_work_done(work);\n\t}\n\tspin_unlock_irqrestore(lock, flags);\n}"
  },
  {
    "function_name": "thresh_exec_hook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
    "lines": "180-221",
    "snippet": "static inline void thresh_exec_hook(struct __btrfs_workqueue *wq)\n{\n\tint new_max_active;\n\tlong pending;\n\tint need_change = 0;\n\n\tif (wq->thresh == NO_THRESHOLD)\n\t\treturn;\n\n\tatomic_dec(&wq->pending);\n\tspin_lock(&wq->thres_lock);\n\t/*\n\t * Use wq->count to limit the calling frequency of\n\t * workqueue_set_max_active.\n\t */\n\twq->count++;\n\twq->count %= (wq->thresh / 4);\n\tif (!wq->count)\n\t\tgoto  out;\n\tnew_max_active = wq->current_max;\n\n\t/*\n\t * pending may be changed later, but it's OK since we really\n\t * don't need it so accurate to calculate new_max_active.\n\t */\n\tpending = atomic_read(&wq->pending);\n\tif (pending > wq->thresh)\n\t\tnew_max_active++;\n\tif (pending < wq->thresh / 2)\n\t\tnew_max_active--;\n\tnew_max_active = clamp_val(new_max_active, 1, wq->max_active);\n\tif (new_max_active != wq->current_max)  {\n\t\tneed_change = 1;\n\t\twq->current_max = new_max_active;\n\t}\nout:\n\tspin_unlock(&wq->thres_lock);\n\n\tif (need_change) {\n\t\tworkqueue_set_max_active(wq->normal_wq, wq->current_max);\n\t}\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"async-thread.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [
      "#define NO_THRESHOLD (-1)"
    ],
    "globals_used": [
      "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "workqueue_set_max_active",
          "args": [
            "wq->normal_wq",
            "wq->current_max"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&wq->thres_lock"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "clamp_val",
          "args": [
            "new_max_active",
            "1",
            "wq->max_active"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&wq->pending"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&wq->thres_lock"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&wq->pending"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define NO_THRESHOLD (-1)\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nstatic inline void thresh_exec_hook(struct __btrfs_workqueue *wq)\n{\n\tint new_max_active;\n\tlong pending;\n\tint need_change = 0;\n\n\tif (wq->thresh == NO_THRESHOLD)\n\t\treturn;\n\n\tatomic_dec(&wq->pending);\n\tspin_lock(&wq->thres_lock);\n\t/*\n\t * Use wq->count to limit the calling frequency of\n\t * workqueue_set_max_active.\n\t */\n\twq->count++;\n\twq->count %= (wq->thresh / 4);\n\tif (!wq->count)\n\t\tgoto  out;\n\tnew_max_active = wq->current_max;\n\n\t/*\n\t * pending may be changed later, but it's OK since we really\n\t * don't need it so accurate to calculate new_max_active.\n\t */\n\tpending = atomic_read(&wq->pending);\n\tif (pending > wq->thresh)\n\t\tnew_max_active++;\n\tif (pending < wq->thresh / 2)\n\t\tnew_max_active--;\n\tnew_max_active = clamp_val(new_max_active, 1, wq->max_active);\n\tif (new_max_active != wq->current_max)  {\n\t\tneed_change = 1;\n\t\twq->current_max = new_max_active;\n\t}\nout:\n\tspin_unlock(&wq->thres_lock);\n\n\tif (need_change) {\n\t\tworkqueue_set_max_active(wq->normal_wq, wq->current_max);\n\t}\n}"
  },
  {
    "function_name": "thresh_queue_hook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
    "lines": "168-173",
    "snippet": "static inline void thresh_queue_hook(struct __btrfs_workqueue *wq)\n{\n\tif (wq->thresh == NO_THRESHOLD)\n\t\treturn;\n\tatomic_inc(&wq->pending);\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"async-thread.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [
      "#define NO_THRESHOLD (-1)"
    ],
    "globals_used": [
      "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&wq->pending"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define NO_THRESHOLD (-1)\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nstatic inline void thresh_queue_hook(struct __btrfs_workqueue *wq)\n{\n\tif (wq->thresh == NO_THRESHOLD)\n\t\treturn;\n\tatomic_inc(&wq->pending);\n}"
  },
  {
    "function_name": "btrfs_alloc_workqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
    "lines": "134-161",
    "snippet": "struct btrfs_workqueue *btrfs_alloc_workqueue(const char *name,\n\t\t\t\t\t      int flags,\n\t\t\t\t\t      int max_active,\n\t\t\t\t\t      int thresh)\n{\n\tstruct btrfs_workqueue *ret = kzalloc(sizeof(*ret), GFP_NOFS);\n\n\tif (!ret)\n\t\treturn NULL;\n\n\tret->normal = __btrfs_alloc_workqueue(name, flags & ~WQ_HIGHPRI,\n\t\t\t\t\t      max_active, thresh);\n\tif (!ret->normal) {\n\t\tkfree(ret);\n\t\treturn NULL;\n\t}\n\n\tif (flags & WQ_HIGHPRI) {\n\t\tret->high = __btrfs_alloc_workqueue(name, flags, max_active,\n\t\t\t\t\t\t    thresh);\n\t\tif (!ret->high) {\n\t\t\t__btrfs_destroy_workqueue(ret->normal);\n\t\t\tkfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"async-thread.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ret"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_destroy_workqueue",
          "args": [
            "ret->normal"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "335-341",
          "snippet": "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq)\n{\n\tdestroy_workqueue(wq->normal_wq);\n\ttrace_btrfs_workqueue_destroy(wq);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq)\n{\n\tdestroy_workqueue(wq->normal_wq);\n\ttrace_btrfs_workqueue_destroy(wq);\n\tkfree(wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_alloc_workqueue",
          "args": [
            "name",
            "flags",
            "max_active",
            "thresh"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_alloc_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "89-129",
          "snippet": "static struct __btrfs_workqueue *\n__btrfs_alloc_workqueue(const char *name, int flags, int max_active,\n\t\t\t int thresh)\n{\n\tstruct __btrfs_workqueue *ret = kzalloc(sizeof(*ret), GFP_NOFS);\n\n\tif (!ret)\n\t\treturn NULL;\n\n\tret->max_active = max_active;\n\tatomic_set(&ret->pending, 0);\n\tif (thresh == 0)\n\t\tthresh = DFT_THRESHOLD;\n\t/* For low threshold, disabling threshold is a better choice */\n\tif (thresh < DFT_THRESHOLD) {\n\t\tret->current_max = max_active;\n\t\tret->thresh = NO_THRESHOLD;\n\t} else {\n\t\tret->current_max = 1;\n\t\tret->thresh = thresh;\n\t}\n\n\tif (flags & WQ_HIGHPRI)\n\t\tret->normal_wq = alloc_workqueue(\"%s-%s-high\", flags,\n\t\t\t\t\t\t ret->max_active,\n\t\t\t\t\t\t \"btrfs\", name);\n\telse\n\t\tret->normal_wq = alloc_workqueue(\"%s-%s\", flags,\n\t\t\t\t\t\t ret->max_active, \"btrfs\",\n\t\t\t\t\t\t name);\n\tif (!ret->normal_wq) {\n\t\tkfree(ret);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&ret->ordered_list);\n\tspin_lock_init(&ret->list_lock);\n\tspin_lock_init(&ret->thres_lock);\n\ttrace_btrfs_workqueue_alloc(ret, name, flags & WQ_HIGHPRI);\n\treturn ret;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define DFT_THRESHOLD (32)",
            "#define NO_THRESHOLD (-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define DFT_THRESHOLD (32)\n#define NO_THRESHOLD (-1)\n\nstatic struct __btrfs_workqueue *\n__btrfs_alloc_workqueue(const char *name, int flags, int max_active,\n\t\t\t int thresh)\n{\n\tstruct __btrfs_workqueue *ret = kzalloc(sizeof(*ret), GFP_NOFS);\n\n\tif (!ret)\n\t\treturn NULL;\n\n\tret->max_active = max_active;\n\tatomic_set(&ret->pending, 0);\n\tif (thresh == 0)\n\t\tthresh = DFT_THRESHOLD;\n\t/* For low threshold, disabling threshold is a better choice */\n\tif (thresh < DFT_THRESHOLD) {\n\t\tret->current_max = max_active;\n\t\tret->thresh = NO_THRESHOLD;\n\t} else {\n\t\tret->current_max = 1;\n\t\tret->thresh = thresh;\n\t}\n\n\tif (flags & WQ_HIGHPRI)\n\t\tret->normal_wq = alloc_workqueue(\"%s-%s-high\", flags,\n\t\t\t\t\t\t ret->max_active,\n\t\t\t\t\t\t \"btrfs\", name);\n\telse\n\t\tret->normal_wq = alloc_workqueue(\"%s-%s\", flags,\n\t\t\t\t\t\t ret->max_active, \"btrfs\",\n\t\t\t\t\t\t name);\n\tif (!ret->normal_wq) {\n\t\tkfree(ret);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&ret->ordered_list);\n\tspin_lock_init(&ret->list_lock);\n\tspin_lock_init(&ret->thres_lock);\n\ttrace_btrfs_workqueue_alloc(ret, name, flags & WQ_HIGHPRI);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ret"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ret)",
            "GFP_NOFS"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstruct btrfs_workqueue *btrfs_alloc_workqueue(const char *name,\n\t\t\t\t\t      int flags,\n\t\t\t\t\t      int max_active,\n\t\t\t\t\t      int thresh)\n{\n\tstruct btrfs_workqueue *ret = kzalloc(sizeof(*ret), GFP_NOFS);\n\n\tif (!ret)\n\t\treturn NULL;\n\n\tret->normal = __btrfs_alloc_workqueue(name, flags & ~WQ_HIGHPRI,\n\t\t\t\t\t      max_active, thresh);\n\tif (!ret->normal) {\n\t\tkfree(ret);\n\t\treturn NULL;\n\t}\n\n\tif (flags & WQ_HIGHPRI) {\n\t\tret->high = __btrfs_alloc_workqueue(name, flags, max_active,\n\t\t\t\t\t\t    thresh);\n\t\tif (!ret->high) {\n\t\t\t__btrfs_destroy_workqueue(ret->normal);\n\t\t\tkfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "__btrfs_alloc_workqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
    "lines": "89-129",
    "snippet": "static struct __btrfs_workqueue *\n__btrfs_alloc_workqueue(const char *name, int flags, int max_active,\n\t\t\t int thresh)\n{\n\tstruct __btrfs_workqueue *ret = kzalloc(sizeof(*ret), GFP_NOFS);\n\n\tif (!ret)\n\t\treturn NULL;\n\n\tret->max_active = max_active;\n\tatomic_set(&ret->pending, 0);\n\tif (thresh == 0)\n\t\tthresh = DFT_THRESHOLD;\n\t/* For low threshold, disabling threshold is a better choice */\n\tif (thresh < DFT_THRESHOLD) {\n\t\tret->current_max = max_active;\n\t\tret->thresh = NO_THRESHOLD;\n\t} else {\n\t\tret->current_max = 1;\n\t\tret->thresh = thresh;\n\t}\n\n\tif (flags & WQ_HIGHPRI)\n\t\tret->normal_wq = alloc_workqueue(\"%s-%s-high\", flags,\n\t\t\t\t\t\t ret->max_active,\n\t\t\t\t\t\t \"btrfs\", name);\n\telse\n\t\tret->normal_wq = alloc_workqueue(\"%s-%s\", flags,\n\t\t\t\t\t\t ret->max_active, \"btrfs\",\n\t\t\t\t\t\t name);\n\tif (!ret->normal_wq) {\n\t\tkfree(ret);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&ret->ordered_list);\n\tspin_lock_init(&ret->list_lock);\n\tspin_lock_init(&ret->thres_lock);\n\ttrace_btrfs_workqueue_alloc(ret, name, flags & WQ_HIGHPRI);\n\treturn ret;\n}",
    "includes": [
      "#include \"ctree.h\"",
      "#include \"async-thread.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>"
    ],
    "macros_used": [
      "#define DFT_THRESHOLD (32)",
      "#define NO_THRESHOLD (-1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_btrfs_workqueue_alloc",
          "args": [
            "ret",
            "name",
            "flags & WQ_HIGHPRI"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ret->thres_lock"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ret->list_lock"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ret->ordered_list"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ret"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"%s-%s\"",
            "flags",
            "ret->max_active",
            "\"btrfs\"",
            "name"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"%s-%s-high\"",
            "flags",
            "ret->max_active",
            "\"btrfs\"",
            "name"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ret->pending",
            "0"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ret)",
            "GFP_NOFS"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define DFT_THRESHOLD (32)\n#define NO_THRESHOLD (-1)\n\nstatic struct __btrfs_workqueue *\n__btrfs_alloc_workqueue(const char *name, int flags, int max_active,\n\t\t\t int thresh)\n{\n\tstruct __btrfs_workqueue *ret = kzalloc(sizeof(*ret), GFP_NOFS);\n\n\tif (!ret)\n\t\treturn NULL;\n\n\tret->max_active = max_active;\n\tatomic_set(&ret->pending, 0);\n\tif (thresh == 0)\n\t\tthresh = DFT_THRESHOLD;\n\t/* For low threshold, disabling threshold is a better choice */\n\tif (thresh < DFT_THRESHOLD) {\n\t\tret->current_max = max_active;\n\t\tret->thresh = NO_THRESHOLD;\n\t} else {\n\t\tret->current_max = 1;\n\t\tret->thresh = thresh;\n\t}\n\n\tif (flags & WQ_HIGHPRI)\n\t\tret->normal_wq = alloc_workqueue(\"%s-%s-high\", flags,\n\t\t\t\t\t\t ret->max_active,\n\t\t\t\t\t\t \"btrfs\", name);\n\telse\n\t\tret->normal_wq = alloc_workqueue(\"%s-%s\", flags,\n\t\t\t\t\t\t ret->max_active, \"btrfs\",\n\t\t\t\t\t\t name);\n\tif (!ret->normal_wq) {\n\t\tkfree(ret);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&ret->ordered_list);\n\tspin_lock_init(&ret->list_lock);\n\tspin_lock_init(&ret->thres_lock);\n\ttrace_btrfs_workqueue_alloc(ret, name, flags & WQ_HIGHPRI);\n\treturn ret;\n}"
  }
]