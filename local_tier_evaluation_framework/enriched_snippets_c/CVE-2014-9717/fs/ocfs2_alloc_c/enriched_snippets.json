[
  {
    "function_name": "ocfs2_trim_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "7310-7409",
    "snippet": "int ocfs2_trim_fs(struct super_block *sb, struct fstrim_range *range)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tu64 start, len, trimmed, first_group, last_group, group;\n\tint ret, cnt;\n\tu32 first_bit, last_bit, minlen;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct inode *main_bm_inode = NULL;\n\tstruct buffer_head *gd_bh = NULL;\n\tstruct ocfs2_dinode *main_bm;\n\tstruct ocfs2_group_desc *gd = NULL;\n\n\tstart = range->start >> osb->s_clustersize_bits;\n\tlen = range->len >> osb->s_clustersize_bits;\n\tminlen = range->minlen >> osb->s_clustersize_bits;\n\n\tif (minlen >= osb->bitmap_cpg || range->len < sb->s_blocksize)\n\t\treturn -EINVAL;\n\n\tmain_bm_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!main_bm_inode) {\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&main_bm_inode->i_mutex);\n\n\tret = ocfs2_inode_lock(main_bm_inode, &main_bm_bh, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\tmain_bm = (struct ocfs2_dinode *)main_bm_bh->b_data;\n\n\tif (start >= le32_to_cpu(main_bm->i_clusters)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tlen = range->len >> osb->s_clustersize_bits;\n\tif (start + len > le32_to_cpu(main_bm->i_clusters))\n\t\tlen = le32_to_cpu(main_bm->i_clusters) - start;\n\n\ttrace_ocfs2_trim_fs(start, len, minlen);\n\n\t/* Determine first and last group to examine based on start and len */\n\tfirst_group = ocfs2_which_cluster_group(main_bm_inode, start);\n\tif (first_group == osb->first_cluster_group_blkno)\n\t\tfirst_bit = start;\n\telse\n\t\tfirst_bit = start - ocfs2_blocks_to_clusters(sb, first_group);\n\tlast_group = ocfs2_which_cluster_group(main_bm_inode, start + len - 1);\n\tlast_bit = osb->bitmap_cpg;\n\n\ttrimmed = 0;\n\tfor (group = first_group; group <= last_group;) {\n\t\tif (first_bit + len >= osb->bitmap_cpg)\n\t\t\tlast_bit = osb->bitmap_cpg;\n\t\telse\n\t\t\tlast_bit = first_bit + len;\n\n\t\tret = ocfs2_read_group_descriptor(main_bm_inode,\n\t\t\t\t\t\t  main_bm, group,\n\t\t\t\t\t\t  &gd_bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tgd = (struct ocfs2_group_desc *)gd_bh->b_data;\n\t\tcnt = ocfs2_trim_group(sb, gd, first_bit, last_bit, minlen);\n\t\tbrelse(gd_bh);\n\t\tgd_bh = NULL;\n\t\tif (cnt < 0) {\n\t\t\tret = cnt;\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\ttrimmed += cnt;\n\t\tlen -= osb->bitmap_cpg - first_bit;\n\t\tfirst_bit = 0;\n\t\tif (group == osb->first_cluster_group_blkno)\n\t\t\tgroup = ocfs2_clusters_to_blocks(sb, osb->bitmap_cpg);\n\t\telse\n\t\t\tgroup += ocfs2_clusters_to_blocks(sb, osb->bitmap_cpg);\n\t}\n\trange->len = trimmed * sb->s_blocksize;\nout_unlock:\n\tocfs2_inode_unlock(main_bm_inode, 0);\n\tbrelse(main_bm_bh);\nout_mutex:\n\tmutex_unlock(&main_bm_inode->i_mutex);\n\tiput(main_bm_inode);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "main_bm_inode"
          ],
          "line": 7406
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&main_bm_inode->i_mutex"
          ],
          "line": 7405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "main_bm_bh"
          ],
          "line": 7403
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "main_bm_inode",
            "0"
          ],
          "line": 7402
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "sb",
            "osb->bitmap_cpg"
          ],
          "line": 7398
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_trim_group",
          "args": [
            "sb",
            "gd",
            "first_bit",
            "last_bit",
            "minlen"
          ],
          "line": 7383
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_trim_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "7265-7308",
          "snippet": "static int ocfs2_trim_group(struct super_block *sb,\n\t\t\t    struct ocfs2_group_desc *gd,\n\t\t\t    u32 start, u32 max, u32 minbits)\n{\n\tint ret = 0, count = 0, next;\n\tvoid *bitmap = gd->bg_bitmap;\n\n\tif (le16_to_cpu(gd->bg_free_bits_count) < minbits)\n\t\treturn 0;\n\n\ttrace_ocfs2_trim_group((unsigned long long)le64_to_cpu(gd->bg_blkno),\n\t\t\t       start, max, minbits);\n\n\twhile (start < max) {\n\t\tstart = ocfs2_find_next_zero_bit(bitmap, max, start);\n\t\tif (start >= max)\n\t\t\tbreak;\n\t\tnext = ocfs2_find_next_bit(bitmap, max, start);\n\n\t\tif ((next - start) >= minbits) {\n\t\t\tret = ocfs2_trim_extent(sb, gd,\n\t\t\t\t\t\tstart, next - start);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount += next - start;\n\t\t}\n\t\tstart = next + 1;\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tcount = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((le16_to_cpu(gd->bg_free_bits_count) - count) < minbits)\n\t\t\tbreak;\n\t}\n\n\tif (ret < 0)\n\t\tcount = ret;\n\n\treturn count;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_trim_group(struct super_block *sb,\n\t\t\t    struct ocfs2_group_desc *gd,\n\t\t\t    u32 start, u32 max, u32 minbits)\n{\n\tint ret = 0, count = 0, next;\n\tvoid *bitmap = gd->bg_bitmap;\n\n\tif (le16_to_cpu(gd->bg_free_bits_count) < minbits)\n\t\treturn 0;\n\n\ttrace_ocfs2_trim_group((unsigned long long)le64_to_cpu(gd->bg_blkno),\n\t\t\t       start, max, minbits);\n\n\twhile (start < max) {\n\t\tstart = ocfs2_find_next_zero_bit(bitmap, max, start);\n\t\tif (start >= max)\n\t\t\tbreak;\n\t\tnext = ocfs2_find_next_bit(bitmap, max, start);\n\n\t\tif ((next - start) >= minbits) {\n\t\t\tret = ocfs2_trim_extent(sb, gd,\n\t\t\t\t\t\tstart, next - start);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount += next - start;\n\t\t}\n\t\tstart = next + 1;\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tcount = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((le16_to_cpu(gd->bg_free_bits_count) - count) < minbits)\n\t\t\tbreak;\n\t}\n\n\tif (ret < 0)\n\t\tcount = ret;\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_group_descriptor",
          "args": [
            "main_bm_inode",
            "main_bm",
            "group",
            "&gd_bh"
          ],
          "line": 7374
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_group_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "326-349",
          "snippet": "int ocfs2_read_group_descriptor(struct inode *inode, struct ocfs2_dinode *di,\n\t\t\t\tu64 gd_blkno, struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), gd_blkno, &tmp,\n\t\t\t      ocfs2_validate_group_descriptor);\n\tif (rc)\n\t\tgoto out;\n\n\trc = ocfs2_validate_gd_parent(inode->i_sb, di, tmp, 0);\n\tif (rc) {\n\t\tbrelse(tmp);\n\t\tgoto out;\n\t}\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!*bh)\n\t\t*bh = tmp;\n\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_group_descriptor(struct inode *inode, struct ocfs2_dinode *di,\n\t\t\t\tu64 gd_blkno, struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), gd_blkno, &tmp,\n\t\t\t      ocfs2_validate_group_descriptor);\n\tif (rc)\n\t\tgoto out;\n\n\trc = ocfs2_validate_gd_parent(inode->i_sb, di, tmp, 0);\n\tif (rc) {\n\t\tbrelse(tmp);\n\t\tgoto out;\n\t}\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!*bh)\n\t\t*bh = tmp;\n\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_which_cluster_group",
          "args": [
            "main_bm_inode",
            "start + len - 1"
          ],
          "line": 7364
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_which_cluster_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2260-2272",
          "snippet": "u64 ocfs2_which_cluster_group(struct inode *inode, u32 cluster)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu32 group_no;\n\n\tBUG_ON(!ocfs2_is_cluster_bitmap(inode));\n\n\tgroup_no = cluster / osb->bitmap_cpg;\n\tif (!group_no)\n\t\treturn osb->first_cluster_group_blkno;\n\treturn ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\tgroup_no * osb->bitmap_cpg);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_which_cluster_group(struct inode *inode, u32 cluster)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu32 group_no;\n\n\tBUG_ON(!ocfs2_is_cluster_bitmap(inode));\n\n\tgroup_no = cluster / osb->bitmap_cpg;\n\tif (!group_no)\n\t\treturn osb->first_cluster_group_blkno;\n\treturn ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\tgroup_no * osb->bitmap_cpg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_to_clusters",
          "args": [
            "sb",
            "first_group"
          ],
          "line": 7363
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "720-727",
          "snippet": "static inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_trim_fs",
          "args": [
            "start",
            "len",
            "minlen"
          ],
          "line": 7356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "main_bm->i_clusters"
          ],
          "line": 7354
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "main_bm_inode",
            "&main_bm_bh",
            "0"
          ],
          "line": 7340
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&main_bm_inode->i_mutex"
          ],
          "line": 7338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "GLOBAL_BITMAP_SYSTEM_INODE",
            "OCFS2_INVALID_SLOT"
          ],
          "line": 7329
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 7312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_trim_fs(struct super_block *sb, struct fstrim_range *range)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tu64 start, len, trimmed, first_group, last_group, group;\n\tint ret, cnt;\n\tu32 first_bit, last_bit, minlen;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct inode *main_bm_inode = NULL;\n\tstruct buffer_head *gd_bh = NULL;\n\tstruct ocfs2_dinode *main_bm;\n\tstruct ocfs2_group_desc *gd = NULL;\n\n\tstart = range->start >> osb->s_clustersize_bits;\n\tlen = range->len >> osb->s_clustersize_bits;\n\tminlen = range->minlen >> osb->s_clustersize_bits;\n\n\tif (minlen >= osb->bitmap_cpg || range->len < sb->s_blocksize)\n\t\treturn -EINVAL;\n\n\tmain_bm_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!main_bm_inode) {\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&main_bm_inode->i_mutex);\n\n\tret = ocfs2_inode_lock(main_bm_inode, &main_bm_bh, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\tmain_bm = (struct ocfs2_dinode *)main_bm_bh->b_data;\n\n\tif (start >= le32_to_cpu(main_bm->i_clusters)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tlen = range->len >> osb->s_clustersize_bits;\n\tif (start + len > le32_to_cpu(main_bm->i_clusters))\n\t\tlen = le32_to_cpu(main_bm->i_clusters) - start;\n\n\ttrace_ocfs2_trim_fs(start, len, minlen);\n\n\t/* Determine first and last group to examine based on start and len */\n\tfirst_group = ocfs2_which_cluster_group(main_bm_inode, start);\n\tif (first_group == osb->first_cluster_group_blkno)\n\t\tfirst_bit = start;\n\telse\n\t\tfirst_bit = start - ocfs2_blocks_to_clusters(sb, first_group);\n\tlast_group = ocfs2_which_cluster_group(main_bm_inode, start + len - 1);\n\tlast_bit = osb->bitmap_cpg;\n\n\ttrimmed = 0;\n\tfor (group = first_group; group <= last_group;) {\n\t\tif (first_bit + len >= osb->bitmap_cpg)\n\t\t\tlast_bit = osb->bitmap_cpg;\n\t\telse\n\t\t\tlast_bit = first_bit + len;\n\n\t\tret = ocfs2_read_group_descriptor(main_bm_inode,\n\t\t\t\t\t\t  main_bm, group,\n\t\t\t\t\t\t  &gd_bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tgd = (struct ocfs2_group_desc *)gd_bh->b_data;\n\t\tcnt = ocfs2_trim_group(sb, gd, first_bit, last_bit, minlen);\n\t\tbrelse(gd_bh);\n\t\tgd_bh = NULL;\n\t\tif (cnt < 0) {\n\t\t\tret = cnt;\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\ttrimmed += cnt;\n\t\tlen -= osb->bitmap_cpg - first_bit;\n\t\tfirst_bit = 0;\n\t\tif (group == osb->first_cluster_group_blkno)\n\t\t\tgroup = ocfs2_clusters_to_blocks(sb, osb->bitmap_cpg);\n\t\telse\n\t\t\tgroup += ocfs2_clusters_to_blocks(sb, osb->bitmap_cpg);\n\t}\n\trange->len = trimmed * sb->s_blocksize;\nout_unlock:\n\tocfs2_inode_unlock(main_bm_inode, 0);\n\tbrelse(main_bm_bh);\nout_mutex:\n\tmutex_unlock(&main_bm_inode->i_mutex);\n\tiput(main_bm_inode);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_trim_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "7265-7308",
    "snippet": "static int ocfs2_trim_group(struct super_block *sb,\n\t\t\t    struct ocfs2_group_desc *gd,\n\t\t\t    u32 start, u32 max, u32 minbits)\n{\n\tint ret = 0, count = 0, next;\n\tvoid *bitmap = gd->bg_bitmap;\n\n\tif (le16_to_cpu(gd->bg_free_bits_count) < minbits)\n\t\treturn 0;\n\n\ttrace_ocfs2_trim_group((unsigned long long)le64_to_cpu(gd->bg_blkno),\n\t\t\t       start, max, minbits);\n\n\twhile (start < max) {\n\t\tstart = ocfs2_find_next_zero_bit(bitmap, max, start);\n\t\tif (start >= max)\n\t\t\tbreak;\n\t\tnext = ocfs2_find_next_bit(bitmap, max, start);\n\n\t\tif ((next - start) >= minbits) {\n\t\t\tret = ocfs2_trim_extent(sb, gd,\n\t\t\t\t\t\tstart, next - start);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount += next - start;\n\t\t}\n\t\tstart = next + 1;\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tcount = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((le16_to_cpu(gd->bg_free_bits_count) - count) < minbits)\n\t\t\tbreak;\n\t}\n\n\tif (ret < 0)\n\t\tcount = ret;\n\n\treturn count;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "gd->bg_free_bits_count"
          ],
          "line": 7300
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 7295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_trim_extent",
          "args": [
            "sb",
            "gd",
            "start",
            "next - start"
          ],
          "line": 7285
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_trim_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "7250-7263",
          "snippet": "static int ocfs2_trim_extent(struct super_block *sb,\n\t\t\t     struct ocfs2_group_desc *gd,\n\t\t\t     u32 start, u32 count)\n{\n\tu64 discard, bcount;\n\n\tbcount = ocfs2_clusters_to_blocks(sb, count);\n\tdiscard = le64_to_cpu(gd->bg_blkno) +\n\t\t\tocfs2_clusters_to_blocks(sb, start);\n\n\ttrace_ocfs2_trim_extent(sb, (unsigned long long)discard, bcount);\n\n\treturn sb_issue_discard(sb, discard, bcount, GFP_NOFS, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_trim_extent(struct super_block *sb,\n\t\t\t     struct ocfs2_group_desc *gd,\n\t\t\t     u32 start, u32 count)\n{\n\tu64 discard, bcount;\n\n\tbcount = ocfs2_clusters_to_blocks(sb, count);\n\tdiscard = le64_to_cpu(gd->bg_blkno) +\n\t\t\tocfs2_clusters_to_blocks(sb, start);\n\n\ttrace_ocfs2_trim_extent(sb, (unsigned long long)discard, bcount);\n\n\treturn sb_issue_discard(sb, discard, bcount, GFP_NOFS, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_next_bit",
          "args": [
            "bitmap",
            "max",
            "start"
          ],
          "line": 7282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_next_zero_bit",
          "args": [
            "bitmap",
            "max",
            "start"
          ],
          "line": 7279
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_next_zero_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "904-916",
          "snippet": "static inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_find_next_zero_bit find_next_zero_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_find_next_zero_bit find_next_zero_bit_le\n\nstatic inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_trim_group",
          "args": [
            "(unsigned long long)le64_to_cpu(gd->bg_blkno)",
            "start",
            "max",
            "minbits"
          ],
          "line": 7275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "gd->bg_blkno"
          ],
          "line": 7275
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_trim_group(struct super_block *sb,\n\t\t\t    struct ocfs2_group_desc *gd,\n\t\t\t    u32 start, u32 max, u32 minbits)\n{\n\tint ret = 0, count = 0, next;\n\tvoid *bitmap = gd->bg_bitmap;\n\n\tif (le16_to_cpu(gd->bg_free_bits_count) < minbits)\n\t\treturn 0;\n\n\ttrace_ocfs2_trim_group((unsigned long long)le64_to_cpu(gd->bg_blkno),\n\t\t\t       start, max, minbits);\n\n\twhile (start < max) {\n\t\tstart = ocfs2_find_next_zero_bit(bitmap, max, start);\n\t\tif (start >= max)\n\t\t\tbreak;\n\t\tnext = ocfs2_find_next_bit(bitmap, max, start);\n\n\t\tif ((next - start) >= minbits) {\n\t\t\tret = ocfs2_trim_extent(sb, gd,\n\t\t\t\t\t\tstart, next - start);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount += next - start;\n\t\t}\n\t\tstart = next + 1;\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tcount = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((le16_to_cpu(gd->bg_free_bits_count) - count) < minbits)\n\t\t\tbreak;\n\t}\n\n\tif (ret < 0)\n\t\tcount = ret;\n\n\treturn count;\n}"
  },
  {
    "function_name": "ocfs2_trim_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "7250-7263",
    "snippet": "static int ocfs2_trim_extent(struct super_block *sb,\n\t\t\t     struct ocfs2_group_desc *gd,\n\t\t\t     u32 start, u32 count)\n{\n\tu64 discard, bcount;\n\n\tbcount = ocfs2_clusters_to_blocks(sb, count);\n\tdiscard = le64_to_cpu(gd->bg_blkno) +\n\t\t\tocfs2_clusters_to_blocks(sb, start);\n\n\ttrace_ocfs2_trim_extent(sb, (unsigned long long)discard, bcount);\n\n\treturn sb_issue_discard(sb, discard, bcount, GFP_NOFS, 0);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_issue_discard",
          "args": [
            "sb",
            "discard",
            "bcount",
            "GFP_NOFS",
            "0"
          ],
          "line": 7262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_trim_extent",
          "args": [
            "sb",
            "(unsigned long long)discard",
            "bcount"
          ],
          "line": 7260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "sb",
            "start"
          ],
          "line": 7258
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "gd->bg_blkno"
          ],
          "line": 7257
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_trim_extent(struct super_block *sb,\n\t\t\t     struct ocfs2_group_desc *gd,\n\t\t\t     u32 start, u32 count)\n{\n\tu64 discard, bcount;\n\n\tbcount = ocfs2_clusters_to_blocks(sb, count);\n\tdiscard = le64_to_cpu(gd->bg_blkno) +\n\t\t\tocfs2_clusters_to_blocks(sb, start);\n\n\ttrace_ocfs2_trim_extent(sb, (unsigned long long)discard, bcount);\n\n\treturn sb_issue_discard(sb, discard, bcount, GFP_NOFS, 0);\n}"
  },
  {
    "function_name": "ocfs2_truncate_inline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "7177-7248",
    "snippet": "int ocfs2_truncate_inline(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t  unsigned int start, unsigned int end, int trunc)\n{\n\tint ret;\n\tunsigned int numbytes;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inline_data *idata = &di->id2.i_data;\n\n\tif (end > i_size_read(inode))\n\t\tend = i_size_read(inode);\n\n\tBUG_ON(start > end);\n\n\tif (!(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) ||\n\t    !(le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_DATA_FL) ||\n\t    !ocfs2_supports_inline_data(osb)) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inline data flags for inode %llu don't agree! \"\n\t\t\t    \"Disk: 0x%x, Memory: 0x%x, Superblock: 0x%x\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    le16_to_cpu(di->i_dyn_features),\n\t\t\t    OCFS2_I(inode)->ip_dyn_features,\n\t\t\t    osb->s_feature_incompat);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tnumbytes = end - start;\n\tmemset(idata->id_data + start, 0, numbytes);\n\n\t/*\n\t * No need to worry about the data page here - it's been\n\t * truncated already and inline data doesn't need it for\n\t * pushing zero's to disk, so we'll let readpage pick it up\n\t * later.\n\t */\n\tif (trunc) {\n\t\ti_size_write(inode, start);\n\t\tdi->i_size = cpu_to_le64(start);\n\t}\n\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\n\tdi->i_ctime = di->i_mtime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = di->i_mtime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 7244
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "di_bh"
          ],
          "line": 7241
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_inode_fsync_trans",
          "args": [
            "handle",
            "inode",
            "1"
          ],
          "line": 7240
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "634-643",
          "snippet": "static inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_ctime.tv_nsec"
          ],
          "line": 7238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "inode->i_ctime.tv_sec"
          ],
          "line": 7237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_sector_count",
          "args": [
            "inode"
          ],
          "line": 7234
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_sector_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "165-170",
          "snippet": "static inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "start"
          ],
          "line": 7231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "start"
          ],
          "line": 7230
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "idata->id_data + start",
            "0",
            "numbytes"
          ],
          "line": 7221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "di_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 7213
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 7213
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 7208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 7207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_INODE_UPDATE_CREDITS"
          ],
          "line": 7206
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "inode->i_sb",
            "\"Inline data flags for inode %llu don't agree! \"\n\t\t\t    \"Disk: 0x%x, Memory: 0x%x, Superblock: 0x%x\\n\"",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "le16_to_cpu(di->i_dyn_features)",
            "OCFS2_I(inode)->ip_dyn_features",
            "osb->s_feature_incompat"
          ],
          "line": 7195
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 7200
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "di->i_dyn_features"
          ],
          "line": 7199
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_supports_inline_data",
          "args": [
            "osb"
          ],
          "line": 7194
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_supports_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "511-516",
          "snippet": "static inline int ocfs2_supports_inline_data(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_INLINE_DATA)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_supports_inline_data(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_INLINE_DATA)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "start > end"
          ],
          "line": 7190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 7188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 7187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 7183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_truncate_inline(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t  unsigned int start, unsigned int end, int trunc)\n{\n\tint ret;\n\tunsigned int numbytes;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inline_data *idata = &di->id2.i_data;\n\n\tif (end > i_size_read(inode))\n\t\tend = i_size_read(inode);\n\n\tBUG_ON(start > end);\n\n\tif (!(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) ||\n\t    !(le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_DATA_FL) ||\n\t    !ocfs2_supports_inline_data(osb)) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inline data flags for inode %llu don't agree! \"\n\t\t\t    \"Disk: 0x%x, Memory: 0x%x, Superblock: 0x%x\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    le16_to_cpu(di->i_dyn_features),\n\t\t\t    OCFS2_I(inode)->ip_dyn_features,\n\t\t\t    osb->s_feature_incompat);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tnumbytes = end - start;\n\tmemset(idata->id_data + start, 0, numbytes);\n\n\t/*\n\t * No need to worry about the data page here - it's been\n\t * truncated already and inline data doesn't need it for\n\t * pushing zero's to disk, so we'll let readpage pick it up\n\t * later.\n\t */\n\tif (trunc) {\n\t\ti_size_write(inode, start);\n\t\tdi->i_size = cpu_to_le64(start);\n\t}\n\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\n\tdi->i_ctime = di->i_mtime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = di->i_mtime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_commit_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "7011-7172",
    "snippet": "int ocfs2_commit_truncate(struct ocfs2_super *osb,\n\t\t\t  struct inode *inode,\n\t\t\t  struct buffer_head *di_bh)\n{\n\tint status = 0, i, flags = 0;\n\tu32 new_highest_cpos, range, trunc_cpos, trunc_len, phys_cpos, coff;\n\tu64 blkno = 0;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_extent_list *root_el = &(di->id2.i_list);\n\tu64 refcount_loc = le64_to_cpu(di->i_refcount_loc);\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), di_bh);\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\tnew_highest_cpos = ocfs2_clusters_for_bytes(osb->sb,\n\t\t\t\t\t\t     i_size_read(inode));\n\n\tpath = ocfs2_new_path(di_bh, &di->id2.i_list,\n\t\t\t      ocfs2_journal_access_di);\n\tif (!path) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_extent_map_trunc(inode, new_highest_cpos);\n\nstart:\n\t/*\n\t * Check that we still have allocation to delete.\n\t */\n\tif (OCFS2_I(inode)->ip_clusters == 0) {\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Truncate always works against the rightmost tree branch.\n\t */\n\tstatus = ocfs2_find_path(INODE_CACHE(inode), path, UINT_MAX);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_commit_truncate(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\tnew_highest_cpos,\n\t\tOCFS2_I(inode)->ip_clusters,\n\t\tpath->p_tree_depth);\n\n\t/*\n\t * By now, el will point to the extent list on the bottom most\n\t * portion of this tree. Only the tail record is considered in\n\t * each pass.\n\t *\n\t * We handle the following cases, in order:\n\t * - empty extent: delete the remaining branch\n\t * - remove the entire record\n\t * - remove a partial record\n\t * - no record needs to be removed (truncate has completed)\n\t */\n\tel = path_leaf_el(path);\n\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %llu has empty extent block at %llu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)path_leaf_bh(path)->b_blocknr);\n\t\tstatus = -EROFS;\n\t\tgoto bail;\n\t}\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[i];\n\tflags = rec->e_flags;\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\n\tif (i == 0 && ocfs2_is_empty_extent(rec)) {\n\t\t/*\n\t\t * Lower levels depend on this never happening, but it's best\n\t\t * to check it up here before changing the tree.\n\t\t*/\n\t\tif (root_el->l_tree_depth && rec->e_int_clusters == 0) {\n\t\t\tocfs2_error(inode->i_sb, \"Inode %lu has an empty \"\n\t\t\t\t    \"extent record, depth %u\\n\", inode->i_ino,\n\t\t\t\t    le16_to_cpu(root_el->l_tree_depth));\n\t\t\tstatus = -EROFS;\n\t\t\tgoto bail;\n\t\t}\n\t\ttrunc_cpos = le32_to_cpu(rec->e_cpos);\n\t\ttrunc_len = 0;\n\t\tblkno = 0;\n\t} else if (le32_to_cpu(rec->e_cpos) >= new_highest_cpos) {\n\t\t/*\n\t\t * Truncate entire record.\n\t\t */\n\t\ttrunc_cpos = le32_to_cpu(rec->e_cpos);\n\t\ttrunc_len = ocfs2_rec_clusters(el, rec);\n\t\tblkno = le64_to_cpu(rec->e_blkno);\n\t} else if (range > new_highest_cpos) {\n\t\t/*\n\t\t * Partial truncate. it also should be\n\t\t * the last truncate we're doing.\n\t\t */\n\t\ttrunc_cpos = new_highest_cpos;\n\t\ttrunc_len = range - new_highest_cpos;\n\t\tcoff = new_highest_cpos - le32_to_cpu(rec->e_cpos);\n\t\tblkno = le64_to_cpu(rec->e_blkno) +\n\t\t\t\tocfs2_clusters_to_blocks(inode->i_sb, coff);\n\t} else {\n\t\t/*\n\t\t * Truncate completed, leave happily.\n\t\t */\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\tphys_cpos = ocfs2_blocks_to_clusters(inode->i_sb, blkno);\n\n\tif ((flags & OCFS2_EXT_REFCOUNTED) && trunc_len && !ref_tree) {\n\t\tstatus = ocfs2_lock_refcount_tree(osb, refcount_loc, 1,\n\t\t\t\t&ref_tree, NULL);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = ocfs2_remove_btree_range(inode, &et, trunc_cpos,\n\t\t\t\t\t  phys_cpos, trunc_len, flags, &dealloc,\n\t\t\t\t\t  refcount_loc, true);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_reinit_path(path, 1);\n\n\t/*\n\t * The check above will catch the case where we've truncated\n\t * away all allocation.\n\t */\n\tgoto start;\n\nbail:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\n\tocfs2_run_deallocs(osb, &dealloc);\n\n\tocfs2_free_path(path);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "path"
          ],
          "line": 7169
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "609-615",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_run_deallocs",
          "args": [
            "osb",
            "&dealloc"
          ],
          "line": 7167
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_run_deallocs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6472-6513",
          "snippet": "int ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_schedule_truncate_log_flush",
          "args": [
            "osb",
            "1"
          ],
          "line": 7165
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_schedule_truncate_log_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6057-6070",
          "snippet": "void ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)\n\nvoid ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_unlock_refcount_tree",
          "args": [
            "osb",
            "ref_tree",
            "1"
          ],
          "line": 7163
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "526-536",
          "snippet": "void ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nvoid ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_reinit_path",
          "args": [
            "path",
            "1"
          ],
          "line": 7153
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reinit_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "580-607",
          "snippet": "void ocfs2_reinit_path(struct ocfs2_path *path, int keep_root)\n{\n\tint i, start = 0, depth = 0;\n\tstruct ocfs2_path_item *node;\n\n\tif (keep_root)\n\t\tstart = 1;\n\n\tfor(i = start; i < path_num_items(path); i++) {\n\t\tnode = &path->p_node[i];\n\n\t\tbrelse(node->bh);\n\t\tnode->bh = NULL;\n\t\tnode->el = NULL;\n\t}\n\n\t/*\n\t * Tree depth may change during truncate, or insert. If we're\n\t * keeping the root extent list, then make sure that our path\n\t * structure reflects the proper depth.\n\t */\n\tif (keep_root)\n\t\tdepth = le16_to_cpu(path_root_el(path)->l_tree_depth);\n\telse\n\t\tpath_root_access(path) = NULL;\n\n\tpath->p_tree_depth = depth;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_reinit_path(struct ocfs2_path *path, int keep_root)\n{\n\tint i, start = 0, depth = 0;\n\tstruct ocfs2_path_item *node;\n\n\tif (keep_root)\n\t\tstart = 1;\n\n\tfor(i = start; i < path_num_items(path); i++) {\n\t\tnode = &path->p_node[i];\n\n\t\tbrelse(node->bh);\n\t\tnode->bh = NULL;\n\t\tnode->el = NULL;\n\t}\n\n\t/*\n\t * Tree depth may change during truncate, or insert. If we're\n\t * keeping the root extent list, then make sure that our path\n\t * structure reflects the proper depth.\n\t */\n\tif (keep_root)\n\t\tdepth = le16_to_cpu(path_root_el(path)->l_tree_depth);\n\telse\n\t\tpath_root_access(path) = NULL;\n\n\tpath->p_tree_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 7149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_btree_range",
          "args": [
            "inode",
            "&et",
            "trunc_cpos",
            "phys_cpos",
            "trunc_len",
            "flags",
            "&dealloc",
            "refcount_loc",
            "true"
          ],
          "line": 7145
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_btree_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5661-5773",
          "snippet": "int ocfs2_remove_btree_range(struct inode *inode,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     u32 cpos, u32 phys_cpos, u32 len, int flags,\n\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t     u64 refcount_loc, bool refcount_tree_locked)\n{\n\tint ret, credits = 0, extra_blocks = 0;\n\tu64 phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\thandle_t *handle;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tif ((flags & OCFS2_EXT_REFCOUNTED) && len) {\n\t\tBUG_ON(!(OCFS2_I(inode)->ip_dyn_features &\n\t\t\t OCFS2_HAS_REFCOUNT_FL));\n\n\t\tif (!refcount_tree_locked) {\n\t\t\tret = ocfs2_lock_refcount_tree(osb, refcount_loc, 1,\n\t\t\t\t\t\t       &ref_tree, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tret = ocfs2_prepare_refcount_change_for_del(inode,\n\t\t\t\t\t\t\t    refcount_loc,\n\t\t\t\t\t\t\t    phys_blkno,\n\t\t\t\t\t\t\t    len,\n\t\t\t\t\t\t\t    &credits,\n\t\t\t\t\t\t\t    &extra_blocks);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tret = ocfs2_reserve_blocks_for_rec_trunc(inode, et, 1, &meta_ac,\n\t\t\t\t\t\t extra_blocks);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\tocfs2_remove_extent_credits(osb->sb) + credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tdquot_free_space_nodirty(inode,\n\t\t\t\t  ocfs2_clusters_to_bytes(inode->i_sb, len));\n\n\tret = ocfs2_remove_extent(handle, et, cpos, len, meta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_et_update_clusters(et, -len);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\tif (phys_blkno) {\n\t\tif (flags & OCFS2_EXT_REFCOUNTED)\n\t\t\tret = ocfs2_decrease_refcount(inode, handle,\n\t\t\t\t\tocfs2_blocks_to_clusters(osb->sb,\n\t\t\t\t\t\t\t\t phys_blkno),\n\t\t\t\t\tlen, meta_ac,\n\t\t\t\t\tdealloc, 1);\n\t\telse\n\t\t\tret = ocfs2_truncate_log_append(osb, handle,\n\t\t\t\t\t\t\tphys_blkno, len);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tmutex_unlock(&tl_inode->i_mutex);\nbail:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_remove_btree_range(struct inode *inode,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     u32 cpos, u32 phys_cpos, u32 len, int flags,\n\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t     u64 refcount_loc, bool refcount_tree_locked)\n{\n\tint ret, credits = 0, extra_blocks = 0;\n\tu64 phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\thandle_t *handle;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tif ((flags & OCFS2_EXT_REFCOUNTED) && len) {\n\t\tBUG_ON(!(OCFS2_I(inode)->ip_dyn_features &\n\t\t\t OCFS2_HAS_REFCOUNT_FL));\n\n\t\tif (!refcount_tree_locked) {\n\t\t\tret = ocfs2_lock_refcount_tree(osb, refcount_loc, 1,\n\t\t\t\t\t\t       &ref_tree, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tret = ocfs2_prepare_refcount_change_for_del(inode,\n\t\t\t\t\t\t\t    refcount_loc,\n\t\t\t\t\t\t\t    phys_blkno,\n\t\t\t\t\t\t\t    len,\n\t\t\t\t\t\t\t    &credits,\n\t\t\t\t\t\t\t    &extra_blocks);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tret = ocfs2_reserve_blocks_for_rec_trunc(inode, et, 1, &meta_ac,\n\t\t\t\t\t\t extra_blocks);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\tocfs2_remove_extent_credits(osb->sb) + credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tdquot_free_space_nodirty(inode,\n\t\t\t\t  ocfs2_clusters_to_bytes(inode->i_sb, len));\n\n\tret = ocfs2_remove_extent(handle, et, cpos, len, meta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_et_update_clusters(et, -len);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\tif (phys_blkno) {\n\t\tif (flags & OCFS2_EXT_REFCOUNTED)\n\t\t\tret = ocfs2_decrease_refcount(inode, handle,\n\t\t\t\t\tocfs2_blocks_to_clusters(osb->sb,\n\t\t\t\t\t\t\t\t phys_blkno),\n\t\t\t\t\tlen, meta_ac,\n\t\t\t\t\tdealloc, 1);\n\t\telse\n\t\t\tret = ocfs2_truncate_log_append(osb, handle,\n\t\t\t\t\t\t\tphys_blkno, len);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tmutex_unlock(&tl_inode->i_mutex);\nbail:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 7140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_refcount_tree",
          "args": [
            "osb",
            "refcount_loc",
            "1",
            "&ref_tree",
            "NULL"
          ],
          "line": 7137
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "452-524",
          "snippet": "int ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_to_clusters",
          "args": [
            "inode->i_sb",
            "blkno"
          ],
          "line": 7134
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "720-727",
          "snippet": "static inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "inode->i_sb",
            "coff"
          ],
          "line": 7125
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "rec->e_blkno"
          ],
          "line": 7124
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 7123
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_rec_clusters",
          "args": [
            "el",
            "rec"
          ],
          "line": 7114
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rec_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "246-260",
          "snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "inode->i_sb",
            "\"Inode %lu has an empty \"\n\t\t\t\t    \"extent record, depth %u\\n\"",
            "inode->i_ino",
            "le16_to_cpu(root_el->l_tree_depth)"
          ],
          "line": 7100
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "root_el->l_tree_depth"
          ],
          "line": 7102
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "rec"
          ],
          "line": 7094
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "266-269",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "path"
          ],
          "line": 7084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 7083
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 7079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_commit_truncate",
          "args": [
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "new_highest_cpos",
            "OCFS2_I(inode)->ip_clusters",
            "path->p_tree_depth"
          ],
          "line": 7062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 7058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "INODE_CACHE(inode)",
            "path",
            "UINT_MAX"
          ],
          "line": 7056
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1885-1894",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 7056
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_map_trunc",
          "args": [
            "inode",
            "new_highest_cpos"
          ],
          "line": 7042
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_map_trunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "114-144",
          "snippet": "void ocfs2_extent_map_trunc(struct inode *inode, unsigned int cpos)\n{\n\tstruct ocfs2_extent_map_item *emi, *n;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map *em = &oi->ip_extent_map;\n\tLIST_HEAD(tmp_list);\n\tunsigned int range;\n\n\tspin_lock(&oi->ip_lock);\n\tlist_for_each_entry_safe(emi, n, &em->em_list, ei_list) {\n\t\tif (emi->ei_cpos >= cpos) {\n\t\t\t/* Full truncate of this record. */\n\t\t\tlist_move(&emi->ei_list, &tmp_list);\n\t\t\tBUG_ON(em->em_num_items == 0);\n\t\t\tem->em_num_items--;\n\t\t\tcontinue;\n\t\t}\n\n\t\trange = emi->ei_cpos + emi->ei_clusters;\n\t\tif (range > cpos) {\n\t\t\t/* Partial truncate */\n\t\t\temi->ei_clusters = cpos - emi->ei_cpos;\n\t\t}\n\t}\n\tspin_unlock(&oi->ip_lock);\n\n\tlist_for_each_entry_safe(emi, n, &tmp_list, ei_list) {\n\t\tlist_del(&emi->ei_list);\n\t\tkfree(emi);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid ocfs2_extent_map_trunc(struct inode *inode, unsigned int cpos)\n{\n\tstruct ocfs2_extent_map_item *emi, *n;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map *em = &oi->ip_extent_map;\n\tLIST_HEAD(tmp_list);\n\tunsigned int range;\n\n\tspin_lock(&oi->ip_lock);\n\tlist_for_each_entry_safe(emi, n, &em->em_list, ei_list) {\n\t\tif (emi->ei_cpos >= cpos) {\n\t\t\t/* Full truncate of this record. */\n\t\t\tlist_move(&emi->ei_list, &tmp_list);\n\t\t\tBUG_ON(em->em_num_items == 0);\n\t\t\tem->em_num_items--;\n\t\t\tcontinue;\n\t\t}\n\n\t\trange = emi->ei_cpos + emi->ei_clusters;\n\t\tif (range > cpos) {\n\t\t\t/* Partial truncate */\n\t\t\temi->ei_clusters = cpos - emi->ei_cpos;\n\t\t}\n\t}\n\tspin_unlock(&oi->ip_lock);\n\n\tlist_for_each_entry_safe(emi, n, &tmp_list, ei_list) {\n\t\tlist_del(&emi->ei_list);\n\t\tkfree(emi);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 7038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path",
          "args": [
            "di_bh",
            "&di->id2.i_list",
            "ocfs2_journal_access_di"
          ],
          "line": 7034
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "687-705",
          "snippet": "static struct ocfs2_path *ocfs2_new_path(struct buffer_head *root_bh,\n\t\t\t\t\t struct ocfs2_extent_list *root_el,\n\t\t\t\t\t ocfs2_journal_access_func access)\n{\n\tstruct ocfs2_path *path;\n\n\tBUG_ON(le16_to_cpu(root_el->l_tree_depth) >= OCFS2_MAX_PATH_DEPTH);\n\n\tpath = kzalloc(sizeof(*path), GFP_NOFS);\n\tif (path) {\n\t\tpath->p_tree_depth = le16_to_cpu(root_el->l_tree_depth);\n\t\tget_bh(root_bh);\n\t\tpath_root_bh(path) = root_bh;\n\t\tpath_root_el(path) = root_el;\n\t\tpath_root_access(path) = access;\n\t}\n\n\treturn path;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_path *ocfs2_new_path(struct buffer_head *root_bh,\n\t\t\t\t\t struct ocfs2_extent_list *root_el,\n\t\t\t\t\t ocfs2_journal_access_func access)\n{\n\tstruct ocfs2_path *path;\n\n\tBUG_ON(le16_to_cpu(root_el->l_tree_depth) >= OCFS2_MAX_PATH_DEPTH);\n\n\tpath = kzalloc(sizeof(*path), GFP_NOFS);\n\tif (path) {\n\t\tpath->p_tree_depth = le16_to_cpu(root_el->l_tree_depth);\n\t\tget_bh(root_bh);\n\t\tpath_root_bh(path) = root_bh;\n\t\tpath_root_el(path) = root_el;\n\t\tpath_root_access(path) = access;\n\t}\n\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_for_bytes",
          "args": [
            "osb->sb",
            "i_size_read(inode)"
          ],
          "line": 7031
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_for_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-740",
          "snippet": "static inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 7032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dealloc_ctxt",
          "args": [
            "&dealloc"
          ],
          "line": 7029
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dealloc_ctxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "205-209",
          "snippet": "static inline void ocfs2_init_dealloc_ctxt(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\tc->c_first_suballocator = NULL;\n\tc->c_global_allocator = NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ocfs2_init_dealloc_ctxt(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\tc->c_first_suballocator = NULL;\n\tc->c_global_allocator = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dinode_extent_tree",
          "args": [
            "&et",
            "INODE_CACHE(inode)",
            "di_bh"
          ],
          "line": 7028
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dinode_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "458-464",
          "snippet": "void ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};\n\nvoid ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_commit_truncate(struct ocfs2_super *osb,\n\t\t\t  struct inode *inode,\n\t\t\t  struct buffer_head *di_bh)\n{\n\tint status = 0, i, flags = 0;\n\tu32 new_highest_cpos, range, trunc_cpos, trunc_len, phys_cpos, coff;\n\tu64 blkno = 0;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_extent_list *root_el = &(di->id2.i_list);\n\tu64 refcount_loc = le64_to_cpu(di->i_refcount_loc);\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), di_bh);\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\tnew_highest_cpos = ocfs2_clusters_for_bytes(osb->sb,\n\t\t\t\t\t\t     i_size_read(inode));\n\n\tpath = ocfs2_new_path(di_bh, &di->id2.i_list,\n\t\t\t      ocfs2_journal_access_di);\n\tif (!path) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_extent_map_trunc(inode, new_highest_cpos);\n\nstart:\n\t/*\n\t * Check that we still have allocation to delete.\n\t */\n\tif (OCFS2_I(inode)->ip_clusters == 0) {\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Truncate always works against the rightmost tree branch.\n\t */\n\tstatus = ocfs2_find_path(INODE_CACHE(inode), path, UINT_MAX);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_commit_truncate(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\tnew_highest_cpos,\n\t\tOCFS2_I(inode)->ip_clusters,\n\t\tpath->p_tree_depth);\n\n\t/*\n\t * By now, el will point to the extent list on the bottom most\n\t * portion of this tree. Only the tail record is considered in\n\t * each pass.\n\t *\n\t * We handle the following cases, in order:\n\t * - empty extent: delete the remaining branch\n\t * - remove the entire record\n\t * - remove a partial record\n\t * - no record needs to be removed (truncate has completed)\n\t */\n\tel = path_leaf_el(path);\n\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %llu has empty extent block at %llu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)path_leaf_bh(path)->b_blocknr);\n\t\tstatus = -EROFS;\n\t\tgoto bail;\n\t}\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[i];\n\tflags = rec->e_flags;\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\n\tif (i == 0 && ocfs2_is_empty_extent(rec)) {\n\t\t/*\n\t\t * Lower levels depend on this never happening, but it's best\n\t\t * to check it up here before changing the tree.\n\t\t*/\n\t\tif (root_el->l_tree_depth && rec->e_int_clusters == 0) {\n\t\t\tocfs2_error(inode->i_sb, \"Inode %lu has an empty \"\n\t\t\t\t    \"extent record, depth %u\\n\", inode->i_ino,\n\t\t\t\t    le16_to_cpu(root_el->l_tree_depth));\n\t\t\tstatus = -EROFS;\n\t\t\tgoto bail;\n\t\t}\n\t\ttrunc_cpos = le32_to_cpu(rec->e_cpos);\n\t\ttrunc_len = 0;\n\t\tblkno = 0;\n\t} else if (le32_to_cpu(rec->e_cpos) >= new_highest_cpos) {\n\t\t/*\n\t\t * Truncate entire record.\n\t\t */\n\t\ttrunc_cpos = le32_to_cpu(rec->e_cpos);\n\t\ttrunc_len = ocfs2_rec_clusters(el, rec);\n\t\tblkno = le64_to_cpu(rec->e_blkno);\n\t} else if (range > new_highest_cpos) {\n\t\t/*\n\t\t * Partial truncate. it also should be\n\t\t * the last truncate we're doing.\n\t\t */\n\t\ttrunc_cpos = new_highest_cpos;\n\t\ttrunc_len = range - new_highest_cpos;\n\t\tcoff = new_highest_cpos - le32_to_cpu(rec->e_cpos);\n\t\tblkno = le64_to_cpu(rec->e_blkno) +\n\t\t\t\tocfs2_clusters_to_blocks(inode->i_sb, coff);\n\t} else {\n\t\t/*\n\t\t * Truncate completed, leave happily.\n\t\t */\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\tphys_cpos = ocfs2_blocks_to_clusters(inode->i_sb, blkno);\n\n\tif ((flags & OCFS2_EXT_REFCOUNTED) && trunc_len && !ref_tree) {\n\t\tstatus = ocfs2_lock_refcount_tree(osb, refcount_loc, 1,\n\t\t\t\t&ref_tree, NULL);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = ocfs2_remove_btree_range(inode, &et, trunc_cpos,\n\t\t\t\t\t  phys_cpos, trunc_len, flags, &dealloc,\n\t\t\t\t\t  refcount_loc, true);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_reinit_path(path, 1);\n\n\t/*\n\t * The check above will catch the case where we've truncated\n\t * away all allocation.\n\t */\n\tgoto start;\n\nbail:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\n\tocfs2_run_deallocs(osb, &dealloc);\n\n\tocfs2_free_path(path);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_convert_inline_data_to_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "6836-7003",
    "snippet": "int ocfs2_convert_inline_data_to_extents(struct inode *inode,\n\t\t\t\t\t struct buffer_head *di_bh)\n{\n\tint ret, i, has_data, num_pages = 0;\n\tint need_free = 0;\n\tu32 bit_off, num;\n\thandle_t *handle;\n\tu64 uninitialized_var(block);\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct page **pages = NULL;\n\tloff_t end = osb->s_clustersize;\n\tstruct ocfs2_extent_tree et;\n\tint did_quota = 0;\n\n\thas_data = i_size_read(inode) ? 1 : 0;\n\n\tif (has_data) {\n\t\tpages = kcalloc(ocfs2_pages_per_cluster(osb->sb),\n\t\t\t\tsizeof(struct page *), GFP_NOFS);\n\t\tif (pages == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_reserve_clusters(osb, 1, &data_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\t\t   ocfs2_inline_to_extents_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tif (has_data) {\n\t\tunsigned int page_end;\n\t\tu64 phys;\n\n\t\tret = dquot_alloc_space_nodirty(inode,\n\t\t\t\t       ocfs2_clusters_to_bytes(osb->sb, 1));\n\t\tif (ret)\n\t\t\tgoto out_commit;\n\t\tdid_quota = 1;\n\n\t\tdata_ac->ac_resv = &OCFS2_I(inode)->ip_la_data_resv;\n\n\t\tret = ocfs2_claim_clusters(handle, data_ac, 1, &bit_off,\n\t\t\t\t\t   &num);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\t/*\n\t\t * Save two copies, one for insert, and one that can\n\t\t * be changed by ocfs2_map_and_dirty_page() below.\n\t\t */\n\t\tblock = phys = ocfs2_clusters_to_blocks(inode->i_sb, bit_off);\n\n\t\t/*\n\t\t * Non sparse file systems zero on extend, so no need\n\t\t * to do that now.\n\t\t */\n\t\tif (!ocfs2_sparse_alloc(osb) &&\n\t\t    PAGE_CACHE_SIZE < osb->s_clustersize)\n\t\t\tend = PAGE_CACHE_SIZE;\n\n\t\tret = ocfs2_grab_eof_pages(inode, 0, end, pages, &num_pages);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tneed_free = 1;\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\t/*\n\t\t * This should populate the 1st page for us and mark\n\t\t * it up to date.\n\t\t */\n\t\tret = ocfs2_read_inline_data(inode, pages[0], di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tneed_free = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tpage_end = PAGE_CACHE_SIZE;\n\t\tif (PAGE_CACHE_SIZE > osb->s_clustersize)\n\t\t\tpage_end = osb->s_clustersize;\n\n\t\tfor (i = 0; i < num_pages; i++)\n\t\t\tocfs2_map_and_dirty_page(inode, handle, 0, page_end,\n\t\t\t\t\t\t pages[i], i > 0, &phys);\n\t}\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features &= ~OCFS2_INLINE_DATA_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tspin_unlock(&oi->ip_lock);\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_dinode_new_extent_list(inode, di);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tif (has_data) {\n\t\t/*\n\t\t * An error at this point should be extremely rare. If\n\t\t * this proves to be false, we could always re-build\n\t\t * the in-inode data from our pages.\n\t\t */\n\t\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), di_bh);\n\t\tret = ocfs2_insert_extent(handle, &et, 0, block, 1, 0, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tneed_free = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\t}\n\nout_unlock:\n\tif (pages)\n\t\tocfs2_unlock_and_free_pages(pages, num_pages);\n\nout_commit:\n\tif (ret < 0 && did_quota)\n\t\tdquot_free_space_nodirty(inode,\n\t\t\t\t\t  ocfs2_clusters_to_bytes(osb->sb, 1));\n\n\tif (need_free) {\n\t\tif (data_ac->ac_which == OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_free_local_alloc_bits(osb, handle, data_ac,\n\t\t\t\t\tbit_off, num);\n\t\telse\n\t\t\tocfs2_free_clusters(handle,\n\t\t\t\t\tdata_ac->ac_inode,\n\t\t\t\t\tdata_ac->ac_bh,\n\t\t\t\t\tocfs2_clusters_to_blocks(osb->sb, bit_off),\n\t\t\t\t\tnum);\n\t}\n\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\tif (pages)\n\t\tkfree(pages);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pages"
          ],
          "line": 7000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "data_ac"
          ],
          "line": 6998
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 6994
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_clusters",
          "args": [
            "handle",
            "data_ac->ac_inode",
            "data_ac->ac_bh",
            "ocfs2_clusters_to_blocks(osb->sb, bit_off)",
            "num"
          ],
          "line": 6987
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2591-2600",
          "snippet": "int ocfs2_free_clusters(handle_t *handle,\n\t\t\tstruct inode *bitmap_inode,\n\t\t\tstruct buffer_head *bitmap_bh,\n\t\t\tu64 start_blk,\n\t\t\tunsigned int num_clusters)\n{\n\treturn _ocfs2_free_clusters(handle, bitmap_inode, bitmap_bh,\n\t\t\t\t    start_blk, num_clusters,\n\t\t\t\t    _ocfs2_set_bit);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_free_clusters(handle_t *handle,\n\t\t\tstruct inode *bitmap_inode,\n\t\t\tstruct buffer_head *bitmap_bh,\n\t\t\tu64 start_blk,\n\t\t\tunsigned int num_clusters)\n{\n\treturn _ocfs2_free_clusters(handle, bitmap_inode, bitmap_bh,\n\t\t\t\t    start_blk, num_clusters,\n\t\t\t\t    _ocfs2_set_bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "osb->sb",
            "bit_off"
          ],
          "line": 6990
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_local_alloc_bits",
          "args": [
            "osb",
            "handle",
            "data_ac",
            "bit_off",
            "num"
          ],
          "line": 6984
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_local_alloc_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "784-824",
          "snippet": "int ocfs2_free_local_alloc_bits(struct ocfs2_super *osb,\n\t\t\t\thandle_t *handle,\n\t\t\t\tstruct ocfs2_alloc_context *ac,\n\t\t\t\tu32 bit_off,\n\t\t\t\tu32 num_bits)\n{\n\tint status, start;\n\tu32 clear_bits;\n\tstruct inode *local_alloc_inode;\n\tvoid *bitmap;\n\tstruct ocfs2_dinode *alloc;\n\tstruct ocfs2_local_alloc *la;\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL);\n\n\tlocal_alloc_inode = ac->ac_inode;\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\tla = OCFS2_LOCAL_ALLOC(alloc);\n\n\tbitmap = la->la_bitmap;\n\tstart = bit_off - le32_to_cpu(la->la_bm_off);\n\tclear_bits = num_bits;\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\tINODE_CACHE(local_alloc_inode),\n\t\t\tosb->local_alloc_bh,\n\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\twhile (clear_bits--)\n\t\tocfs2_clear_bit(start++, bitmap);\n\n\tle32_add_cpu(&alloc->id1.bitmap1.i_used, -num_bits);\n\tocfs2_journal_dirty(handle, osb->local_alloc_bh);\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
            "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);",
            "static int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);",
            "static int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\nstatic int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);\nstatic int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode);\n\nint ocfs2_free_local_alloc_bits(struct ocfs2_super *osb,\n\t\t\t\thandle_t *handle,\n\t\t\t\tstruct ocfs2_alloc_context *ac,\n\t\t\t\tu32 bit_off,\n\t\t\t\tu32 num_bits)\n{\n\tint status, start;\n\tu32 clear_bits;\n\tstruct inode *local_alloc_inode;\n\tvoid *bitmap;\n\tstruct ocfs2_dinode *alloc;\n\tstruct ocfs2_local_alloc *la;\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL);\n\n\tlocal_alloc_inode = ac->ac_inode;\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\tla = OCFS2_LOCAL_ALLOC(alloc);\n\n\tbitmap = la->la_bitmap;\n\tstart = bit_off - le32_to_cpu(la->la_bm_off);\n\tclear_bits = num_bits;\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\tINODE_CACHE(local_alloc_inode),\n\t\t\tosb->local_alloc_bh,\n\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\twhile (clear_bits--)\n\t\tocfs2_clear_bit(start++, bitmap);\n\n\tle32_add_cpu(&alloc->id1.bitmap1.i_used, -num_bits);\n\tocfs2_journal_dirty(handle, osb->local_alloc_bh);\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_space_nodirty",
          "args": [
            "inode",
            "ocfs2_clusters_to_bytes(osb->sb, 1)"
          ],
          "line": 6979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_bytes",
          "args": [
            "osb->sb",
            "1"
          ],
          "line": 6980
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "759-763",
          "snippet": "static inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_unlock_and_free_pages",
          "args": [
            "pages",
            "num_pages"
          ],
          "line": 6975
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_and_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1114-1125",
          "snippet": "void ocfs2_unlock_and_free_pages(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor(i = 0; i < num_pages; i++) {\n\t\tif (pages[i]) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tmark_page_accessed(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid ocfs2_unlock_and_free_pages(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor(i = 0; i < num_pages; i++) {\n\t\tif (pages[i]) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tmark_page_accessed(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_sector_count",
          "args": [
            "inode"
          ],
          "line": 6970
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_sector_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "165-170",
          "snippet": "static inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_insert_extent",
          "args": [
            "handle",
            "&et",
            "0",
            "block",
            "1",
            "0",
            "NULL"
          ],
          "line": 6963
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_insert_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "4665-4726",
          "snippet": "int ocfs2_insert_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos,\n\t\t\tu64 start_blk,\n\t\t\tu32 new_clusters,\n\t\t\tu8 flags,\n\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint status;\n\tint uninitialized_var(free_records);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_insert_type insert = {0, };\n\tstruct ocfs2_extent_rec rec;\n\n\ttrace_ocfs2_insert_extent_start(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, new_clusters);\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.e_cpos = cpu_to_le32(cpos);\n\trec.e_blkno = cpu_to_le64(start_blk);\n\trec.e_leaf_clusters = cpu_to_le16(new_clusters);\n\trec.e_flags = flags;\n\tstatus = ocfs2_et_insert_check(et, &rec);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_figure_insert_type(et, &last_eb_bh, &rec,\n\t\t\t\t\t  &free_records, &insert);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_insert_extent(insert.ins_appending, insert.ins_contig,\n\t\t\t\t  insert.ins_contig_index, free_records,\n\t\t\t\t  insert.ins_tree_depth);\n\n\tif (insert.ins_contig == CONTIG_NONE && free_records == 0) {\n\t\tstatus = ocfs2_grow_tree(handle, et,\n\t\t\t\t\t &insert.ins_tree_depth, &last_eb_bh,\n\t\t\t\t\t meta_ac);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Finally, we can add clusters. This might rotate the tree for us. */\n\tstatus = ocfs2_do_insert_extent(handle, et, &rec, &insert);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_et_extent_map_insert(et, &rec);\n\nbail:\n\tbrelse(last_eb_bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_insert_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos,\n\t\t\tu64 start_blk,\n\t\t\tu32 new_clusters,\n\t\t\tu8 flags,\n\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint status;\n\tint uninitialized_var(free_records);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_insert_type insert = {0, };\n\tstruct ocfs2_extent_rec rec;\n\n\ttrace_ocfs2_insert_extent_start(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, new_clusters);\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.e_cpos = cpu_to_le32(cpos);\n\trec.e_blkno = cpu_to_le64(start_blk);\n\trec.e_leaf_clusters = cpu_to_le16(new_clusters);\n\trec.e_flags = flags;\n\tstatus = ocfs2_et_insert_check(et, &rec);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_figure_insert_type(et, &last_eb_bh, &rec,\n\t\t\t\t\t  &free_records, &insert);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_insert_extent(insert.ins_appending, insert.ins_contig,\n\t\t\t\t  insert.ins_contig_index, free_records,\n\t\t\t\t  insert.ins_tree_depth);\n\n\tif (insert.ins_contig == CONTIG_NONE && free_records == 0) {\n\t\tstatus = ocfs2_grow_tree(handle, et,\n\t\t\t\t\t &insert.ins_tree_depth, &last_eb_bh,\n\t\t\t\t\t meta_ac);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Finally, we can add clusters. This might rotate the tree for us. */\n\tstatus = ocfs2_do_insert_extent(handle, et, &rec, &insert);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_et_extent_map_insert(et, &rec);\n\nbail:\n\tbrelse(last_eb_bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dinode_extent_tree",
          "args": [
            "&et",
            "INODE_CACHE(inode)",
            "di_bh"
          ],
          "line": 6962
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dinode_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "458-464",
          "snippet": "void ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};\n\nvoid ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 6962
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "di_bh"
          ],
          "line": 6954
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dinode_new_extent_list",
          "args": [
            "inode",
            "di"
          ],
          "line": 6952
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dinode_new_extent_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6806-6814",
          "snippet": "void ocfs2_dinode_new_extent_list(struct inode *inode,\n\t\t\t\t  struct ocfs2_dinode *di)\n{\n\tocfs2_zero_dinode_id2_with_xattr(inode, di);\n\tdi->id2.i_list.l_tree_depth = 0;\n\tdi->id2.i_list.l_next_free_rec = 0;\n\tdi->id2.i_list.l_count = cpu_to_le16(\n\t\tocfs2_extent_recs_per_inode_with_xattr(inode->i_sb, di));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_dinode_new_extent_list(struct inode *inode,\n\t\t\t\t  struct ocfs2_dinode *di)\n{\n\tocfs2_zero_dinode_id2_with_xattr(inode, di);\n\tdi->id2.i_list.l_tree_depth = 0;\n\tdi->id2.i_list.l_next_free_rec = 0;\n\tdi->id2.i_list.l_count = cpu_to_le16(\n\t\tocfs2_extent_recs_per_inode_with_xattr(inode->i_sb, di));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_inode_fsync_trans",
          "args": [
            "handle",
            "inode",
            "1"
          ],
          "line": 6951
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "634-643",
          "snippet": "static inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 6949
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "oi->ip_dyn_features"
          ],
          "line": 6948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 6946
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_map_and_dirty_page",
          "args": [
            "inode",
            "handle",
            "0",
            "page_end",
            "pages[i]",
            "i > 0",
            "&phys"
          ],
          "line": 6942
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_map_and_dirty_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6596-6629",
          "snippet": "void ocfs2_map_and_dirty_page(struct inode *inode, handle_t *handle,\n\t\t\t      unsigned int from, unsigned int to,\n\t\t\t      struct page *page, int zero, u64 *phys)\n{\n\tint ret, partial = 0;\n\n\tret = ocfs2_map_page_blocks(page, phys, inode, from, to, 0);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (zero)\n\t\tzero_user_segment(page, from, to);\n\n\t/*\n\t * Need to set the buffers we zero'd into uptodate\n\t * here if they aren't - ocfs2_map_page_blocks()\n\t * might've skipped some\n\t */\n\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\tfrom, to, &partial,\n\t\t\t\tocfs2_zero_func);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\telse if (ocfs2_should_order_data(inode)) {\n\t\tret = ocfs2_jbd2_file_inode(handle, inode);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t}\n\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\n\tflush_dcache_page(page);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_map_and_dirty_page(struct inode *inode, handle_t *handle,\n\t\t\t      unsigned int from, unsigned int to,\n\t\t\t      struct page *page, int zero, u64 *phys)\n{\n\tint ret, partial = 0;\n\n\tret = ocfs2_map_page_blocks(page, phys, inode, from, to, 0);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (zero)\n\t\tzero_user_segment(page, from, to);\n\n\t/*\n\t * Need to set the buffers we zero'd into uptodate\n\t * here if they aren't - ocfs2_map_page_blocks()\n\t * might've skipped some\n\t */\n\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\tfrom, to, &partial,\n\t\t\t\tocfs2_zero_func);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\telse if (ocfs2_should_order_data(inode)) {\n\t\tret = ocfs2_jbd2_file_inode(handle, inode);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t}\n\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\n\tflush_dcache_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_inline_data",
          "args": [
            "inode",
            "pages[0]",
            "di_bh"
          ],
          "line": 6930
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "221-256",
          "snippet": "int ocfs2_read_inline_data(struct inode *inode, struct page *page,\n\t\t\t   struct buffer_head *di_bh)\n{\n\tvoid *kaddr;\n\tloff_t size;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tif (!(le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_DATA_FL)) {\n\t\tocfs2_error(inode->i_sb, \"Inode %llu lost inline data flag\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\treturn -EROFS;\n\t}\n\n\tsize = i_size_read(inode);\n\n\tif (size > PAGE_CACHE_SIZE ||\n\t    size > ocfs2_max_inline_data_with_xattr(inode->i_sb, di)) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %llu has with inline data has bad size: %Lu\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)size);\n\t\treturn -EROFS;\n\t}\n\n\tkaddr = kmap_atomic(page);\n\tif (size)\n\t\tmemcpy(kaddr, di->id2.i_data.id_data, size);\n\t/* Clear the remaining part of the page */\n\tmemset(kaddr + size, 0, PAGE_CACHE_SIZE - size);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\n\tSetPageUptodate(page);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ocfs2_read_inline_data(struct inode *inode, struct page *page,\n\t\t\t   struct buffer_head *di_bh)\n{\n\tvoid *kaddr;\n\tloff_t size;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tif (!(le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_DATA_FL)) {\n\t\tocfs2_error(inode->i_sb, \"Inode %llu lost inline data flag\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\treturn -EROFS;\n\t}\n\n\tsize = i_size_read(inode);\n\n\tif (size > PAGE_CACHE_SIZE ||\n\t    size > ocfs2_max_inline_data_with_xattr(inode->i_sb, di)) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %llu has with inline data has bad size: %Lu\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)size);\n\t\treturn -EROFS;\n\t}\n\n\tkaddr = kmap_atomic(page);\n\tif (size)\n\t\tmemcpy(kaddr, di->id2.i_data.id_data, size);\n\t/* Clear the remaining part of the page */\n\tmemset(kaddr + size, 0, PAGE_CACHE_SIZE - size);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\n\tSetPageUptodate(page);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_grab_eof_pages",
          "args": [
            "inode",
            "0",
            "end",
            "pages",
            "&num_pages"
          ],
          "line": 6919
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_grab_eof_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6703-6712",
          "snippet": "static int ocfs2_grab_eof_pages(struct inode *inode, loff_t start, loff_t end,\n\t\t\t\tstruct page **pages, int *num)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(start >> OCFS2_SB(sb)->s_clustersize_bits !=\n\t       (end - 1) >> OCFS2_SB(sb)->s_clustersize_bits);\n\n\treturn ocfs2_grab_pages(inode, start, end, pages, num);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_grab_eof_pages(struct inode *inode, loff_t start, loff_t end,\n\t\t\t\tstruct page **pages, int *num)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(start >> OCFS2_SB(sb)->s_clustersize_bits !=\n\t       (end - 1) >> OCFS2_SB(sb)->s_clustersize_bits);\n\n\treturn ocfs2_grab_pages(inode, start, end, pages, num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_sparse_alloc",
          "args": [
            "osb"
          ],
          "line": 6915
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sparse_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "483-488",
          "snippet": "static inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_claim_clusters",
          "args": [
            "handle",
            "data_ac",
            "1",
            "&bit_off",
            "&num"
          ],
          "line": 6898
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_claim_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2373-2383",
          "snippet": "int ocfs2_claim_clusters(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 min_clusters,\n\t\t\t u32 *cluster_start,\n\t\t\t u32 *num_clusters)\n{\n\tunsigned int bits_wanted = ac->ac_bits_wanted - ac->ac_bits_given;\n\n\treturn __ocfs2_claim_clusters(handle, ac, min_clusters,\n\t\t\t\t      bits_wanted, cluster_start, num_clusters);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_claim_clusters(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 min_clusters,\n\t\t\t u32 *cluster_start,\n\t\t\t u32 *num_clusters)\n{\n\tunsigned int bits_wanted = ac->ac_bits_wanted - ac->ac_bits_given;\n\n\treturn __ocfs2_claim_clusters(handle, ac, min_clusters,\n\t\t\t\t      bits_wanted, cluster_start, num_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 6896
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_alloc_space_nodirty",
          "args": [
            "inode",
            "ocfs2_clusters_to_bytes(osb->sb, 1)"
          ],
          "line": 6890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "di_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 6879
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 6874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 6873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "ocfs2_inline_to_extents_credits(osb->sb)"
          ],
          "line": 6871
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inline_to_extents_credits",
          "args": [
            "osb->sb"
          ],
          "line": 6872
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inline_to_extents_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "399-403",
          "snippet": "static inline int ocfs2_inline_to_extents_credits(struct super_block *sb)\n{\n\treturn OCFS2_SUBALLOC_ALLOC + OCFS2_INODE_UPDATE_CREDITS +\n\t       ocfs2_quota_trans_credits(sb);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_SUBALLOC_ALLOC (3)",
            "#define OCFS2_INODE_UPDATE_CREDITS 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_SUBALLOC_ALLOC (3)\n#define OCFS2_INODE_UPDATE_CREDITS 1\n\nstatic inline int ocfs2_inline_to_extents_credits(struct super_block *sb)\n{\n\treturn OCFS2_SUBALLOC_ALLOC + OCFS2_INODE_UPDATE_CREDITS +\n\t       ocfs2_quota_trans_credits(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_clusters",
          "args": [
            "osb",
            "1",
            "&data_ac"
          ],
          "line": 6864
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1228-1234",
          "snippet": "int ocfs2_reserve_clusters(struct ocfs2_super *osb,\n\t\t\t   u32 bits_wanted,\n\t\t\t   struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_clusters_with_limit(osb, bits_wanted, 0,\n\t\t\t\t\t\t ALLOC_NEW_GROUP, ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_clusters(struct ocfs2_super *osb,\n\t\t\t   u32 bits_wanted,\n\t\t\t   struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_clusters_with_limit(osb, bits_wanted, 0,\n\t\t\t\t\t\t ALLOC_NEW_GROUP, ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "ocfs2_pages_per_cluster(osb->sb)",
            "sizeof(struct page *)",
            "GFP_NOFS"
          ],
          "line": 6856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_pages_per_cluster",
          "args": [
            "osb->sb"
          ],
          "line": 6856
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_pages_per_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "831-840",
          "snippet": "static inline unsigned int ocfs2_pages_per_cluster(struct super_block *sb)\n{\n\tunsigned int cbits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int pages_per_cluster = 1;\n\n\tif (PAGE_CACHE_SHIFT < cbits)\n\t\tpages_per_cluster = 1 << (cbits - PAGE_CACHE_SHIFT);\n\n\treturn pages_per_cluster;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_pages_per_cluster(struct super_block *sb)\n{\n\tunsigned int cbits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int pages_per_cluster = 1;\n\n\tif (PAGE_CACHE_SHIFT < cbits)\n\t\tpages_per_cluster = 1 << (cbits - PAGE_CACHE_SHIFT);\n\n\treturn pages_per_cluster;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 6853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 6845
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_convert_inline_data_to_extents(struct inode *inode,\n\t\t\t\t\t struct buffer_head *di_bh)\n{\n\tint ret, i, has_data, num_pages = 0;\n\tint need_free = 0;\n\tu32 bit_off, num;\n\thandle_t *handle;\n\tu64 uninitialized_var(block);\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct page **pages = NULL;\n\tloff_t end = osb->s_clustersize;\n\tstruct ocfs2_extent_tree et;\n\tint did_quota = 0;\n\n\thas_data = i_size_read(inode) ? 1 : 0;\n\n\tif (has_data) {\n\t\tpages = kcalloc(ocfs2_pages_per_cluster(osb->sb),\n\t\t\t\tsizeof(struct page *), GFP_NOFS);\n\t\tif (pages == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_reserve_clusters(osb, 1, &data_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\t\t   ocfs2_inline_to_extents_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tif (has_data) {\n\t\tunsigned int page_end;\n\t\tu64 phys;\n\n\t\tret = dquot_alloc_space_nodirty(inode,\n\t\t\t\t       ocfs2_clusters_to_bytes(osb->sb, 1));\n\t\tif (ret)\n\t\t\tgoto out_commit;\n\t\tdid_quota = 1;\n\n\t\tdata_ac->ac_resv = &OCFS2_I(inode)->ip_la_data_resv;\n\n\t\tret = ocfs2_claim_clusters(handle, data_ac, 1, &bit_off,\n\t\t\t\t\t   &num);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\t/*\n\t\t * Save two copies, one for insert, and one that can\n\t\t * be changed by ocfs2_map_and_dirty_page() below.\n\t\t */\n\t\tblock = phys = ocfs2_clusters_to_blocks(inode->i_sb, bit_off);\n\n\t\t/*\n\t\t * Non sparse file systems zero on extend, so no need\n\t\t * to do that now.\n\t\t */\n\t\tif (!ocfs2_sparse_alloc(osb) &&\n\t\t    PAGE_CACHE_SIZE < osb->s_clustersize)\n\t\t\tend = PAGE_CACHE_SIZE;\n\n\t\tret = ocfs2_grab_eof_pages(inode, 0, end, pages, &num_pages);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tneed_free = 1;\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\t/*\n\t\t * This should populate the 1st page for us and mark\n\t\t * it up to date.\n\t\t */\n\t\tret = ocfs2_read_inline_data(inode, pages[0], di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tneed_free = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tpage_end = PAGE_CACHE_SIZE;\n\t\tif (PAGE_CACHE_SIZE > osb->s_clustersize)\n\t\t\tpage_end = osb->s_clustersize;\n\n\t\tfor (i = 0; i < num_pages; i++)\n\t\t\tocfs2_map_and_dirty_page(inode, handle, 0, page_end,\n\t\t\t\t\t\t pages[i], i > 0, &phys);\n\t}\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features &= ~OCFS2_INLINE_DATA_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tspin_unlock(&oi->ip_lock);\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_dinode_new_extent_list(inode, di);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tif (has_data) {\n\t\t/*\n\t\t * An error at this point should be extremely rare. If\n\t\t * this proves to be false, we could always re-build\n\t\t * the in-inode data from our pages.\n\t\t */\n\t\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), di_bh);\n\t\tret = ocfs2_insert_extent(handle, &et, 0, block, 1, 0, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tneed_free = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\t}\n\nout_unlock:\n\tif (pages)\n\t\tocfs2_unlock_and_free_pages(pages, num_pages);\n\nout_commit:\n\tif (ret < 0 && did_quota)\n\t\tdquot_free_space_nodirty(inode,\n\t\t\t\t\t  ocfs2_clusters_to_bytes(osb->sb, 1));\n\n\tif (need_free) {\n\t\tif (data_ac->ac_which == OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_free_local_alloc_bits(osb, handle, data_ac,\n\t\t\t\t\tbit_off, num);\n\t\telse\n\t\t\tocfs2_free_clusters(handle,\n\t\t\t\t\tdata_ac->ac_inode,\n\t\t\t\t\tdata_ac->ac_bh,\n\t\t\t\t\tocfs2_clusters_to_blocks(osb->sb, bit_off),\n\t\t\t\t\tnum);\n\t}\n\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\tif (pages)\n\t\tkfree(pages);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_set_inode_data_inline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "6816-6834",
    "snippet": "void ocfs2_set_inode_data_inline(struct inode *inode, struct ocfs2_dinode *di)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_inline_data *idata = &di->id2.i_data;\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features |= OCFS2_INLINE_DATA_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tspin_unlock(&oi->ip_lock);\n\n\t/*\n\t * We clear the entire i_data structure here so that all\n\t * fields can be properly initialized.\n\t */\n\tocfs2_zero_dinode_id2_with_xattr(inode, di);\n\n\tidata->id_count = cpu_to_le16(\n\t\t\tocfs2_max_inline_data_with_xattr(inode->i_sb, di));\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ocfs2_max_inline_data_with_xattr(inode->i_sb, di)"
          ],
          "line": 6832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_max_inline_data_with_xattr",
          "args": [
            "inode->i_sb",
            "di"
          ],
          "line": 6833
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_max_inline_data_with_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1485-1495",
          "snippet": "static inline int ocfs2_max_inline_data_with_xattr(int blocksize,\n\t\t\t\t\t\t   struct ocfs2_dinode *di)\n{\n\tif (di && (di->i_dyn_features & OCFS2_INLINE_XATTR_FL))\n\t\treturn blocksize -\n\t\t\toffsetof(struct ocfs2_dinode, id2.i_data.id_data) -\n\t\t\tdi->i_xattr_inline_size;\n\telse\n\t\treturn blocksize -\n\t\t\toffsetof(struct ocfs2_dinode, id2.i_data.id_data);\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_INLINE_XATTR_FL\t(0x0004)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_INLINE_XATTR_FL\t(0x0004)\n\nstatic inline int ocfs2_max_inline_data_with_xattr(int blocksize,\n\t\t\t\t\t\t   struct ocfs2_dinode *di)\n{\n\tif (di && (di->i_dyn_features & OCFS2_INLINE_XATTR_FL))\n\t\treturn blocksize -\n\t\t\toffsetof(struct ocfs2_dinode, id2.i_data.id_data) -\n\t\t\tdi->i_xattr_inline_size;\n\telse\n\t\treturn blocksize -\n\t\t\toffsetof(struct ocfs2_dinode, id2.i_data.id_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_zero_dinode_id2_with_xattr",
          "args": [
            "inode",
            "di"
          ],
          "line": 6830
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_zero_dinode_id2_with_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6791-6804",
          "snippet": "static void ocfs2_zero_dinode_id2_with_xattr(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_dinode *di)\n{\n\tunsigned int blocksize = 1 << inode->i_sb->s_blocksize_bits;\n\tunsigned int xattrsize = le16_to_cpu(di->i_xattr_inline_size);\n\n\tif (le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_XATTR_FL)\n\t\tmemset(&di->id2, 0, blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2) -\n\t\t\t\t    xattrsize);\n\telse\n\t\tmemset(&di->id2, 0, blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_zero_dinode_id2_with_xattr(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_dinode *di)\n{\n\tunsigned int blocksize = 1 << inode->i_sb->s_blocksize_bits;\n\tunsigned int xattrsize = le16_to_cpu(di->i_xattr_inline_size);\n\n\tif (le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_XATTR_FL)\n\t\tmemset(&di->id2, 0, blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2) -\n\t\t\t\t    xattrsize);\n\telse\n\t\tmemset(&di->id2, 0, blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 6824
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "oi->ip_dyn_features"
          ],
          "line": 6823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 6821
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 6818
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_inode_data_inline(struct inode *inode, struct ocfs2_dinode *di)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_inline_data *idata = &di->id2.i_data;\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features |= OCFS2_INLINE_DATA_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tspin_unlock(&oi->ip_lock);\n\n\t/*\n\t * We clear the entire i_data structure here so that all\n\t * fields can be properly initialized.\n\t */\n\tocfs2_zero_dinode_id2_with_xattr(inode, di);\n\n\tidata->id_count = cpu_to_le16(\n\t\t\tocfs2_max_inline_data_with_xattr(inode->i_sb, di));\n}"
  },
  {
    "function_name": "ocfs2_dinode_new_extent_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "6806-6814",
    "snippet": "void ocfs2_dinode_new_extent_list(struct inode *inode,\n\t\t\t\t  struct ocfs2_dinode *di)\n{\n\tocfs2_zero_dinode_id2_with_xattr(inode, di);\n\tdi->id2.i_list.l_tree_depth = 0;\n\tdi->id2.i_list.l_next_free_rec = 0;\n\tdi->id2.i_list.l_count = cpu_to_le16(\n\t\tocfs2_extent_recs_per_inode_with_xattr(inode->i_sb, di));\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ocfs2_extent_recs_per_inode_with_xattr(inode->i_sb, di)"
          ],
          "line": 6812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_recs_per_inode_with_xattr",
          "args": [
            "inode->i_sb",
            "di"
          ],
          "line": 6813
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_recs_per_inode_with_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1311-1327",
          "snippet": "static inline int ocfs2_extent_recs_per_inode_with_xattr(\n\t\t\t\t\t\tstruct super_block *sb,\n\t\t\t\t\t\tstruct ocfs2_dinode *di)\n{\n\tint size;\n\tunsigned int xattrsize = le16_to_cpu(di->i_xattr_inline_size);\n\n\tif (le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_XATTR_FL)\n\t\tsize = sb->s_blocksize -\n\t\t\toffsetof(struct ocfs2_dinode, id2.i_list.l_recs) -\n\t\t\txattrsize;\n\telse\n\t\tsize = sb->s_blocksize -\n\t\t\toffsetof(struct ocfs2_dinode, id2.i_list.l_recs);\n\n\treturn size / sizeof(struct ocfs2_extent_rec);\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_INLINE_XATTR_FL\t(0x0004)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_INLINE_XATTR_FL\t(0x0004)\n\nstatic inline int ocfs2_extent_recs_per_inode_with_xattr(\n\t\t\t\t\t\tstruct super_block *sb,\n\t\t\t\t\t\tstruct ocfs2_dinode *di)\n{\n\tint size;\n\tunsigned int xattrsize = le16_to_cpu(di->i_xattr_inline_size);\n\n\tif (le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_XATTR_FL)\n\t\tsize = sb->s_blocksize -\n\t\t\toffsetof(struct ocfs2_dinode, id2.i_list.l_recs) -\n\t\t\txattrsize;\n\telse\n\t\tsize = sb->s_blocksize -\n\t\t\toffsetof(struct ocfs2_dinode, id2.i_list.l_recs);\n\n\treturn size / sizeof(struct ocfs2_extent_rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_zero_dinode_id2_with_xattr",
          "args": [
            "inode",
            "di"
          ],
          "line": 6809
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_zero_dinode_id2_with_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6791-6804",
          "snippet": "static void ocfs2_zero_dinode_id2_with_xattr(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_dinode *di)\n{\n\tunsigned int blocksize = 1 << inode->i_sb->s_blocksize_bits;\n\tunsigned int xattrsize = le16_to_cpu(di->i_xattr_inline_size);\n\n\tif (le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_XATTR_FL)\n\t\tmemset(&di->id2, 0, blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2) -\n\t\t\t\t    xattrsize);\n\telse\n\t\tmemset(&di->id2, 0, blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_zero_dinode_id2_with_xattr(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_dinode *di)\n{\n\tunsigned int blocksize = 1 << inode->i_sb->s_blocksize_bits;\n\tunsigned int xattrsize = le16_to_cpu(di->i_xattr_inline_size);\n\n\tif (le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_XATTR_FL)\n\t\tmemset(&di->id2, 0, blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2) -\n\t\t\t\t    xattrsize);\n\telse\n\t\tmemset(&di->id2, 0, blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_dinode_new_extent_list(struct inode *inode,\n\t\t\t\t  struct ocfs2_dinode *di)\n{\n\tocfs2_zero_dinode_id2_with_xattr(inode, di);\n\tdi->id2.i_list.l_tree_depth = 0;\n\tdi->id2.i_list.l_next_free_rec = 0;\n\tdi->id2.i_list.l_count = cpu_to_le16(\n\t\tocfs2_extent_recs_per_inode_with_xattr(inode->i_sb, di));\n}"
  },
  {
    "function_name": "ocfs2_zero_dinode_id2_with_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "6791-6804",
    "snippet": "static void ocfs2_zero_dinode_id2_with_xattr(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_dinode *di)\n{\n\tunsigned int blocksize = 1 << inode->i_sb->s_blocksize_bits;\n\tunsigned int xattrsize = le16_to_cpu(di->i_xattr_inline_size);\n\n\tif (le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_XATTR_FL)\n\t\tmemset(&di->id2, 0, blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2) -\n\t\t\t\t    xattrsize);\n\telse\n\t\tmemset(&di->id2, 0, blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2));\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&di->id2",
            "0",
            "blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2)"
          ],
          "line": 6802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&di->id2",
            "0",
            "blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2) -\n\t\t\t\t    xattrsize"
          ],
          "line": 6798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "di->i_dyn_features"
          ],
          "line": 6797
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_zero_dinode_id2_with_xattr(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_dinode *di)\n{\n\tunsigned int blocksize = 1 << inode->i_sb->s_blocksize_bits;\n\tunsigned int xattrsize = le16_to_cpu(di->i_xattr_inline_size);\n\n\tif (le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_XATTR_FL)\n\t\tmemset(&di->id2, 0, blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2) -\n\t\t\t\t    xattrsize);\n\telse\n\t\tmemset(&di->id2, 0, blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2));\n}"
  },
  {
    "function_name": "ocfs2_zero_range_for_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "6723-6789",
    "snippet": "int ocfs2_zero_range_for_truncate(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 range_start, u64 range_end)\n{\n\tint ret = 0, numpages;\n\tstruct page **pages = NULL;\n\tu64 phys;\n\tunsigned int ext_flags;\n\tstruct super_block *sb = inode->i_sb;\n\n\t/*\n\t * File systems which don't support sparse files zero on every\n\t * extend.\n\t */\n\tif (!ocfs2_sparse_alloc(OCFS2_SB(sb)))\n\t\treturn 0;\n\n\tpages = kcalloc(ocfs2_pages_per_cluster(sb),\n\t\t\tsizeof(struct page *), GFP_NOFS);\n\tif (pages == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (range_start == range_end)\n\t\tgoto out;\n\n\tret = ocfs2_extent_map_get_blocks(inode,\n\t\t\t\t\t  range_start >> sb->s_blocksize_bits,\n\t\t\t\t\t  &phys, NULL, &ext_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Tail is a hole, or is marked unwritten. In either case, we\n\t * can count on read and write to return/push zero's.\n\t */\n\tif (phys == 0 || ext_flags & OCFS2_EXT_UNWRITTEN)\n\t\tgoto out;\n\n\tret = ocfs2_grab_eof_pages(inode, range_start, range_end, pages,\n\t\t\t\t   &numpages);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_zero_cluster_pages(inode, range_start, range_end, pages,\n\t\t\t\t numpages, phys, handle);\n\n\t/*\n\t * Initiate writeout of the pages we zero'd here. We don't\n\t * wait on them - the truncate_inode_pages() call later will\n\t * do that for us.\n\t */\n\tret = filemap_fdatawrite_range(inode->i_mapping, range_start,\n\t\t\t\t       range_end - 1);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tkfree(pages);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pages"
          ],
          "line": 6786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_fdatawrite_range",
          "args": [
            "inode->i_mapping",
            "range_start",
            "range_end - 1"
          ],
          "line": 6780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_zero_cluster_pages",
          "args": [
            "inode",
            "range_start",
            "range_end",
            "pages",
            "numpages",
            "phys",
            "handle"
          ],
          "line": 6772
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_zero_cluster_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6631-6664",
          "snippet": "static void ocfs2_zero_cluster_pages(struct inode *inode, loff_t start,\n\t\t\t\t     loff_t end, struct page **pages,\n\t\t\t\t     int numpages, u64 phys, handle_t *handle)\n{\n\tint i;\n\tstruct page *page;\n\tunsigned int from, to = PAGE_CACHE_SIZE;\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(!ocfs2_sparse_alloc(OCFS2_SB(sb)));\n\n\tif (numpages == 0)\n\t\tgoto out;\n\n\tto = PAGE_CACHE_SIZE;\n\tfor(i = 0; i < numpages; i++) {\n\t\tpage = pages[i];\n\n\t\tfrom = start & (PAGE_CACHE_SIZE - 1);\n\t\tif ((end >> PAGE_CACHE_SHIFT) == page->index)\n\t\t\tto = end & (PAGE_CACHE_SIZE - 1);\n\n\t\tBUG_ON(from > PAGE_CACHE_SIZE);\n\t\tBUG_ON(to > PAGE_CACHE_SIZE);\n\n\t\tocfs2_map_and_dirty_page(inode, handle, from, to, page, 1,\n\t\t\t\t\t &phys);\n\n\t\tstart = (page->index + 1) << PAGE_CACHE_SHIFT;\n\t}\nout:\n\tif (pages)\n\t\tocfs2_unlock_and_free_pages(pages, numpages);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_zero_cluster_pages(struct inode *inode, loff_t start,\n\t\t\t\t     loff_t end, struct page **pages,\n\t\t\t\t     int numpages, u64 phys, handle_t *handle)\n{\n\tint i;\n\tstruct page *page;\n\tunsigned int from, to = PAGE_CACHE_SIZE;\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(!ocfs2_sparse_alloc(OCFS2_SB(sb)));\n\n\tif (numpages == 0)\n\t\tgoto out;\n\n\tto = PAGE_CACHE_SIZE;\n\tfor(i = 0; i < numpages; i++) {\n\t\tpage = pages[i];\n\n\t\tfrom = start & (PAGE_CACHE_SIZE - 1);\n\t\tif ((end >> PAGE_CACHE_SHIFT) == page->index)\n\t\t\tto = end & (PAGE_CACHE_SIZE - 1);\n\n\t\tBUG_ON(from > PAGE_CACHE_SIZE);\n\t\tBUG_ON(to > PAGE_CACHE_SIZE);\n\n\t\tocfs2_map_and_dirty_page(inode, handle, from, to, page, 1,\n\t\t\t\t\t &phys);\n\n\t\tstart = (page->index + 1) << PAGE_CACHE_SHIFT;\n\t}\nout:\n\tif (pages)\n\t\tocfs2_unlock_and_free_pages(pages, numpages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_grab_eof_pages",
          "args": [
            "inode",
            "range_start",
            "range_end",
            "pages",
            "&numpages"
          ],
          "line": 6765
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_grab_eof_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6703-6712",
          "snippet": "static int ocfs2_grab_eof_pages(struct inode *inode, loff_t start, loff_t end,\n\t\t\t\tstruct page **pages, int *num)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(start >> OCFS2_SB(sb)->s_clustersize_bits !=\n\t       (end - 1) >> OCFS2_SB(sb)->s_clustersize_bits);\n\n\treturn ocfs2_grab_pages(inode, start, end, pages, num);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_grab_eof_pages(struct inode *inode, loff_t start, loff_t end,\n\t\t\t\tstruct page **pages, int *num)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(start >> OCFS2_SB(sb)->s_clustersize_bits !=\n\t       (end - 1) >> OCFS2_SB(sb)->s_clustersize_bits);\n\n\treturn ocfs2_grab_pages(inode, start, end, pages, num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_map_get_blocks",
          "args": [
            "inode",
            "range_start >> sb->s_blocksize_bits",
            "&phys",
            "NULL",
            "&ext_flags"
          ],
          "line": 6750
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_map_get_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "671-705",
          "snippet": "int ocfs2_extent_map_get_blocks(struct inode *inode, u64 v_blkno, u64 *p_blkno,\n\t\t\t\tu64 *ret_count, unsigned int *extent_flags)\n{\n\tint ret;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 cpos, num_clusters, p_cluster;\n\tu64 boff = 0;\n\n\tcpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);\n\n\tret = ocfs2_get_clusters(inode, cpos, &p_cluster, &num_clusters,\n\t\t\t\t extent_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * p_cluster == 0 indicates a hole.\n\t */\n\tif (p_cluster) {\n\t\tboff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\tboff += (v_blkno & (u64)(bpc - 1));\n\t}\n\n\t*p_blkno = boff;\n\n\tif (ret_count) {\n\t\t*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\t*ret_count -= v_blkno & (u64)(bpc - 1);\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_extent_map_get_blocks(struct inode *inode, u64 v_blkno, u64 *p_blkno,\n\t\t\t\tu64 *ret_count, unsigned int *extent_flags)\n{\n\tint ret;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 cpos, num_clusters, p_cluster;\n\tu64 boff = 0;\n\n\tcpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);\n\n\tret = ocfs2_get_clusters(inode, cpos, &p_cluster, &num_clusters,\n\t\t\t\t extent_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * p_cluster == 0 indicates a hole.\n\t */\n\tif (p_cluster) {\n\t\tboff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\tboff += (v_blkno & (u64)(bpc - 1));\n\t}\n\n\t*p_blkno = boff;\n\n\tif (ret_count) {\n\t\t*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\t*ret_count -= v_blkno & (u64)(bpc - 1);\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "ocfs2_pages_per_cluster(sb)",
            "sizeof(struct page *)",
            "GFP_NOFS"
          ],
          "line": 6739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_pages_per_cluster",
          "args": [
            "sb"
          ],
          "line": 6739
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_pages_per_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "831-840",
          "snippet": "static inline unsigned int ocfs2_pages_per_cluster(struct super_block *sb)\n{\n\tunsigned int cbits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int pages_per_cluster = 1;\n\n\tif (PAGE_CACHE_SHIFT < cbits)\n\t\tpages_per_cluster = 1 << (cbits - PAGE_CACHE_SHIFT);\n\n\treturn pages_per_cluster;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_pages_per_cluster(struct super_block *sb)\n{\n\tunsigned int cbits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int pages_per_cluster = 1;\n\n\tif (PAGE_CACHE_SHIFT < cbits)\n\t\tpages_per_cluster = 1 << (cbits - PAGE_CACHE_SHIFT);\n\n\treturn pages_per_cluster;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_sparse_alloc",
          "args": [
            "OCFS2_SB(sb)"
          ],
          "line": 6736
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sparse_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "483-488",
          "snippet": "static inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 6736
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_zero_range_for_truncate(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 range_start, u64 range_end)\n{\n\tint ret = 0, numpages;\n\tstruct page **pages = NULL;\n\tu64 phys;\n\tunsigned int ext_flags;\n\tstruct super_block *sb = inode->i_sb;\n\n\t/*\n\t * File systems which don't support sparse files zero on every\n\t * extend.\n\t */\n\tif (!ocfs2_sparse_alloc(OCFS2_SB(sb)))\n\t\treturn 0;\n\n\tpages = kcalloc(ocfs2_pages_per_cluster(sb),\n\t\t\tsizeof(struct page *), GFP_NOFS);\n\tif (pages == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (range_start == range_end)\n\t\tgoto out;\n\n\tret = ocfs2_extent_map_get_blocks(inode,\n\t\t\t\t\t  range_start >> sb->s_blocksize_bits,\n\t\t\t\t\t  &phys, NULL, &ext_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Tail is a hole, or is marked unwritten. In either case, we\n\t * can count on read and write to return/push zero's.\n\t */\n\tif (phys == 0 || ext_flags & OCFS2_EXT_UNWRITTEN)\n\t\tgoto out;\n\n\tret = ocfs2_grab_eof_pages(inode, range_start, range_end, pages,\n\t\t\t\t   &numpages);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_zero_cluster_pages(inode, range_start, range_end, pages,\n\t\t\t\t numpages, phys, handle);\n\n\t/*\n\t * Initiate writeout of the pages we zero'd here. We don't\n\t * wait on them - the truncate_inode_pages() call later will\n\t * do that for us.\n\t */\n\tret = filemap_fdatawrite_range(inode->i_mapping, range_start,\n\t\t\t\t       range_end - 1);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tkfree(pages);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_grab_eof_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "6703-6712",
    "snippet": "static int ocfs2_grab_eof_pages(struct inode *inode, loff_t start, loff_t end,\n\t\t\t\tstruct page **pages, int *num)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(start >> OCFS2_SB(sb)->s_clustersize_bits !=\n\t       (end - 1) >> OCFS2_SB(sb)->s_clustersize_bits);\n\n\treturn ocfs2_grab_pages(inode, start, end, pages, num);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_grab_pages",
          "args": [
            "inode",
            "start",
            "end",
            "pages",
            "num"
          ],
          "line": 6711
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_grab_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6666-6701",
          "snippet": "int ocfs2_grab_pages(struct inode *inode, loff_t start, loff_t end,\n\t\t     struct page **pages, int *num)\n{\n\tint numpages, ret = 0;\n\tstruct address_space *mapping = inode->i_mapping;\n\tunsigned long index;\n\tloff_t last_page_bytes;\n\n\tBUG_ON(start > end);\n\n\tnumpages = 0;\n\tlast_page_bytes = PAGE_ALIGN(end);\n\tindex = start >> PAGE_CACHE_SHIFT;\n\tdo {\n\t\tpages[numpages] = find_or_create_page(mapping, index, GFP_NOFS);\n\t\tif (!pages[numpages]) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tnumpages++;\n\t\tindex++;\n\t} while (index < (last_page_bytes >> PAGE_CACHE_SHIFT));\n\nout:\n\tif (ret != 0) {\n\t\tif (pages)\n\t\t\tocfs2_unlock_and_free_pages(pages, numpages);\n\t\tnumpages = 0;\n\t}\n\n\t*num = numpages;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_grab_pages(struct inode *inode, loff_t start, loff_t end,\n\t\t     struct page **pages, int *num)\n{\n\tint numpages, ret = 0;\n\tstruct address_space *mapping = inode->i_mapping;\n\tunsigned long index;\n\tloff_t last_page_bytes;\n\n\tBUG_ON(start > end);\n\n\tnumpages = 0;\n\tlast_page_bytes = PAGE_ALIGN(end);\n\tindex = start >> PAGE_CACHE_SHIFT;\n\tdo {\n\t\tpages[numpages] = find_or_create_page(mapping, index, GFP_NOFS);\n\t\tif (!pages[numpages]) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tnumpages++;\n\t\tindex++;\n\t} while (index < (last_page_bytes >> PAGE_CACHE_SHIFT));\n\nout:\n\tif (ret != 0) {\n\t\tif (pages)\n\t\t\tocfs2_unlock_and_free_pages(pages, numpages);\n\t\tnumpages = 0;\n\t}\n\n\t*num = numpages;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "start >> OCFS2_SB(sb)->s_clustersize_bits !=\n\t       (end - 1) >> OCFS2_SB(sb)->s_clustersize_bits"
          ],
          "line": 6708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 6709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 6708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_grab_eof_pages(struct inode *inode, loff_t start, loff_t end,\n\t\t\t\tstruct page **pages, int *num)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(start >> OCFS2_SB(sb)->s_clustersize_bits !=\n\t       (end - 1) >> OCFS2_SB(sb)->s_clustersize_bits);\n\n\treturn ocfs2_grab_pages(inode, start, end, pages, num);\n}"
  },
  {
    "function_name": "ocfs2_grab_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "6666-6701",
    "snippet": "int ocfs2_grab_pages(struct inode *inode, loff_t start, loff_t end,\n\t\t     struct page **pages, int *num)\n{\n\tint numpages, ret = 0;\n\tstruct address_space *mapping = inode->i_mapping;\n\tunsigned long index;\n\tloff_t last_page_bytes;\n\n\tBUG_ON(start > end);\n\n\tnumpages = 0;\n\tlast_page_bytes = PAGE_ALIGN(end);\n\tindex = start >> PAGE_CACHE_SHIFT;\n\tdo {\n\t\tpages[numpages] = find_or_create_page(mapping, index, GFP_NOFS);\n\t\tif (!pages[numpages]) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tnumpages++;\n\t\tindex++;\n\t} while (index < (last_page_bytes >> PAGE_CACHE_SHIFT));\n\nout:\n\tif (ret != 0) {\n\t\tif (pages)\n\t\t\tocfs2_unlock_and_free_pages(pages, numpages);\n\t\tnumpages = 0;\n\t}\n\n\t*num = numpages;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_unlock_and_free_pages",
          "args": [
            "pages",
            "numpages"
          ],
          "line": 6694
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_and_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1114-1125",
          "snippet": "void ocfs2_unlock_and_free_pages(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor(i = 0; i < num_pages; i++) {\n\t\tif (pages[i]) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tmark_page_accessed(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid ocfs2_unlock_and_free_pages(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor(i = 0; i < num_pages; i++) {\n\t\tif (pages[i]) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tmark_page_accessed(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "mapping",
            "index",
            "GFP_NOFS"
          ],
          "line": 6680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "end"
          ],
          "line": 6677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "start > end"
          ],
          "line": 6674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_grab_pages(struct inode *inode, loff_t start, loff_t end,\n\t\t     struct page **pages, int *num)\n{\n\tint numpages, ret = 0;\n\tstruct address_space *mapping = inode->i_mapping;\n\tunsigned long index;\n\tloff_t last_page_bytes;\n\n\tBUG_ON(start > end);\n\n\tnumpages = 0;\n\tlast_page_bytes = PAGE_ALIGN(end);\n\tindex = start >> PAGE_CACHE_SHIFT;\n\tdo {\n\t\tpages[numpages] = find_or_create_page(mapping, index, GFP_NOFS);\n\t\tif (!pages[numpages]) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tnumpages++;\n\t\tindex++;\n\t} while (index < (last_page_bytes >> PAGE_CACHE_SHIFT));\n\nout:\n\tif (ret != 0) {\n\t\tif (pages)\n\t\t\tocfs2_unlock_and_free_pages(pages, numpages);\n\t\tnumpages = 0;\n\t}\n\n\t*num = numpages;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_zero_cluster_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "6631-6664",
    "snippet": "static void ocfs2_zero_cluster_pages(struct inode *inode, loff_t start,\n\t\t\t\t     loff_t end, struct page **pages,\n\t\t\t\t     int numpages, u64 phys, handle_t *handle)\n{\n\tint i;\n\tstruct page *page;\n\tunsigned int from, to = PAGE_CACHE_SIZE;\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(!ocfs2_sparse_alloc(OCFS2_SB(sb)));\n\n\tif (numpages == 0)\n\t\tgoto out;\n\n\tto = PAGE_CACHE_SIZE;\n\tfor(i = 0; i < numpages; i++) {\n\t\tpage = pages[i];\n\n\t\tfrom = start & (PAGE_CACHE_SIZE - 1);\n\t\tif ((end >> PAGE_CACHE_SHIFT) == page->index)\n\t\t\tto = end & (PAGE_CACHE_SIZE - 1);\n\n\t\tBUG_ON(from > PAGE_CACHE_SIZE);\n\t\tBUG_ON(to > PAGE_CACHE_SIZE);\n\n\t\tocfs2_map_and_dirty_page(inode, handle, from, to, page, 1,\n\t\t\t\t\t &phys);\n\n\t\tstart = (page->index + 1) << PAGE_CACHE_SHIFT;\n\t}\nout:\n\tif (pages)\n\t\tocfs2_unlock_and_free_pages(pages, numpages);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_unlock_and_free_pages",
          "args": [
            "pages",
            "numpages"
          ],
          "line": 6663
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_and_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1114-1125",
          "snippet": "void ocfs2_unlock_and_free_pages(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor(i = 0; i < num_pages; i++) {\n\t\tif (pages[i]) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tmark_page_accessed(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid ocfs2_unlock_and_free_pages(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor(i = 0; i < num_pages; i++) {\n\t\tif (pages[i]) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tmark_page_accessed(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_map_and_dirty_page",
          "args": [
            "inode",
            "handle",
            "from",
            "to",
            "page",
            "1",
            "&phys"
          ],
          "line": 6656
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_map_and_dirty_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6596-6629",
          "snippet": "void ocfs2_map_and_dirty_page(struct inode *inode, handle_t *handle,\n\t\t\t      unsigned int from, unsigned int to,\n\t\t\t      struct page *page, int zero, u64 *phys)\n{\n\tint ret, partial = 0;\n\n\tret = ocfs2_map_page_blocks(page, phys, inode, from, to, 0);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (zero)\n\t\tzero_user_segment(page, from, to);\n\n\t/*\n\t * Need to set the buffers we zero'd into uptodate\n\t * here if they aren't - ocfs2_map_page_blocks()\n\t * might've skipped some\n\t */\n\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\tfrom, to, &partial,\n\t\t\t\tocfs2_zero_func);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\telse if (ocfs2_should_order_data(inode)) {\n\t\tret = ocfs2_jbd2_file_inode(handle, inode);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t}\n\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\n\tflush_dcache_page(page);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_map_and_dirty_page(struct inode *inode, handle_t *handle,\n\t\t\t      unsigned int from, unsigned int to,\n\t\t\t      struct page *page, int zero, u64 *phys)\n{\n\tint ret, partial = 0;\n\n\tret = ocfs2_map_page_blocks(page, phys, inode, from, to, 0);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (zero)\n\t\tzero_user_segment(page, from, to);\n\n\t/*\n\t * Need to set the buffers we zero'd into uptodate\n\t * here if they aren't - ocfs2_map_page_blocks()\n\t * might've skipped some\n\t */\n\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\tfrom, to, &partial,\n\t\t\t\tocfs2_zero_func);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\telse if (ocfs2_should_order_data(inode)) {\n\t\tret = ocfs2_jbd2_file_inode(handle, inode);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t}\n\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\n\tflush_dcache_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "to > PAGE_CACHE_SIZE"
          ],
          "line": 6654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "from > PAGE_CACHE_SIZE"
          ],
          "line": 6653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ocfs2_sparse_alloc(OCFS2_SB(sb))"
          ],
          "line": 6640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_sparse_alloc",
          "args": [
            "OCFS2_SB(sb)"
          ],
          "line": 6640
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sparse_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "483-488",
          "snippet": "static inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 6640
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_zero_cluster_pages(struct inode *inode, loff_t start,\n\t\t\t\t     loff_t end, struct page **pages,\n\t\t\t\t     int numpages, u64 phys, handle_t *handle)\n{\n\tint i;\n\tstruct page *page;\n\tunsigned int from, to = PAGE_CACHE_SIZE;\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(!ocfs2_sparse_alloc(OCFS2_SB(sb)));\n\n\tif (numpages == 0)\n\t\tgoto out;\n\n\tto = PAGE_CACHE_SIZE;\n\tfor(i = 0; i < numpages; i++) {\n\t\tpage = pages[i];\n\n\t\tfrom = start & (PAGE_CACHE_SIZE - 1);\n\t\tif ((end >> PAGE_CACHE_SHIFT) == page->index)\n\t\t\tto = end & (PAGE_CACHE_SIZE - 1);\n\n\t\tBUG_ON(from > PAGE_CACHE_SIZE);\n\t\tBUG_ON(to > PAGE_CACHE_SIZE);\n\n\t\tocfs2_map_and_dirty_page(inode, handle, from, to, page, 1,\n\t\t\t\t\t &phys);\n\n\t\tstart = (page->index + 1) << PAGE_CACHE_SHIFT;\n\t}\nout:\n\tif (pages)\n\t\tocfs2_unlock_and_free_pages(pages, numpages);\n}"
  },
  {
    "function_name": "ocfs2_map_and_dirty_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "6596-6629",
    "snippet": "void ocfs2_map_and_dirty_page(struct inode *inode, handle_t *handle,\n\t\t\t      unsigned int from, unsigned int to,\n\t\t\t      struct page *page, int zero, u64 *phys)\n{\n\tint ret, partial = 0;\n\n\tret = ocfs2_map_page_blocks(page, phys, inode, from, to, 0);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (zero)\n\t\tzero_user_segment(page, from, to);\n\n\t/*\n\t * Need to set the buffers we zero'd into uptodate\n\t * here if they aren't - ocfs2_map_page_blocks()\n\t * might've skipped some\n\t */\n\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\tfrom, to, &partial,\n\t\t\t\tocfs2_zero_func);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\telse if (ocfs2_should_order_data(inode)) {\n\t\tret = ocfs2_jbd2_file_inode(handle, inode);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t}\n\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\n\tflush_dcache_page(page);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 6628
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 6626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_jbd2_file_inode",
          "args": [
            "handle",
            "inode"
          ],
          "line": 6620
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_jbd2_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "620-623",
          "snippet": "static inline int ocfs2_jbd2_file_inode(handle_t *handle, struct inode *inode)\n{\n\treturn jbd2_journal_file_inode(handle, &OCFS2_I(inode)->ip_jinode);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ocfs2_jbd2_file_inode(handle_t *handle, struct inode *inode)\n{\n\treturn jbd2_journal_file_inode(handle, &OCFS2_I(inode)->ip_jinode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_should_order_data",
          "args": [
            "inode"
          ],
          "line": 6619
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_should_order_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "474-481",
          "snippet": "static inline int ocfs2_should_order_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (OCFS2_SB(inode->i_sb)->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_should_order_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (OCFS2_SB(inode->i_sb)->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_page_buffers",
          "args": [
            "handle",
            "page_buffers(page)",
            "from",
            "to",
            "&partial",
            "ocfs2_zero_func"
          ],
          "line": 6614
        },
        "resolved": true,
        "details": {
          "function_name": "walk_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "424-454",
          "snippet": "int walk_page_buffers(\thandle_t *handle,\n\t\t\tstruct buffer_head *head,\n\t\t\tunsigned from,\n\t\t\tunsigned to,\n\t\t\tint *partial,\n\t\t\tint (*fn)(\thandle_t *handle,\n\t\t\t\t\tstruct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (\tbh = head, block_start = 0;\n\t\tret == 0 && (bh != head || !block_start);\n\t    \tblock_start = block_end, bh = next)\n\t{\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint walk_page_buffers(\thandle_t *handle,\n\t\t\tstruct buffer_head *head,\n\t\t\tunsigned from,\n\t\t\tunsigned to,\n\t\t\tint *partial,\n\t\t\tint (*fn)(\thandle_t *handle,\n\t\t\t\t\tstruct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (\tbh = head, block_start = 0;\n\t\tret == 0 && (bh != head || !block_start);\n\t    \tblock_start = block_end, bh = next)\n\t{\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 6614
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "from",
            "to"
          ],
          "line": 6607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_map_page_blocks",
          "args": [
            "page",
            "phys",
            "inode",
            "from",
            "to",
            "0"
          ],
          "line": 6602
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_map_page_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "941-1031",
          "snippet": "int ocfs2_map_page_blocks(struct page *page, u64 *p_blkno,\n\t\t\t  struct inode *inode, unsigned int from,\n\t\t\t  unsigned int to, int new)\n{\n\tint ret = 0;\n\tstruct buffer_head *head, *bh, *wait[2], **wait_bh = wait;\n\tunsigned int block_end, block_start;\n\tunsigned int bsize = 1 << inode->i_blkbits;\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, bsize, 0);\n\n\thead = page_buffers(page);\n\tfor (bh = head, block_start = 0; bh != head || !block_start;\n\t     bh = bh->b_this_page, block_start += bsize) {\n\t\tblock_end = block_start + bsize;\n\n\t\tclear_buffer_new(bh);\n\n\t\t/*\n\t\t * Ignore blocks outside of our i/o range -\n\t\t * they may belong to unallocated clusters.\n\t\t */\n\t\tif (block_start >= to || block_end <= from) {\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * For an allocating write with cluster size >= page\n\t\t * size, we always write the entire page.\n\t\t */\n\t\tif (new)\n\t\t\tset_buffer_new(bh);\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tmap_bh(bh, inode->i_sb, *p_blkno);\n\t\t\tunmap_underlying_metadata(bh->b_bdev, bh->b_blocknr);\n\t\t}\n\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t} else if (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t\t   !buffer_new(bh) &&\n\t\t\t   ocfs2_should_read_blk(inode, page, block_start) &&\n\t\t\t   (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\n\t\t*p_blkno = *p_blkno + 1;\n\t}\n\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\tret = -EIO;\n\t}\n\n\tif (ret == 0 || !new)\n\t\treturn ret;\n\n\t/*\n\t * If we get -EIO above, zero out any newly allocated blocks\n\t * to avoid exposing stale data.\n\t */\n\tbh = head;\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bsize;\n\t\tif (block_end <= from)\n\t\t\tgoto next_bh;\n\t\tif (block_start >= to)\n\t\t\tbreak;\n\n\t\tzero_user(page, block_start, bh->b_size);\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\nnext_bh:\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ocfs2_map_page_blocks(struct page *page, u64 *p_blkno,\n\t\t\t  struct inode *inode, unsigned int from,\n\t\t\t  unsigned int to, int new)\n{\n\tint ret = 0;\n\tstruct buffer_head *head, *bh, *wait[2], **wait_bh = wait;\n\tunsigned int block_end, block_start;\n\tunsigned int bsize = 1 << inode->i_blkbits;\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, bsize, 0);\n\n\thead = page_buffers(page);\n\tfor (bh = head, block_start = 0; bh != head || !block_start;\n\t     bh = bh->b_this_page, block_start += bsize) {\n\t\tblock_end = block_start + bsize;\n\n\t\tclear_buffer_new(bh);\n\n\t\t/*\n\t\t * Ignore blocks outside of our i/o range -\n\t\t * they may belong to unallocated clusters.\n\t\t */\n\t\tif (block_start >= to || block_end <= from) {\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * For an allocating write with cluster size >= page\n\t\t * size, we always write the entire page.\n\t\t */\n\t\tif (new)\n\t\t\tset_buffer_new(bh);\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tmap_bh(bh, inode->i_sb, *p_blkno);\n\t\t\tunmap_underlying_metadata(bh->b_bdev, bh->b_blocknr);\n\t\t}\n\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t} else if (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t\t   !buffer_new(bh) &&\n\t\t\t   ocfs2_should_read_blk(inode, page, block_start) &&\n\t\t\t   (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\n\t\t*p_blkno = *p_blkno + 1;\n\t}\n\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\tret = -EIO;\n\t}\n\n\tif (ret == 0 || !new)\n\t\treturn ret;\n\n\t/*\n\t * If we get -EIO above, zero out any newly allocated blocks\n\t * to avoid exposing stale data.\n\t */\n\tbh = head;\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bsize;\n\t\tif (block_end <= from)\n\t\t\tgoto next_bh;\n\t\tif (block_start >= to)\n\t\t\tbreak;\n\n\t\tzero_user(page, block_start, bh->b_size);\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\nnext_bh:\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_map_and_dirty_page(struct inode *inode, handle_t *handle,\n\t\t\t      unsigned int from, unsigned int to,\n\t\t\t      struct page *page, int zero, u64 *phys)\n{\n\tint ret, partial = 0;\n\n\tret = ocfs2_map_page_blocks(page, phys, inode, from, to, 0);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (zero)\n\t\tzero_user_segment(page, from, to);\n\n\t/*\n\t * Need to set the buffers we zero'd into uptodate\n\t * here if they aren't - ocfs2_map_page_blocks()\n\t * might've skipped some\n\t */\n\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\tfrom, to, &partial,\n\t\t\t\tocfs2_zero_func);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\telse if (ocfs2_should_order_data(inode)) {\n\t\tret = ocfs2_jbd2_file_inode(handle, inode);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t}\n\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\n\tflush_dcache_page(page);\n}"
  },
  {
    "function_name": "ocfs2_zero_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "6589-6594",
    "snippet": "static int ocfs2_zero_func(handle_t *handle, struct buffer_head *bh)\n{\n\tset_buffer_uptodate(bh);\n\tmark_buffer_dirty(bh);\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 6592
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 6591
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_zero_func(handle_t *handle, struct buffer_head *bh)\n{\n\tset_buffer_uptodate(bh);\n\tmark_buffer_dirty(bh);\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_cache_extent_block_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "6579-6587",
    "snippet": "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb)\n{\n\treturn ocfs2_cache_block_dealloc(ctxt, EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t le16_to_cpu(eb->h_suballoc_slot),\n\t\t\t\t\t le64_to_cpu(eb->h_suballoc_loc),\n\t\t\t\t\t le64_to_cpu(eb->h_blkno),\n\t\t\t\t\t le16_to_cpu(eb->h_suballoc_bit));\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_cache_block_dealloc",
          "args": [
            "ctxt",
            "EXTENT_ALLOC_SYSTEM_INODE",
            "le16_to_cpu(eb->h_suballoc_slot)",
            "le64_to_cpu(eb->h_suballoc_loc)",
            "le64_to_cpu(eb->h_blkno)",
            "le16_to_cpu(eb->h_suballoc_bit)"
          ],
          "line": 6582
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cache_block_dealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6541-6577",
          "snippet": "int ocfs2_cache_block_dealloc(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t      int type, int slot, u64 suballoc,\n\t\t\t      u64 blkno, unsigned int bit)\n{\n\tint ret;\n\tstruct ocfs2_per_slot_free_list *fl;\n\tstruct ocfs2_cached_block_free *item;\n\n\tfl = ocfs2_find_per_slot_free_list(type, slot, ctxt);\n\tif (fl == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\titem = kzalloc(sizeof(*item), GFP_NOFS);\n\tif (item == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_cache_block_dealloc(type, slot,\n\t\t\t\t\t(unsigned long long)suballoc,\n\t\t\t\t\t(unsigned long long)blkno, bit);\n\n\titem->free_bg = suballoc;\n\titem->free_blk = blkno;\n\titem->free_bit = bit;\n\titem->free_next = fl->f_first;\n\n\tfl->f_first = item;\n\n\tret = 0;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_cache_block_dealloc(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t      int type, int slot, u64 suballoc,\n\t\t\t      u64 blkno, unsigned int bit)\n{\n\tint ret;\n\tstruct ocfs2_per_slot_free_list *fl;\n\tstruct ocfs2_cached_block_free *item;\n\n\tfl = ocfs2_find_per_slot_free_list(type, slot, ctxt);\n\tif (fl == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\titem = kzalloc(sizeof(*item), GFP_NOFS);\n\tif (item == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_cache_block_dealloc(type, slot,\n\t\t\t\t\t(unsigned long long)suballoc,\n\t\t\t\t\t(unsigned long long)blkno, bit);\n\n\titem->free_bg = suballoc;\n\titem->free_blk = blkno;\n\titem->free_bit = bit;\n\titem->free_next = fl->f_first;\n\n\tfl->f_first = item;\n\n\tret = 0;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "eb->h_suballoc_bit"
          ],
          "line": 6586
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "eb->h_blkno"
          ],
          "line": 6585
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb)\n{\n\treturn ocfs2_cache_block_dealloc(ctxt, EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t le16_to_cpu(eb->h_suballoc_slot),\n\t\t\t\t\t le64_to_cpu(eb->h_suballoc_loc),\n\t\t\t\t\t le64_to_cpu(eb->h_blkno),\n\t\t\t\t\t le16_to_cpu(eb->h_suballoc_bit));\n}"
  },
  {
    "function_name": "ocfs2_cache_block_dealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "6541-6577",
    "snippet": "int ocfs2_cache_block_dealloc(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t      int type, int slot, u64 suballoc,\n\t\t\t      u64 blkno, unsigned int bit)\n{\n\tint ret;\n\tstruct ocfs2_per_slot_free_list *fl;\n\tstruct ocfs2_cached_block_free *item;\n\n\tfl = ocfs2_find_per_slot_free_list(type, slot, ctxt);\n\tif (fl == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\titem = kzalloc(sizeof(*item), GFP_NOFS);\n\tif (item == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_cache_block_dealloc(type, slot,\n\t\t\t\t\t(unsigned long long)suballoc,\n\t\t\t\t\t(unsigned long long)blkno, bit);\n\n\titem->free_bg = suballoc;\n\titem->free_blk = blkno;\n\titem->free_bit = bit;\n\titem->free_next = fl->f_first;\n\n\tfl->f_first = item;\n\n\tret = 0;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ocfs2_cache_block_dealloc",
          "args": [
            "type",
            "slot",
            "(unsigned long long)suballoc",
            "(unsigned long long)blkno",
            "bit"
          ],
          "line": 6563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*item)",
            "GFP_NOFS"
          ],
          "line": 6556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_per_slot_free_list",
          "args": [
            "type",
            "slot",
            "ctxt"
          ],
          "line": 6549
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_per_slot_free_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6515-6539",
          "snippet": "static struct ocfs2_per_slot_free_list *\nocfs2_find_per_slot_free_list(int type,\n\t\t\t      int slot,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tstruct ocfs2_per_slot_free_list *fl = ctxt->c_first_suballocator;\n\n\twhile (fl) {\n\t\tif (fl->f_inode_type == type && fl->f_slot == slot)\n\t\t\treturn fl;\n\n\t\tfl = fl->f_next_suballocator;\n\t}\n\n\tfl = kmalloc(sizeof(*fl), GFP_NOFS);\n\tif (fl) {\n\t\tfl->f_inode_type = type;\n\t\tfl->f_slot = slot;\n\t\tfl->f_first = NULL;\n\t\tfl->f_next_suballocator = ctxt->c_first_suballocator;\n\n\t\tctxt->c_first_suballocator = fl;\n\t}\n\treturn fl;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_per_slot_free_list *\nocfs2_find_per_slot_free_list(int type,\n\t\t\t      int slot,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tstruct ocfs2_per_slot_free_list *fl = ctxt->c_first_suballocator;\n\n\twhile (fl) {\n\t\tif (fl->f_inode_type == type && fl->f_slot == slot)\n\t\t\treturn fl;\n\n\t\tfl = fl->f_next_suballocator;\n\t}\n\n\tfl = kmalloc(sizeof(*fl), GFP_NOFS);\n\tif (fl) {\n\t\tfl->f_inode_type = type;\n\t\tfl->f_slot = slot;\n\t\tfl->f_first = NULL;\n\t\tfl->f_next_suballocator = ctxt->c_first_suballocator;\n\n\t\tctxt->c_first_suballocator = fl;\n\t}\n\treturn fl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_cache_block_dealloc(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t      int type, int slot, u64 suballoc,\n\t\t\t      u64 blkno, unsigned int bit)\n{\n\tint ret;\n\tstruct ocfs2_per_slot_free_list *fl;\n\tstruct ocfs2_cached_block_free *item;\n\n\tfl = ocfs2_find_per_slot_free_list(type, slot, ctxt);\n\tif (fl == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\titem = kzalloc(sizeof(*item), GFP_NOFS);\n\tif (item == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_cache_block_dealloc(type, slot,\n\t\t\t\t\t(unsigned long long)suballoc,\n\t\t\t\t\t(unsigned long long)blkno, bit);\n\n\titem->free_bg = suballoc;\n\titem->free_blk = blkno;\n\titem->free_bit = bit;\n\titem->free_next = fl->f_first;\n\n\tfl->f_first = item;\n\n\tret = 0;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_find_per_slot_free_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "6515-6539",
    "snippet": "static struct ocfs2_per_slot_free_list *\nocfs2_find_per_slot_free_list(int type,\n\t\t\t      int slot,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tstruct ocfs2_per_slot_free_list *fl = ctxt->c_first_suballocator;\n\n\twhile (fl) {\n\t\tif (fl->f_inode_type == type && fl->f_slot == slot)\n\t\t\treturn fl;\n\n\t\tfl = fl->f_next_suballocator;\n\t}\n\n\tfl = kmalloc(sizeof(*fl), GFP_NOFS);\n\tif (fl) {\n\t\tfl->f_inode_type = type;\n\t\tfl->f_slot = slot;\n\t\tfl->f_first = NULL;\n\t\tfl->f_next_suballocator = ctxt->c_first_suballocator;\n\n\t\tctxt->c_first_suballocator = fl;\n\t}\n\treturn fl;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*fl)",
            "GFP_NOFS"
          ],
          "line": 6529
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_per_slot_free_list *\nocfs2_find_per_slot_free_list(int type,\n\t\t\t      int slot,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tstruct ocfs2_per_slot_free_list *fl = ctxt->c_first_suballocator;\n\n\twhile (fl) {\n\t\tif (fl->f_inode_type == type && fl->f_slot == slot)\n\t\t\treturn fl;\n\n\t\tfl = fl->f_next_suballocator;\n\t}\n\n\tfl = kmalloc(sizeof(*fl), GFP_NOFS);\n\tif (fl) {\n\t\tfl->f_inode_type = type;\n\t\tfl->f_slot = slot;\n\t\tfl->f_first = NULL;\n\t\tfl->f_next_suballocator = ctxt->c_first_suballocator;\n\n\t\tctxt->c_first_suballocator = fl;\n\t}\n\treturn fl;\n}"
  },
  {
    "function_name": "ocfs2_run_deallocs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "6472-6513",
    "snippet": "int ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret2"
          ],
          "line": 6505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_cached_clusters",
          "args": [
            "osb",
            "ctxt->c_global_allocator"
          ],
          "line": 6502
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_cached_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6420-6470",
          "snippet": "static int ocfs2_free_cached_clusters(struct ocfs2_super *osb,\n\t\t\t\t      struct ocfs2_cached_block_free *head)\n{\n\tstruct ocfs2_cached_block_free *tmp;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\thandle_t *handle;\n\tint ret = 0;\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\twhile (head) {\n\t\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_truncate_log_append(osb, handle, head->free_blk,\n\t\t\t\t\t\thead->free_bit);\n\n\t\tocfs2_commit_trans(osb, handle);\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\twhile (head) {\n\t\t/* Premature exit may have left some dangling items. */\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_free_cached_clusters(struct ocfs2_super *osb,\n\t\t\t\t      struct ocfs2_cached_block_free *head)\n{\n\tstruct ocfs2_cached_block_free *tmp;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\thandle_t *handle;\n\tint ret = 0;\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\twhile (head) {\n\t\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_truncate_log_append(osb, handle, head->free_blk,\n\t\t\t\t\t\thead->free_bit);\n\n\t\tocfs2_commit_trans(osb, handle);\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\twhile (head) {\n\t\t/* Premature exit may have left some dangling items. */\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fl"
          ],
          "line": 6498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret2"
          ],
          "line": 6492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_cached_blocks",
          "args": [
            "osb",
            "fl->f_inode_type",
            "fl->f_slot",
            "fl->f_first"
          ],
          "line": 6487
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_cached_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6316-6395",
          "snippet": "static int ocfs2_free_cached_blocks(struct ocfs2_super *osb,\n\t\t\t\t    int sysfile_type,\n\t\t\t\t    int slot,\n\t\t\t\t    struct ocfs2_cached_block_free *head)\n{\n\tint ret;\n\tu64 bg_blkno;\n\thandle_t *handle;\n\tstruct inode *inode;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_cached_block_free *tmp;\n\n\tinode = ocfs2_get_system_file_inode(osb, sysfile_type, slot);\n\tif (!inode) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_SUBALLOC_FREE);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\twhile (head) {\n\t\tif (head->free_bg)\n\t\t\tbg_blkno = head->free_bg;\n\t\telse\n\t\t\tbg_blkno = ocfs2_which_suballoc_group(head->free_blk,\n\t\t\t\t\t\t\t      head->free_bit);\n\t\ttrace_ocfs2_free_cached_blocks(\n\t\t     (unsigned long long)head->free_blk, head->free_bit);\n\n\t\tret = ocfs2_free_suballoc_bits(handle, inode, di_bh,\n\t\t\t\t\t       head->free_bit, bg_blkno, 1);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_journal;\n\t\t}\n\n\t\tret = ocfs2_extend_trans(handle, OCFS2_SUBALLOC_FREE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_journal;\n\t\t}\n\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\t}\n\nout_journal:\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\nout_mutex:\n\tmutex_unlock(&inode->i_mutex);\n\tiput(inode);\nout:\n\twhile(head) {\n\t\t/* Premature exit may have left some dangling items. */\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_free_cached_blocks(struct ocfs2_super *osb,\n\t\t\t\t    int sysfile_type,\n\t\t\t\t    int slot,\n\t\t\t\t    struct ocfs2_cached_block_free *head)\n{\n\tint ret;\n\tu64 bg_blkno;\n\thandle_t *handle;\n\tstruct inode *inode;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_cached_block_free *tmp;\n\n\tinode = ocfs2_get_system_file_inode(osb, sysfile_type, slot);\n\tif (!inode) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_SUBALLOC_FREE);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\twhile (head) {\n\t\tif (head->free_bg)\n\t\t\tbg_blkno = head->free_bg;\n\t\telse\n\t\t\tbg_blkno = ocfs2_which_suballoc_group(head->free_blk,\n\t\t\t\t\t\t\t      head->free_bit);\n\t\ttrace_ocfs2_free_cached_blocks(\n\t\t     (unsigned long long)head->free_blk, head->free_bit);\n\n\t\tret = ocfs2_free_suballoc_bits(handle, inode, di_bh,\n\t\t\t\t\t       head->free_bit, bg_blkno, 1);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_journal;\n\t\t}\n\n\t\tret = ocfs2_extend_trans(handle, OCFS2_SUBALLOC_FREE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_journal;\n\t\t}\n\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\t}\n\nout_journal:\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\nout_mutex:\n\tmutex_unlock(&inode->i_mutex);\n\tiput(inode);\nout:\n\twhile(head) {\n\t\t/* Premature exit may have left some dangling items. */\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_run_deallocs",
          "args": [
            "fl->f_inode_type",
            "fl->f_slot"
          ],
          "line": 6485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_free_cached_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "6420-6470",
    "snippet": "static int ocfs2_free_cached_clusters(struct ocfs2_super *osb,\n\t\t\t\t      struct ocfs2_cached_block_free *head)\n{\n\tstruct ocfs2_cached_block_free *tmp;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\thandle_t *handle;\n\tint ret = 0;\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\twhile (head) {\n\t\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_truncate_log_append(osb, handle, head->free_blk,\n\t\t\t\t\t\thead->free_bit);\n\n\t\tocfs2_commit_trans(osb, handle);\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\twhile (head) {\n\t\t/* Premature exit may have left some dangling items. */\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmp"
          ],
          "line": 6466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tl_inode->i_mutex"
          ],
          "line": 6460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmp"
          ],
          "line": 6452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 6449
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_log_append",
          "args": [
            "osb",
            "handle",
            "head->free_blk",
            "head->free_bit"
          ],
          "line": 6446
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_log_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5808-5882",
          "snippet": "int ocfs2_truncate_log_append(struct ocfs2_super *osb,\n\t\t\t      handle_t *handle,\n\t\t\t      u64 start_blk,\n\t\t\t      unsigned int num_clusters)\n{\n\tint status, index;\n\tunsigned int start_cluster, tl_count;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(mutex_trylock(&tl_inode->i_mutex));\n\n\tstart_cluster = ocfs2_blocks_to_clusters(osb->sb, start_blk);\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\ttl_count = le16_to_cpu(tl->tl_count);\n\tmlog_bug_on_msg(tl_count > ocfs2_truncate_recs_per_inode(osb->sb) ||\n\t\t\ttl_count == 0,\n\t\t\t\"Truncate record count on #%llu invalid \"\n\t\t\t\"wanted %u, actual %u\\n\",\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tocfs2_truncate_recs_per_inode(osb->sb),\n\t\t\tle16_to_cpu(tl->tl_count));\n\n\t/* Caller should have known to flush before calling us. */\n\tindex = le16_to_cpu(tl->tl_used);\n\tif (index >= tl_count) {\n\t\tstatus = -ENOSPC;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_truncate_log_append(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno, index,\n\t\tstart_cluster, num_clusters);\n\tif (ocfs2_truncate_log_can_coalesce(tl, start_cluster)) {\n\t\t/*\n\t\t * Move index back to the record we are coalescing with.\n\t\t * ocfs2_truncate_log_can_coalesce() guarantees nonzero\n\t\t */\n\t\tindex--;\n\n\t\tnum_clusters += le32_to_cpu(tl->tl_recs[index].t_clusters);\n\t\ttrace_ocfs2_truncate_log_append(\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tindex, le32_to_cpu(tl->tl_recs[index].t_start),\n\t\t\tnum_clusters);\n\t} else {\n\t\ttl->tl_recs[index].t_start = cpu_to_le32(start_cluster);\n\t\ttl->tl_used = cpu_to_le16(index + 1);\n\t}\n\ttl->tl_recs[index].t_clusters = cpu_to_le32(num_clusters);\n\n\tocfs2_journal_dirty(handle, tl_bh);\n\n\tosb->truncated_clusters += num_clusters;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_truncate_log_append(struct ocfs2_super *osb,\n\t\t\t      handle_t *handle,\n\t\t\t      u64 start_blk,\n\t\t\t      unsigned int num_clusters)\n{\n\tint status, index;\n\tunsigned int start_cluster, tl_count;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(mutex_trylock(&tl_inode->i_mutex));\n\n\tstart_cluster = ocfs2_blocks_to_clusters(osb->sb, start_blk);\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\ttl_count = le16_to_cpu(tl->tl_count);\n\tmlog_bug_on_msg(tl_count > ocfs2_truncate_recs_per_inode(osb->sb) ||\n\t\t\ttl_count == 0,\n\t\t\t\"Truncate record count on #%llu invalid \"\n\t\t\t\"wanted %u, actual %u\\n\",\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tocfs2_truncate_recs_per_inode(osb->sb),\n\t\t\tle16_to_cpu(tl->tl_count));\n\n\t/* Caller should have known to flush before calling us. */\n\tindex = le16_to_cpu(tl->tl_used);\n\tif (index >= tl_count) {\n\t\tstatus = -ENOSPC;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_truncate_log_append(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno, index,\n\t\tstart_cluster, num_clusters);\n\tif (ocfs2_truncate_log_can_coalesce(tl, start_cluster)) {\n\t\t/*\n\t\t * Move index back to the record we are coalescing with.\n\t\t * ocfs2_truncate_log_can_coalesce() guarantees nonzero\n\t\t */\n\t\tindex--;\n\n\t\tnum_clusters += le32_to_cpu(tl->tl_recs[index].t_clusters);\n\t\ttrace_ocfs2_truncate_log_append(\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tindex, le32_to_cpu(tl->tl_recs[index].t_start),\n\t\t\tnum_clusters);\n\t} else {\n\t\ttl->tl_recs[index].t_start = cpu_to_le32(start_cluster);\n\t\ttl->tl_used = cpu_to_le16(index + 1);\n\t}\n\ttl->tl_recs[index].t_clusters = cpu_to_le32(num_clusters);\n\n\tocfs2_journal_dirty(handle, tl_bh);\n\n\tosb->truncated_clusters += num_clusters;\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 6441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 6440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_TRUNCATE_LOG_UPDATE"
          ],
          "line": 6439
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_flush_truncate_log",
          "args": [
            "osb"
          ],
          "line": 6432
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_flush_truncate_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5956-6028",
          "snippet": "int __ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tunsigned int num_to_flush;\n\thandle_t *handle;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *data_alloc_inode = NULL;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct buffer_head *data_alloc_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(mutex_trylock(&tl_inode->i_mutex));\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tnum_to_flush = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_flush_truncate_log(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\tnum_to_flush);\n\tif (!num_to_flush) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\tdata_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!data_alloc_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get bitmap inode!\\n\");\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&data_alloc_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(data_alloc_inode, &data_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_unlock;\n\t}\n\n\tstatus = ocfs2_replay_truncate_records(osb, handle, data_alloc_inode,\n\t\t\t\t\t       data_alloc_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tbrelse(data_alloc_bh);\n\tocfs2_inode_unlock(data_alloc_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&data_alloc_inode->i_mutex);\n\tiput(data_alloc_inode);\n\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint __ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tunsigned int num_to_flush;\n\thandle_t *handle;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *data_alloc_inode = NULL;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct buffer_head *data_alloc_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(mutex_trylock(&tl_inode->i_mutex));\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tnum_to_flush = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_flush_truncate_log(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\tnum_to_flush);\n\tif (!num_to_flush) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\tdata_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!data_alloc_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get bitmap inode!\\n\");\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&data_alloc_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(data_alloc_inode, &data_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_unlock;\n\t}\n\n\tstatus = ocfs2_replay_truncate_records(osb, handle, data_alloc_inode,\n\t\t\t\t\t       data_alloc_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tbrelse(data_alloc_bh);\n\tocfs2_inode_unlock(data_alloc_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&data_alloc_inode->i_mutex);\n\tiput(data_alloc_inode);\n\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_log_needs_flush",
          "args": [
            "osb"
          ],
          "line": 6431
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_log_needs_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5775-5789",
          "snippet": "int ocfs2_truncate_log_needs_flush(struct ocfs2_super *osb)\n{\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\n\tmlog_bug_on_msg(le16_to_cpu(tl->tl_used) > le16_to_cpu(tl->tl_count),\n\t\t\t\"slot %d, invalid truncate log parameters: used = \"\n\t\t\t\"%u, count = %u\\n\", osb->slot_num,\n\t\t\tle16_to_cpu(tl->tl_used), le16_to_cpu(tl->tl_count));\n\treturn le16_to_cpu(tl->tl_used) == le16_to_cpu(tl->tl_count);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_truncate_log_needs_flush(struct ocfs2_super *osb)\n{\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\n\tmlog_bug_on_msg(le16_to_cpu(tl->tl_used) > le16_to_cpu(tl->tl_count),\n\t\t\t\"slot %d, invalid truncate log parameters: used = \"\n\t\t\t\"%u, count = %u\\n\", osb->slot_num,\n\t\t\tle16_to_cpu(tl->tl_used), le16_to_cpu(tl->tl_count));\n\treturn le16_to_cpu(tl->tl_used) == le16_to_cpu(tl->tl_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tl_inode->i_mutex"
          ],
          "line": 6428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_free_cached_clusters(struct ocfs2_super *osb,\n\t\t\t\t      struct ocfs2_cached_block_free *head)\n{\n\tstruct ocfs2_cached_block_free *tmp;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\thandle_t *handle;\n\tint ret = 0;\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\twhile (head) {\n\t\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_truncate_log_append(osb, handle, head->free_blk,\n\t\t\t\t\t\thead->free_bit);\n\n\t\tocfs2_commit_trans(osb, handle);\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\twhile (head) {\n\t\t/* Premature exit may have left some dangling items. */\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_cache_cluster_dealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "6397-6418",
    "snippet": "int ocfs2_cache_cluster_dealloc(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\tu64 blkno, unsigned int bit)\n{\n\tint ret = 0;\n\tstruct ocfs2_cached_block_free *item;\n\n\titem = kzalloc(sizeof(*item), GFP_NOFS);\n\tif (item == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\ttrace_ocfs2_cache_cluster_dealloc((unsigned long long)blkno, bit);\n\n\titem->free_blk = blkno;\n\titem->free_bit = bit;\n\titem->free_next = ctxt->c_global_allocator;\n\n\tctxt->c_global_allocator = item;\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ocfs2_cache_cluster_dealloc",
          "args": [
            "(unsigned long long)blkno",
            "bit"
          ],
          "line": 6410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*item)",
            "GFP_NOFS"
          ],
          "line": 6403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_cache_cluster_dealloc(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\tu64 blkno, unsigned int bit)\n{\n\tint ret = 0;\n\tstruct ocfs2_cached_block_free *item;\n\n\titem = kzalloc(sizeof(*item), GFP_NOFS);\n\tif (item == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\ttrace_ocfs2_cache_cluster_dealloc((unsigned long long)blkno, bit);\n\n\titem->free_blk = blkno;\n\titem->free_bit = bit;\n\titem->free_next = ctxt->c_global_allocator;\n\n\tctxt->c_global_allocator = item;\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_free_cached_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "6316-6395",
    "snippet": "static int ocfs2_free_cached_blocks(struct ocfs2_super *osb,\n\t\t\t\t    int sysfile_type,\n\t\t\t\t    int slot,\n\t\t\t\t    struct ocfs2_cached_block_free *head)\n{\n\tint ret;\n\tu64 bg_blkno;\n\thandle_t *handle;\n\tstruct inode *inode;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_cached_block_free *tmp;\n\n\tinode = ocfs2_get_system_file_inode(osb, sysfile_type, slot);\n\tif (!inode) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_SUBALLOC_FREE);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\twhile (head) {\n\t\tif (head->free_bg)\n\t\t\tbg_blkno = head->free_bg;\n\t\telse\n\t\t\tbg_blkno = ocfs2_which_suballoc_group(head->free_blk,\n\t\t\t\t\t\t\t      head->free_bit);\n\t\ttrace_ocfs2_free_cached_blocks(\n\t\t     (unsigned long long)head->free_blk, head->free_bit);\n\n\t\tret = ocfs2_free_suballoc_bits(handle, inode, di_bh,\n\t\t\t\t\t       head->free_bit, bg_blkno, 1);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_journal;\n\t\t}\n\n\t\tret = ocfs2_extend_trans(handle, OCFS2_SUBALLOC_FREE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_journal;\n\t\t}\n\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\t}\n\nout_journal:\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\nout_mutex:\n\tmutex_unlock(&inode->i_mutex);\n\tiput(inode);\nout:\n\twhile(head) {\n\t\t/* Premature exit may have left some dangling items. */\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmp"
          ],
          "line": 6391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 6385
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 6384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "di_bh"
          ],
          "line": 6382
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "1"
          ],
          "line": 6381
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 6378
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmp"
          ],
          "line": 6374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_trans",
          "args": [
            "handle",
            "OCFS2_SUBALLOC_FREE"
          ],
          "line": 6366
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "426-463",
          "snippet": "int ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_suballoc_bits",
          "args": [
            "handle",
            "inode",
            "di_bh",
            "head->free_bit",
            "bg_blkno",
            "1"
          ],
          "line": 6359
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_suballoc_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2519-2528",
          "snippet": "int ocfs2_free_suballoc_bits(handle_t *handle,\n\t\t\t     struct inode *alloc_inode,\n\t\t\t     struct buffer_head *alloc_bh,\n\t\t\t     unsigned int start_bit,\n\t\t\t     u64 bg_blkno,\n\t\t\t     unsigned int count)\n{\n\treturn _ocfs2_free_suballoc_bits(handle, alloc_inode, alloc_bh,\n\t\t\t\t\t start_bit, bg_blkno, count, NULL);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_free_suballoc_bits(handle_t *handle,\n\t\t\t     struct inode *alloc_inode,\n\t\t\t     struct buffer_head *alloc_bh,\n\t\t\t     unsigned int start_bit,\n\t\t\t     u64 bg_blkno,\n\t\t\t     unsigned int count)\n{\n\treturn _ocfs2_free_suballoc_bits(handle, alloc_inode, alloc_bh,\n\t\t\t\t\t start_bit, bg_blkno, count, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_free_cached_blocks",
          "args": [
            "(unsigned long long)head->free_blk",
            "head->free_bit"
          ],
          "line": 6356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_which_suballoc_group",
          "args": [
            "head->free_blk",
            "head->free_bit"
          ],
          "line": 6354
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_which_suballoc_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.h",
          "lines": "156-161",
          "snippet": "static inline u64 ocfs2_which_suballoc_group(u64 block, unsigned int bit)\n{\n\tu64 group = block - (u64) bit;\n\n\treturn group;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64 ocfs2_which_suballoc_group(u64 block, unsigned int bit)\n{\n\tu64 group = block - (u64) bit;\n\n\treturn group;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 6345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 6344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_SUBALLOC_FREE"
          ],
          "line": 6343
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "&di_bh",
            "1"
          ],
          "line": 6337
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 6335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "sysfile_type",
            "slot"
          ],
          "line": 6328
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_free_cached_blocks(struct ocfs2_super *osb,\n\t\t\t\t    int sysfile_type,\n\t\t\t\t    int slot,\n\t\t\t\t    struct ocfs2_cached_block_free *head)\n{\n\tint ret;\n\tu64 bg_blkno;\n\thandle_t *handle;\n\tstruct inode *inode;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_cached_block_free *tmp;\n\n\tinode = ocfs2_get_system_file_inode(osb, sysfile_type, slot);\n\tif (!inode) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_SUBALLOC_FREE);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\twhile (head) {\n\t\tif (head->free_bg)\n\t\t\tbg_blkno = head->free_bg;\n\t\telse\n\t\t\tbg_blkno = ocfs2_which_suballoc_group(head->free_blk,\n\t\t\t\t\t\t\t      head->free_bit);\n\t\ttrace_ocfs2_free_cached_blocks(\n\t\t     (unsigned long long)head->free_blk, head->free_bit);\n\n\t\tret = ocfs2_free_suballoc_bits(handle, inode, di_bh,\n\t\t\t\t\t       head->free_bit, bg_blkno, 1);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_journal;\n\t\t}\n\n\t\tret = ocfs2_extend_trans(handle, OCFS2_SUBALLOC_FREE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_journal;\n\t\t}\n\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\t}\n\nout_journal:\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\nout_mutex:\n\tmutex_unlock(&inode->i_mutex);\n\tiput(inode);\nout:\n\twhile(head) {\n\t\t/* Premature exit may have left some dangling items. */\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_truncate_log_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "6253-6276",
    "snippet": "int ocfs2_truncate_log_init(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = NULL;\n\tstruct buffer_head *tl_bh = NULL;\n\n\tstatus = ocfs2_get_truncate_log_info(osb,\n\t\t\t\t\t     osb->slot_num,\n\t\t\t\t\t     &tl_inode,\n\t\t\t\t\t     &tl_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\t/* ocfs2_truncate_log_shutdown keys on the existence of\n\t * osb->osb_tl_inode so we don't set any of the osb variables\n\t * until we're sure all is well. */\n\tINIT_DELAYED_WORK(&osb->osb_truncate_log_wq,\n\t\t\t  ocfs2_truncate_log_worker);\n\tatomic_set(&osb->osb_tl_disable, 0);\n\tosb->osb_tl_bh    = tl_bh;\n\tosb->osb_tl_inode = tl_inode;\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&osb->osb_tl_disable",
            "0"
          ],
          "line": 6271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&osb->osb_truncate_log_wq",
            "ocfs2_truncate_log_worker"
          ],
          "line": 6269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 6264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_truncate_log_info",
          "args": [
            "osb",
            "osb->slot_num",
            "&tl_inode",
            "&tl_bh"
          ],
          "line": 6259
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_truncate_log_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6072-6101",
          "snippet": "static int ocfs2_get_truncate_log_info(struct ocfs2_super *osb,\n\t\t\t\t       int slot_num,\n\t\t\t\t       struct inode **tl_inode,\n\t\t\t\t       struct buffer_head **tl_bh)\n{\n\tint status;\n\tstruct inode *inode = NULL;\n\tstruct buffer_head *bh = NULL;\n\n\tinode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t   TRUNCATE_LOG_SYSTEM_INODE,\n\t\t\t\t\t   slot_num);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get load truncate log inode!\\n\");\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_read_inode_block(inode, &bh);\n\tif (status < 0) {\n\t\tiput(inode);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*tl_inode = inode;\n\t*tl_bh    = bh;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_get_truncate_log_info(struct ocfs2_super *osb,\n\t\t\t\t       int slot_num,\n\t\t\t\t       struct inode **tl_inode,\n\t\t\t\t       struct buffer_head **tl_bh)\n{\n\tint status;\n\tstruct inode *inode = NULL;\n\tstruct buffer_head *bh = NULL;\n\n\tinode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t   TRUNCATE_LOG_SYSTEM_INODE,\n\t\t\t\t\t   slot_num);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get load truncate log inode!\\n\");\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_read_inode_block(inode, &bh);\n\tif (status < 0) {\n\t\tiput(inode);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*tl_inode = inode;\n\t*tl_bh    = bh;\nbail:\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_truncate_log_init(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = NULL;\n\tstruct buffer_head *tl_bh = NULL;\n\n\tstatus = ocfs2_get_truncate_log_info(osb,\n\t\t\t\t\t     osb->slot_num,\n\t\t\t\t\t     &tl_inode,\n\t\t\t\t\t     &tl_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\t/* ocfs2_truncate_log_shutdown keys on the existence of\n\t * osb->osb_tl_inode so we don't set any of the osb variables\n\t * until we're sure all is well. */\n\tINIT_DELAYED_WORK(&osb->osb_truncate_log_wq,\n\t\t\t  ocfs2_truncate_log_worker);\n\tatomic_set(&osb->osb_tl_disable, 0);\n\tosb->osb_tl_bh    = tl_bh;\n\tosb->osb_tl_inode = tl_inode;\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_truncate_log_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "6233-6251",
    "snippet": "void ocfs2_truncate_log_shutdown(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\n\tatomic_set(&osb->osb_tl_disable, 1);\n\n\tif (tl_inode) {\n\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\t\tflush_workqueue(ocfs2_wq);\n\n\t\tstatus = ocfs2_flush_truncate_log(osb);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\n\t\tbrelse(osb->osb_tl_bh);\n\t\tiput(osb->osb_tl_inode);\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "osb->osb_tl_inode"
          ],
          "line": 6249
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "osb->osb_tl_bh"
          ],
          "line": 6248
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 6246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_flush_truncate_log",
          "args": [
            "osb"
          ],
          "line": 6244
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_flush_truncate_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6030-6040",
          "snippet": "int ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\n\tmutex_lock(&tl_inode->i_mutex);\n\tstatus = __ocfs2_flush_truncate_log(osb);\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\n\tmutex_lock(&tl_inode->i_mutex);\n\tstatus = __ocfs2_flush_truncate_log(osb);\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_workqueue",
          "args": [
            "ocfs2_wq"
          ],
          "line": 6242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work",
          "args": [
            "&osb->osb_truncate_log_wq"
          ],
          "line": 6241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&osb->osb_tl_disable",
            "1"
          ],
          "line": 6238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_truncate_log_shutdown(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\n\tatomic_set(&osb->osb_tl_disable, 1);\n\n\tif (tl_inode) {\n\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\t\tflush_workqueue(ocfs2_wq);\n\n\t\tstatus = ocfs2_flush_truncate_log(osb);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\n\t\tbrelse(osb->osb_tl_bh);\n\t\tiput(osb->osb_tl_inode);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_complete_truncate_log_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "6175-6231",
    "snippet": "int ocfs2_complete_truncate_log_recovery(struct ocfs2_super *osb,\n\t\t\t\t\t struct ocfs2_dinode *tl_copy)\n{\n\tint status = 0;\n\tint i;\n\tunsigned int clusters, num_recs, start_cluster;\n\tu64 start_blk;\n\thandle_t *handle;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct ocfs2_truncate_log *tl;\n\n\tif (OCFS2_I(tl_inode)->ip_blkno == le64_to_cpu(tl_copy->i_blkno)) {\n\t\tmlog(ML_ERROR, \"Asked to recover my own truncate log!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttl = &tl_copy->id2.i_dealloc;\n\tnum_recs = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_complete_truncate_log_recovery(\n\t\t(unsigned long long)le64_to_cpu(tl_copy->i_blkno),\n\t\tnum_recs);\n\n\tmutex_lock(&tl_inode->i_mutex);\n\tfor(i = 0; i < num_recs; i++) {\n\t\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\t\tstatus = __ocfs2_flush_truncate_log(osb);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail_up;\n\t\t\t}\n\t\t}\n\n\t\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_up;\n\t\t}\n\n\t\tclusters = le32_to_cpu(tl->tl_recs[i].t_clusters);\n\t\tstart_cluster = le32_to_cpu(tl->tl_recs[i].t_start);\n\t\tstart_blk = ocfs2_clusters_to_blocks(osb->sb, start_cluster);\n\n\t\tstatus = ocfs2_truncate_log_append(osb, handle,\n\t\t\t\t\t\t   start_blk, clusters);\n\t\tocfs2_commit_trans(osb, handle);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_up;\n\t\t}\n\t}\n\nbail_up:\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
      "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tl_inode->i_mutex"
          ],
          "line": 6228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 6222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 6220
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_log_append",
          "args": [
            "osb",
            "handle",
            "start_blk",
            "clusters"
          ],
          "line": 6218
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_log_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5808-5882",
          "snippet": "int ocfs2_truncate_log_append(struct ocfs2_super *osb,\n\t\t\t      handle_t *handle,\n\t\t\t      u64 start_blk,\n\t\t\t      unsigned int num_clusters)\n{\n\tint status, index;\n\tunsigned int start_cluster, tl_count;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(mutex_trylock(&tl_inode->i_mutex));\n\n\tstart_cluster = ocfs2_blocks_to_clusters(osb->sb, start_blk);\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\ttl_count = le16_to_cpu(tl->tl_count);\n\tmlog_bug_on_msg(tl_count > ocfs2_truncate_recs_per_inode(osb->sb) ||\n\t\t\ttl_count == 0,\n\t\t\t\"Truncate record count on #%llu invalid \"\n\t\t\t\"wanted %u, actual %u\\n\",\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tocfs2_truncate_recs_per_inode(osb->sb),\n\t\t\tle16_to_cpu(tl->tl_count));\n\n\t/* Caller should have known to flush before calling us. */\n\tindex = le16_to_cpu(tl->tl_used);\n\tif (index >= tl_count) {\n\t\tstatus = -ENOSPC;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_truncate_log_append(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno, index,\n\t\tstart_cluster, num_clusters);\n\tif (ocfs2_truncate_log_can_coalesce(tl, start_cluster)) {\n\t\t/*\n\t\t * Move index back to the record we are coalescing with.\n\t\t * ocfs2_truncate_log_can_coalesce() guarantees nonzero\n\t\t */\n\t\tindex--;\n\n\t\tnum_clusters += le32_to_cpu(tl->tl_recs[index].t_clusters);\n\t\ttrace_ocfs2_truncate_log_append(\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tindex, le32_to_cpu(tl->tl_recs[index].t_start),\n\t\t\tnum_clusters);\n\t} else {\n\t\ttl->tl_recs[index].t_start = cpu_to_le32(start_cluster);\n\t\ttl->tl_used = cpu_to_le16(index + 1);\n\t}\n\ttl->tl_recs[index].t_clusters = cpu_to_le32(num_clusters);\n\n\tocfs2_journal_dirty(handle, tl_bh);\n\n\tosb->truncated_clusters += num_clusters;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_truncate_log_append(struct ocfs2_super *osb,\n\t\t\t      handle_t *handle,\n\t\t\t      u64 start_blk,\n\t\t\t      unsigned int num_clusters)\n{\n\tint status, index;\n\tunsigned int start_cluster, tl_count;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(mutex_trylock(&tl_inode->i_mutex));\n\n\tstart_cluster = ocfs2_blocks_to_clusters(osb->sb, start_blk);\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\ttl_count = le16_to_cpu(tl->tl_count);\n\tmlog_bug_on_msg(tl_count > ocfs2_truncate_recs_per_inode(osb->sb) ||\n\t\t\ttl_count == 0,\n\t\t\t\"Truncate record count on #%llu invalid \"\n\t\t\t\"wanted %u, actual %u\\n\",\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tocfs2_truncate_recs_per_inode(osb->sb),\n\t\t\tle16_to_cpu(tl->tl_count));\n\n\t/* Caller should have known to flush before calling us. */\n\tindex = le16_to_cpu(tl->tl_used);\n\tif (index >= tl_count) {\n\t\tstatus = -ENOSPC;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_truncate_log_append(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno, index,\n\t\tstart_cluster, num_clusters);\n\tif (ocfs2_truncate_log_can_coalesce(tl, start_cluster)) {\n\t\t/*\n\t\t * Move index back to the record we are coalescing with.\n\t\t * ocfs2_truncate_log_can_coalesce() guarantees nonzero\n\t\t */\n\t\tindex--;\n\n\t\tnum_clusters += le32_to_cpu(tl->tl_recs[index].t_clusters);\n\t\ttrace_ocfs2_truncate_log_append(\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tindex, le32_to_cpu(tl->tl_recs[index].t_start),\n\t\t\tnum_clusters);\n\t} else {\n\t\ttl->tl_recs[index].t_start = cpu_to_le32(start_cluster);\n\t\ttl->tl_used = cpu_to_le16(index + 1);\n\t}\n\ttl->tl_recs[index].t_clusters = cpu_to_le32(num_clusters);\n\n\tocfs2_journal_dirty(handle, tl_bh);\n\n\tosb->truncated_clusters += num_clusters;\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "osb->sb",
            "start_cluster"
          ],
          "line": 6216
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "tl->tl_recs[i].t_start"
          ],
          "line": 6215
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 6210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 6209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 6208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_TRUNCATE_LOG_UPDATE"
          ],
          "line": 6207
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 6202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_flush_truncate_log",
          "args": [
            "osb"
          ],
          "line": 6200
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_flush_truncate_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5956-6028",
          "snippet": "int __ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tunsigned int num_to_flush;\n\thandle_t *handle;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *data_alloc_inode = NULL;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct buffer_head *data_alloc_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(mutex_trylock(&tl_inode->i_mutex));\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tnum_to_flush = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_flush_truncate_log(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\tnum_to_flush);\n\tif (!num_to_flush) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\tdata_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!data_alloc_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get bitmap inode!\\n\");\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&data_alloc_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(data_alloc_inode, &data_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_unlock;\n\t}\n\n\tstatus = ocfs2_replay_truncate_records(osb, handle, data_alloc_inode,\n\t\t\t\t\t       data_alloc_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tbrelse(data_alloc_bh);\n\tocfs2_inode_unlock(data_alloc_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&data_alloc_inode->i_mutex);\n\tiput(data_alloc_inode);\n\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint __ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tunsigned int num_to_flush;\n\thandle_t *handle;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *data_alloc_inode = NULL;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct buffer_head *data_alloc_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(mutex_trylock(&tl_inode->i_mutex));\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tnum_to_flush = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_flush_truncate_log(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\tnum_to_flush);\n\tif (!num_to_flush) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\tdata_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!data_alloc_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get bitmap inode!\\n\");\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&data_alloc_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(data_alloc_inode, &data_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_unlock;\n\t}\n\n\tstatus = ocfs2_replay_truncate_records(osb, handle, data_alloc_inode,\n\t\t\t\t\t       data_alloc_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tbrelse(data_alloc_bh);\n\tocfs2_inode_unlock(data_alloc_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&data_alloc_inode->i_mutex);\n\tiput(data_alloc_inode);\n\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_log_needs_flush",
          "args": [
            "osb"
          ],
          "line": 6199
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_log_needs_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5775-5789",
          "snippet": "int ocfs2_truncate_log_needs_flush(struct ocfs2_super *osb)\n{\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\n\tmlog_bug_on_msg(le16_to_cpu(tl->tl_used) > le16_to_cpu(tl->tl_count),\n\t\t\t\"slot %d, invalid truncate log parameters: used = \"\n\t\t\t\"%u, count = %u\\n\", osb->slot_num,\n\t\t\tle16_to_cpu(tl->tl_used), le16_to_cpu(tl->tl_count));\n\treturn le16_to_cpu(tl->tl_used) == le16_to_cpu(tl->tl_count);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_truncate_log_needs_flush(struct ocfs2_super *osb)\n{\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\n\tmlog_bug_on_msg(le16_to_cpu(tl->tl_used) > le16_to_cpu(tl->tl_count),\n\t\t\t\"slot %d, invalid truncate log parameters: used = \"\n\t\t\t\"%u, count = %u\\n\", osb->slot_num,\n\t\t\tle16_to_cpu(tl->tl_used), le16_to_cpu(tl->tl_count));\n\treturn le16_to_cpu(tl->tl_used) == le16_to_cpu(tl->tl_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tl_inode->i_mutex"
          ],
          "line": 6197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_complete_truncate_log_recovery",
          "args": [
            "(unsigned long long)le64_to_cpu(tl_copy->i_blkno)",
            "num_recs"
          ],
          "line": 6193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "tl_copy->i_blkno"
          ],
          "line": 6194
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "tl->tl_used"
          ],
          "line": 6192
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Asked to recover my own truncate log!\\n\""
          ],
          "line": 6187
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "tl_inode"
          ],
          "line": 6186
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\n\nint ocfs2_complete_truncate_log_recovery(struct ocfs2_super *osb,\n\t\t\t\t\t struct ocfs2_dinode *tl_copy)\n{\n\tint status = 0;\n\tint i;\n\tunsigned int clusters, num_recs, start_cluster;\n\tu64 start_blk;\n\thandle_t *handle;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct ocfs2_truncate_log *tl;\n\n\tif (OCFS2_I(tl_inode)->ip_blkno == le64_to_cpu(tl_copy->i_blkno)) {\n\t\tmlog(ML_ERROR, \"Asked to recover my own truncate log!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttl = &tl_copy->id2.i_dealloc;\n\tnum_recs = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_complete_truncate_log_recovery(\n\t\t(unsigned long long)le64_to_cpu(tl_copy->i_blkno),\n\t\tnum_recs);\n\n\tmutex_lock(&tl_inode->i_mutex);\n\tfor(i = 0; i < num_recs; i++) {\n\t\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\t\tstatus = __ocfs2_flush_truncate_log(osb);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail_up;\n\t\t\t}\n\t\t}\n\n\t\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_up;\n\t\t}\n\n\t\tclusters = le32_to_cpu(tl->tl_recs[i].t_clusters);\n\t\tstart_cluster = le32_to_cpu(tl->tl_recs[i].t_start);\n\t\tstart_blk = ocfs2_clusters_to_blocks(osb->sb, start_cluster);\n\n\t\tstatus = ocfs2_truncate_log_append(osb, handle,\n\t\t\t\t\t\t   start_blk, clusters);\n\t\tocfs2_commit_trans(osb, handle);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_up;\n\t\t}\n\t}\n\nbail_up:\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_begin_truncate_log_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "6107-6173",
    "snippet": "int ocfs2_begin_truncate_log_recovery(struct ocfs2_super *osb,\n\t\t\t\t      int slot_num,\n\t\t\t\t      struct ocfs2_dinode **tl_copy)\n{\n\tint status;\n\tstruct inode *tl_inode = NULL;\n\tstruct buffer_head *tl_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\t*tl_copy = NULL;\n\n\ttrace_ocfs2_begin_truncate_log_recovery(slot_num);\n\n\tstatus = ocfs2_get_truncate_log_info(osb, slot_num, &tl_inode, &tl_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_get_truncate_log_info().  It's\n\t * validated by the underlying call to ocfs2_read_inode_block(),\n\t * so any corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tif (le16_to_cpu(tl->tl_used)) {\n\t\ttrace_ocfs2_truncate_log_recovery_num(le16_to_cpu(tl->tl_used));\n\n\t\t*tl_copy = kmalloc(tl_bh->b_size, GFP_KERNEL);\n\t\tif (!(*tl_copy)) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* Assuming the write-out below goes well, this copy\n\t\t * will be passed back to recovery for processing. */\n\t\tmemcpy(*tl_copy, tl_bh->b_data, tl_bh->b_size);\n\n\t\t/* All we need to do to clear the truncate log is set\n\t\t * tl_used. */\n\t\ttl->tl_used = 0;\n\n\t\tocfs2_compute_meta_ecc(osb->sb, tl_bh->b_data, &di->i_check);\n\t\tstatus = ocfs2_write_block(osb, tl_bh, INODE_CACHE(tl_inode));\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\nbail:\n\tif (tl_inode)\n\t\tiput(tl_inode);\n\tbrelse(tl_bh);\n\n\tif (status < 0 && (*tl_copy)) {\n\t\tkfree(*tl_copy);\n\t\t*tl_copy = NULL;\n\t\tmlog_errno(status);\n\t}\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 6169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "*tl_copy"
          ],
          "line": 6167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "tl_bh"
          ],
          "line": 6164
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "tl_inode"
          ],
          "line": 6163
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 6156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_write_block",
          "args": [
            "osb",
            "tl_bh",
            "INODE_CACHE(tl_inode)"
          ],
          "line": 6154
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_write_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "53-99",
          "snippet": "int ocfs2_write_block(struct ocfs2_super *osb, struct buffer_head *bh,\n\t\t      struct ocfs2_caching_info *ci)\n{\n\tint ret = 0;\n\n\ttrace_ocfs2_write_block((unsigned long long)bh->b_blocknr, ci);\n\n\tBUG_ON(bh->b_blocknr < OCFS2_SUPER_BLOCK_BLKNO);\n\tBUG_ON(buffer_jbd(bh));\n\n\t/* No need to check for a soft readonly file system here. non\n\t * journalled writes are only ever done on system files which\n\t * can get modified during recovery even if read-only. */\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_metadata_cache_io_lock(ci);\n\n\tlock_buffer(bh);\n\tset_buffer_uptodate(bh);\n\n\t/* remove from dirty list before I/O. */\n\tclear_buffer_dirty(bh);\n\n\tget_bh(bh); /* for end_buffer_write_sync() */\n\tbh->b_end_io = end_buffer_write_sync;\n\tsubmit_bh(WRITE, bh);\n\n\twait_on_buffer(bh);\n\n\tif (buffer_uptodate(bh)) {\n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t} else {\n\t\t/* We don't need to remove the clustered uptodate\n\t\t * information for this bh as it's not marked locally\n\t\t * uptodate. */\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t}\n\n\tocfs2_metadata_cache_io_unlock(ci);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_write_block(struct ocfs2_super *osb, struct buffer_head *bh,\n\t\t      struct ocfs2_caching_info *ci)\n{\n\tint ret = 0;\n\n\ttrace_ocfs2_write_block((unsigned long long)bh->b_blocknr, ci);\n\n\tBUG_ON(bh->b_blocknr < OCFS2_SUPER_BLOCK_BLKNO);\n\tBUG_ON(buffer_jbd(bh));\n\n\t/* No need to check for a soft readonly file system here. non\n\t * journalled writes are only ever done on system files which\n\t * can get modified during recovery even if read-only. */\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_metadata_cache_io_lock(ci);\n\n\tlock_buffer(bh);\n\tset_buffer_uptodate(bh);\n\n\t/* remove from dirty list before I/O. */\n\tclear_buffer_dirty(bh);\n\n\tget_bh(bh); /* for end_buffer_write_sync() */\n\tbh->b_end_io = end_buffer_write_sync;\n\tsubmit_bh(WRITE, bh);\n\n\twait_on_buffer(bh);\n\n\tif (buffer_uptodate(bh)) {\n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t} else {\n\t\t/* We don't need to remove the clustered uptodate\n\t\t * information for this bh as it's not marked locally\n\t\t * uptodate. */\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t}\n\n\tocfs2_metadata_cache_io_unlock(ci);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "tl_inode"
          ],
          "line": 6154
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_compute_meta_ecc",
          "args": [
            "osb->sb",
            "tl_bh->b_data",
            "&di->i_check"
          ],
          "line": 6153
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_compute_meta_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "606-611",
          "snippet": "void ocfs2_compute_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tif (ocfs2_meta_ecc(OCFS2_SB(sb)))\n\t\tocfs2_block_check_compute(data, sb->s_blocksize, bc);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_compute_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tif (ocfs2_meta_ecc(OCFS2_SB(sb)))\n\t\tocfs2_block_check_compute(data, sb->s_blocksize, bc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*tl_copy",
            "tl_bh->b_data",
            "tl_bh->b_size"
          ],
          "line": 6147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 6141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "tl_bh->b_size",
            "GFP_KERNEL"
          ],
          "line": 6138
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_truncate_log_recovery_num",
          "args": [
            "le16_to_cpu(tl->tl_used)"
          ],
          "line": 6136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "tl->tl_used"
          ],
          "line": 6136
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!OCFS2_IS_VALID_DINODE(di)"
          ],
          "line": 6132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_DINODE",
          "args": [
            "di"
          ],
          "line": 6132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 6123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_truncate_log_info",
          "args": [
            "osb",
            "slot_num",
            "&tl_inode",
            "&tl_bh"
          ],
          "line": 6121
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_truncate_log_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6072-6101",
          "snippet": "static int ocfs2_get_truncate_log_info(struct ocfs2_super *osb,\n\t\t\t\t       int slot_num,\n\t\t\t\t       struct inode **tl_inode,\n\t\t\t\t       struct buffer_head **tl_bh)\n{\n\tint status;\n\tstruct inode *inode = NULL;\n\tstruct buffer_head *bh = NULL;\n\n\tinode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t   TRUNCATE_LOG_SYSTEM_INODE,\n\t\t\t\t\t   slot_num);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get load truncate log inode!\\n\");\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_read_inode_block(inode, &bh);\n\tif (status < 0) {\n\t\tiput(inode);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*tl_inode = inode;\n\t*tl_bh    = bh;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_get_truncate_log_info(struct ocfs2_super *osb,\n\t\t\t\t       int slot_num,\n\t\t\t\t       struct inode **tl_inode,\n\t\t\t\t       struct buffer_head **tl_bh)\n{\n\tint status;\n\tstruct inode *inode = NULL;\n\tstruct buffer_head *bh = NULL;\n\n\tinode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t   TRUNCATE_LOG_SYSTEM_INODE,\n\t\t\t\t\t   slot_num);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get load truncate log inode!\\n\");\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_read_inode_block(inode, &bh);\n\tif (status < 0) {\n\t\tiput(inode);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*tl_inode = inode;\n\t*tl_bh    = bh;\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_begin_truncate_log_recovery",
          "args": [
            "slot_num"
          ],
          "line": 6119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_begin_truncate_log_recovery(struct ocfs2_super *osb,\n\t\t\t\t      int slot_num,\n\t\t\t\t      struct ocfs2_dinode **tl_copy)\n{\n\tint status;\n\tstruct inode *tl_inode = NULL;\n\tstruct buffer_head *tl_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\t*tl_copy = NULL;\n\n\ttrace_ocfs2_begin_truncate_log_recovery(slot_num);\n\n\tstatus = ocfs2_get_truncate_log_info(osb, slot_num, &tl_inode, &tl_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_get_truncate_log_info().  It's\n\t * validated by the underlying call to ocfs2_read_inode_block(),\n\t * so any corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tif (le16_to_cpu(tl->tl_used)) {\n\t\ttrace_ocfs2_truncate_log_recovery_num(le16_to_cpu(tl->tl_used));\n\n\t\t*tl_copy = kmalloc(tl_bh->b_size, GFP_KERNEL);\n\t\tif (!(*tl_copy)) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* Assuming the write-out below goes well, this copy\n\t\t * will be passed back to recovery for processing. */\n\t\tmemcpy(*tl_copy, tl_bh->b_data, tl_bh->b_size);\n\n\t\t/* All we need to do to clear the truncate log is set\n\t\t * tl_used. */\n\t\ttl->tl_used = 0;\n\n\t\tocfs2_compute_meta_ecc(osb->sb, tl_bh->b_data, &di->i_check);\n\t\tstatus = ocfs2_write_block(osb, tl_bh, INODE_CACHE(tl_inode));\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\nbail:\n\tif (tl_inode)\n\t\tiput(tl_inode);\n\tbrelse(tl_bh);\n\n\tif (status < 0 && (*tl_copy)) {\n\t\tkfree(*tl_copy);\n\t\t*tl_copy = NULL;\n\t\tmlog_errno(status);\n\t}\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_get_truncate_log_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "6072-6101",
    "snippet": "static int ocfs2_get_truncate_log_info(struct ocfs2_super *osb,\n\t\t\t\t       int slot_num,\n\t\t\t\t       struct inode **tl_inode,\n\t\t\t\t       struct buffer_head **tl_bh)\n{\n\tint status;\n\tstruct inode *inode = NULL;\n\tstruct buffer_head *bh = NULL;\n\n\tinode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t   TRUNCATE_LOG_SYSTEM_INODE,\n\t\t\t\t\t   slot_num);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get load truncate log inode!\\n\");\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_read_inode_block(inode, &bh);\n\tif (status < 0) {\n\t\tiput(inode);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*tl_inode = inode;\n\t*tl_bh    = bh;\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 6093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 6092
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_read_inode_block",
          "args": [
            "inode",
            "&bh"
          ],
          "line": 6090
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1404-1407",
          "snippet": "int ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Could not get load truncate log inode!\\n\""
          ],
          "line": 6086
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "TRUNCATE_LOG_SYSTEM_INODE",
            "slot_num"
          ],
          "line": 6081
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_get_truncate_log_info(struct ocfs2_super *osb,\n\t\t\t\t       int slot_num,\n\t\t\t\t       struct inode **tl_inode,\n\t\t\t\t       struct buffer_head **tl_bh)\n{\n\tint status;\n\tstruct inode *inode = NULL;\n\tstruct buffer_head *bh = NULL;\n\n\tinode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t   TRUNCATE_LOG_SYSTEM_INODE,\n\t\t\t\t\t   slot_num);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get load truncate log inode!\\n\");\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_read_inode_block(inode, &bh);\n\tif (status < 0) {\n\t\tiput(inode);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*tl_inode = inode;\n\t*tl_bh    = bh;\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_schedule_truncate_log_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "6057-6070",
    "snippet": "void ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "ocfs2_wq",
            "&osb->osb_truncate_log_wq",
            "OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL"
          ],
          "line": 6067
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work",
          "args": [
            "&osb->osb_truncate_log_wq"
          ],
          "line": 6065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&osb->osb_tl_disable"
          ],
          "line": 6061
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)\n\nvoid ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_truncate_log_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "6042-6054",
    "snippet": "static void ocfs2_truncate_log_worker(struct work_struct *work)\n{\n\tint status;\n\tstruct ocfs2_super *osb =\n\t\tcontainer_of(work, struct ocfs2_super,\n\t\t\t     osb_truncate_log_wq.work);\n\n\tstatus = ocfs2_flush_truncate_log(osb);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_init_steal_slots(osb);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_init_steal_slots",
          "args": [
            "osb"
          ],
          "line": 6053
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_steal_slots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "904-908",
          "snippet": "void ocfs2_init_steal_slots(struct ocfs2_super *osb)\n{\n\tocfs2_init_inode_steal_slot(osb);\n\tocfs2_init_meta_steal_slot(osb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_init_steal_slots(struct ocfs2_super *osb)\n{\n\tocfs2_init_inode_steal_slot(osb);\n\tocfs2_init_meta_steal_slot(osb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 6051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_flush_truncate_log",
          "args": [
            "osb"
          ],
          "line": 6049
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_flush_truncate_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6030-6040",
          "snippet": "int ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\n\tmutex_lock(&tl_inode->i_mutex);\n\tstatus = __ocfs2_flush_truncate_log(osb);\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\n\tmutex_lock(&tl_inode->i_mutex);\n\tstatus = __ocfs2_flush_truncate_log(osb);\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structocfs2_super",
            "osb_truncate_log_wq.work"
          ],
          "line": 6046
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_truncate_log_worker(struct work_struct *work)\n{\n\tint status;\n\tstruct ocfs2_super *osb =\n\t\tcontainer_of(work, struct ocfs2_super,\n\t\t\t     osb_truncate_log_wq.work);\n\n\tstatus = ocfs2_flush_truncate_log(osb);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_init_steal_slots(osb);\n}"
  },
  {
    "function_name": "ocfs2_flush_truncate_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "6030-6040",
    "snippet": "int ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\n\tmutex_lock(&tl_inode->i_mutex);\n\tstatus = __ocfs2_flush_truncate_log(osb);\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tl_inode->i_mutex"
          ],
          "line": 6037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_flush_truncate_log",
          "args": [
            "osb"
          ],
          "line": 6036
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_flush_truncate_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5956-6028",
          "snippet": "int __ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tunsigned int num_to_flush;\n\thandle_t *handle;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *data_alloc_inode = NULL;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct buffer_head *data_alloc_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(mutex_trylock(&tl_inode->i_mutex));\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tnum_to_flush = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_flush_truncate_log(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\tnum_to_flush);\n\tif (!num_to_flush) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\tdata_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!data_alloc_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get bitmap inode!\\n\");\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&data_alloc_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(data_alloc_inode, &data_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_unlock;\n\t}\n\n\tstatus = ocfs2_replay_truncate_records(osb, handle, data_alloc_inode,\n\t\t\t\t\t       data_alloc_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tbrelse(data_alloc_bh);\n\tocfs2_inode_unlock(data_alloc_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&data_alloc_inode->i_mutex);\n\tiput(data_alloc_inode);\n\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint __ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tunsigned int num_to_flush;\n\thandle_t *handle;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *data_alloc_inode = NULL;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct buffer_head *data_alloc_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(mutex_trylock(&tl_inode->i_mutex));\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tnum_to_flush = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_flush_truncate_log(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\tnum_to_flush);\n\tif (!num_to_flush) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\tdata_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!data_alloc_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get bitmap inode!\\n\");\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&data_alloc_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(data_alloc_inode, &data_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_unlock;\n\t}\n\n\tstatus = ocfs2_replay_truncate_records(osb, handle, data_alloc_inode,\n\t\t\t\t\t       data_alloc_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tbrelse(data_alloc_bh);\n\tocfs2_inode_unlock(data_alloc_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&data_alloc_inode->i_mutex);\n\tiput(data_alloc_inode);\n\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tl_inode->i_mutex"
          ],
          "line": 6035
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\n\tmutex_lock(&tl_inode->i_mutex);\n\tstatus = __ocfs2_flush_truncate_log(osb);\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\treturn status;\n}"
  },
  {
    "function_name": "__ocfs2_flush_truncate_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "5956-6028",
    "snippet": "int __ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tunsigned int num_to_flush;\n\thandle_t *handle;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *data_alloc_inode = NULL;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct buffer_head *data_alloc_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(mutex_trylock(&tl_inode->i_mutex));\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tnum_to_flush = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_flush_truncate_log(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\tnum_to_flush);\n\tif (!num_to_flush) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\tdata_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!data_alloc_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get bitmap inode!\\n\");\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&data_alloc_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(data_alloc_inode, &data_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_unlock;\n\t}\n\n\tstatus = ocfs2_replay_truncate_records(osb, handle, data_alloc_inode,\n\t\t\t\t\t       data_alloc_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tbrelse(data_alloc_bh);\n\tocfs2_inode_unlock(data_alloc_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&data_alloc_inode->i_mutex);\n\tiput(data_alloc_inode);\n\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "data_alloc_inode"
          ],
          "line": 6024
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&data_alloc_inode->i_mutex"
          ],
          "line": 6023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "data_alloc_inode",
            "1"
          ],
          "line": 6020
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "data_alloc_bh"
          ],
          "line": 6019
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 6016
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 6014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_replay_truncate_records",
          "args": [
            "osb",
            "handle",
            "data_alloc_inode",
            "data_alloc_bh"
          ],
          "line": 6011
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_replay_truncate_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5884-5953",
          "snippet": "static int ocfs2_replay_truncate_records(struct ocfs2_super *osb,\n\t\t\t\t\t handle_t *handle,\n\t\t\t\t\t struct inode *data_alloc_inode,\n\t\t\t\t\t struct buffer_head *data_alloc_bh)\n{\n\tint status = 0;\n\tint i;\n\tunsigned int num_clusters;\n\tu64 start_blk;\n\tstruct ocfs2_truncate_rec rec;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\ti = le16_to_cpu(tl->tl_used) - 1;\n\twhile (i >= 0) {\n\t\t/* Caller has given us at least enough credits to\n\t\t * update the truncate log dinode */\n\t\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\ttl->tl_used = cpu_to_le16(i);\n\n\t\tocfs2_journal_dirty(handle, tl_bh);\n\n\t\t/* TODO: Perhaps we can calculate the bulk of the\n\t\t * credits up front rather than extending like\n\t\t * this. */\n\t\tstatus = ocfs2_extend_trans(handle,\n\t\t\t\t\t    OCFS2_TRUNCATE_LOG_FLUSH_ONE_REC);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\trec = tl->tl_recs[i];\n\t\tstart_blk = ocfs2_clusters_to_blocks(data_alloc_inode->i_sb,\n\t\t\t\t\t\t    le32_to_cpu(rec.t_start));\n\t\tnum_clusters = le32_to_cpu(rec.t_clusters);\n\n\t\t/* if start_blk is not set, we ignore the record as\n\t\t * invalid. */\n\t\tif (start_blk) {\n\t\t\ttrace_ocfs2_replay_truncate_records(\n\t\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\t\ti, le32_to_cpu(rec.t_start), num_clusters);\n\n\t\t\tstatus = ocfs2_free_clusters(handle, data_alloc_inode,\n\t\t\t\t\t\t     data_alloc_bh, start_blk,\n\t\t\t\t\t\t     num_clusters);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\ti--;\n\t}\n\n\tosb->truncated_clusters = 0;\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic int ocfs2_replay_truncate_records(struct ocfs2_super *osb,\n\t\t\t\t\t handle_t *handle,\n\t\t\t\t\t struct inode *data_alloc_inode,\n\t\t\t\t\t struct buffer_head *data_alloc_bh)\n{\n\tint status = 0;\n\tint i;\n\tunsigned int num_clusters;\n\tu64 start_blk;\n\tstruct ocfs2_truncate_rec rec;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\ti = le16_to_cpu(tl->tl_used) - 1;\n\twhile (i >= 0) {\n\t\t/* Caller has given us at least enough credits to\n\t\t * update the truncate log dinode */\n\t\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\ttl->tl_used = cpu_to_le16(i);\n\n\t\tocfs2_journal_dirty(handle, tl_bh);\n\n\t\t/* TODO: Perhaps we can calculate the bulk of the\n\t\t * credits up front rather than extending like\n\t\t * this. */\n\t\tstatus = ocfs2_extend_trans(handle,\n\t\t\t\t\t    OCFS2_TRUNCATE_LOG_FLUSH_ONE_REC);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\trec = tl->tl_recs[i];\n\t\tstart_blk = ocfs2_clusters_to_blocks(data_alloc_inode->i_sb,\n\t\t\t\t\t\t    le32_to_cpu(rec.t_start));\n\t\tnum_clusters = le32_to_cpu(rec.t_clusters);\n\n\t\t/* if start_blk is not set, we ignore the record as\n\t\t * invalid. */\n\t\tif (start_blk) {\n\t\t\ttrace_ocfs2_replay_truncate_records(\n\t\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\t\ti, le32_to_cpu(rec.t_start), num_clusters);\n\n\t\t\tstatus = ocfs2_free_clusters(handle, data_alloc_inode,\n\t\t\t\t\t\t     data_alloc_bh, start_blk,\n\t\t\t\t\t\t     num_clusters);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\ti--;\n\t}\n\n\tosb->truncated_clusters = 0;\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 6007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 6006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 6005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_TRUNCATE_LOG_UPDATE"
          ],
          "line": 6004
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 6000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "data_alloc_inode",
            "&data_alloc_bh",
            "1"
          ],
          "line": 5998
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&data_alloc_inode->i_mutex"
          ],
          "line": 5996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Could not get bitmap inode!\\n\""
          ],
          "line": 5992
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "GLOBAL_BITMAP_SYSTEM_INODE",
            "OCFS2_INVALID_SLOT"
          ],
          "line": 5987
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_flush_truncate_log",
          "args": [
            "(unsigned long long)OCFS2_I(tl_inode)->ip_blkno",
            "num_to_flush"
          ],
          "line": 5979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "tl_inode"
          ],
          "line": 5980
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "tl->tl_used"
          ],
          "line": 5978
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!OCFS2_IS_VALID_DINODE(di)"
          ],
          "line": 5975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_DINODE",
          "args": [
            "di"
          ],
          "line": 5975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mutex_trylock(&tl_inode->i_mutex)"
          ],
          "line": 5968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&tl_inode->i_mutex"
          ],
          "line": 5968
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint __ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tunsigned int num_to_flush;\n\thandle_t *handle;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *data_alloc_inode = NULL;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct buffer_head *data_alloc_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(mutex_trylock(&tl_inode->i_mutex));\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tnum_to_flush = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_flush_truncate_log(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\tnum_to_flush);\n\tif (!num_to_flush) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\tdata_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!data_alloc_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get bitmap inode!\\n\");\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&data_alloc_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(data_alloc_inode, &data_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_unlock;\n\t}\n\n\tstatus = ocfs2_replay_truncate_records(osb, handle, data_alloc_inode,\n\t\t\t\t\t       data_alloc_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tbrelse(data_alloc_bh);\n\tocfs2_inode_unlock(data_alloc_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&data_alloc_inode->i_mutex);\n\tiput(data_alloc_inode);\n\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_replay_truncate_records",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "5884-5953",
    "snippet": "static int ocfs2_replay_truncate_records(struct ocfs2_super *osb,\n\t\t\t\t\t handle_t *handle,\n\t\t\t\t\t struct inode *data_alloc_inode,\n\t\t\t\t\t struct buffer_head *data_alloc_bh)\n{\n\tint status = 0;\n\tint i;\n\tunsigned int num_clusters;\n\tu64 start_blk;\n\tstruct ocfs2_truncate_rec rec;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\ti = le16_to_cpu(tl->tl_used) - 1;\n\twhile (i >= 0) {\n\t\t/* Caller has given us at least enough credits to\n\t\t * update the truncate log dinode */\n\t\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\ttl->tl_used = cpu_to_le16(i);\n\n\t\tocfs2_journal_dirty(handle, tl_bh);\n\n\t\t/* TODO: Perhaps we can calculate the bulk of the\n\t\t * credits up front rather than extending like\n\t\t * this. */\n\t\tstatus = ocfs2_extend_trans(handle,\n\t\t\t\t\t    OCFS2_TRUNCATE_LOG_FLUSH_ONE_REC);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\trec = tl->tl_recs[i];\n\t\tstart_blk = ocfs2_clusters_to_blocks(data_alloc_inode->i_sb,\n\t\t\t\t\t\t    le32_to_cpu(rec.t_start));\n\t\tnum_clusters = le32_to_cpu(rec.t_clusters);\n\n\t\t/* if start_blk is not set, we ignore the record as\n\t\t * invalid. */\n\t\tif (start_blk) {\n\t\t\ttrace_ocfs2_replay_truncate_records(\n\t\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\t\ti, le32_to_cpu(rec.t_start), num_clusters);\n\n\t\t\tstatus = ocfs2_free_clusters(handle, data_alloc_inode,\n\t\t\t\t\t\t     data_alloc_bh, start_blk,\n\t\t\t\t\t\t     num_clusters);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\ti--;\n\t}\n\n\tosb->truncated_clusters = 0;\n\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 5942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_clusters",
          "args": [
            "handle",
            "data_alloc_inode",
            "data_alloc_bh",
            "start_blk",
            "num_clusters"
          ],
          "line": 5938
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2591-2600",
          "snippet": "int ocfs2_free_clusters(handle_t *handle,\n\t\t\tstruct inode *bitmap_inode,\n\t\t\tstruct buffer_head *bitmap_bh,\n\t\t\tu64 start_blk,\n\t\t\tunsigned int num_clusters)\n{\n\treturn _ocfs2_free_clusters(handle, bitmap_inode, bitmap_bh,\n\t\t\t\t    start_blk, num_clusters,\n\t\t\t\t    _ocfs2_set_bit);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_free_clusters(handle_t *handle,\n\t\t\tstruct inode *bitmap_inode,\n\t\t\tstruct buffer_head *bitmap_bh,\n\t\t\tu64 start_blk,\n\t\t\tunsigned int num_clusters)\n{\n\treturn _ocfs2_free_clusters(handle, bitmap_inode, bitmap_bh,\n\t\t\t\t    start_blk, num_clusters,\n\t\t\t\t    _ocfs2_set_bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_replay_truncate_records",
          "args": [
            "(unsigned long long)OCFS2_I(tl_inode)->ip_blkno",
            "i",
            "le32_to_cpu(rec.t_start)",
            "num_clusters"
          ],
          "line": 5934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec.t_start"
          ],
          "line": 5936
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "tl_inode"
          ],
          "line": 5935
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "data_alloc_inode->i_sb",
            "le32_to_cpu(rec.t_start)"
          ],
          "line": 5927
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 5922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_trans",
          "args": [
            "handle",
            "OCFS2_TRUNCATE_LOG_FLUSH_ONE_REC"
          ],
          "line": 5919
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "426-463",
          "snippet": "int ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "tl_bh"
          ],
          "line": 5914
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "i"
          ],
          "line": 5912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 5908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(tl_inode)",
            "tl_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 5905
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "tl_inode"
          ],
          "line": 5905
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "tl->tl_used"
          ],
          "line": 5901
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic int ocfs2_replay_truncate_records(struct ocfs2_super *osb,\n\t\t\t\t\t handle_t *handle,\n\t\t\t\t\t struct inode *data_alloc_inode,\n\t\t\t\t\t struct buffer_head *data_alloc_bh)\n{\n\tint status = 0;\n\tint i;\n\tunsigned int num_clusters;\n\tu64 start_blk;\n\tstruct ocfs2_truncate_rec rec;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\ti = le16_to_cpu(tl->tl_used) - 1;\n\twhile (i >= 0) {\n\t\t/* Caller has given us at least enough credits to\n\t\t * update the truncate log dinode */\n\t\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\ttl->tl_used = cpu_to_le16(i);\n\n\t\tocfs2_journal_dirty(handle, tl_bh);\n\n\t\t/* TODO: Perhaps we can calculate the bulk of the\n\t\t * credits up front rather than extending like\n\t\t * this. */\n\t\tstatus = ocfs2_extend_trans(handle,\n\t\t\t\t\t    OCFS2_TRUNCATE_LOG_FLUSH_ONE_REC);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\trec = tl->tl_recs[i];\n\t\tstart_blk = ocfs2_clusters_to_blocks(data_alloc_inode->i_sb,\n\t\t\t\t\t\t    le32_to_cpu(rec.t_start));\n\t\tnum_clusters = le32_to_cpu(rec.t_clusters);\n\n\t\t/* if start_blk is not set, we ignore the record as\n\t\t * invalid. */\n\t\tif (start_blk) {\n\t\t\ttrace_ocfs2_replay_truncate_records(\n\t\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\t\ti, le32_to_cpu(rec.t_start), num_clusters);\n\n\t\t\tstatus = ocfs2_free_clusters(handle, data_alloc_inode,\n\t\t\t\t\t\t     data_alloc_bh, start_blk,\n\t\t\t\t\t\t     num_clusters);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\ti--;\n\t}\n\n\tosb->truncated_clusters = 0;\n\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_truncate_log_append",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "5808-5882",
    "snippet": "int ocfs2_truncate_log_append(struct ocfs2_super *osb,\n\t\t\t      handle_t *handle,\n\t\t\t      u64 start_blk,\n\t\t\t      unsigned int num_clusters)\n{\n\tint status, index;\n\tunsigned int start_cluster, tl_count;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(mutex_trylock(&tl_inode->i_mutex));\n\n\tstart_cluster = ocfs2_blocks_to_clusters(osb->sb, start_blk);\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\ttl_count = le16_to_cpu(tl->tl_count);\n\tmlog_bug_on_msg(tl_count > ocfs2_truncate_recs_per_inode(osb->sb) ||\n\t\t\ttl_count == 0,\n\t\t\t\"Truncate record count on #%llu invalid \"\n\t\t\t\"wanted %u, actual %u\\n\",\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tocfs2_truncate_recs_per_inode(osb->sb),\n\t\t\tle16_to_cpu(tl->tl_count));\n\n\t/* Caller should have known to flush before calling us. */\n\tindex = le16_to_cpu(tl->tl_used);\n\tif (index >= tl_count) {\n\t\tstatus = -ENOSPC;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_truncate_log_append(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno, index,\n\t\tstart_cluster, num_clusters);\n\tif (ocfs2_truncate_log_can_coalesce(tl, start_cluster)) {\n\t\t/*\n\t\t * Move index back to the record we are coalescing with.\n\t\t * ocfs2_truncate_log_can_coalesce() guarantees nonzero\n\t\t */\n\t\tindex--;\n\n\t\tnum_clusters += le32_to_cpu(tl->tl_recs[index].t_clusters);\n\t\ttrace_ocfs2_truncate_log_append(\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tindex, le32_to_cpu(tl->tl_recs[index].t_start),\n\t\t\tnum_clusters);\n\t} else {\n\t\ttl->tl_recs[index].t_start = cpu_to_le32(start_cluster);\n\t\ttl->tl_used = cpu_to_le16(index + 1);\n\t}\n\ttl->tl_recs[index].t_clusters = cpu_to_le32(num_clusters);\n\n\tocfs2_journal_dirty(handle, tl_bh);\n\n\tosb->truncated_clusters += num_clusters;\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "tl_bh"
          ],
          "line": 5877
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "num_clusters"
          ],
          "line": 5875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "index + 1"
          ],
          "line": 5873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "start_cluster"
          ],
          "line": 5872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_truncate_log_append",
          "args": [
            "(unsigned long long)OCFS2_I(tl_inode)->ip_blkno",
            "index",
            "le32_to_cpu(tl->tl_recs[index].t_start)",
            "num_clusters"
          ],
          "line": 5867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "tl->tl_recs[index].t_start"
          ],
          "line": 5869
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "tl_inode"
          ],
          "line": 5868
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_log_can_coalesce",
          "args": [
            "tl",
            "start_cluster"
          ],
          "line": 5859
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_log_can_coalesce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5791-5806",
          "snippet": "static int ocfs2_truncate_log_can_coalesce(struct ocfs2_truncate_log *tl,\n\t\t\t\t\t   unsigned int new_start)\n{\n\tunsigned int tail_index;\n\tunsigned int current_tail;\n\n\t/* No records, nothing to coalesce */\n\tif (!le16_to_cpu(tl->tl_used))\n\t\treturn 0;\n\n\ttail_index = le16_to_cpu(tl->tl_used) - 1;\n\tcurrent_tail = le32_to_cpu(tl->tl_recs[tail_index].t_start);\n\tcurrent_tail += le32_to_cpu(tl->tl_recs[tail_index].t_clusters);\n\n\treturn current_tail == new_start;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_truncate_log_can_coalesce(struct ocfs2_truncate_log *tl,\n\t\t\t\t\t   unsigned int new_start)\n{\n\tunsigned int tail_index;\n\tunsigned int current_tail;\n\n\t/* No records, nothing to coalesce */\n\tif (!le16_to_cpu(tl->tl_used))\n\t\treturn 0;\n\n\ttail_index = le16_to_cpu(tl->tl_used) - 1;\n\tcurrent_tail = le32_to_cpu(tl->tl_recs[tail_index].t_start);\n\tcurrent_tail += le32_to_cpu(tl->tl_recs[tail_index].t_clusters);\n\n\treturn current_tail == new_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_truncate_log_append",
          "args": [
            "(unsigned long long)OCFS2_I(tl_inode)->ip_blkno",
            "index",
            "start_cluster",
            "num_clusters"
          ],
          "line": 5856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 5852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(tl_inode)",
            "tl_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 5849
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "tl_inode"
          ],
          "line": 5849
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 5845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "tl->tl_used"
          ],
          "line": 5842
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "tl_count > ocfs2_truncate_recs_per_inode(osb->sb) ||\n\t\t\ttl_count == 0",
            "\"Truncate record count on #%llu invalid \"\n\t\t\t\"wanted %u, actual %u\\n\"",
            "(unsigned long long)OCFS2_I(tl_inode)->ip_blkno",
            "ocfs2_truncate_recs_per_inode(osb->sb)",
            "le16_to_cpu(tl->tl_count)"
          ],
          "line": 5833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_recs_per_inode",
          "args": [
            "osb->sb"
          ],
          "line": 5838
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_recs_per_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1567-1575",
          "snippet": "static inline int ocfs2_truncate_recs_per_inode(int blocksize)\n{\n\tint size;\n\n\tsize = blocksize -\n\t\toffsetof(struct ocfs2_dinode, id2.i_dealloc.tl_recs);\n\n\treturn size / sizeof(struct ocfs2_truncate_rec);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_truncate_recs_per_inode(int blocksize)\n{\n\tint size;\n\n\tsize = blocksize -\n\t\toffsetof(struct ocfs2_dinode, id2.i_dealloc.tl_recs);\n\n\treturn size / sizeof(struct ocfs2_truncate_rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!OCFS2_IS_VALID_DINODE(di)"
          ],
          "line": 5829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_DINODE",
          "args": [
            "di"
          ],
          "line": 5829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_to_clusters",
          "args": [
            "osb->sb",
            "start_blk"
          ],
          "line": 5822
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "720-727",
          "snippet": "static inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mutex_trylock(&tl_inode->i_mutex)"
          ],
          "line": 5820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&tl_inode->i_mutex"
          ],
          "line": 5820
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_truncate_log_append(struct ocfs2_super *osb,\n\t\t\t      handle_t *handle,\n\t\t\t      u64 start_blk,\n\t\t\t      unsigned int num_clusters)\n{\n\tint status, index;\n\tunsigned int start_cluster, tl_count;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(mutex_trylock(&tl_inode->i_mutex));\n\n\tstart_cluster = ocfs2_blocks_to_clusters(osb->sb, start_blk);\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\ttl_count = le16_to_cpu(tl->tl_count);\n\tmlog_bug_on_msg(tl_count > ocfs2_truncate_recs_per_inode(osb->sb) ||\n\t\t\ttl_count == 0,\n\t\t\t\"Truncate record count on #%llu invalid \"\n\t\t\t\"wanted %u, actual %u\\n\",\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tocfs2_truncate_recs_per_inode(osb->sb),\n\t\t\tle16_to_cpu(tl->tl_count));\n\n\t/* Caller should have known to flush before calling us. */\n\tindex = le16_to_cpu(tl->tl_used);\n\tif (index >= tl_count) {\n\t\tstatus = -ENOSPC;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_truncate_log_append(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno, index,\n\t\tstart_cluster, num_clusters);\n\tif (ocfs2_truncate_log_can_coalesce(tl, start_cluster)) {\n\t\t/*\n\t\t * Move index back to the record we are coalescing with.\n\t\t * ocfs2_truncate_log_can_coalesce() guarantees nonzero\n\t\t */\n\t\tindex--;\n\n\t\tnum_clusters += le32_to_cpu(tl->tl_recs[index].t_clusters);\n\t\ttrace_ocfs2_truncate_log_append(\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tindex, le32_to_cpu(tl->tl_recs[index].t_start),\n\t\t\tnum_clusters);\n\t} else {\n\t\ttl->tl_recs[index].t_start = cpu_to_le32(start_cluster);\n\t\ttl->tl_used = cpu_to_le16(index + 1);\n\t}\n\ttl->tl_recs[index].t_clusters = cpu_to_le32(num_clusters);\n\n\tocfs2_journal_dirty(handle, tl_bh);\n\n\tosb->truncated_clusters += num_clusters;\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_truncate_log_can_coalesce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "5791-5806",
    "snippet": "static int ocfs2_truncate_log_can_coalesce(struct ocfs2_truncate_log *tl,\n\t\t\t\t\t   unsigned int new_start)\n{\n\tunsigned int tail_index;\n\tunsigned int current_tail;\n\n\t/* No records, nothing to coalesce */\n\tif (!le16_to_cpu(tl->tl_used))\n\t\treturn 0;\n\n\ttail_index = le16_to_cpu(tl->tl_used) - 1;\n\tcurrent_tail = le32_to_cpu(tl->tl_recs[tail_index].t_start);\n\tcurrent_tail += le32_to_cpu(tl->tl_recs[tail_index].t_clusters);\n\n\treturn current_tail == new_start;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "tl->tl_recs[tail_index].t_clusters"
          ],
          "line": 5803
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "tl->tl_used"
          ],
          "line": 5801
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_truncate_log_can_coalesce(struct ocfs2_truncate_log *tl,\n\t\t\t\t\t   unsigned int new_start)\n{\n\tunsigned int tail_index;\n\tunsigned int current_tail;\n\n\t/* No records, nothing to coalesce */\n\tif (!le16_to_cpu(tl->tl_used))\n\t\treturn 0;\n\n\ttail_index = le16_to_cpu(tl->tl_used) - 1;\n\tcurrent_tail = le32_to_cpu(tl->tl_recs[tail_index].t_start);\n\tcurrent_tail += le32_to_cpu(tl->tl_recs[tail_index].t_clusters);\n\n\treturn current_tail == new_start;\n}"
  },
  {
    "function_name": "ocfs2_truncate_log_needs_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "5775-5789",
    "snippet": "int ocfs2_truncate_log_needs_flush(struct ocfs2_super *osb)\n{\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\n\tmlog_bug_on_msg(le16_to_cpu(tl->tl_used) > le16_to_cpu(tl->tl_count),\n\t\t\t\"slot %d, invalid truncate log parameters: used = \"\n\t\t\t\"%u, count = %u\\n\", osb->slot_num,\n\t\t\tle16_to_cpu(tl->tl_used), le16_to_cpu(tl->tl_count));\n\treturn le16_to_cpu(tl->tl_used) == le16_to_cpu(tl->tl_count);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "tl->tl_count"
          ],
          "line": 5788
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "le16_to_cpu(tl->tl_used) > le16_to_cpu(tl->tl_count)",
            "\"slot %d, invalid truncate log parameters: used = \"\n\t\t\t\"%u, count = %u\\n\"",
            "osb->slot_num",
            "le16_to_cpu(tl->tl_used)",
            "le16_to_cpu(tl->tl_count)"
          ],
          "line": 5784
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_truncate_log_needs_flush(struct ocfs2_super *osb)\n{\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\n\tmlog_bug_on_msg(le16_to_cpu(tl->tl_used) > le16_to_cpu(tl->tl_count),\n\t\t\t\"slot %d, invalid truncate log parameters: used = \"\n\t\t\t\"%u, count = %u\\n\", osb->slot_num,\n\t\t\tle16_to_cpu(tl->tl_used), le16_to_cpu(tl->tl_count));\n\treturn le16_to_cpu(tl->tl_used) == le16_to_cpu(tl->tl_count);\n}"
  },
  {
    "function_name": "ocfs2_remove_btree_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "5661-5773",
    "snippet": "int ocfs2_remove_btree_range(struct inode *inode,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     u32 cpos, u32 phys_cpos, u32 len, int flags,\n\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t     u64 refcount_loc, bool refcount_tree_locked)\n{\n\tint ret, credits = 0, extra_blocks = 0;\n\tu64 phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\thandle_t *handle;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tif ((flags & OCFS2_EXT_REFCOUNTED) && len) {\n\t\tBUG_ON(!(OCFS2_I(inode)->ip_dyn_features &\n\t\t\t OCFS2_HAS_REFCOUNT_FL));\n\n\t\tif (!refcount_tree_locked) {\n\t\t\tret = ocfs2_lock_refcount_tree(osb, refcount_loc, 1,\n\t\t\t\t\t\t       &ref_tree, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tret = ocfs2_prepare_refcount_change_for_del(inode,\n\t\t\t\t\t\t\t    refcount_loc,\n\t\t\t\t\t\t\t    phys_blkno,\n\t\t\t\t\t\t\t    len,\n\t\t\t\t\t\t\t    &credits,\n\t\t\t\t\t\t\t    &extra_blocks);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tret = ocfs2_reserve_blocks_for_rec_trunc(inode, et, 1, &meta_ac,\n\t\t\t\t\t\t extra_blocks);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\tocfs2_remove_extent_credits(osb->sb) + credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tdquot_free_space_nodirty(inode,\n\t\t\t\t  ocfs2_clusters_to_bytes(inode->i_sb, len));\n\n\tret = ocfs2_remove_extent(handle, et, cpos, len, meta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_et_update_clusters(et, -len);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\tif (phys_blkno) {\n\t\tif (flags & OCFS2_EXT_REFCOUNTED)\n\t\t\tret = ocfs2_decrease_refcount(inode, handle,\n\t\t\t\t\tocfs2_blocks_to_clusters(osb->sb,\n\t\t\t\t\t\t\t\t phys_blkno),\n\t\t\t\t\tlen, meta_ac,\n\t\t\t\t\tdealloc, 1);\n\t\telse\n\t\t\tret = ocfs2_truncate_log_append(osb, handle,\n\t\t\t\t\t\t\tphys_blkno, len);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tmutex_unlock(&tl_inode->i_mutex);\nbail:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_unlock_refcount_tree",
          "args": [
            "osb",
            "ref_tree",
            "1"
          ],
          "line": 5770
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "526-536",
          "snippet": "void ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nvoid ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "meta_ac"
          ],
          "line": 5767
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tl_inode->i_mutex"
          ],
          "line": 5764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 5762
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_log_append",
          "args": [
            "osb",
            "handle",
            "phys_blkno",
            "len"
          ],
          "line": 5754
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_log_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5808-5882",
          "snippet": "int ocfs2_truncate_log_append(struct ocfs2_super *osb,\n\t\t\t      handle_t *handle,\n\t\t\t      u64 start_blk,\n\t\t\t      unsigned int num_clusters)\n{\n\tint status, index;\n\tunsigned int start_cluster, tl_count;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(mutex_trylock(&tl_inode->i_mutex));\n\n\tstart_cluster = ocfs2_blocks_to_clusters(osb->sb, start_blk);\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\ttl_count = le16_to_cpu(tl->tl_count);\n\tmlog_bug_on_msg(tl_count > ocfs2_truncate_recs_per_inode(osb->sb) ||\n\t\t\ttl_count == 0,\n\t\t\t\"Truncate record count on #%llu invalid \"\n\t\t\t\"wanted %u, actual %u\\n\",\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tocfs2_truncate_recs_per_inode(osb->sb),\n\t\t\tle16_to_cpu(tl->tl_count));\n\n\t/* Caller should have known to flush before calling us. */\n\tindex = le16_to_cpu(tl->tl_used);\n\tif (index >= tl_count) {\n\t\tstatus = -ENOSPC;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_truncate_log_append(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno, index,\n\t\tstart_cluster, num_clusters);\n\tif (ocfs2_truncate_log_can_coalesce(tl, start_cluster)) {\n\t\t/*\n\t\t * Move index back to the record we are coalescing with.\n\t\t * ocfs2_truncate_log_can_coalesce() guarantees nonzero\n\t\t */\n\t\tindex--;\n\n\t\tnum_clusters += le32_to_cpu(tl->tl_recs[index].t_clusters);\n\t\ttrace_ocfs2_truncate_log_append(\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tindex, le32_to_cpu(tl->tl_recs[index].t_start),\n\t\t\tnum_clusters);\n\t} else {\n\t\ttl->tl_recs[index].t_start = cpu_to_le32(start_cluster);\n\t\ttl->tl_used = cpu_to_le16(index + 1);\n\t}\n\ttl->tl_recs[index].t_clusters = cpu_to_le32(num_clusters);\n\n\tocfs2_journal_dirty(handle, tl_bh);\n\n\tosb->truncated_clusters += num_clusters;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_truncate_log_append(struct ocfs2_super *osb,\n\t\t\t      handle_t *handle,\n\t\t\t      u64 start_blk,\n\t\t\t      unsigned int num_clusters)\n{\n\tint status, index;\n\tunsigned int start_cluster, tl_count;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(mutex_trylock(&tl_inode->i_mutex));\n\n\tstart_cluster = ocfs2_blocks_to_clusters(osb->sb, start_blk);\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\ttl_count = le16_to_cpu(tl->tl_count);\n\tmlog_bug_on_msg(tl_count > ocfs2_truncate_recs_per_inode(osb->sb) ||\n\t\t\ttl_count == 0,\n\t\t\t\"Truncate record count on #%llu invalid \"\n\t\t\t\"wanted %u, actual %u\\n\",\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tocfs2_truncate_recs_per_inode(osb->sb),\n\t\t\tle16_to_cpu(tl->tl_count));\n\n\t/* Caller should have known to flush before calling us. */\n\tindex = le16_to_cpu(tl->tl_used);\n\tif (index >= tl_count) {\n\t\tstatus = -ENOSPC;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_truncate_log_append(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno, index,\n\t\tstart_cluster, num_clusters);\n\tif (ocfs2_truncate_log_can_coalesce(tl, start_cluster)) {\n\t\t/*\n\t\t * Move index back to the record we are coalescing with.\n\t\t * ocfs2_truncate_log_can_coalesce() guarantees nonzero\n\t\t */\n\t\tindex--;\n\n\t\tnum_clusters += le32_to_cpu(tl->tl_recs[index].t_clusters);\n\t\ttrace_ocfs2_truncate_log_append(\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tindex, le32_to_cpu(tl->tl_recs[index].t_start),\n\t\t\tnum_clusters);\n\t} else {\n\t\ttl->tl_recs[index].t_start = cpu_to_le32(start_cluster);\n\t\ttl->tl_used = cpu_to_le16(index + 1);\n\t}\n\ttl->tl_recs[index].t_clusters = cpu_to_le32(num_clusters);\n\n\tocfs2_journal_dirty(handle, tl_bh);\n\n\tosb->truncated_clusters += num_clusters;\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_decrease_refcount",
          "args": [
            "inode",
            "handle",
            "ocfs2_blocks_to_clusters(osb->sb,\n\t\t\t\t\t\t\t\t phys_blkno)",
            "len",
            "meta_ac",
            "dealloc",
            "1"
          ],
          "line": 5748
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_decrease_refcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "2300-2340",
          "snippet": "int ocfs2_decrease_refcount(struct inode *inode,\n\t\t\t    handle_t *handle, u32 cpos, u32 len,\n\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t    int delete)\n{\n\tint ret;\n\tu64 ref_blkno;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_tree *tree;\n\n\tBUG_ON(!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\n\tret = ocfs2_get_refcount_block(inode, &ref_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_refcount_tree(OCFS2_SB(inode->i_sb), ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = __ocfs2_decrease_refcount(handle, &tree->rf_ci, ref_root_bh,\n\t\t\t\t\tcpos, len, meta_ac, dealloc, delete);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_decrease_refcount(struct inode *inode,\n\t\t\t    handle_t *handle, u32 cpos, u32 len,\n\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t    int delete)\n{\n\tint ret;\n\tu64 ref_blkno;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_tree *tree;\n\n\tBUG_ON(!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\n\tret = ocfs2_get_refcount_block(inode, &ref_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_refcount_tree(OCFS2_SB(inode->i_sb), ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = __ocfs2_decrease_refcount(handle, &tree->rf_ci, ref_root_bh,\n\t\t\t\t\tcpos, len, meta_ac, dealloc, delete);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_to_clusters",
          "args": [
            "osb->sb",
            "phys_blkno"
          ],
          "line": 5749
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "720-727",
          "snippet": "static inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "et->et_root_bh"
          ],
          "line": 5744
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_inode_fsync_trans",
          "args": [
            "handle",
            "inode",
            "1"
          ],
          "line": 5742
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "634-643",
          "snippet": "static inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_et_update_clusters",
          "args": [
            "et",
            "-len"
          ],
          "line": 5741
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_update_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "509-513",
          "snippet": "static inline void ocfs2_et_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u32 clusters)\n{\n\tet->et_ops->eo_update_clusters(et, clusters);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic inline void ocfs2_et_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u32 clusters)\n{\n\tet->et_ops->eo_update_clusters(et, clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_extent",
          "args": [
            "handle",
            "et",
            "cpos",
            "len",
            "meta_ac",
            "dealloc"
          ],
          "line": 5735
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5470-5607",
          "snippet": "int ocfs2_remove_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos, u32 len,\n\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, index;\n\tu32 rec_range, trunc_range;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *path = NULL;\n\n\t/*\n\t * XXX: Why are we truncating to 0 instead of wherever this\n\t * affects us?\n\t */\n\tocfs2_et_extent_map_truncate(et, 0);\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t    \"Owner %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\",\n\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t    cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We have 3 cases of extent removal:\n\t *   1) Range covers the entire extent rec\n\t *   2) Range begins or ends on one edge of the extent rec\n\t *   3) Range is in the middle of the extent rec (no shared edges)\n\t *\n\t * For case 1 we remove the extent rec and left rotate to\n\t * fill the hole.\n\t *\n\t * For case 2 we just shrink the existing extent rec, with a\n\t * tree update if the shrinking edge is also the edge of an\n\t * extent block.\n\t *\n\t * For case 3 we do a right split to turn the extent rec into\n\t * something case 2 can handle.\n\t */\n\trec = &el->l_recs[index];\n\trec_range = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\ttrunc_range = cpos + len;\n\n\tBUG_ON(cpos < le32_to_cpu(rec->e_cpos) || trunc_range > rec_range);\n\n\ttrace_ocfs2_remove_extent(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, len, index, le32_to_cpu(rec->e_cpos),\n\t\tocfs2_rec_clusters(el, rec));\n\n\tif (le32_to_cpu(rec->e_cpos) == cpos || rec_range == trunc_range) {\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tret = ocfs2_split_tree(handle, et, path, index,\n\t\t\t\t       trunc_range, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * The split could have manipulated the tree enough to\n\t\t * move the record location, so we have to look for it again.\n\t\t */\n\t\tocfs2_reinit_path(path, 1);\n\n\t\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tel = path_leaf_el(path);\n\t\tindex = ocfs2_search_extent_list(el, cpos);\n\t\tif (index == -1) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: split at cpos %u lost record.\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Double check our values here. If anything is fishy,\n\t\t * it's easier to catch it at the top level.\n\t\t */\n\t\trec = &el->l_recs[index];\n\t\trec_range = le32_to_cpu(rec->e_cpos) +\n\t\t\tocfs2_rec_clusters(el, rec);\n\t\tif (rec_range != trunc_range) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: error after split at cpos %u\"\n\t\t\t\t    \"trunc len %u, existing record is (%u,%u)\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos, len, le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_remove_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos, u32 len,\n\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, index;\n\tu32 rec_range, trunc_range;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *path = NULL;\n\n\t/*\n\t * XXX: Why are we truncating to 0 instead of wherever this\n\t * affects us?\n\t */\n\tocfs2_et_extent_map_truncate(et, 0);\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t    \"Owner %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\",\n\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t    cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We have 3 cases of extent removal:\n\t *   1) Range covers the entire extent rec\n\t *   2) Range begins or ends on one edge of the extent rec\n\t *   3) Range is in the middle of the extent rec (no shared edges)\n\t *\n\t * For case 1 we remove the extent rec and left rotate to\n\t * fill the hole.\n\t *\n\t * For case 2 we just shrink the existing extent rec, with a\n\t * tree update if the shrinking edge is also the edge of an\n\t * extent block.\n\t *\n\t * For case 3 we do a right split to turn the extent rec into\n\t * something case 2 can handle.\n\t */\n\trec = &el->l_recs[index];\n\trec_range = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\ttrunc_range = cpos + len;\n\n\tBUG_ON(cpos < le32_to_cpu(rec->e_cpos) || trunc_range > rec_range);\n\n\ttrace_ocfs2_remove_extent(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, len, index, le32_to_cpu(rec->e_cpos),\n\t\tocfs2_rec_clusters(el, rec));\n\n\tif (le32_to_cpu(rec->e_cpos) == cpos || rec_range == trunc_range) {\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tret = ocfs2_split_tree(handle, et, path, index,\n\t\t\t\t       trunc_range, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * The split could have manipulated the tree enough to\n\t\t * move the record location, so we have to look for it again.\n\t\t */\n\t\tocfs2_reinit_path(path, 1);\n\n\t\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tel = path_leaf_el(path);\n\t\tindex = ocfs2_search_extent_list(el, cpos);\n\t\tif (index == -1) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: split at cpos %u lost record.\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Double check our values here. If anything is fishy,\n\t\t * it's easier to catch it at the top level.\n\t\t */\n\t\trec = &el->l_recs[index];\n\t\trec_range = le32_to_cpu(rec->e_cpos) +\n\t\t\tocfs2_rec_clusters(el, rec);\n\t\tif (rec_range != trunc_range) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: error after split at cpos %u\"\n\t\t\t\t    \"trunc len %u, existing record is (%u,%u)\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos, len, le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_space_nodirty",
          "args": [
            "inode",
            "ocfs2_clusters_to_bytes(inode->i_sb, len)"
          ],
          "line": 5732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_bytes",
          "args": [
            "inode->i_sb",
            "len"
          ],
          "line": 5733
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "759-763",
          "snippet": "static inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_et_root_journal_access",
          "args": [
            "handle",
            "et",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 5725
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_root_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "529-535",
          "snippet": "static inline int ocfs2_et_root_journal_access(handle_t *handle,\n\t\t\t\t\t       struct ocfs2_extent_tree *et,\n\t\t\t\t\t       int type)\n{\n\treturn et->et_root_journal_access(handle, et->et_ci, et->et_root_bh,\n\t\t\t\t\t  type);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic inline int ocfs2_et_root_journal_access(handle_t *handle,\n\t\t\t\t\t       struct ocfs2_extent_tree *et,\n\t\t\t\t\t       int type)\n{\n\treturn et->et_root_journal_access(handle, et->et_ci, et->et_root_bh,\n\t\t\t\t\t  type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 5720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 5719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "ocfs2_remove_extent_credits(osb->sb) + credits"
          ],
          "line": 5717
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_extent_credits",
          "args": [
            "osb->sb"
          ],
          "line": 5718
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_extent_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "412-416",
          "snippet": "static inline int ocfs2_remove_extent_credits(struct super_block *sb)\n{\n\treturn OCFS2_TRUNCATE_LOG_UPDATE + OCFS2_INODE_UPDATE_CREDITS +\n\t       ocfs2_quota_trans_credits(sb);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_TRUNCATE_LOG_UPDATE OCFS2_INODE_UPDATE_CREDITS",
            "#define OCFS2_INODE_UPDATE_CREDITS 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_TRUNCATE_LOG_UPDATE OCFS2_INODE_UPDATE_CREDITS\n#define OCFS2_INODE_UPDATE_CREDITS 1\n\nstatic inline int ocfs2_remove_extent_credits(struct super_block *sb)\n{\n\treturn OCFS2_TRUNCATE_LOG_UPDATE + OCFS2_INODE_UPDATE_CREDITS +\n\t       ocfs2_quota_trans_credits(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_flush_truncate_log",
          "args": [
            "osb"
          ],
          "line": 5710
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_flush_truncate_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5956-6028",
          "snippet": "int __ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tunsigned int num_to_flush;\n\thandle_t *handle;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *data_alloc_inode = NULL;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct buffer_head *data_alloc_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(mutex_trylock(&tl_inode->i_mutex));\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tnum_to_flush = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_flush_truncate_log(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\tnum_to_flush);\n\tif (!num_to_flush) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\tdata_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!data_alloc_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get bitmap inode!\\n\");\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&data_alloc_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(data_alloc_inode, &data_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_unlock;\n\t}\n\n\tstatus = ocfs2_replay_truncate_records(osb, handle, data_alloc_inode,\n\t\t\t\t\t       data_alloc_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tbrelse(data_alloc_bh);\n\tocfs2_inode_unlock(data_alloc_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&data_alloc_inode->i_mutex);\n\tiput(data_alloc_inode);\n\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint __ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tunsigned int num_to_flush;\n\thandle_t *handle;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *data_alloc_inode = NULL;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct buffer_head *data_alloc_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(mutex_trylock(&tl_inode->i_mutex));\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tnum_to_flush = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_flush_truncate_log(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\tnum_to_flush);\n\tif (!num_to_flush) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\tdata_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!data_alloc_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get bitmap inode!\\n\");\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&data_alloc_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(data_alloc_inode, &data_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_unlock;\n\t}\n\n\tstatus = ocfs2_replay_truncate_records(osb, handle, data_alloc_inode,\n\t\t\t\t\t       data_alloc_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tbrelse(data_alloc_bh);\n\tocfs2_inode_unlock(data_alloc_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&data_alloc_inode->i_mutex);\n\tiput(data_alloc_inode);\n\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_log_needs_flush",
          "args": [
            "osb"
          ],
          "line": 5709
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_log_needs_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5775-5789",
          "snippet": "int ocfs2_truncate_log_needs_flush(struct ocfs2_super *osb)\n{\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\n\tmlog_bug_on_msg(le16_to_cpu(tl->tl_used) > le16_to_cpu(tl->tl_count),\n\t\t\t\"slot %d, invalid truncate log parameters: used = \"\n\t\t\t\"%u, count = %u\\n\", osb->slot_num,\n\t\t\tle16_to_cpu(tl->tl_used), le16_to_cpu(tl->tl_count));\n\treturn le16_to_cpu(tl->tl_used) == le16_to_cpu(tl->tl_count);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_truncate_log_needs_flush(struct ocfs2_super *osb)\n{\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\n\tmlog_bug_on_msg(le16_to_cpu(tl->tl_used) > le16_to_cpu(tl->tl_count),\n\t\t\t\"slot %d, invalid truncate log parameters: used = \"\n\t\t\t\"%u, count = %u\\n\", osb->slot_num,\n\t\t\tle16_to_cpu(tl->tl_used), le16_to_cpu(tl->tl_count));\n\treturn le16_to_cpu(tl->tl_used) == le16_to_cpu(tl->tl_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tl_inode->i_mutex"
          ],
          "line": 5707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_blocks_for_rec_trunc",
          "args": [
            "inode",
            "et",
            "1",
            "&meta_ac",
            "extra_blocks"
          ],
          "line": 5700
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_blocks_for_rec_trunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5618-5659",
          "snippet": "static int ocfs2_reserve_blocks_for_rec_trunc(struct inode *inode,\n\t\t\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t\t\t      u32 extents_to_split,\n\t\t\t\t\t      struct ocfs2_alloc_context **ac,\n\t\t\t\t\t      int extra_blocks)\n{\n\tint ret = 0, num_free_extents;\n\tunsigned int max_recs_needed = 2 * extents_to_split;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t*ac = NULL;\n\n\tnum_free_extents = ocfs2_num_free_extents(osb, et);\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!num_free_extents ||\n\t    (ocfs2_sparse_alloc(osb) && num_free_extents < max_recs_needed))\n\t\textra_blocks += ocfs2_extend_meta_needed(et->et_root_el);\n\n\tif (extra_blocks) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(osb, extra_blocks, ac);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tif (ret) {\n\t\tif (*ac) {\n\t\t\tocfs2_free_alloc_context(*ac);\n\t\t\t*ac = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_reserve_blocks_for_rec_trunc(struct inode *inode,\n\t\t\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t\t\t      u32 extents_to_split,\n\t\t\t\t\t      struct ocfs2_alloc_context **ac,\n\t\t\t\t\t      int extra_blocks)\n{\n\tint ret = 0, num_free_extents;\n\tunsigned int max_recs_needed = 2 * extents_to_split;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t*ac = NULL;\n\n\tnum_free_extents = ocfs2_num_free_extents(osb, et);\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!num_free_extents ||\n\t    (ocfs2_sparse_alloc(osb) && num_free_extents < max_recs_needed))\n\t\textra_blocks += ocfs2_extend_meta_needed(et->et_root_el);\n\n\tif (extra_blocks) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(osb, extra_blocks, ac);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tif (ret) {\n\t\tif (*ac) {\n\t\t\tocfs2_free_alloc_context(*ac);\n\t\t\t*ac = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_prepare_refcount_change_for_del",
          "args": [
            "inode",
            "refcount_loc",
            "phys_blkno",
            "len",
            "&credits",
            "&extra_blocks"
          ],
          "line": 5688
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_prepare_refcount_change_for_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "2536-2588",
          "snippet": "int ocfs2_prepare_refcount_change_for_del(struct inode *inode,\n\t\t\t\t\t  u64 refcount_loc,\n\t\t\t\t\t  u64 phys_blkno,\n\t\t\t\t\t  u32 clusters,\n\t\t\t\t\t  int *credits,\n\t\t\t\t\t  int *ref_blocks)\n{\n\tint ret;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_tree *tree;\n\tu64 start_cpos = ocfs2_blocks_to_clusters(inode->i_sb, phys_blkno);\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb))) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu want to use refcount \"\n\t\t\t    \"tree, but the feature bit is not set in the \"\n\t\t\t    \"super block.\", inode->i_ino);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tBUG_ON(!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\n\tret = ocfs2_get_refcount_tree(OCFS2_SB(inode->i_sb),\n\t\t\t\t      refcount_loc, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, refcount_loc,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_calc_refcount_meta_credits(inode->i_sb,\n\t\t\t\t\t       &tree->rf_ci,\n\t\t\t\t\t       ref_root_bh,\n\t\t\t\t\t       start_cpos, clusters,\n\t\t\t\t\t       ref_blocks, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_prepare_refcount_change_for_del(*ref_blocks, *credits);\n\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_prepare_refcount_change_for_del(struct inode *inode,\n\t\t\t\t\t  u64 refcount_loc,\n\t\t\t\t\t  u64 phys_blkno,\n\t\t\t\t\t  u32 clusters,\n\t\t\t\t\t  int *credits,\n\t\t\t\t\t  int *ref_blocks)\n{\n\tint ret;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_tree *tree;\n\tu64 start_cpos = ocfs2_blocks_to_clusters(inode->i_sb, phys_blkno);\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb))) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu want to use refcount \"\n\t\t\t    \"tree, but the feature bit is not set in the \"\n\t\t\t    \"super block.\", inode->i_ino);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tBUG_ON(!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\n\tret = ocfs2_get_refcount_tree(OCFS2_SB(inode->i_sb),\n\t\t\t\t      refcount_loc, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, refcount_loc,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_calc_refcount_meta_credits(inode->i_sb,\n\t\t\t\t\t       &tree->rf_ci,\n\t\t\t\t\t       ref_root_bh,\n\t\t\t\t\t       start_cpos, clusters,\n\t\t\t\t\t       ref_blocks, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_prepare_refcount_change_for_del(*ref_blocks, *credits);\n\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_refcount_tree",
          "args": [
            "osb",
            "refcount_loc",
            "1",
            "&ref_tree",
            "NULL"
          ],
          "line": 5680
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "452-524",
          "snippet": "int ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(OCFS2_I(inode)->ip_dyn_features &\n\t\t\t OCFS2_HAS_REFCOUNT_FL)"
          ],
          "line": 5676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 5676
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 5669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "inode->i_sb",
            "phys_cpos"
          ],
          "line": 5668
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_remove_btree_range(struct inode *inode,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     u32 cpos, u32 phys_cpos, u32 len, int flags,\n\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t     u64 refcount_loc, bool refcount_tree_locked)\n{\n\tint ret, credits = 0, extra_blocks = 0;\n\tu64 phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\thandle_t *handle;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tif ((flags & OCFS2_EXT_REFCOUNTED) && len) {\n\t\tBUG_ON(!(OCFS2_I(inode)->ip_dyn_features &\n\t\t\t OCFS2_HAS_REFCOUNT_FL));\n\n\t\tif (!refcount_tree_locked) {\n\t\t\tret = ocfs2_lock_refcount_tree(osb, refcount_loc, 1,\n\t\t\t\t\t\t       &ref_tree, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tret = ocfs2_prepare_refcount_change_for_del(inode,\n\t\t\t\t\t\t\t    refcount_loc,\n\t\t\t\t\t\t\t    phys_blkno,\n\t\t\t\t\t\t\t    len,\n\t\t\t\t\t\t\t    &credits,\n\t\t\t\t\t\t\t    &extra_blocks);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tret = ocfs2_reserve_blocks_for_rec_trunc(inode, et, 1, &meta_ac,\n\t\t\t\t\t\t extra_blocks);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\tocfs2_remove_extent_credits(osb->sb) + credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tdquot_free_space_nodirty(inode,\n\t\t\t\t  ocfs2_clusters_to_bytes(inode->i_sb, len));\n\n\tret = ocfs2_remove_extent(handle, et, cpos, len, meta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_et_update_clusters(et, -len);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\tif (phys_blkno) {\n\t\tif (flags & OCFS2_EXT_REFCOUNTED)\n\t\t\tret = ocfs2_decrease_refcount(inode, handle,\n\t\t\t\t\tocfs2_blocks_to_clusters(osb->sb,\n\t\t\t\t\t\t\t\t phys_blkno),\n\t\t\t\t\tlen, meta_ac,\n\t\t\t\t\tdealloc, 1);\n\t\telse\n\t\t\tret = ocfs2_truncate_log_append(osb, handle,\n\t\t\t\t\t\t\tphys_blkno, len);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tmutex_unlock(&tl_inode->i_mutex);\nbail:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_reserve_blocks_for_rec_trunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "5618-5659",
    "snippet": "static int ocfs2_reserve_blocks_for_rec_trunc(struct inode *inode,\n\t\t\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t\t\t      u32 extents_to_split,\n\t\t\t\t\t      struct ocfs2_alloc_context **ac,\n\t\t\t\t\t      int extra_blocks)\n{\n\tint ret = 0, num_free_extents;\n\tunsigned int max_recs_needed = 2 * extents_to_split;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t*ac = NULL;\n\n\tnum_free_extents = ocfs2_num_free_extents(osb, et);\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!num_free_extents ||\n\t    (ocfs2_sparse_alloc(osb) && num_free_extents < max_recs_needed))\n\t\textra_blocks += ocfs2_extend_meta_needed(et->et_root_el);\n\n\tif (extra_blocks) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(osb, extra_blocks, ac);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tif (ret) {\n\t\tif (*ac) {\n\t\t\tocfs2_free_alloc_context(*ac);\n\t\t\t*ac = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "*ac"
          ],
          "line": 5653
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_new_metadata_blocks",
          "args": [
            "osb",
            "extra_blocks",
            "ac"
          ],
          "line": 5642
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_new_metadata_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "989-1049",
          "snippet": "int ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_MAX_TO_STEAL\t\t1024",
            "#define ALLOC_GROUPS_FROM_GLOBAL\t0x2",
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_MAX_TO_STEAL\t\t1024\n#define ALLOC_GROUPS_FROM_GLOBAL\t0x2\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_meta_needed",
          "args": [
            "et->et_root_el"
          ],
          "line": 5639
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_meta_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "157-168",
          "snippet": "static inline int ocfs2_extend_meta_needed(struct ocfs2_extent_list *root_el)\n{\n\t/*\n\t * Rather than do all the work of determining how much we need\n\t * (involves a ton of reads and locks), just ask for the\n\t * maximal limit.  That's a tree depth shift.  So, one block for\n\t * level of the tree (current l_tree_depth), one block for the\n\t * new tree_depth==0 extent_block, and one block at the new\n\t * top-of-the tree.\n\t */\n\treturn le16_to_cpu(root_el->l_tree_depth) + 2;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_extend_meta_needed(struct ocfs2_extent_list *root_el)\n{\n\t/*\n\t * Rather than do all the work of determining how much we need\n\t * (involves a ton of reads and locks), just ask for the\n\t * maximal limit.  That's a tree depth shift.  So, one block for\n\t * level of the tree (current l_tree_depth), one block for the\n\t * new tree_depth==0 extent_block, and one block at the new\n\t * top-of-the tree.\n\t */\n\treturn le16_to_cpu(root_el->l_tree_depth) + 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_sparse_alloc",
          "args": [
            "osb"
          ],
          "line": 5638
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sparse_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "483-488",
          "snippet": "static inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_num_free_extents",
          "args": [
            "osb",
            "et"
          ],
          "line": 5630
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_num_free_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "959-990",
          "snippet": "int ocfs2_num_free_extents(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_extent_tree *et)\n{\n\tint retval;\n\tstruct ocfs2_extent_list *el = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct buffer_head *eb_bh = NULL;\n\tu64 last_eb_blk = 0;\n\n\tel = et->et_root_el;\n\tlast_eb_blk = ocfs2_et_get_last_eb_blk(et);\n\n\tif (last_eb_blk) {\n\t\tretval = ocfs2_read_extent_block(et->et_ci, last_eb_blk,\n\t\t\t\t\t\t &eb_bh);\n\t\tif (retval < 0) {\n\t\t\tmlog_errno(retval);\n\t\t\tgoto bail;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\tBUG_ON(el->l_tree_depth != 0);\n\n\tretval = le16_to_cpu(el->l_count) - le16_to_cpu(el->l_next_free_rec);\nbail:\n\tbrelse(eb_bh);\n\n\ttrace_ocfs2_num_free_extents(retval);\n\treturn retval;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nint ocfs2_num_free_extents(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_extent_tree *et)\n{\n\tint retval;\n\tstruct ocfs2_extent_list *el = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct buffer_head *eb_bh = NULL;\n\tu64 last_eb_blk = 0;\n\n\tel = et->et_root_el;\n\tlast_eb_blk = ocfs2_et_get_last_eb_blk(et);\n\n\tif (last_eb_blk) {\n\t\tretval = ocfs2_read_extent_block(et->et_ci, last_eb_blk,\n\t\t\t\t\t\t &eb_bh);\n\t\tif (retval < 0) {\n\t\t\tmlog_errno(retval);\n\t\t\tgoto bail;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\tBUG_ON(el->l_tree_depth != 0);\n\n\tretval = le16_to_cpu(el->l_count) - le16_to_cpu(el->l_next_free_rec);\nbail:\n\tbrelse(eb_bh);\n\n\ttrace_ocfs2_num_free_extents(retval);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 5626
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_reserve_blocks_for_rec_trunc(struct inode *inode,\n\t\t\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t\t\t      u32 extents_to_split,\n\t\t\t\t\t      struct ocfs2_alloc_context **ac,\n\t\t\t\t\t      int extra_blocks)\n{\n\tint ret = 0, num_free_extents;\n\tunsigned int max_recs_needed = 2 * extents_to_split;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t*ac = NULL;\n\n\tnum_free_extents = ocfs2_num_free_extents(osb, et);\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!num_free_extents ||\n\t    (ocfs2_sparse_alloc(osb) && num_free_extents < max_recs_needed))\n\t\textra_blocks += ocfs2_extend_meta_needed(et->et_root_el);\n\n\tif (extra_blocks) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(osb, extra_blocks, ac);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tif (ret) {\n\t\tif (*ac) {\n\t\t\tocfs2_free_alloc_context(*ac);\n\t\t\t*ac = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_remove_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "5470-5607",
    "snippet": "int ocfs2_remove_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos, u32 len,\n\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, index;\n\tu32 rec_range, trunc_range;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *path = NULL;\n\n\t/*\n\t * XXX: Why are we truncating to 0 instead of wherever this\n\t * affects us?\n\t */\n\tocfs2_et_extent_map_truncate(et, 0);\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t    \"Owner %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\",\n\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t    cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We have 3 cases of extent removal:\n\t *   1) Range covers the entire extent rec\n\t *   2) Range begins or ends on one edge of the extent rec\n\t *   3) Range is in the middle of the extent rec (no shared edges)\n\t *\n\t * For case 1 we remove the extent rec and left rotate to\n\t * fill the hole.\n\t *\n\t * For case 2 we just shrink the existing extent rec, with a\n\t * tree update if the shrinking edge is also the edge of an\n\t * extent block.\n\t *\n\t * For case 3 we do a right split to turn the extent rec into\n\t * something case 2 can handle.\n\t */\n\trec = &el->l_recs[index];\n\trec_range = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\ttrunc_range = cpos + len;\n\n\tBUG_ON(cpos < le32_to_cpu(rec->e_cpos) || trunc_range > rec_range);\n\n\ttrace_ocfs2_remove_extent(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, len, index, le32_to_cpu(rec->e_cpos),\n\t\tocfs2_rec_clusters(el, rec));\n\n\tif (le32_to_cpu(rec->e_cpos) == cpos || rec_range == trunc_range) {\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tret = ocfs2_split_tree(handle, et, path, index,\n\t\t\t\t       trunc_range, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * The split could have manipulated the tree enough to\n\t\t * move the record location, so we have to look for it again.\n\t\t */\n\t\tocfs2_reinit_path(path, 1);\n\n\t\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tel = path_leaf_el(path);\n\t\tindex = ocfs2_search_extent_list(el, cpos);\n\t\tif (index == -1) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: split at cpos %u lost record.\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Double check our values here. If anything is fishy,\n\t\t * it's easier to catch it at the top level.\n\t\t */\n\t\trec = &el->l_recs[index];\n\t\trec_range = le32_to_cpu(rec->e_cpos) +\n\t\t\tocfs2_rec_clusters(el, rec);\n\t\tif (rec_range != trunc_range) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: error after split at cpos %u\"\n\t\t\t\t    \"trunc len %u, existing record is (%u,%u)\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos, len, le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "path"
          ],
          "line": 5605
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "609-615",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_rec",
          "args": [
            "handle",
            "et",
            "path",
            "index",
            "dealloc",
            "cpos",
            "len"
          ],
          "line": 5596
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5312-5468",
          "snippet": "static int ocfs2_truncate_rec(handle_t *handle,\n\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t      struct ocfs2_path *path, int index,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t      u32 cpos, u32 len)\n{\n\tint ret;\n\tu32 left_cpos, rec_range, trunc_range;\n\tint wants_rotate = 0, is_rightmost_tree_rec = 0;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_block *eb;\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0]) && index > 0) {\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tindex--;\n\t}\n\n\tif (index == (le16_to_cpu(el->l_next_free_rec) - 1) &&\n\t    path->p_tree_depth) {\n\t\t/*\n\t\t * Check whether this is the rightmost tree record. If\n\t\t * we remove all of this record or part of its right\n\t\t * edge then an update of the record lengths above it\n\t\t * will be required.\n\t\t */\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\t\tif (eb->h_next_leaf_blk == 0)\n\t\t\tis_rightmost_tree_rec = 1;\n\t}\n\n\trec = &el->l_recs[index];\n\tif (index == 0 && path->p_tree_depth &&\n\t    le32_to_cpu(rec->e_cpos) == cpos) {\n\t\t/*\n\t\t * Changing the leftmost offset (via partial or whole\n\t\t * record truncate) of an interior (or rightmost) path\n\t\t * means we have to update the subtree that is formed\n\t\t * by this leaf and the one to it's left.\n\t\t *\n\t\t * There are two cases we can skip:\n\t\t *   1) Path is the leftmost one in our btree.\n\t\t *   2) The leaf is rightmost and will be empty after\n\t\t *      we remove the extent record - the rotate code\n\t\t *      knows how to update the newly formed edge.\n\t\t */\n\n\t\tret = ocfs2_find_cpos_for_left_leaf(sb, path, &left_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (left_cpos && le16_to_cpu(el->l_next_free_rec) > 1) {\n\t\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\t\tif (!left_path) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_find_path(et->et_ci, left_path,\n\t\t\t\t\t      left_cpos);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t      path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\trec_range = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\ttrunc_range = cpos + len;\n\n\tif (le32_to_cpu(rec->e_cpos) == cpos && rec_range == trunc_range) {\n\t\tint next_free;\n\n\t\tmemset(rec, 0, sizeof(*rec));\n\t\tocfs2_cleanup_merge(el, index);\n\t\twants_rotate = 1;\n\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tif (is_rightmost_tree_rec && next_free > 1) {\n\t\t\t/*\n\t\t\t * We skip the edge update if this path will\n\t\t\t * be deleted by the rotate code.\n\t\t\t */\n\t\t\trec = &el->l_recs[next_free - 1];\n\t\t\tocfs2_adjust_rightmost_records(handle, et, path,\n\t\t\t\t\t\t       rec);\n\t\t}\n\t} else if (le32_to_cpu(rec->e_cpos) == cpos) {\n\t\t/* Remove leftmost portion of the record. */\n\t\tle32_add_cpu(&rec->e_cpos, len);\n\t\tle64_add_cpu(&rec->e_blkno, ocfs2_clusters_to_blocks(sb, len));\n\t\tle16_add_cpu(&rec->e_leaf_clusters, -len);\n\t} else if (rec_range == trunc_range) {\n\t\t/* Remove rightmost portion of the record */\n\t\tle16_add_cpu(&rec->e_leaf_clusters, -len);\n\t\tif (is_rightmost_tree_rec)\n\t\t\tocfs2_adjust_rightmost_records(handle, et, path, rec);\n\t} else {\n\t\t/* Caller should have trapped this. */\n\t\tmlog(ML_ERROR, \"Owner %llu: Invalid record truncate: (%u, %u) \"\n\t\t     \"(%u, %u)\\n\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     le32_to_cpu(rec->e_cpos),\n\t\t     le16_to_cpu(rec->e_leaf_clusters), cpos, len);\n\t\tBUG();\n\t}\n\n\tif (left_path) {\n\t\tint subtree_index;\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path, path);\n\t\tocfs2_complete_edge_insert(handle, left_path, path,\n\t\t\t\t\t   subtree_index);\n\t}\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(path));\n\n\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_truncate_rec(handle_t *handle,\n\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t      struct ocfs2_path *path, int index,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t      u32 cpos, u32 len)\n{\n\tint ret;\n\tu32 left_cpos, rec_range, trunc_range;\n\tint wants_rotate = 0, is_rightmost_tree_rec = 0;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_block *eb;\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0]) && index > 0) {\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tindex--;\n\t}\n\n\tif (index == (le16_to_cpu(el->l_next_free_rec) - 1) &&\n\t    path->p_tree_depth) {\n\t\t/*\n\t\t * Check whether this is the rightmost tree record. If\n\t\t * we remove all of this record or part of its right\n\t\t * edge then an update of the record lengths above it\n\t\t * will be required.\n\t\t */\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\t\tif (eb->h_next_leaf_blk == 0)\n\t\t\tis_rightmost_tree_rec = 1;\n\t}\n\n\trec = &el->l_recs[index];\n\tif (index == 0 && path->p_tree_depth &&\n\t    le32_to_cpu(rec->e_cpos) == cpos) {\n\t\t/*\n\t\t * Changing the leftmost offset (via partial or whole\n\t\t * record truncate) of an interior (or rightmost) path\n\t\t * means we have to update the subtree that is formed\n\t\t * by this leaf and the one to it's left.\n\t\t *\n\t\t * There are two cases we can skip:\n\t\t *   1) Path is the leftmost one in our btree.\n\t\t *   2) The leaf is rightmost and will be empty after\n\t\t *      we remove the extent record - the rotate code\n\t\t *      knows how to update the newly formed edge.\n\t\t */\n\n\t\tret = ocfs2_find_cpos_for_left_leaf(sb, path, &left_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (left_cpos && le16_to_cpu(el->l_next_free_rec) > 1) {\n\t\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\t\tif (!left_path) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_find_path(et->et_ci, left_path,\n\t\t\t\t\t      left_cpos);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t      path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\trec_range = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\ttrunc_range = cpos + len;\n\n\tif (le32_to_cpu(rec->e_cpos) == cpos && rec_range == trunc_range) {\n\t\tint next_free;\n\n\t\tmemset(rec, 0, sizeof(*rec));\n\t\tocfs2_cleanup_merge(el, index);\n\t\twants_rotate = 1;\n\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tif (is_rightmost_tree_rec && next_free > 1) {\n\t\t\t/*\n\t\t\t * We skip the edge update if this path will\n\t\t\t * be deleted by the rotate code.\n\t\t\t */\n\t\t\trec = &el->l_recs[next_free - 1];\n\t\t\tocfs2_adjust_rightmost_records(handle, et, path,\n\t\t\t\t\t\t       rec);\n\t\t}\n\t} else if (le32_to_cpu(rec->e_cpos) == cpos) {\n\t\t/* Remove leftmost portion of the record. */\n\t\tle32_add_cpu(&rec->e_cpos, len);\n\t\tle64_add_cpu(&rec->e_blkno, ocfs2_clusters_to_blocks(sb, len));\n\t\tle16_add_cpu(&rec->e_leaf_clusters, -len);\n\t} else if (rec_range == trunc_range) {\n\t\t/* Remove rightmost portion of the record */\n\t\tle16_add_cpu(&rec->e_leaf_clusters, -len);\n\t\tif (is_rightmost_tree_rec)\n\t\t\tocfs2_adjust_rightmost_records(handle, et, path, rec);\n\t} else {\n\t\t/* Caller should have trapped this. */\n\t\tmlog(ML_ERROR, \"Owner %llu: Invalid record truncate: (%u, %u) \"\n\t\t     \"(%u, %u)\\n\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     le32_to_cpu(rec->e_cpos),\n\t\t     le16_to_cpu(rec->e_leaf_clusters), cpos, len);\n\t\tBUG();\n\t}\n\n\tif (left_path) {\n\t\tint subtree_index;\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path, path);\n\t\tocfs2_complete_edge_insert(handle, left_path, path,\n\t\t\t\t\t   subtree_index);\n\t}\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(path));\n\n\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "\"Owner %llu: error after split at cpos %u\"\n\t\t\t\t    \"trunc len %u, existing record is (%u,%u)\"",
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "cpos",
            "len",
            "le32_to_cpu(rec->e_cpos)",
            "ocfs2_rec_clusters(el, rec)"
          ],
          "line": 5586
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_rec_clusters",
          "args": [
            "el",
            "rec"
          ],
          "line": 5591
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rec_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "246-260",
          "snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 5590
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 5589
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 5586
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_search_extent_list",
          "args": [
            "el",
            "cpos"
          ],
          "line": 5568
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_search_extent_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "773-795",
          "snippet": "int ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nint ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 5567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "et->et_ci",
            "path",
            "cpos"
          ],
          "line": 5561
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1885-1894",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_reinit_path",
          "args": [
            "path",
            "1"
          ],
          "line": 5559
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reinit_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "580-607",
          "snippet": "void ocfs2_reinit_path(struct ocfs2_path *path, int keep_root)\n{\n\tint i, start = 0, depth = 0;\n\tstruct ocfs2_path_item *node;\n\n\tif (keep_root)\n\t\tstart = 1;\n\n\tfor(i = start; i < path_num_items(path); i++) {\n\t\tnode = &path->p_node[i];\n\n\t\tbrelse(node->bh);\n\t\tnode->bh = NULL;\n\t\tnode->el = NULL;\n\t}\n\n\t/*\n\t * Tree depth may change during truncate, or insert. If we're\n\t * keeping the root extent list, then make sure that our path\n\t * structure reflects the proper depth.\n\t */\n\tif (keep_root)\n\t\tdepth = le16_to_cpu(path_root_el(path)->l_tree_depth);\n\telse\n\t\tpath_root_access(path) = NULL;\n\n\tpath->p_tree_depth = depth;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_reinit_path(struct ocfs2_path *path, int keep_root)\n{\n\tint i, start = 0, depth = 0;\n\tstruct ocfs2_path_item *node;\n\n\tif (keep_root)\n\t\tstart = 1;\n\n\tfor(i = start; i < path_num_items(path); i++) {\n\t\tnode = &path->p_node[i];\n\n\t\tbrelse(node->bh);\n\t\tnode->bh = NULL;\n\t\tnode->el = NULL;\n\t}\n\n\t/*\n\t * Tree depth may change during truncate, or insert. If we're\n\t * keeping the root extent list, then make sure that our path\n\t * structure reflects the proper depth.\n\t */\n\tif (keep_root)\n\t\tdepth = le16_to_cpu(path_root_el(path)->l_tree_depth);\n\telse\n\t\tpath_root_access(path) = NULL;\n\n\tpath->p_tree_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_split_tree",
          "args": [
            "handle",
            "et",
            "path",
            "index",
            "trunc_range",
            "meta_ac"
          ],
          "line": 5548
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_split_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5243-5310",
          "snippet": "static int ocfs2_split_tree(handle_t *handle, struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *path,\n\t\t\t    int index, u32 new_range,\n\t\t\t    struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret, depth, credits;\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *rightmost_el, *el;\n\tstruct ocfs2_extent_rec split_rec;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_insert_type insert;\n\n\t/*\n\t * Setup the record to split before we grow the tree.\n\t */\n\tel = path_leaf_el(path);\n\trec = &el->l_recs[index];\n\tocfs2_make_right_split_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t   &split_rec, new_range, rec);\n\n\tdepth = path->p_tree_depth;\n\tif (depth > 0) {\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &last_eb_bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) last_eb_bh->b_data;\n\t\trightmost_el = &eb->h_list;\n\t} else\n\t\trightmost_el = path_leaf_el(path);\n\n\tcredits = path->p_tree_depth +\n\t\t  ocfs2_extend_meta_needed(et->et_root_el);\n\tret = ocfs2_extend_trans(handle, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(rightmost_el->l_next_free_rec) ==\n\t    le16_to_cpu(rightmost_el->l_count)) {\n\t\tret = ocfs2_grow_tree(handle, et, &depth, &last_eb_bh,\n\t\t\t\t      meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemset(&insert, 0, sizeof(struct ocfs2_insert_type));\n\tinsert.ins_appending = APPEND_NONE;\n\tinsert.ins_contig = CONTIG_NONE;\n\tinsert.ins_split = SPLIT_RIGHT;\n\tinsert.ins_tree_depth = depth;\n\n\tret = ocfs2_do_insert_extent(handle, et, &split_rec, &insert);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tbrelse(last_eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_split_tree(handle_t *handle, struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *path,\n\t\t\t    int index, u32 new_range,\n\t\t\t    struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret, depth, credits;\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *rightmost_el, *el;\n\tstruct ocfs2_extent_rec split_rec;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_insert_type insert;\n\n\t/*\n\t * Setup the record to split before we grow the tree.\n\t */\n\tel = path_leaf_el(path);\n\trec = &el->l_recs[index];\n\tocfs2_make_right_split_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t   &split_rec, new_range, rec);\n\n\tdepth = path->p_tree_depth;\n\tif (depth > 0) {\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &last_eb_bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) last_eb_bh->b_data;\n\t\trightmost_el = &eb->h_list;\n\t} else\n\t\trightmost_el = path_leaf_el(path);\n\n\tcredits = path->p_tree_depth +\n\t\t  ocfs2_extend_meta_needed(et->et_root_el);\n\tret = ocfs2_extend_trans(handle, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(rightmost_el->l_next_free_rec) ==\n\t    le16_to_cpu(rightmost_el->l_count)) {\n\t\tret = ocfs2_grow_tree(handle, et, &depth, &last_eb_bh,\n\t\t\t\t      meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemset(&insert, 0, sizeof(struct ocfs2_insert_type));\n\tinsert.ins_appending = APPEND_NONE;\n\tinsert.ins_contig = CONTIG_NONE;\n\tinsert.ins_split = SPLIT_RIGHT;\n\tinsert.ins_tree_depth = depth;\n\n\tret = ocfs2_do_insert_extent(handle, et, &split_rec, &insert);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tbrelse(last_eb_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_remove_extent",
          "args": [
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "cpos",
            "len",
            "index",
            "le32_to_cpu(rec->e_cpos)",
            "ocfs2_rec_clusters(el, rec)"
          ],
          "line": 5535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cpos < le32_to_cpu(rec->e_cpos) || trunc_range > rec_range"
          ],
          "line": 5533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 5501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_et",
          "args": [
            "et"
          ],
          "line": 5488
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_et",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "713-717",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstruct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_et_extent_map_truncate",
          "args": [
            "et",
            "0"
          ],
          "line": 5486
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_extent_map_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "522-527",
          "snippet": "static inline void ocfs2_et_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t\tu32 clusters)\n{\n\tif (et->et_ops->eo_extent_map_truncate)\n\t\tet->et_ops->eo_extent_map_truncate(et, clusters);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic inline void ocfs2_et_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t\tu32 clusters)\n{\n\tif (et->et_ops->eo_extent_map_truncate)\n\t\tet->et_ops->eo_extent_map_truncate(et, clusters);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_remove_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos, u32 len,\n\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, index;\n\tu32 rec_range, trunc_range;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *path = NULL;\n\n\t/*\n\t * XXX: Why are we truncating to 0 instead of wherever this\n\t * affects us?\n\t */\n\tocfs2_et_extent_map_truncate(et, 0);\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t    \"Owner %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\",\n\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t    cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We have 3 cases of extent removal:\n\t *   1) Range covers the entire extent rec\n\t *   2) Range begins or ends on one edge of the extent rec\n\t *   3) Range is in the middle of the extent rec (no shared edges)\n\t *\n\t * For case 1 we remove the extent rec and left rotate to\n\t * fill the hole.\n\t *\n\t * For case 2 we just shrink the existing extent rec, with a\n\t * tree update if the shrinking edge is also the edge of an\n\t * extent block.\n\t *\n\t * For case 3 we do a right split to turn the extent rec into\n\t * something case 2 can handle.\n\t */\n\trec = &el->l_recs[index];\n\trec_range = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\ttrunc_range = cpos + len;\n\n\tBUG_ON(cpos < le32_to_cpu(rec->e_cpos) || trunc_range > rec_range);\n\n\ttrace_ocfs2_remove_extent(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, len, index, le32_to_cpu(rec->e_cpos),\n\t\tocfs2_rec_clusters(el, rec));\n\n\tif (le32_to_cpu(rec->e_cpos) == cpos || rec_range == trunc_range) {\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tret = ocfs2_split_tree(handle, et, path, index,\n\t\t\t\t       trunc_range, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * The split could have manipulated the tree enough to\n\t\t * move the record location, so we have to look for it again.\n\t\t */\n\t\tocfs2_reinit_path(path, 1);\n\n\t\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tel = path_leaf_el(path);\n\t\tindex = ocfs2_search_extent_list(el, cpos);\n\t\tif (index == -1) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: split at cpos %u lost record.\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Double check our values here. If anything is fishy,\n\t\t * it's easier to catch it at the top level.\n\t\t */\n\t\trec = &el->l_recs[index];\n\t\trec_range = le32_to_cpu(rec->e_cpos) +\n\t\t\tocfs2_rec_clusters(el, rec);\n\t\tif (rec_range != trunc_range) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: error after split at cpos %u\"\n\t\t\t\t    \"trunc len %u, existing record is (%u,%u)\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos, len, le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_truncate_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "5312-5468",
    "snippet": "static int ocfs2_truncate_rec(handle_t *handle,\n\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t      struct ocfs2_path *path, int index,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t      u32 cpos, u32 len)\n{\n\tint ret;\n\tu32 left_cpos, rec_range, trunc_range;\n\tint wants_rotate = 0, is_rightmost_tree_rec = 0;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_block *eb;\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0]) && index > 0) {\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tindex--;\n\t}\n\n\tif (index == (le16_to_cpu(el->l_next_free_rec) - 1) &&\n\t    path->p_tree_depth) {\n\t\t/*\n\t\t * Check whether this is the rightmost tree record. If\n\t\t * we remove all of this record or part of its right\n\t\t * edge then an update of the record lengths above it\n\t\t * will be required.\n\t\t */\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\t\tif (eb->h_next_leaf_blk == 0)\n\t\t\tis_rightmost_tree_rec = 1;\n\t}\n\n\trec = &el->l_recs[index];\n\tif (index == 0 && path->p_tree_depth &&\n\t    le32_to_cpu(rec->e_cpos) == cpos) {\n\t\t/*\n\t\t * Changing the leftmost offset (via partial or whole\n\t\t * record truncate) of an interior (or rightmost) path\n\t\t * means we have to update the subtree that is formed\n\t\t * by this leaf and the one to it's left.\n\t\t *\n\t\t * There are two cases we can skip:\n\t\t *   1) Path is the leftmost one in our btree.\n\t\t *   2) The leaf is rightmost and will be empty after\n\t\t *      we remove the extent record - the rotate code\n\t\t *      knows how to update the newly formed edge.\n\t\t */\n\n\t\tret = ocfs2_find_cpos_for_left_leaf(sb, path, &left_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (left_cpos && le16_to_cpu(el->l_next_free_rec) > 1) {\n\t\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\t\tif (!left_path) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_find_path(et->et_ci, left_path,\n\t\t\t\t\t      left_cpos);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t      path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\trec_range = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\ttrunc_range = cpos + len;\n\n\tif (le32_to_cpu(rec->e_cpos) == cpos && rec_range == trunc_range) {\n\t\tint next_free;\n\n\t\tmemset(rec, 0, sizeof(*rec));\n\t\tocfs2_cleanup_merge(el, index);\n\t\twants_rotate = 1;\n\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tif (is_rightmost_tree_rec && next_free > 1) {\n\t\t\t/*\n\t\t\t * We skip the edge update if this path will\n\t\t\t * be deleted by the rotate code.\n\t\t\t */\n\t\t\trec = &el->l_recs[next_free - 1];\n\t\t\tocfs2_adjust_rightmost_records(handle, et, path,\n\t\t\t\t\t\t       rec);\n\t\t}\n\t} else if (le32_to_cpu(rec->e_cpos) == cpos) {\n\t\t/* Remove leftmost portion of the record. */\n\t\tle32_add_cpu(&rec->e_cpos, len);\n\t\tle64_add_cpu(&rec->e_blkno, ocfs2_clusters_to_blocks(sb, len));\n\t\tle16_add_cpu(&rec->e_leaf_clusters, -len);\n\t} else if (rec_range == trunc_range) {\n\t\t/* Remove rightmost portion of the record */\n\t\tle16_add_cpu(&rec->e_leaf_clusters, -len);\n\t\tif (is_rightmost_tree_rec)\n\t\t\tocfs2_adjust_rightmost_records(handle, et, path, rec);\n\t} else {\n\t\t/* Caller should have trapped this. */\n\t\tmlog(ML_ERROR, \"Owner %llu: Invalid record truncate: (%u, %u) \"\n\t\t     \"(%u, %u)\\n\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     le32_to_cpu(rec->e_cpos),\n\t\t     le16_to_cpu(rec->e_leaf_clusters), cpos, len);\n\t\tBUG();\n\t}\n\n\tif (left_path) {\n\t\tint subtree_index;\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path, path);\n\t\tocfs2_complete_edge_insert(handle, left_path, path,\n\t\t\t\t\t   subtree_index);\n\t}\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(path));\n\n\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "left_path"
          ],
          "line": 5466
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "609-615",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rotate_tree_left",
          "args": [
            "handle",
            "et",
            "path",
            "dealloc"
          ],
          "line": 5459
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rotate_tree_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "3149-3259",
          "snippet": "static int ocfs2_rotate_tree_left(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_path *path,\n\t\t\t\t  struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, orig_credits = handle->h_buffer_credits;\n\tstruct ocfs2_path *tmp_path = NULL, *restart_path = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\tel = path_leaf_el(path);\n\tif (!ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn 0;\n\n\tif (path->p_tree_depth == 0) {\nrightmost_no_delete:\n\t\t/*\n\t\t * Inline extents. This is trivially handled, so do\n\t\t * it up front.\n\t\t */\n\t\tret = ocfs2_rotate_rightmost_leaf_left(handle, et, path);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Handle rightmost branch now. There's several cases:\n\t *  1) simple rotation leaving records in there. That's trivial.\n\t *  2) rotation requiring a branch delete - there's no more\n\t *     records left. Two cases of this:\n\t *     a) There are branches to the left.\n\t *     b) This is also the leftmost (the only) branch.\n\t *\n\t *  1) is handled via ocfs2_rotate_rightmost_leaf_left()\n\t *  2a) we need the left branch so that we can update it with the unlink\n\t *  2b) we need to bring the root back to inline extents.\n\t */\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\tel = &eb->h_list;\n\tif (eb->h_next_leaf_blk == 0) {\n\t\t/*\n\t\t * This gets a bit tricky if we're going to delete the\n\t\t * rightmost path. Get the other cases out of the way\n\t\t * 1st.\n\t\t */\n\t\tif (le16_to_cpu(el->l_next_free_rec) > 1)\n\t\t\tgoto rightmost_no_delete;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tret = -EIO;\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has empty extent block at %llu\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    (unsigned long long)le64_to_cpu(eb->h_blkno));\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * XXX: The caller can not trust \"path\" any more after\n\t\t * this as it will have been deleted. What do we do?\n\t\t *\n\t\t * In theory the rotate-for-merge code will never get\n\t\t * here because it'll always ask for a rotate in a\n\t\t * nonempty list.\n\t\t */\n\n\t\tret = ocfs2_remove_rightmost_path(handle, et, path,\n\t\t\t\t\t\t  dealloc);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Now we can loop, remembering the path we get from -EAGAIN\n\t * and restarting from there.\n\t */\ntry_rotate:\n\tret = __ocfs2_rotate_tree_left(handle, et, orig_credits, path,\n\t\t\t\t       dealloc, &restart_path);\n\tif (ret && ret != -EAGAIN) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (ret == -EAGAIN) {\n\t\ttmp_path = restart_path;\n\t\trestart_path = NULL;\n\n\t\tret = __ocfs2_rotate_tree_left(handle, et, orig_credits,\n\t\t\t\t\t       tmp_path, dealloc,\n\t\t\t\t\t       &restart_path);\n\t\tif (ret && ret != -EAGAIN) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tocfs2_free_path(tmp_path);\n\t\ttmp_path = NULL;\n\n\t\tif (ret == 0)\n\t\t\tgoto try_rotate;\n\t}\n\nout:\n\tocfs2_free_path(tmp_path);\n\tocfs2_free_path(restart_path);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_rotate_tree_left(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_path *path,\n\t\t\t\t  struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, orig_credits = handle->h_buffer_credits;\n\tstruct ocfs2_path *tmp_path = NULL, *restart_path = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\tel = path_leaf_el(path);\n\tif (!ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn 0;\n\n\tif (path->p_tree_depth == 0) {\nrightmost_no_delete:\n\t\t/*\n\t\t * Inline extents. This is trivially handled, so do\n\t\t * it up front.\n\t\t */\n\t\tret = ocfs2_rotate_rightmost_leaf_left(handle, et, path);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Handle rightmost branch now. There's several cases:\n\t *  1) simple rotation leaving records in there. That's trivial.\n\t *  2) rotation requiring a branch delete - there's no more\n\t *     records left. Two cases of this:\n\t *     a) There are branches to the left.\n\t *     b) This is also the leftmost (the only) branch.\n\t *\n\t *  1) is handled via ocfs2_rotate_rightmost_leaf_left()\n\t *  2a) we need the left branch so that we can update it with the unlink\n\t *  2b) we need to bring the root back to inline extents.\n\t */\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\tel = &eb->h_list;\n\tif (eb->h_next_leaf_blk == 0) {\n\t\t/*\n\t\t * This gets a bit tricky if we're going to delete the\n\t\t * rightmost path. Get the other cases out of the way\n\t\t * 1st.\n\t\t */\n\t\tif (le16_to_cpu(el->l_next_free_rec) > 1)\n\t\t\tgoto rightmost_no_delete;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tret = -EIO;\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has empty extent block at %llu\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    (unsigned long long)le64_to_cpu(eb->h_blkno));\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * XXX: The caller can not trust \"path\" any more after\n\t\t * this as it will have been deleted. What do we do?\n\t\t *\n\t\t * In theory the rotate-for-merge code will never get\n\t\t * here because it'll always ask for a rotate in a\n\t\t * nonempty list.\n\t\t */\n\n\t\tret = ocfs2_remove_rightmost_path(handle, et, path,\n\t\t\t\t\t\t  dealloc);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Now we can loop, remembering the path we get from -EAGAIN\n\t * and restarting from there.\n\t */\ntry_rotate:\n\tret = __ocfs2_rotate_tree_left(handle, et, orig_credits, path,\n\t\t\t\t       dealloc, &restart_path);\n\tif (ret && ret != -EAGAIN) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (ret == -EAGAIN) {\n\t\ttmp_path = restart_path;\n\t\trestart_path = NULL;\n\n\t\tret = __ocfs2_rotate_tree_left(handle, et, orig_credits,\n\t\t\t\t\t       tmp_path, dealloc,\n\t\t\t\t\t       &restart_path);\n\t\tif (ret && ret != -EAGAIN) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tocfs2_free_path(tmp_path);\n\t\ttmp_path = NULL;\n\n\t\tif (ret == 0)\n\t\t\tgoto try_rotate;\n\t}\n\nout:\n\tocfs2_free_path(tmp_path);\n\tocfs2_free_path(restart_path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "path_leaf_bh(path)"
          ],
          "line": 5457
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "path"
          ],
          "line": 5457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_complete_edge_insert",
          "args": [
            "handle",
            "left_path",
            "path",
            "subtree_index"
          ],
          "line": 5453
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_complete_edge_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2030-2099",
          "snippet": "static void ocfs2_complete_edge_insert(handle_t *handle,\n\t\t\t\t       struct ocfs2_path *left_path,\n\t\t\t\t       struct ocfs2_path *right_path,\n\t\t\t\t       int subtree_index)\n{\n\tint i, idx;\n\tstruct ocfs2_extent_list *el, *left_el, *right_el;\n\tstruct ocfs2_extent_rec *left_rec, *right_rec;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\n\t/*\n\t * Update the counts and position values within all the\n\t * interior nodes to reflect the leaf rotation we just did.\n\t *\n\t * The root node is handled below the loop.\n\t *\n\t * We begin the loop with right_el and left_el pointing to the\n\t * leaf lists and work our way up.\n\t *\n\t * NOTE: within this loop, left_el and right_el always refer\n\t * to the *child* lists.\n\t */\n\tleft_el = path_leaf_el(left_path);\n\tright_el = path_leaf_el(right_path);\n\tfor(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {\n\t\ttrace_ocfs2_complete_edge_insert(i);\n\n\t\t/*\n\t\t * One nice property of knowing that all of these\n\t\t * nodes are below the root is that we only deal with\n\t\t * the leftmost right node record and the rightmost\n\t\t * left node record.\n\t\t */\n\t\tel = left_path->p_node[i].el;\n\t\tidx = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\t\tleft_rec = &el->l_recs[idx];\n\n\t\tel = right_path->p_node[i].el;\n\t\tright_rec = &el->l_recs[0];\n\n\t\tocfs2_adjust_adjacent_records(left_rec, left_el, right_rec,\n\t\t\t\t\t      right_el);\n\n\t\tocfs2_journal_dirty(handle, left_path->p_node[i].bh);\n\t\tocfs2_journal_dirty(handle, right_path->p_node[i].bh);\n\n\t\t/*\n\t\t * Setup our list pointers now so that the current\n\t\t * parents become children in the next iteration.\n\t\t */\n\t\tleft_el = left_path->p_node[i].el;\n\t\tright_el = right_path->p_node[i].el;\n\t}\n\n\t/*\n\t * At the root node, adjust the two adjacent records which\n\t * begin our path to the leaves.\n\t */\n\n\tel = left_path->p_node[subtree_index].el;\n\tleft_el = left_path->p_node[subtree_index + 1].el;\n\tright_el = right_path->p_node[subtree_index + 1].el;\n\n\tocfs2_adjust_root_records(el, left_el, right_el,\n\t\t\t\t  left_path->p_node[subtree_index + 1].bh->b_blocknr);\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\n\tocfs2_journal_dirty(handle, root_bh);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_complete_edge_insert(handle_t *handle,\n\t\t\t\t       struct ocfs2_path *left_path,\n\t\t\t\t       struct ocfs2_path *right_path,\n\t\t\t\t       int subtree_index)\n{\n\tint i, idx;\n\tstruct ocfs2_extent_list *el, *left_el, *right_el;\n\tstruct ocfs2_extent_rec *left_rec, *right_rec;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\n\t/*\n\t * Update the counts and position values within all the\n\t * interior nodes to reflect the leaf rotation we just did.\n\t *\n\t * The root node is handled below the loop.\n\t *\n\t * We begin the loop with right_el and left_el pointing to the\n\t * leaf lists and work our way up.\n\t *\n\t * NOTE: within this loop, left_el and right_el always refer\n\t * to the *child* lists.\n\t */\n\tleft_el = path_leaf_el(left_path);\n\tright_el = path_leaf_el(right_path);\n\tfor(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {\n\t\ttrace_ocfs2_complete_edge_insert(i);\n\n\t\t/*\n\t\t * One nice property of knowing that all of these\n\t\t * nodes are below the root is that we only deal with\n\t\t * the leftmost right node record and the rightmost\n\t\t * left node record.\n\t\t */\n\t\tel = left_path->p_node[i].el;\n\t\tidx = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\t\tleft_rec = &el->l_recs[idx];\n\n\t\tel = right_path->p_node[i].el;\n\t\tright_rec = &el->l_recs[0];\n\n\t\tocfs2_adjust_adjacent_records(left_rec, left_el, right_rec,\n\t\t\t\t\t      right_el);\n\n\t\tocfs2_journal_dirty(handle, left_path->p_node[i].bh);\n\t\tocfs2_journal_dirty(handle, right_path->p_node[i].bh);\n\n\t\t/*\n\t\t * Setup our list pointers now so that the current\n\t\t * parents become children in the next iteration.\n\t\t */\n\t\tleft_el = left_path->p_node[i].el;\n\t\tright_el = right_path->p_node[i].el;\n\t}\n\n\t/*\n\t * At the root node, adjust the two adjacent records which\n\t * begin our path to the leaves.\n\t */\n\n\tel = left_path->p_node[subtree_index].el;\n\tleft_el = left_path->p_node[subtree_index + 1].el;\n\tright_el = right_path->p_node[subtree_index + 1].el;\n\n\tocfs2_adjust_root_records(el, left_el, right_el,\n\t\t\t\t  left_path->p_node[subtree_index + 1].bh->b_blocknr);\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\n\tocfs2_journal_dirty(handle, root_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_subtree_root",
          "args": [
            "et",
            "left_path",
            "path"
          ],
          "line": 5452
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_subtree_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1737-1765",
          "snippet": "int ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 5446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Owner %llu: Invalid record truncate: (%u, %u) \"\n\t\t     \"(%u, %u)\\n\"",
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "le32_to_cpu(rec->e_cpos)",
            "le16_to_cpu(rec->e_leaf_clusters)",
            "cpos",
            "len"
          ],
          "line": 5441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rec->e_leaf_clusters"
          ],
          "line": 5445
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 5444
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 5443
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_adjust_rightmost_records",
          "args": [
            "handle",
            "et",
            "path",
            "rec"
          ],
          "line": 5438
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_adjust_rightmost_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "3914-3950",
          "snippet": "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec)\n{\n\tint ret, i, next_free;\n\tstruct buffer_head *bh;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\t/*\n\t * Update everything except the leaf block.\n\t */\n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tbh = path->p_node[i].bh;\n\t\tel = path->p_node[i].el;\n\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tif (next_free == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has a bad extent list\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci));\n\t\t\tret = -EIO;\n\t\t\treturn;\n\t\t}\n\n\t\trec = &el->l_recs[next_free - 1];\n\n\t\trec->e_int_clusters = insert_rec->e_cpos;\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec)\n{\n\tint ret, i, next_free;\n\tstruct buffer_head *bh;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\t/*\n\t * Update everything except the leaf block.\n\t */\n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tbh = path->p_node[i].bh;\n\t\tel = path->p_node[i].el;\n\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tif (next_free == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has a bad extent list\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci));\n\t\t\tret = -EIO;\n\t\t\treturn;\n\t\t}\n\n\t\trec = &el->l_recs[next_free - 1];\n\n\t\trec->e_int_clusters = insert_rec->e_cpos;\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&rec->e_leaf_clusters",
            "-len"
          ],
          "line": 5436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&rec->e_leaf_clusters",
            "-len"
          ],
          "line": 5433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_add_cpu",
          "args": [
            "&rec->e_blkno",
            "ocfs2_clusters_to_blocks(sb, len)"
          ],
          "line": 5432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "sb",
            "len"
          ],
          "line": 5432
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&rec->e_cpos",
            "len"
          ],
          "line": 5431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cleanup_merge",
          "args": [
            "el",
            "index"
          ],
          "line": 5416
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cleanup_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "3261-3291",
          "snippet": "static void ocfs2_cleanup_merge(struct ocfs2_extent_list *el,\n\t\t\t\tint index)\n{\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[index];\n\tunsigned int size;\n\n\tif (rec->e_leaf_clusters == 0) {\n\t\t/*\n\t\t * We consumed all of the merged-from record. An empty\n\t\t * extent cannot exist anywhere but the 1st array\n\t\t * position, so move things over if the merged-from\n\t\t * record doesn't occupy that position.\n\t\t *\n\t\t * This creates a new empty extent so the caller\n\t\t * should be smart enough to have removed any existing\n\t\t * ones.\n\t\t */\n\t\tif (index > 0) {\n\t\t\tBUG_ON(ocfs2_is_empty_extent(&el->l_recs[0]));\n\t\t\tsize = index * sizeof(struct ocfs2_extent_rec);\n\t\t\tmemmove(&el->l_recs[1], &el->l_recs[0], size);\n\t\t}\n\n\t\t/*\n\t\t * Always memset - the caller doesn't check whether it\n\t\t * created an empty extent, so there could be junk in\n\t\t * the other fields.\n\t\t */\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic void ocfs2_cleanup_merge(struct ocfs2_extent_list *el,\n\t\t\t\tint index)\n{\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[index];\n\tunsigned int size;\n\n\tif (rec->e_leaf_clusters == 0) {\n\t\t/*\n\t\t * We consumed all of the merged-from record. An empty\n\t\t * extent cannot exist anywhere but the 1st array\n\t\t * position, so move things over if the merged-from\n\t\t * record doesn't occupy that position.\n\t\t *\n\t\t * This creates a new empty extent so the caller\n\t\t * should be smart enough to have removed any existing\n\t\t * ones.\n\t\t */\n\t\tif (index > 0) {\n\t\t\tBUG_ON(ocfs2_is_empty_extent(&el->l_recs[0]));\n\t\t\tsize = index * sizeof(struct ocfs2_extent_rec);\n\t\t\tmemmove(&el->l_recs[1], &el->l_recs[0], size);\n\t\t}\n\n\t\t/*\n\t\t * Always memset - the caller doesn't check whether it\n\t\t * created an empty extent, so there could be junk in\n\t\t * the other fields.\n\t\t */\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "rec",
            "0",
            "sizeof(*rec)"
          ],
          "line": 5415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rec_clusters",
          "args": [
            "el",
            "rec"
          ],
          "line": 5409
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rec_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "246-260",
          "snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_path",
          "args": [
            "et->et_ci",
            "handle",
            "left_path"
          ],
          "line": 5403
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "746-765",
          "snippet": "int ocfs2_journal_access_path(struct ocfs2_caching_info *ci,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_path *path)\n{\n\tint i, ret = 0;\n\n\tif (!path)\n\t\tgoto out;\n\n\tfor(i = 0; i < path_num_items(path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, ci, path, i);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_journal_access_path(struct ocfs2_caching_info *ci,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_path *path)\n{\n\tint i, ret = 0;\n\n\tif (!path)\n\t\tgoto out;\n\n\tfor(i = 0; i < path_num_items(path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, ci, path, i);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_rotate_transaction",
          "args": [
            "handle",
            "0",
            "handle->h_buffer_credits",
            "path"
          ],
          "line": 5389
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_rotate_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2279-2291",
          "snippet": "static int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,\n\t\t\t\t\t   int op_credits,\n\t\t\t\t\t   struct ocfs2_path *path)\n{\n\tint ret = 0;\n\tint credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;\n\n\tif (handle->h_buffer_credits < credits)\n\t\tret = ocfs2_extend_trans(handle,\n\t\t\t\t\t credits - handle->h_buffer_credits);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,\n\t\t\t\t\t   int op_credits,\n\t\t\t\t\t   struct ocfs2_path *path)\n{\n\tint ret = 0;\n\tint credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;\n\n\tif (handle->h_buffer_credits < credits)\n\t\tret = ocfs2_extend_trans(handle,\n\t\t\t\t\t credits - handle->h_buffer_credits);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "et->et_ci",
            "left_path",
            "left_cpos"
          ],
          "line": 5380
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1885-1894",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_path",
          "args": [
            "path"
          ],
          "line": 5373
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "707-711",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_cpos_for_left_leaf",
          "args": [
            "sb",
            "path",
            "&left_cpos"
          ],
          "line": 5366
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_cpos_for_left_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2205-2272",
          "snippet": "int ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "path"
          ],
          "line": 5345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&el->l_recs[0]"
          ],
          "line": 5327
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "266-269",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 5323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 5321
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_truncate_rec(handle_t *handle,\n\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t      struct ocfs2_path *path, int index,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t      u32 cpos, u32 len)\n{\n\tint ret;\n\tu32 left_cpos, rec_range, trunc_range;\n\tint wants_rotate = 0, is_rightmost_tree_rec = 0;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_block *eb;\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0]) && index > 0) {\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tindex--;\n\t}\n\n\tif (index == (le16_to_cpu(el->l_next_free_rec) - 1) &&\n\t    path->p_tree_depth) {\n\t\t/*\n\t\t * Check whether this is the rightmost tree record. If\n\t\t * we remove all of this record or part of its right\n\t\t * edge then an update of the record lengths above it\n\t\t * will be required.\n\t\t */\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\t\tif (eb->h_next_leaf_blk == 0)\n\t\t\tis_rightmost_tree_rec = 1;\n\t}\n\n\trec = &el->l_recs[index];\n\tif (index == 0 && path->p_tree_depth &&\n\t    le32_to_cpu(rec->e_cpos) == cpos) {\n\t\t/*\n\t\t * Changing the leftmost offset (via partial or whole\n\t\t * record truncate) of an interior (or rightmost) path\n\t\t * means we have to update the subtree that is formed\n\t\t * by this leaf and the one to it's left.\n\t\t *\n\t\t * There are two cases we can skip:\n\t\t *   1) Path is the leftmost one in our btree.\n\t\t *   2) The leaf is rightmost and will be empty after\n\t\t *      we remove the extent record - the rotate code\n\t\t *      knows how to update the newly formed edge.\n\t\t */\n\n\t\tret = ocfs2_find_cpos_for_left_leaf(sb, path, &left_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (left_cpos && le16_to_cpu(el->l_next_free_rec) > 1) {\n\t\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\t\tif (!left_path) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_find_path(et->et_ci, left_path,\n\t\t\t\t\t      left_cpos);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t      path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\trec_range = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\ttrunc_range = cpos + len;\n\n\tif (le32_to_cpu(rec->e_cpos) == cpos && rec_range == trunc_range) {\n\t\tint next_free;\n\n\t\tmemset(rec, 0, sizeof(*rec));\n\t\tocfs2_cleanup_merge(el, index);\n\t\twants_rotate = 1;\n\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tif (is_rightmost_tree_rec && next_free > 1) {\n\t\t\t/*\n\t\t\t * We skip the edge update if this path will\n\t\t\t * be deleted by the rotate code.\n\t\t\t */\n\t\t\trec = &el->l_recs[next_free - 1];\n\t\t\tocfs2_adjust_rightmost_records(handle, et, path,\n\t\t\t\t\t\t       rec);\n\t\t}\n\t} else if (le32_to_cpu(rec->e_cpos) == cpos) {\n\t\t/* Remove leftmost portion of the record. */\n\t\tle32_add_cpu(&rec->e_cpos, len);\n\t\tle64_add_cpu(&rec->e_blkno, ocfs2_clusters_to_blocks(sb, len));\n\t\tle16_add_cpu(&rec->e_leaf_clusters, -len);\n\t} else if (rec_range == trunc_range) {\n\t\t/* Remove rightmost portion of the record */\n\t\tle16_add_cpu(&rec->e_leaf_clusters, -len);\n\t\tif (is_rightmost_tree_rec)\n\t\t\tocfs2_adjust_rightmost_records(handle, et, path, rec);\n\t} else {\n\t\t/* Caller should have trapped this. */\n\t\tmlog(ML_ERROR, \"Owner %llu: Invalid record truncate: (%u, %u) \"\n\t\t     \"(%u, %u)\\n\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     le32_to_cpu(rec->e_cpos),\n\t\t     le16_to_cpu(rec->e_leaf_clusters), cpos, len);\n\t\tBUG();\n\t}\n\n\tif (left_path) {\n\t\tint subtree_index;\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path, path);\n\t\tocfs2_complete_edge_insert(handle, left_path, path,\n\t\t\t\t\t   subtree_index);\n\t}\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(path));\n\n\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_split_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "5243-5310",
    "snippet": "static int ocfs2_split_tree(handle_t *handle, struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *path,\n\t\t\t    int index, u32 new_range,\n\t\t\t    struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret, depth, credits;\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *rightmost_el, *el;\n\tstruct ocfs2_extent_rec split_rec;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_insert_type insert;\n\n\t/*\n\t * Setup the record to split before we grow the tree.\n\t */\n\tel = path_leaf_el(path);\n\trec = &el->l_recs[index];\n\tocfs2_make_right_split_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t   &split_rec, new_range, rec);\n\n\tdepth = path->p_tree_depth;\n\tif (depth > 0) {\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &last_eb_bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) last_eb_bh->b_data;\n\t\trightmost_el = &eb->h_list;\n\t} else\n\t\trightmost_el = path_leaf_el(path);\n\n\tcredits = path->p_tree_depth +\n\t\t  ocfs2_extend_meta_needed(et->et_root_el);\n\tret = ocfs2_extend_trans(handle, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(rightmost_el->l_next_free_rec) ==\n\t    le16_to_cpu(rightmost_el->l_count)) {\n\t\tret = ocfs2_grow_tree(handle, et, &depth, &last_eb_bh,\n\t\t\t\t      meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemset(&insert, 0, sizeof(struct ocfs2_insert_type));\n\tinsert.ins_appending = APPEND_NONE;\n\tinsert.ins_contig = CONTIG_NONE;\n\tinsert.ins_split = SPLIT_RIGHT;\n\tinsert.ins_tree_depth = depth;\n\n\tret = ocfs2_do_insert_extent(handle, et, &split_rec, &insert);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tbrelse(last_eb_bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "last_eb_bh"
          ],
          "line": 5308
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_do_insert_extent",
          "args": [
            "handle",
            "et",
            "&split_rec",
            "&insert"
          ],
          "line": 5303
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_do_insert_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "4204-4314",
          "snippet": "static int ocfs2_do_insert_extent(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t  struct ocfs2_insert_type *type)\n{\n\tint ret, rotate = 0;\n\tu32 cpos;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el;\n\n\tel = et->et_root_el;\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(el->l_tree_depth) == 0) {\n\t\tocfs2_insert_at_leaf(et, insert_rec, el, type);\n\t\tgoto out_update_clusters;\n\t}\n\n\tright_path = ocfs2_new_path_from_et(et);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Determine the path to start with. Rotations need the\n\t * rightmost path, everything else can go directly to the\n\t * target leaf.\n\t */\n\tcpos = le32_to_cpu(insert_rec->e_cpos);\n\tif (type->ins_appending == APPEND_NONE &&\n\t    type->ins_contig == CONTIG_NONE) {\n\t\trotate = 1;\n\t\tcpos = UINT_MAX;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, right_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Rotations and appends need special treatment - they modify\n\t * parts of the tree's above them.\n\t *\n\t * Both might pass back a path immediate to the left of the\n\t * one being inserted to. This will be cause\n\t * ocfs2_insert_path() to modify the rightmost records of\n\t * left_path to account for an edge insert.\n\t *\n\t * XXX: When modifying this code, keep in mind that an insert\n\t * can wind up skipping both of these two special cases...\n\t */\n\tif (rotate) {\n\t\tret = ocfs2_rotate_tree_right(handle, et, type->ins_split,\n\t\t\t\t\t      le32_to_cpu(insert_rec->e_cpos),\n\t\t\t\t\t      right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * ocfs2_rotate_tree_right() might have extended the\n\t\t * transaction without re-journaling our tree root.\n\t\t */\n\t\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else if (type->ins_appending == APPEND_TAIL\n\t\t   && type->ins_contig != CONTIG_LEFT) {\n\t\tret = ocfs2_append_rec_to_path(handle, et, insert_rec,\n\t\t\t\t\t       right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_insert_path(handle, et, left_path, right_path,\n\t\t\t\tinsert_rec, type);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout_update_clusters:\n\tif (type->ins_split == SPLIT_NONE)\n\t\tocfs2_et_update_clusters(et,\n\t\t\t\t\t le16_to_cpu(insert_rec->e_leaf_clusters));\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\nout:\n\tocfs2_free_path(left_path);\n\tocfs2_free_path(right_path);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic int ocfs2_do_insert_extent(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t  struct ocfs2_insert_type *type)\n{\n\tint ret, rotate = 0;\n\tu32 cpos;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el;\n\n\tel = et->et_root_el;\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(el->l_tree_depth) == 0) {\n\t\tocfs2_insert_at_leaf(et, insert_rec, el, type);\n\t\tgoto out_update_clusters;\n\t}\n\n\tright_path = ocfs2_new_path_from_et(et);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Determine the path to start with. Rotations need the\n\t * rightmost path, everything else can go directly to the\n\t * target leaf.\n\t */\n\tcpos = le32_to_cpu(insert_rec->e_cpos);\n\tif (type->ins_appending == APPEND_NONE &&\n\t    type->ins_contig == CONTIG_NONE) {\n\t\trotate = 1;\n\t\tcpos = UINT_MAX;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, right_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Rotations and appends need special treatment - they modify\n\t * parts of the tree's above them.\n\t *\n\t * Both might pass back a path immediate to the left of the\n\t * one being inserted to. This will be cause\n\t * ocfs2_insert_path() to modify the rightmost records of\n\t * left_path to account for an edge insert.\n\t *\n\t * XXX: When modifying this code, keep in mind that an insert\n\t * can wind up skipping both of these two special cases...\n\t */\n\tif (rotate) {\n\t\tret = ocfs2_rotate_tree_right(handle, et, type->ins_split,\n\t\t\t\t\t      le32_to_cpu(insert_rec->e_cpos),\n\t\t\t\t\t      right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * ocfs2_rotate_tree_right() might have extended the\n\t\t * transaction without re-journaling our tree root.\n\t\t */\n\t\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else if (type->ins_appending == APPEND_TAIL\n\t\t   && type->ins_contig != CONTIG_LEFT) {\n\t\tret = ocfs2_append_rec_to_path(handle, et, insert_rec,\n\t\t\t\t\t       right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_insert_path(handle, et, left_path, right_path,\n\t\t\t\tinsert_rec, type);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout_update_clusters:\n\tif (type->ins_split == SPLIT_NONE)\n\t\tocfs2_et_update_clusters(et,\n\t\t\t\t\t le16_to_cpu(insert_rec->e_leaf_clusters));\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\nout:\n\tocfs2_free_path(left_path);\n\tocfs2_free_path(right_path);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&insert",
            "0",
            "sizeof(struct ocfs2_insert_type)"
          ],
          "line": 5297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_grow_tree",
          "args": [
            "handle",
            "et",
            "&depth",
            "&last_eb_bh",
            "meta_ac"
          ],
          "line": 5289
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_grow_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1510-1578",
          "snippet": "static int ocfs2_grow_tree(handle_t *handle, struct ocfs2_extent_tree *et,\n\t\t\t   int *final_depth, struct buffer_head **last_eb_bh,\n\t\t\t   struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret, shift;\n\tstruct ocfs2_extent_list *el = et->et_root_el;\n\tint depth = le16_to_cpu(el->l_tree_depth);\n\tstruct buffer_head *bh = NULL;\n\n\tBUG_ON(meta_ac == NULL);\n\n\tshift = ocfs2_find_branch_target(et, &bh);\n\tif (shift < 0) {\n\t\tret = shift;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* We traveled all the way to the bottom of the allocation tree\n\t * and didn't find room for any more extents - we need to add\n\t * another tree level */\n\tif (shift) {\n\t\tBUG_ON(bh);\n\t\ttrace_ocfs2_grow_tree(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tdepth);\n\n\t\t/* ocfs2_shift_tree_depth will return us a buffer with\n\t\t * the new extent block (so we can pass that to\n\t\t * ocfs2_add_branch). */\n\t\tret = ocfs2_shift_tree_depth(handle, et, meta_ac, &bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tdepth++;\n\t\tif (depth == 1) {\n\t\t\t/*\n\t\t\t * Special case: we have room now if we shifted from\n\t\t\t * tree_depth 0, so no more work needs to be done.\n\t\t\t *\n\t\t\t * We won't be calling add_branch, so pass\n\t\t\t * back *last_eb_bh as the new leaf. At depth\n\t\t\t * zero, it should always be null so there's\n\t\t\t * no reason to brelse.\n\t\t\t */\n\t\t\tBUG_ON(*last_eb_bh);\n\t\t\tget_bh(bh);\n\t\t\t*last_eb_bh = bh;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* call ocfs2_add_branch to add the final part of the tree with\n\t * the new data. */\n\tret = ocfs2_add_branch(handle, et, bh, last_eb_bh,\n\t\t\t       meta_ac);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout:\n\tif (final_depth)\n\t\t*final_depth = depth;\n\tbrelse(bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_grow_tree(handle_t *handle, struct ocfs2_extent_tree *et,\n\t\t\t   int *final_depth, struct buffer_head **last_eb_bh,\n\t\t\t   struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret, shift;\n\tstruct ocfs2_extent_list *el = et->et_root_el;\n\tint depth = le16_to_cpu(el->l_tree_depth);\n\tstruct buffer_head *bh = NULL;\n\n\tBUG_ON(meta_ac == NULL);\n\n\tshift = ocfs2_find_branch_target(et, &bh);\n\tif (shift < 0) {\n\t\tret = shift;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* We traveled all the way to the bottom of the allocation tree\n\t * and didn't find room for any more extents - we need to add\n\t * another tree level */\n\tif (shift) {\n\t\tBUG_ON(bh);\n\t\ttrace_ocfs2_grow_tree(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tdepth);\n\n\t\t/* ocfs2_shift_tree_depth will return us a buffer with\n\t\t * the new extent block (so we can pass that to\n\t\t * ocfs2_add_branch). */\n\t\tret = ocfs2_shift_tree_depth(handle, et, meta_ac, &bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tdepth++;\n\t\tif (depth == 1) {\n\t\t\t/*\n\t\t\t * Special case: we have room now if we shifted from\n\t\t\t * tree_depth 0, so no more work needs to be done.\n\t\t\t *\n\t\t\t * We won't be calling add_branch, so pass\n\t\t\t * back *last_eb_bh as the new leaf. At depth\n\t\t\t * zero, it should always be null so there's\n\t\t\t * no reason to brelse.\n\t\t\t */\n\t\t\tBUG_ON(*last_eb_bh);\n\t\t\tget_bh(bh);\n\t\t\t*last_eb_bh = bh;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* call ocfs2_add_branch to add the final part of the tree with\n\t * the new data. */\n\tret = ocfs2_add_branch(handle, et, bh, last_eb_bh,\n\t\t\t       meta_ac);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout:\n\tif (final_depth)\n\t\t*final_depth = depth;\n\tbrelse(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rightmost_el->l_count"
          ],
          "line": 5288
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_trans",
          "args": [
            "handle",
            "credits"
          ],
          "line": 5281
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "426-463",
          "snippet": "int ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_meta_needed",
          "args": [
            "et->et_root_el"
          ],
          "line": 5280
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_meta_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "157-168",
          "snippet": "static inline int ocfs2_extend_meta_needed(struct ocfs2_extent_list *root_el)\n{\n\t/*\n\t * Rather than do all the work of determining how much we need\n\t * (involves a ton of reads and locks), just ask for the\n\t * maximal limit.  That's a tree depth shift.  So, one block for\n\t * level of the tree (current l_tree_depth), one block for the\n\t * new tree_depth==0 extent_block, and one block at the new\n\t * top-of-the tree.\n\t */\n\treturn le16_to_cpu(root_el->l_tree_depth) + 2;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_extend_meta_needed(struct ocfs2_extent_list *root_el)\n{\n\t/*\n\t * Rather than do all the work of determining how much we need\n\t * (involves a ton of reads and locks), just ask for the\n\t * maximal limit.  That's a tree depth shift.  So, one block for\n\t * level of the tree (current l_tree_depth), one block for the\n\t * new tree_depth==0 extent_block, and one block at the new\n\t * top-of-the tree.\n\t */\n\treturn le16_to_cpu(root_el->l_tree_depth) + 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 5277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_extent_block",
          "args": [
            "et->et_ci",
            "ocfs2_et_get_last_eb_blk(et)",
            "&last_eb_bh"
          ],
          "line": 5266
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_extent_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "939-953",
          "snippet": "int ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_et_get_last_eb_blk",
          "args": [
            "et"
          ],
          "line": 5267
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_get_last_eb_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "504-507",
          "snippet": "static inline u64 ocfs2_et_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\treturn et->et_ops->eo_get_last_eb_blk(et);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic inline u64 ocfs2_et_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\treturn et->et_ops->eo_get_last_eb_blk(et);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_make_right_split_rec",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "&split_rec",
            "new_range",
            "rec"
          ],
          "line": 5261
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_make_right_split_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "4847-4865",
          "snippet": "static void ocfs2_make_right_split_rec(struct super_block *sb,\n\t\t\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t\t\t       u32 cpos,\n\t\t\t\t       struct ocfs2_extent_rec *rec)\n{\n\tu32 rec_cpos = le32_to_cpu(rec->e_cpos);\n\tu32 rec_range = rec_cpos + le16_to_cpu(rec->e_leaf_clusters);\n\n\tmemset(split_rec, 0, sizeof(struct ocfs2_extent_rec));\n\n\tsplit_rec->e_cpos = cpu_to_le32(cpos);\n\tsplit_rec->e_leaf_clusters = cpu_to_le16(rec_range - cpos);\n\n\tsplit_rec->e_blkno = rec->e_blkno;\n\tle64_add_cpu(&split_rec->e_blkno,\n\t\t     ocfs2_clusters_to_blocks(sb, cpos - rec_cpos));\n\n\tsplit_rec->e_flags = rec->e_flags;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic void ocfs2_make_right_split_rec(struct super_block *sb,\n\t\t\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t\t\t       u32 cpos,\n\t\t\t\t       struct ocfs2_extent_rec *rec)\n{\n\tu32 rec_cpos = le32_to_cpu(rec->e_cpos);\n\tu32 rec_range = rec_cpos + le16_to_cpu(rec->e_leaf_clusters);\n\n\tmemset(split_rec, 0, sizeof(struct ocfs2_extent_rec));\n\n\tsplit_rec->e_cpos = cpu_to_le32(cpos);\n\tsplit_rec->e_leaf_clusters = cpu_to_le16(rec_range - cpos);\n\n\tsplit_rec->e_blkno = rec->e_blkno;\n\tle64_add_cpu(&split_rec->e_blkno,\n\t\t     ocfs2_clusters_to_blocks(sb, cpos - rec_cpos));\n\n\tsplit_rec->e_flags = rec->e_flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 5261
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 5259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_split_tree(handle_t *handle, struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *path,\n\t\t\t    int index, u32 new_range,\n\t\t\t    struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret, depth, credits;\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *rightmost_el, *el;\n\tstruct ocfs2_extent_rec split_rec;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_insert_type insert;\n\n\t/*\n\t * Setup the record to split before we grow the tree.\n\t */\n\tel = path_leaf_el(path);\n\trec = &el->l_recs[index];\n\tocfs2_make_right_split_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t   &split_rec, new_range, rec);\n\n\tdepth = path->p_tree_depth;\n\tif (depth > 0) {\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &last_eb_bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) last_eb_bh->b_data;\n\t\trightmost_el = &eb->h_list;\n\t} else\n\t\trightmost_el = path_leaf_el(path);\n\n\tcredits = path->p_tree_depth +\n\t\t  ocfs2_extend_meta_needed(et->et_root_el);\n\tret = ocfs2_extend_trans(handle, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(rightmost_el->l_next_free_rec) ==\n\t    le16_to_cpu(rightmost_el->l_count)) {\n\t\tret = ocfs2_grow_tree(handle, et, &depth, &last_eb_bh,\n\t\t\t\t      meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemset(&insert, 0, sizeof(struct ocfs2_insert_type));\n\tinsert.ins_appending = APPEND_NONE;\n\tinsert.ins_contig = CONTIG_NONE;\n\tinsert.ins_split = SPLIT_RIGHT;\n\tinsert.ins_tree_depth = depth;\n\n\tret = ocfs2_do_insert_extent(handle, et, &split_rec, &insert);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tbrelse(last_eb_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_mark_extent_written",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "5206-5241",
    "snippet": "int ocfs2_mark_extent_written(struct inode *inode,\n\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t      handle_t *handle, u32 cpos, u32 len, u32 phys,\n\t\t\t      struct ocfs2_alloc_context *meta_ac,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret;\n\n\ttrace_ocfs2_mark_extent_written(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\tcpos, len, phys);\n\n\tif (!ocfs2_writes_unwritten_extents(OCFS2_SB(inode->i_sb))) {\n\t\tocfs2_error(inode->i_sb, \"Inode %llu has unwritten extents \"\n\t\t\t    \"that are being written to, but the feature bit \"\n\t\t\t    \"is not set in the super block.\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * XXX: This should be fixed up so that we just re-insert the\n\t * next extent records.\n\t */\n\tocfs2_et_extent_map_truncate(et, 0);\n\n\tret = ocfs2_change_extent_flag(handle, et, cpos,\n\t\t\t\t       len, phys, meta_ac, dealloc,\n\t\t\t\t       0, OCFS2_EXT_UNWRITTEN);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_change_extent_flag",
          "args": [
            "handle",
            "et",
            "cpos",
            "len",
            "phys",
            "meta_ac",
            "dealloc",
            "0",
            "OCFS2_EXT_UNWRITTEN"
          ],
          "line": 5233
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_change_extent_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5117-5195",
          "snippet": "int ocfs2_change_extent_flag(handle_t *handle,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     u32 cpos, u32 len, u32 phys,\n\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t     int new_flags, int clear_flags)\n{\n\tint ret, index;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tu64 start_blkno = ocfs2_clusters_to_blocks(sb, phys);\n\tstruct ocfs2_extent_rec split_rec;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tleft_path = ocfs2_new_path_from_et(et);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tel = path_leaf_el(left_path);\n\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Owner %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\",\n\t\t\t     (unsigned long long)\n\t\t\t     ocfs2_metadata_cache_owner(et->et_ci), cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tret = -EIO;\n\trec = &el->l_recs[index];\n\tif (new_flags && (rec->e_flags & new_flags)) {\n\t\tmlog(ML_ERROR, \"Owner %llu tried to set %d flags on an \"\n\t\t     \"extent that already had them\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     new_flags);\n\t\tgoto out;\n\t}\n\n\tif (clear_flags && !(rec->e_flags & clear_flags)) {\n\t\tmlog(ML_ERROR, \"Owner %llu tried to clear %d flags on an \"\n\t\t     \"extent that didn't have them\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     clear_flags);\n\t\tgoto out;\n\t}\n\n\tmemset(&split_rec, 0, sizeof(struct ocfs2_extent_rec));\n\tsplit_rec.e_cpos = cpu_to_le32(cpos);\n\tsplit_rec.e_leaf_clusters = cpu_to_le16(len);\n\tsplit_rec.e_blkno = cpu_to_le64(start_blkno);\n\tsplit_rec.e_flags = rec->e_flags;\n\tif (new_flags)\n\t\tsplit_rec.e_flags |= new_flags;\n\tif (clear_flags)\n\t\tsplit_rec.e_flags &= ~clear_flags;\n\n\tret = ocfs2_split_extent(handle, et, left_path,\n\t\t\t\t index, &split_rec, meta_ac,\n\t\t\t\t dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_change_extent_flag(handle_t *handle,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     u32 cpos, u32 len, u32 phys,\n\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t     int new_flags, int clear_flags)\n{\n\tint ret, index;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tu64 start_blkno = ocfs2_clusters_to_blocks(sb, phys);\n\tstruct ocfs2_extent_rec split_rec;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tleft_path = ocfs2_new_path_from_et(et);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tel = path_leaf_el(left_path);\n\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Owner %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\",\n\t\t\t     (unsigned long long)\n\t\t\t     ocfs2_metadata_cache_owner(et->et_ci), cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tret = -EIO;\n\trec = &el->l_recs[index];\n\tif (new_flags && (rec->e_flags & new_flags)) {\n\t\tmlog(ML_ERROR, \"Owner %llu tried to set %d flags on an \"\n\t\t     \"extent that already had them\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     new_flags);\n\t\tgoto out;\n\t}\n\n\tif (clear_flags && !(rec->e_flags & clear_flags)) {\n\t\tmlog(ML_ERROR, \"Owner %llu tried to clear %d flags on an \"\n\t\t     \"extent that didn't have them\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     clear_flags);\n\t\tgoto out;\n\t}\n\n\tmemset(&split_rec, 0, sizeof(struct ocfs2_extent_rec));\n\tsplit_rec.e_cpos = cpu_to_le32(cpos);\n\tsplit_rec.e_leaf_clusters = cpu_to_le16(len);\n\tsplit_rec.e_blkno = cpu_to_le64(start_blkno);\n\tsplit_rec.e_flags = rec->e_flags;\n\tif (new_flags)\n\t\tsplit_rec.e_flags |= new_flags;\n\tif (clear_flags)\n\t\tsplit_rec.e_flags &= ~clear_flags;\n\n\tret = ocfs2_split_extent(handle, et, left_path,\n\t\t\t\t index, &split_rec, meta_ac,\n\t\t\t\t dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_et_extent_map_truncate",
          "args": [
            "et",
            "0"
          ],
          "line": 5231
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_extent_map_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "522-527",
          "snippet": "static inline void ocfs2_et_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t\tu32 clusters)\n{\n\tif (et->et_ops->eo_extent_map_truncate)\n\t\tet->et_ops->eo_extent_map_truncate(et, clusters);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic inline void ocfs2_et_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t\tu32 clusters)\n{\n\tif (et->et_ops->eo_extent_map_truncate)\n\t\tet->et_ops->eo_extent_map_truncate(et, clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "inode->i_sb",
            "\"Inode %llu has unwritten extents \"\n\t\t\t    \"that are being written to, but the feature bit \"\n\t\t\t    \"is not set in the super block.\"",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno"
          ],
          "line": 5219
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 5222
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_writes_unwritten_extents",
          "args": [
            "OCFS2_SB(inode->i_sb)"
          ],
          "line": 5218
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_writes_unwritten_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "490-501",
          "snippet": "static inline int ocfs2_writes_unwritten_extents(struct ocfs2_super *osb)\n{\n\t/*\n\t * Support for sparse files is a pre-requisite\n\t */\n\tif (!ocfs2_sparse_alloc(osb))\n\t\treturn 0;\n\n\tif (osb->s_feature_ro_compat & OCFS2_FEATURE_RO_COMPAT_UNWRITTEN)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_writes_unwritten_extents(struct ocfs2_super *osb)\n{\n\t/*\n\t * Support for sparse files is a pre-requisite\n\t */\n\tif (!ocfs2_sparse_alloc(osb))\n\t\treturn 0;\n\n\tif (osb->s_feature_ro_compat & OCFS2_FEATURE_RO_COMPAT_UNWRITTEN)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 5218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_mark_extent_written",
          "args": [
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "cpos",
            "len",
            "phys"
          ],
          "line": 5214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_mark_extent_written(struct inode *inode,\n\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t      handle_t *handle, u32 cpos, u32 len, u32 phys,\n\t\t\t      struct ocfs2_alloc_context *meta_ac,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret;\n\n\ttrace_ocfs2_mark_extent_written(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\tcpos, len, phys);\n\n\tif (!ocfs2_writes_unwritten_extents(OCFS2_SB(inode->i_sb))) {\n\t\tocfs2_error(inode->i_sb, \"Inode %llu has unwritten extents \"\n\t\t\t    \"that are being written to, but the feature bit \"\n\t\t\t    \"is not set in the super block.\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * XXX: This should be fixed up so that we just re-insert the\n\t * next extent records.\n\t */\n\tocfs2_et_extent_map_truncate(et, 0);\n\n\tret = ocfs2_change_extent_flag(handle, et, cpos,\n\t\t\t\t       len, phys, meta_ac, dealloc,\n\t\t\t\t       0, OCFS2_EXT_UNWRITTEN);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_change_extent_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "5117-5195",
    "snippet": "int ocfs2_change_extent_flag(handle_t *handle,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     u32 cpos, u32 len, u32 phys,\n\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t     int new_flags, int clear_flags)\n{\n\tint ret, index;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tu64 start_blkno = ocfs2_clusters_to_blocks(sb, phys);\n\tstruct ocfs2_extent_rec split_rec;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tleft_path = ocfs2_new_path_from_et(et);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tel = path_leaf_el(left_path);\n\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Owner %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\",\n\t\t\t     (unsigned long long)\n\t\t\t     ocfs2_metadata_cache_owner(et->et_ci), cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tret = -EIO;\n\trec = &el->l_recs[index];\n\tif (new_flags && (rec->e_flags & new_flags)) {\n\t\tmlog(ML_ERROR, \"Owner %llu tried to set %d flags on an \"\n\t\t     \"extent that already had them\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     new_flags);\n\t\tgoto out;\n\t}\n\n\tif (clear_flags && !(rec->e_flags & clear_flags)) {\n\t\tmlog(ML_ERROR, \"Owner %llu tried to clear %d flags on an \"\n\t\t     \"extent that didn't have them\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     clear_flags);\n\t\tgoto out;\n\t}\n\n\tmemset(&split_rec, 0, sizeof(struct ocfs2_extent_rec));\n\tsplit_rec.e_cpos = cpu_to_le32(cpos);\n\tsplit_rec.e_leaf_clusters = cpu_to_le16(len);\n\tsplit_rec.e_blkno = cpu_to_le64(start_blkno);\n\tsplit_rec.e_flags = rec->e_flags;\n\tif (new_flags)\n\t\tsplit_rec.e_flags |= new_flags;\n\tif (clear_flags)\n\t\tsplit_rec.e_flags &= ~clear_flags;\n\n\tret = ocfs2_split_extent(handle, et, left_path,\n\t\t\t\t index, &split_rec, meta_ac,\n\t\t\t\t dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "left_path"
          ],
          "line": 5192
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "609-615",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_split_extent",
          "args": [
            "handle",
            "et",
            "left_path",
            "index",
            "&split_rec",
            "meta_ac",
            "dealloc"
          ],
          "line": 5185
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_split_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5022-5103",
          "snippet": "int ocfs2_split_extent(handle_t *handle,\n\t\t       struct ocfs2_extent_tree *et,\n\t\t       struct ocfs2_path *path,\n\t\t       int split_index,\n\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t       struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[split_index];\n\tstruct ocfs2_merge_ctxt ctxt;\n\tstruct ocfs2_extent_list *rightmost_el;\n\n\tif (le32_to_cpu(rec->e_cpos) > le32_to_cpu(split_rec->e_cpos) ||\n\t    ((le32_to_cpu(rec->e_cpos) + le16_to_cpu(rec->e_leaf_clusters)) <\n\t     (le32_to_cpu(split_rec->e_cpos) + le16_to_cpu(split_rec->e_leaf_clusters)))) {\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tctxt.c_contig_type = ocfs2_figure_merge_contig_type(et, path, el,\n\t\t\t\t\t\t\t    split_index,\n\t\t\t\t\t\t\t    split_rec);\n\n\t/*\n\t * The core merge / split code wants to know how much room is\n\t * left in this allocation tree, so we pass the\n\t * rightmost extent list.\n\t */\n\tif (path->p_tree_depth) {\n\t\tstruct ocfs2_extent_block *eb;\n\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &last_eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) last_eb_bh->b_data;\n\t\trightmost_el = &eb->h_list;\n\t} else\n\t\trightmost_el = path_root_el(path);\n\n\tif (rec->e_cpos == split_rec->e_cpos &&\n\t    rec->e_leaf_clusters == split_rec->e_leaf_clusters)\n\t\tctxt.c_split_covers_rec = 1;\n\telse\n\t\tctxt.c_split_covers_rec = 0;\n\n\tctxt.c_has_empty_extent = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\ttrace_ocfs2_split_extent(split_index, ctxt.c_contig_type,\n\t\t\t\t ctxt.c_has_empty_extent,\n\t\t\t\t ctxt.c_split_covers_rec);\n\n\tif (ctxt.c_contig_type == CONTIG_NONE) {\n\t\tif (ctxt.c_split_covers_rec)\n\t\t\tret = ocfs2_replace_extent_rec(handle, et, path, el,\n\t\t\t\t\t\t       split_index, split_rec);\n\t\telse\n\t\t\tret = ocfs2_split_and_insert(handle, et, path,\n\t\t\t\t\t\t     &last_eb_bh, split_index,\n\t\t\t\t\t\t     split_rec, meta_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t} else {\n\t\tret = ocfs2_try_to_merge_extent(handle, et, path,\n\t\t\t\t\t\tsplit_index, split_rec,\n\t\t\t\t\t\tdealloc, &ctxt);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tbrelse(last_eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nint ocfs2_split_extent(handle_t *handle,\n\t\t       struct ocfs2_extent_tree *et,\n\t\t       struct ocfs2_path *path,\n\t\t       int split_index,\n\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t       struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[split_index];\n\tstruct ocfs2_merge_ctxt ctxt;\n\tstruct ocfs2_extent_list *rightmost_el;\n\n\tif (le32_to_cpu(rec->e_cpos) > le32_to_cpu(split_rec->e_cpos) ||\n\t    ((le32_to_cpu(rec->e_cpos) + le16_to_cpu(rec->e_leaf_clusters)) <\n\t     (le32_to_cpu(split_rec->e_cpos) + le16_to_cpu(split_rec->e_leaf_clusters)))) {\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tctxt.c_contig_type = ocfs2_figure_merge_contig_type(et, path, el,\n\t\t\t\t\t\t\t    split_index,\n\t\t\t\t\t\t\t    split_rec);\n\n\t/*\n\t * The core merge / split code wants to know how much room is\n\t * left in this allocation tree, so we pass the\n\t * rightmost extent list.\n\t */\n\tif (path->p_tree_depth) {\n\t\tstruct ocfs2_extent_block *eb;\n\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &last_eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) last_eb_bh->b_data;\n\t\trightmost_el = &eb->h_list;\n\t} else\n\t\trightmost_el = path_root_el(path);\n\n\tif (rec->e_cpos == split_rec->e_cpos &&\n\t    rec->e_leaf_clusters == split_rec->e_leaf_clusters)\n\t\tctxt.c_split_covers_rec = 1;\n\telse\n\t\tctxt.c_split_covers_rec = 0;\n\n\tctxt.c_has_empty_extent = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\ttrace_ocfs2_split_extent(split_index, ctxt.c_contig_type,\n\t\t\t\t ctxt.c_has_empty_extent,\n\t\t\t\t ctxt.c_split_covers_rec);\n\n\tif (ctxt.c_contig_type == CONTIG_NONE) {\n\t\tif (ctxt.c_split_covers_rec)\n\t\t\tret = ocfs2_replace_extent_rec(handle, et, path, el,\n\t\t\t\t\t\t       split_index, split_rec);\n\t\telse\n\t\t\tret = ocfs2_split_and_insert(handle, et, path,\n\t\t\t\t\t\t     &last_eb_bh, split_index,\n\t\t\t\t\t\t     split_rec, meta_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t} else {\n\t\tret = ocfs2_try_to_merge_extent(handle, et, path,\n\t\t\t\t\t\tsplit_index, split_rec,\n\t\t\t\t\t\tdealloc, &ctxt);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tbrelse(last_eb_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "start_blkno"
          ],
          "line": 5178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "len"
          ],
          "line": 5177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cpos"
          ],
          "line": 5176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&split_rec",
            "0",
            "sizeof(struct ocfs2_extent_rec)"
          ],
          "line": 5175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Owner %llu tried to clear %d flags on an \"\n\t\t     \"extent that didn't have them\"",
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "clear_flags"
          ],
          "line": 5168
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 5170
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "sb",
            "\"Owner %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\"",
            "(unsigned long long)\n\t\t\t     ocfs2_metadata_cache_owner(et->et_ci)",
            "cpos"
          ],
          "line": 5148
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_search_extent_list",
          "args": [
            "el",
            "cpos"
          ],
          "line": 5146
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_search_extent_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "773-795",
          "snippet": "int ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nint ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "left_path"
          ],
          "line": 5144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "et->et_ci",
            "left_path",
            "cpos"
          ],
          "line": 5139
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1885-1894",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_et",
          "args": [
            "et"
          ],
          "line": 5132
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_et",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "713-717",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstruct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "sb",
            "phys"
          ],
          "line": 5126
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 5125
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_change_extent_flag(handle_t *handle,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     u32 cpos, u32 len, u32 phys,\n\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t     int new_flags, int clear_flags)\n{\n\tint ret, index;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tu64 start_blkno = ocfs2_clusters_to_blocks(sb, phys);\n\tstruct ocfs2_extent_rec split_rec;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tleft_path = ocfs2_new_path_from_et(et);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tel = path_leaf_el(left_path);\n\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Owner %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\",\n\t\t\t     (unsigned long long)\n\t\t\t     ocfs2_metadata_cache_owner(et->et_ci), cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tret = -EIO;\n\trec = &el->l_recs[index];\n\tif (new_flags && (rec->e_flags & new_flags)) {\n\t\tmlog(ML_ERROR, \"Owner %llu tried to set %d flags on an \"\n\t\t     \"extent that already had them\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     new_flags);\n\t\tgoto out;\n\t}\n\n\tif (clear_flags && !(rec->e_flags & clear_flags)) {\n\t\tmlog(ML_ERROR, \"Owner %llu tried to clear %d flags on an \"\n\t\t     \"extent that didn't have them\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     clear_flags);\n\t\tgoto out;\n\t}\n\n\tmemset(&split_rec, 0, sizeof(struct ocfs2_extent_rec));\n\tsplit_rec.e_cpos = cpu_to_le32(cpos);\n\tsplit_rec.e_leaf_clusters = cpu_to_le16(len);\n\tsplit_rec.e_blkno = cpu_to_le64(start_blkno);\n\tsplit_rec.e_flags = rec->e_flags;\n\tif (new_flags)\n\t\tsplit_rec.e_flags |= new_flags;\n\tif (clear_flags)\n\t\tsplit_rec.e_flags &= ~clear_flags;\n\n\tret = ocfs2_split_extent(handle, et, left_path,\n\t\t\t\t index, &split_rec, meta_ac,\n\t\t\t\t dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n\n}"
  },
  {
    "function_name": "ocfs2_split_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "5022-5103",
    "snippet": "int ocfs2_split_extent(handle_t *handle,\n\t\t       struct ocfs2_extent_tree *et,\n\t\t       struct ocfs2_path *path,\n\t\t       int split_index,\n\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t       struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[split_index];\n\tstruct ocfs2_merge_ctxt ctxt;\n\tstruct ocfs2_extent_list *rightmost_el;\n\n\tif (le32_to_cpu(rec->e_cpos) > le32_to_cpu(split_rec->e_cpos) ||\n\t    ((le32_to_cpu(rec->e_cpos) + le16_to_cpu(rec->e_leaf_clusters)) <\n\t     (le32_to_cpu(split_rec->e_cpos) + le16_to_cpu(split_rec->e_leaf_clusters)))) {\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tctxt.c_contig_type = ocfs2_figure_merge_contig_type(et, path, el,\n\t\t\t\t\t\t\t    split_index,\n\t\t\t\t\t\t\t    split_rec);\n\n\t/*\n\t * The core merge / split code wants to know how much room is\n\t * left in this allocation tree, so we pass the\n\t * rightmost extent list.\n\t */\n\tif (path->p_tree_depth) {\n\t\tstruct ocfs2_extent_block *eb;\n\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &last_eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) last_eb_bh->b_data;\n\t\trightmost_el = &eb->h_list;\n\t} else\n\t\trightmost_el = path_root_el(path);\n\n\tif (rec->e_cpos == split_rec->e_cpos &&\n\t    rec->e_leaf_clusters == split_rec->e_leaf_clusters)\n\t\tctxt.c_split_covers_rec = 1;\n\telse\n\t\tctxt.c_split_covers_rec = 0;\n\n\tctxt.c_has_empty_extent = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\ttrace_ocfs2_split_extent(split_index, ctxt.c_contig_type,\n\t\t\t\t ctxt.c_has_empty_extent,\n\t\t\t\t ctxt.c_split_covers_rec);\n\n\tif (ctxt.c_contig_type == CONTIG_NONE) {\n\t\tif (ctxt.c_split_covers_rec)\n\t\t\tret = ocfs2_replace_extent_rec(handle, et, path, el,\n\t\t\t\t\t\t       split_index, split_rec);\n\t\telse\n\t\t\tret = ocfs2_split_and_insert(handle, et, path,\n\t\t\t\t\t\t     &last_eb_bh, split_index,\n\t\t\t\t\t\t     split_rec, meta_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t} else {\n\t\tret = ocfs2_try_to_merge_extent(handle, et, path,\n\t\t\t\t\t\tsplit_index, split_rec,\n\t\t\t\t\t\tdealloc, &ctxt);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tbrelse(last_eb_bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "last_eb_bh"
          ],
          "line": 5101
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_try_to_merge_extent",
          "args": [
            "handle",
            "et",
            "path",
            "split_index",
            "split_rec",
            "dealloc",
            "&ctxt"
          ],
          "line": 5093
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_try_to_merge_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "3655-3788",
          "snippet": "static int ocfs2_try_to_merge_extent(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_path *path,\n\t\t\t\t     int split_index,\n\t\t\t\t     struct ocfs2_extent_rec *split_rec,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t     struct ocfs2_merge_ctxt *ctxt)\n{\n\tint ret = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[split_index];\n\n\tBUG_ON(ctxt->c_contig_type == CONTIG_NONE);\n\n\tif (ctxt->c_split_covers_rec && ctxt->c_has_empty_extent) {\n\t\t/*\n\t\t * The merge code will need to create an empty\n\t\t * extent to take the place of the newly\n\t\t * emptied slot. Remove any pre-existing empty\n\t\t * extents - having more than one in a leaf is\n\t\t * illegal.\n\t\t */\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tsplit_index--;\n\t\trec = &el->l_recs[split_index];\n\t}\n\n\tif (ctxt->c_contig_type == CONTIG_LEFTRIGHT) {\n\t\t/*\n\t\t * Left-right contig implies this.\n\t\t */\n\t\tBUG_ON(!ctxt->c_split_covers_rec);\n\n\t\t/*\n\t\t * Since the leftright insert always covers the entire\n\t\t * extent, this call will delete the insert record\n\t\t * entirely, resulting in an empty extent record added to\n\t\t * the extent block.\n\t\t *\n\t\t * Since the adding of an empty extent shifts\n\t\t * everything back to the right, there's no need to\n\t\t * update split_index here.\n\t\t *\n\t\t * When the split_index is zero, we need to merge it to the\n\t\t * prevoius extent block. It is more efficient and easier\n\t\t * if we do merge_right first and merge_left later.\n\t\t */\n\t\tret = ocfs2_merge_rec_right(path, handle, et, split_rec,\n\t\t\t\t\t    split_index);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * We can only get this from logic error above.\n\t\t */\n\t\tBUG_ON(!ocfs2_is_empty_extent(&el->l_recs[0]));\n\n\t\t/* The merge left us with an empty extent, remove it. */\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\trec = &el->l_recs[split_index];\n\n\t\t/*\n\t\t * Note that we don't pass split_rec here on purpose -\n\t\t * we've merged it into the rec already.\n\t\t */\n\t\tret = ocfs2_merge_rec_left(path, handle, et, rec,\n\t\t\t\t\t   dealloc, split_index);\n\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\t/*\n\t\t * Error from this last rotate is not critical, so\n\t\t * print but don't bubble it up.\n\t\t */\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tret = 0;\n\t} else {\n\t\t/*\n\t\t * Merge a record to the left or right.\n\t\t *\n\t\t * 'contig_type' is relative to the existing record,\n\t\t * so for example, if we're \"right contig\", it's to\n\t\t * the record on the left (hence the left merge).\n\t\t */\n\t\tif (ctxt->c_contig_type == CONTIG_RIGHT) {\n\t\t\tret = ocfs2_merge_rec_left(path, handle, et,\n\t\t\t\t\t\t   split_rec, dealloc,\n\t\t\t\t\t\t   split_index);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tret = ocfs2_merge_rec_right(path, handle,\n\t\t\t\t\t\t    et, split_rec,\n\t\t\t\t\t\t    split_index);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (ctxt->c_split_covers_rec) {\n\t\t\t/*\n\t\t\t * The merge may have left an empty extent in\n\t\t\t * our leaf. Try to rotate it away.\n\t\t\t */\n\t\t\tret = ocfs2_rotate_tree_left(handle, et, path,\n\t\t\t\t\t\t     dealloc);\n\t\t\tif (ret)\n\t\t\t\tmlog_errno(ret);\n\t\t\tret = 0;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_try_to_merge_extent(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_path *path,\n\t\t\t\t     int split_index,\n\t\t\t\t     struct ocfs2_extent_rec *split_rec,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t     struct ocfs2_merge_ctxt *ctxt)\n{\n\tint ret = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[split_index];\n\n\tBUG_ON(ctxt->c_contig_type == CONTIG_NONE);\n\n\tif (ctxt->c_split_covers_rec && ctxt->c_has_empty_extent) {\n\t\t/*\n\t\t * The merge code will need to create an empty\n\t\t * extent to take the place of the newly\n\t\t * emptied slot. Remove any pre-existing empty\n\t\t * extents - having more than one in a leaf is\n\t\t * illegal.\n\t\t */\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tsplit_index--;\n\t\trec = &el->l_recs[split_index];\n\t}\n\n\tif (ctxt->c_contig_type == CONTIG_LEFTRIGHT) {\n\t\t/*\n\t\t * Left-right contig implies this.\n\t\t */\n\t\tBUG_ON(!ctxt->c_split_covers_rec);\n\n\t\t/*\n\t\t * Since the leftright insert always covers the entire\n\t\t * extent, this call will delete the insert record\n\t\t * entirely, resulting in an empty extent record added to\n\t\t * the extent block.\n\t\t *\n\t\t * Since the adding of an empty extent shifts\n\t\t * everything back to the right, there's no need to\n\t\t * update split_index here.\n\t\t *\n\t\t * When the split_index is zero, we need to merge it to the\n\t\t * prevoius extent block. It is more efficient and easier\n\t\t * if we do merge_right first and merge_left later.\n\t\t */\n\t\tret = ocfs2_merge_rec_right(path, handle, et, split_rec,\n\t\t\t\t\t    split_index);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * We can only get this from logic error above.\n\t\t */\n\t\tBUG_ON(!ocfs2_is_empty_extent(&el->l_recs[0]));\n\n\t\t/* The merge left us with an empty extent, remove it. */\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\trec = &el->l_recs[split_index];\n\n\t\t/*\n\t\t * Note that we don't pass split_rec here on purpose -\n\t\t * we've merged it into the rec already.\n\t\t */\n\t\tret = ocfs2_merge_rec_left(path, handle, et, rec,\n\t\t\t\t\t   dealloc, split_index);\n\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\t/*\n\t\t * Error from this last rotate is not critical, so\n\t\t * print but don't bubble it up.\n\t\t */\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tret = 0;\n\t} else {\n\t\t/*\n\t\t * Merge a record to the left or right.\n\t\t *\n\t\t * 'contig_type' is relative to the existing record,\n\t\t * so for example, if we're \"right contig\", it's to\n\t\t * the record on the left (hence the left merge).\n\t\t */\n\t\tif (ctxt->c_contig_type == CONTIG_RIGHT) {\n\t\t\tret = ocfs2_merge_rec_left(path, handle, et,\n\t\t\t\t\t\t   split_rec, dealloc,\n\t\t\t\t\t\t   split_index);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tret = ocfs2_merge_rec_right(path, handle,\n\t\t\t\t\t\t    et, split_rec,\n\t\t\t\t\t\t    split_index);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (ctxt->c_split_covers_rec) {\n\t\t\t/*\n\t\t\t * The merge may have left an empty extent in\n\t\t\t * our leaf. Try to rotate it away.\n\t\t\t */\n\t\t\tret = ocfs2_rotate_tree_left(handle, et, path,\n\t\t\t\t\t\t     dealloc);\n\t\t\tif (ret)\n\t\t\t\tmlog_errno(ret);\n\t\t\tret = 0;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_split_and_insert",
          "args": [
            "handle",
            "et",
            "path",
            "&last_eb_bh",
            "split_index",
            "split_rec",
            "meta_ac"
          ],
          "line": 5087
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_split_and_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "4867-4978",
          "snippet": "static int ocfs2_split_and_insert(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_path *path,\n\t\t\t\t  struct buffer_head **last_eb_bh,\n\t\t\t\t  int split_index,\n\t\t\t\t  struct ocfs2_extent_rec *orig_split_rec,\n\t\t\t\t  struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret = 0, depth;\n\tunsigned int insert_range, rec_range, do_leftright = 0;\n\tstruct ocfs2_extent_rec tmprec;\n\tstruct ocfs2_extent_list *rightmost_el;\n\tstruct ocfs2_extent_rec rec;\n\tstruct ocfs2_extent_rec split_rec = *orig_split_rec;\n\tstruct ocfs2_insert_type insert;\n\tstruct ocfs2_extent_block *eb;\n\nleftright:\n\t/*\n\t * Store a copy of the record on the stack - it might move\n\t * around as the tree is manipulated below.\n\t */\n\trec = path_leaf_el(path)->l_recs[split_index];\n\n\trightmost_el = et->et_root_el;\n\n\tdepth = le16_to_cpu(rightmost_el->l_tree_depth);\n\tif (depth) {\n\t\tBUG_ON(!(*last_eb_bh));\n\t\teb = (struct ocfs2_extent_block *) (*last_eb_bh)->b_data;\n\t\trightmost_el = &eb->h_list;\n\t}\n\n\tif (le16_to_cpu(rightmost_el->l_next_free_rec) ==\n\t    le16_to_cpu(rightmost_el->l_count)) {\n\t\tret = ocfs2_grow_tree(handle, et,\n\t\t\t\t      &depth, last_eb_bh, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemset(&insert, 0, sizeof(struct ocfs2_insert_type));\n\tinsert.ins_appending = APPEND_NONE;\n\tinsert.ins_contig = CONTIG_NONE;\n\tinsert.ins_tree_depth = depth;\n\n\tinsert_range = le32_to_cpu(split_rec.e_cpos) +\n\t\tle16_to_cpu(split_rec.e_leaf_clusters);\n\trec_range = le32_to_cpu(rec.e_cpos) +\n\t\tle16_to_cpu(rec.e_leaf_clusters);\n\n\tif (split_rec.e_cpos == rec.e_cpos) {\n\t\tinsert.ins_split = SPLIT_LEFT;\n\t} else if (insert_range == rec_range) {\n\t\tinsert.ins_split = SPLIT_RIGHT;\n\t} else {\n\t\t/*\n\t\t * Left/right split. We fake this as a right split\n\t\t * first and then make a second pass as a left split.\n\t\t */\n\t\tinsert.ins_split = SPLIT_RIGHT;\n\n\t\tocfs2_make_right_split_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t   &tmprec, insert_range, &rec);\n\n\t\tsplit_rec = tmprec;\n\n\t\tBUG_ON(do_leftright);\n\t\tdo_leftright = 1;\n\t}\n\n\tret = ocfs2_do_insert_extent(handle, et, &split_rec, &insert);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (do_leftright == 1) {\n\t\tu32 cpos;\n\t\tstruct ocfs2_extent_list *el;\n\n\t\tdo_leftright++;\n\t\tsplit_rec = *orig_split_rec;\n\n\t\tocfs2_reinit_path(path, 1);\n\n\t\tcpos = le32_to_cpu(split_rec.e_cpos);\n\t\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tel = path_leaf_el(path);\n\t\tsplit_index = ocfs2_search_extent_list(el, cpos);\n\t\tif (split_index == -1) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\"Owner %llu has an extent at cpos %u \"\n\t\t\t\t\t\"which can no longer be found.\\n\",\n\t\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t\tcpos);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto leftright;\n\t}\nout:\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_split_and_insert(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_path *path,\n\t\t\t\t  struct buffer_head **last_eb_bh,\n\t\t\t\t  int split_index,\n\t\t\t\t  struct ocfs2_extent_rec *orig_split_rec,\n\t\t\t\t  struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret = 0, depth;\n\tunsigned int insert_range, rec_range, do_leftright = 0;\n\tstruct ocfs2_extent_rec tmprec;\n\tstruct ocfs2_extent_list *rightmost_el;\n\tstruct ocfs2_extent_rec rec;\n\tstruct ocfs2_extent_rec split_rec = *orig_split_rec;\n\tstruct ocfs2_insert_type insert;\n\tstruct ocfs2_extent_block *eb;\n\nleftright:\n\t/*\n\t * Store a copy of the record on the stack - it might move\n\t * around as the tree is manipulated below.\n\t */\n\trec = path_leaf_el(path)->l_recs[split_index];\n\n\trightmost_el = et->et_root_el;\n\n\tdepth = le16_to_cpu(rightmost_el->l_tree_depth);\n\tif (depth) {\n\t\tBUG_ON(!(*last_eb_bh));\n\t\teb = (struct ocfs2_extent_block *) (*last_eb_bh)->b_data;\n\t\trightmost_el = &eb->h_list;\n\t}\n\n\tif (le16_to_cpu(rightmost_el->l_next_free_rec) ==\n\t    le16_to_cpu(rightmost_el->l_count)) {\n\t\tret = ocfs2_grow_tree(handle, et,\n\t\t\t\t      &depth, last_eb_bh, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemset(&insert, 0, sizeof(struct ocfs2_insert_type));\n\tinsert.ins_appending = APPEND_NONE;\n\tinsert.ins_contig = CONTIG_NONE;\n\tinsert.ins_tree_depth = depth;\n\n\tinsert_range = le32_to_cpu(split_rec.e_cpos) +\n\t\tle16_to_cpu(split_rec.e_leaf_clusters);\n\trec_range = le32_to_cpu(rec.e_cpos) +\n\t\tle16_to_cpu(rec.e_leaf_clusters);\n\n\tif (split_rec.e_cpos == rec.e_cpos) {\n\t\tinsert.ins_split = SPLIT_LEFT;\n\t} else if (insert_range == rec_range) {\n\t\tinsert.ins_split = SPLIT_RIGHT;\n\t} else {\n\t\t/*\n\t\t * Left/right split. We fake this as a right split\n\t\t * first and then make a second pass as a left split.\n\t\t */\n\t\tinsert.ins_split = SPLIT_RIGHT;\n\n\t\tocfs2_make_right_split_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t   &tmprec, insert_range, &rec);\n\n\t\tsplit_rec = tmprec;\n\n\t\tBUG_ON(do_leftright);\n\t\tdo_leftright = 1;\n\t}\n\n\tret = ocfs2_do_insert_extent(handle, et, &split_rec, &insert);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (do_leftright == 1) {\n\t\tu32 cpos;\n\t\tstruct ocfs2_extent_list *el;\n\n\t\tdo_leftright++;\n\t\tsplit_rec = *orig_split_rec;\n\n\t\tocfs2_reinit_path(path, 1);\n\n\t\tcpos = le32_to_cpu(split_rec.e_cpos);\n\t\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tel = path_leaf_el(path);\n\t\tsplit_index = ocfs2_search_extent_list(el, cpos);\n\t\tif (split_index == -1) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\"Owner %llu has an extent at cpos %u \"\n\t\t\t\t\t\"which can no longer be found.\\n\",\n\t\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t\tcpos);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto leftright;\n\t}\nout:\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_replace_extent_rec",
          "args": [
            "handle",
            "et",
            "path",
            "el",
            "split_index",
            "split_rec"
          ],
          "line": 5084
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_replace_extent_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "4980-5001",
          "snippet": "static int ocfs2_replace_extent_rec(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_path *path,\n\t\t\t\t    struct ocfs2_extent_list *el,\n\t\t\t\t    int split_index,\n\t\t\t\t    struct ocfs2_extent_rec *split_rec)\n{\n\tint ret;\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, path,\n\t\t\t\t\t   path_num_items(path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel->l_recs[split_index] = *split_rec;\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(path));\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_replace_extent_rec(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_path *path,\n\t\t\t\t    struct ocfs2_extent_list *el,\n\t\t\t\t    int split_index,\n\t\t\t\t    struct ocfs2_extent_rec *split_rec)\n{\n\tint ret;\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, path,\n\t\t\t\t\t   path_num_items(path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel->l_recs[split_index] = *split_rec;\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(path));\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_split_extent",
          "args": [
            "split_index",
            "ctxt.c_contig_type",
            "ctxt.c_has_empty_extent",
            "ctxt.c_split_covers_rec"
          ],
          "line": 5078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&el->l_recs[0]"
          ],
          "line": 5076
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "266-269",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_root_el",
          "args": [
            "path"
          ],
          "line": 5068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_extent_block",
          "args": [
            "et->et_ci",
            "ocfs2_et_get_last_eb_blk(et)",
            "&last_eb_bh"
          ],
          "line": 5057
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_extent_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "939-953",
          "snippet": "int ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_et_get_last_eb_blk",
          "args": [
            "et"
          ],
          "line": 5058
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_get_last_eb_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "504-507",
          "snippet": "static inline u64 ocfs2_et_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\treturn et->et_ops->eo_get_last_eb_blk(et);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic inline u64 ocfs2_et_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\treturn et->et_ops->eo_get_last_eb_blk(et);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_figure_merge_contig_type",
          "args": [
            "et",
            "path",
            "el",
            "split_index",
            "split_rec"
          ],
          "line": 5045
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_figure_merge_contig_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "4316-4440",
          "snippet": "static enum ocfs2_contig_type\nocfs2_figure_merge_contig_type(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_path *path,\n\t\t\t       struct ocfs2_extent_list *el, int index,\n\t\t\t       struct ocfs2_extent_rec *split_rec)\n{\n\tint status;\n\tenum ocfs2_contig_type ret = CONTIG_NONE;\n\tu32 left_cpos, right_cpos;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_extent_list *new_el;\n\tstruct ocfs2_path *left_path = NULL, *right_path = NULL;\n\tstruct buffer_head *bh;\n\tstruct ocfs2_extent_block *eb;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\n\tif (index > 0) {\n\t\trec = &el->l_recs[index - 1];\n\t} else if (path->p_tree_depth > 0) {\n\t\tstatus = ocfs2_find_cpos_for_left_leaf(sb, path, &left_cpos);\n\t\tif (status)\n\t\t\tgoto out;\n\n\t\tif (left_cpos != 0) {\n\t\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\t\tif (!left_path)\n\t\t\t\tgoto out;\n\n\t\t\tstatus = ocfs2_find_path(et->et_ci, left_path,\n\t\t\t\t\t\t left_cpos);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\n\t\t\tnew_el = path_leaf_el(left_path);\n\n\t\t\tif (le16_to_cpu(new_el->l_next_free_rec) !=\n\t\t\t    le16_to_cpu(new_el->l_count)) {\n\t\t\t\tbh = path_leaf_bh(left_path);\n\t\t\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t\t\tocfs2_error(sb,\n\t\t\t\t\t    \"Extent block #%llu has an \"\n\t\t\t\t\t    \"invalid l_next_free_rec of \"\n\t\t\t\t\t    \"%d.  It should have \"\n\t\t\t\t\t    \"matched the l_count of %d\",\n\t\t\t\t\t    (unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t\t\t    le16_to_cpu(new_el->l_next_free_rec),\n\t\t\t\t\t    le16_to_cpu(new_el->l_count));\n\t\t\t\tstatus = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trec = &new_el->l_recs[\n\t\t\t\tle16_to_cpu(new_el->l_next_free_rec) - 1];\n\t\t}\n\t}\n\n\t/*\n\t * We're careful to check for an empty extent record here -\n\t * the merge code will know what to do if it sees one.\n\t */\n\tif (rec) {\n\t\tif (index == 1 && ocfs2_is_empty_extent(rec)) {\n\t\t\tif (split_rec->e_cpos == el->l_recs[index].e_cpos)\n\t\t\t\tret = CONTIG_RIGHT;\n\t\t} else {\n\t\t\tret = ocfs2_et_extent_contig(et, rec, split_rec);\n\t\t}\n\t}\n\n\trec = NULL;\n\tif (index < (le16_to_cpu(el->l_next_free_rec) - 1))\n\t\trec = &el->l_recs[index + 1];\n\telse if (le16_to_cpu(el->l_next_free_rec) == le16_to_cpu(el->l_count) &&\n\t\t path->p_tree_depth > 0) {\n\t\tstatus = ocfs2_find_cpos_for_right_leaf(sb, path, &right_cpos);\n\t\tif (status)\n\t\t\tgoto out;\n\n\t\tif (right_cpos == 0)\n\t\t\tgoto out;\n\n\t\tright_path = ocfs2_new_path_from_path(path);\n\t\tif (!right_path)\n\t\t\tgoto out;\n\n\t\tstatus = ocfs2_find_path(et->et_ci, right_path, right_cpos);\n\t\tif (status)\n\t\t\tgoto out;\n\n\t\tnew_el = path_leaf_el(right_path);\n\t\trec = &new_el->l_recs[0];\n\t\tif (ocfs2_is_empty_extent(rec)) {\n\t\t\tif (le16_to_cpu(new_el->l_next_free_rec) <= 1) {\n\t\t\t\tbh = path_leaf_bh(right_path);\n\t\t\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t\t\tocfs2_error(sb,\n\t\t\t\t\t    \"Extent block #%llu has an \"\n\t\t\t\t\t    \"invalid l_next_free_rec of %d\",\n\t\t\t\t\t    (unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t\t\t    le16_to_cpu(new_el->l_next_free_rec));\n\t\t\t\tstatus = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trec = &new_el->l_recs[1];\n\t\t}\n\t}\n\n\tif (rec) {\n\t\tenum ocfs2_contig_type contig_type;\n\n\t\tcontig_type = ocfs2_et_extent_contig(et, rec, split_rec);\n\n\t\tif (contig_type == CONTIG_LEFT && ret == CONTIG_RIGHT)\n\t\t\tret = CONTIG_LEFTRIGHT;\n\t\telse if (ret == CONTIG_NONE)\n\t\t\tret = contig_type;\n\t}\n\nout:\n\tif (left_path)\n\t\tocfs2_free_path(left_path);\n\tif (right_path)\n\t\tocfs2_free_path(right_path);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic enum ocfs2_contig_type\nocfs2_figure_merge_contig_type(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_path *path,\n\t\t\t       struct ocfs2_extent_list *el, int index,\n\t\t\t       struct ocfs2_extent_rec *split_rec)\n{\n\tint status;\n\tenum ocfs2_contig_type ret = CONTIG_NONE;\n\tu32 left_cpos, right_cpos;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_extent_list *new_el;\n\tstruct ocfs2_path *left_path = NULL, *right_path = NULL;\n\tstruct buffer_head *bh;\n\tstruct ocfs2_extent_block *eb;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\n\tif (index > 0) {\n\t\trec = &el->l_recs[index - 1];\n\t} else if (path->p_tree_depth > 0) {\n\t\tstatus = ocfs2_find_cpos_for_left_leaf(sb, path, &left_cpos);\n\t\tif (status)\n\t\t\tgoto out;\n\n\t\tif (left_cpos != 0) {\n\t\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\t\tif (!left_path)\n\t\t\t\tgoto out;\n\n\t\t\tstatus = ocfs2_find_path(et->et_ci, left_path,\n\t\t\t\t\t\t left_cpos);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\n\t\t\tnew_el = path_leaf_el(left_path);\n\n\t\t\tif (le16_to_cpu(new_el->l_next_free_rec) !=\n\t\t\t    le16_to_cpu(new_el->l_count)) {\n\t\t\t\tbh = path_leaf_bh(left_path);\n\t\t\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t\t\tocfs2_error(sb,\n\t\t\t\t\t    \"Extent block #%llu has an \"\n\t\t\t\t\t    \"invalid l_next_free_rec of \"\n\t\t\t\t\t    \"%d.  It should have \"\n\t\t\t\t\t    \"matched the l_count of %d\",\n\t\t\t\t\t    (unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t\t\t    le16_to_cpu(new_el->l_next_free_rec),\n\t\t\t\t\t    le16_to_cpu(new_el->l_count));\n\t\t\t\tstatus = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trec = &new_el->l_recs[\n\t\t\t\tle16_to_cpu(new_el->l_next_free_rec) - 1];\n\t\t}\n\t}\n\n\t/*\n\t * We're careful to check for an empty extent record here -\n\t * the merge code will know what to do if it sees one.\n\t */\n\tif (rec) {\n\t\tif (index == 1 && ocfs2_is_empty_extent(rec)) {\n\t\t\tif (split_rec->e_cpos == el->l_recs[index].e_cpos)\n\t\t\t\tret = CONTIG_RIGHT;\n\t\t} else {\n\t\t\tret = ocfs2_et_extent_contig(et, rec, split_rec);\n\t\t}\n\t}\n\n\trec = NULL;\n\tif (index < (le16_to_cpu(el->l_next_free_rec) - 1))\n\t\trec = &el->l_recs[index + 1];\n\telse if (le16_to_cpu(el->l_next_free_rec) == le16_to_cpu(el->l_count) &&\n\t\t path->p_tree_depth > 0) {\n\t\tstatus = ocfs2_find_cpos_for_right_leaf(sb, path, &right_cpos);\n\t\tif (status)\n\t\t\tgoto out;\n\n\t\tif (right_cpos == 0)\n\t\t\tgoto out;\n\n\t\tright_path = ocfs2_new_path_from_path(path);\n\t\tif (!right_path)\n\t\t\tgoto out;\n\n\t\tstatus = ocfs2_find_path(et->et_ci, right_path, right_cpos);\n\t\tif (status)\n\t\t\tgoto out;\n\n\t\tnew_el = path_leaf_el(right_path);\n\t\trec = &new_el->l_recs[0];\n\t\tif (ocfs2_is_empty_extent(rec)) {\n\t\t\tif (le16_to_cpu(new_el->l_next_free_rec) <= 1) {\n\t\t\t\tbh = path_leaf_bh(right_path);\n\t\t\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t\t\tocfs2_error(sb,\n\t\t\t\t\t    \"Extent block #%llu has an \"\n\t\t\t\t\t    \"invalid l_next_free_rec of %d\",\n\t\t\t\t\t    (unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t\t\t    le16_to_cpu(new_el->l_next_free_rec));\n\t\t\t\tstatus = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trec = &new_el->l_recs[1];\n\t\t}\n\t}\n\n\tif (rec) {\n\t\tenum ocfs2_contig_type contig_type;\n\n\t\tcontig_type = ocfs2_et_extent_contig(et, rec, split_rec);\n\n\t\tif (contig_type == CONTIG_LEFT && ret == CONTIG_RIGHT)\n\t\t\tret = CONTIG_LEFTRIGHT;\n\t\telse if (ret == CONTIG_NONE)\n\t\t\tret = contig_type;\n\t}\n\nout:\n\tif (left_path)\n\t\tocfs2_free_path(left_path);\n\tif (right_path)\n\t\tocfs2_free_path(right_path);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "split_rec->e_leaf_clusters"
          ],
          "line": 5039
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "split_rec->e_cpos"
          ],
          "line": 5039
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 5031
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nint ocfs2_split_extent(handle_t *handle,\n\t\t       struct ocfs2_extent_tree *et,\n\t\t       struct ocfs2_path *path,\n\t\t       int split_index,\n\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t       struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[split_index];\n\tstruct ocfs2_merge_ctxt ctxt;\n\tstruct ocfs2_extent_list *rightmost_el;\n\n\tif (le32_to_cpu(rec->e_cpos) > le32_to_cpu(split_rec->e_cpos) ||\n\t    ((le32_to_cpu(rec->e_cpos) + le16_to_cpu(rec->e_leaf_clusters)) <\n\t     (le32_to_cpu(split_rec->e_cpos) + le16_to_cpu(split_rec->e_leaf_clusters)))) {\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tctxt.c_contig_type = ocfs2_figure_merge_contig_type(et, path, el,\n\t\t\t\t\t\t\t    split_index,\n\t\t\t\t\t\t\t    split_rec);\n\n\t/*\n\t * The core merge / split code wants to know how much room is\n\t * left in this allocation tree, so we pass the\n\t * rightmost extent list.\n\t */\n\tif (path->p_tree_depth) {\n\t\tstruct ocfs2_extent_block *eb;\n\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &last_eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) last_eb_bh->b_data;\n\t\trightmost_el = &eb->h_list;\n\t} else\n\t\trightmost_el = path_root_el(path);\n\n\tif (rec->e_cpos == split_rec->e_cpos &&\n\t    rec->e_leaf_clusters == split_rec->e_leaf_clusters)\n\t\tctxt.c_split_covers_rec = 1;\n\telse\n\t\tctxt.c_split_covers_rec = 0;\n\n\tctxt.c_has_empty_extent = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\ttrace_ocfs2_split_extent(split_index, ctxt.c_contig_type,\n\t\t\t\t ctxt.c_has_empty_extent,\n\t\t\t\t ctxt.c_split_covers_rec);\n\n\tif (ctxt.c_contig_type == CONTIG_NONE) {\n\t\tif (ctxt.c_split_covers_rec)\n\t\t\tret = ocfs2_replace_extent_rec(handle, et, path, el,\n\t\t\t\t\t\t       split_index, split_rec);\n\t\telse\n\t\t\tret = ocfs2_split_and_insert(handle, et, path,\n\t\t\t\t\t\t     &last_eb_bh, split_index,\n\t\t\t\t\t\t     split_rec, meta_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t} else {\n\t\tret = ocfs2_try_to_merge_extent(handle, et, path,\n\t\t\t\t\t\tsplit_index, split_rec,\n\t\t\t\t\t\tdealloc, &ctxt);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tbrelse(last_eb_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_replace_extent_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "4980-5001",
    "snippet": "static int ocfs2_replace_extent_rec(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_path *path,\n\t\t\t\t    struct ocfs2_extent_list *el,\n\t\t\t\t    int split_index,\n\t\t\t\t    struct ocfs2_extent_rec *split_rec)\n{\n\tint ret;\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, path,\n\t\t\t\t\t   path_num_items(path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel->l_recs[split_index] = *split_rec;\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(path));\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "path_leaf_bh(path)"
          ],
          "line": 4998
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "path"
          ],
          "line": 4998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_path_bh_journal_access",
          "args": [
            "handle",
            "et->et_ci",
            "path",
            "path_num_items(path) - 1"
          ],
          "line": 4989
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_path_bh_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "726-741",
          "snippet": "int ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_num_items",
          "args": [
            "path"
          ],
          "line": 4990
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_replace_extent_rec(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_path *path,\n\t\t\t\t    struct ocfs2_extent_list *el,\n\t\t\t\t    int split_index,\n\t\t\t\t    struct ocfs2_extent_rec *split_rec)\n{\n\tint ret;\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, path,\n\t\t\t\t\t   path_num_items(path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel->l_recs[split_index] = *split_rec;\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(path));\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_split_and_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "4867-4978",
    "snippet": "static int ocfs2_split_and_insert(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_path *path,\n\t\t\t\t  struct buffer_head **last_eb_bh,\n\t\t\t\t  int split_index,\n\t\t\t\t  struct ocfs2_extent_rec *orig_split_rec,\n\t\t\t\t  struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret = 0, depth;\n\tunsigned int insert_range, rec_range, do_leftright = 0;\n\tstruct ocfs2_extent_rec tmprec;\n\tstruct ocfs2_extent_list *rightmost_el;\n\tstruct ocfs2_extent_rec rec;\n\tstruct ocfs2_extent_rec split_rec = *orig_split_rec;\n\tstruct ocfs2_insert_type insert;\n\tstruct ocfs2_extent_block *eb;\n\nleftright:\n\t/*\n\t * Store a copy of the record on the stack - it might move\n\t * around as the tree is manipulated below.\n\t */\n\trec = path_leaf_el(path)->l_recs[split_index];\n\n\trightmost_el = et->et_root_el;\n\n\tdepth = le16_to_cpu(rightmost_el->l_tree_depth);\n\tif (depth) {\n\t\tBUG_ON(!(*last_eb_bh));\n\t\teb = (struct ocfs2_extent_block *) (*last_eb_bh)->b_data;\n\t\trightmost_el = &eb->h_list;\n\t}\n\n\tif (le16_to_cpu(rightmost_el->l_next_free_rec) ==\n\t    le16_to_cpu(rightmost_el->l_count)) {\n\t\tret = ocfs2_grow_tree(handle, et,\n\t\t\t\t      &depth, last_eb_bh, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemset(&insert, 0, sizeof(struct ocfs2_insert_type));\n\tinsert.ins_appending = APPEND_NONE;\n\tinsert.ins_contig = CONTIG_NONE;\n\tinsert.ins_tree_depth = depth;\n\n\tinsert_range = le32_to_cpu(split_rec.e_cpos) +\n\t\tle16_to_cpu(split_rec.e_leaf_clusters);\n\trec_range = le32_to_cpu(rec.e_cpos) +\n\t\tle16_to_cpu(rec.e_leaf_clusters);\n\n\tif (split_rec.e_cpos == rec.e_cpos) {\n\t\tinsert.ins_split = SPLIT_LEFT;\n\t} else if (insert_range == rec_range) {\n\t\tinsert.ins_split = SPLIT_RIGHT;\n\t} else {\n\t\t/*\n\t\t * Left/right split. We fake this as a right split\n\t\t * first and then make a second pass as a left split.\n\t\t */\n\t\tinsert.ins_split = SPLIT_RIGHT;\n\n\t\tocfs2_make_right_split_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t   &tmprec, insert_range, &rec);\n\n\t\tsplit_rec = tmprec;\n\n\t\tBUG_ON(do_leftright);\n\t\tdo_leftright = 1;\n\t}\n\n\tret = ocfs2_do_insert_extent(handle, et, &split_rec, &insert);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (do_leftright == 1) {\n\t\tu32 cpos;\n\t\tstruct ocfs2_extent_list *el;\n\n\t\tdo_leftright++;\n\t\tsplit_rec = *orig_split_rec;\n\n\t\tocfs2_reinit_path(path, 1);\n\n\t\tcpos = le32_to_cpu(split_rec.e_cpos);\n\t\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tel = path_leaf_el(path);\n\t\tsplit_index = ocfs2_search_extent_list(el, cpos);\n\t\tif (split_index == -1) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\"Owner %llu has an extent at cpos %u \"\n\t\t\t\t\t\"which can no longer be found.\\n\",\n\t\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t\tcpos);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto leftright;\n\t}\nout:\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "\"Owner %llu has an extent at cpos %u \"\n\t\t\t\t\t\"which can no longer be found.\\n\"",
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "cpos"
          ],
          "line": 4965
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 4968
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 4965
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_search_extent_list",
          "args": [
            "el",
            "cpos"
          ],
          "line": 4963
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_search_extent_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "773-795",
          "snippet": "int ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nint ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 4962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "et->et_ci",
            "path",
            "cpos"
          ],
          "line": 4956
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1885-1894",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "split_rec.e_cpos"
          ],
          "line": 4955
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_reinit_path",
          "args": [
            "path",
            "1"
          ],
          "line": 4953
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reinit_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "580-607",
          "snippet": "void ocfs2_reinit_path(struct ocfs2_path *path, int keep_root)\n{\n\tint i, start = 0, depth = 0;\n\tstruct ocfs2_path_item *node;\n\n\tif (keep_root)\n\t\tstart = 1;\n\n\tfor(i = start; i < path_num_items(path); i++) {\n\t\tnode = &path->p_node[i];\n\n\t\tbrelse(node->bh);\n\t\tnode->bh = NULL;\n\t\tnode->el = NULL;\n\t}\n\n\t/*\n\t * Tree depth may change during truncate, or insert. If we're\n\t * keeping the root extent list, then make sure that our path\n\t * structure reflects the proper depth.\n\t */\n\tif (keep_root)\n\t\tdepth = le16_to_cpu(path_root_el(path)->l_tree_depth);\n\telse\n\t\tpath_root_access(path) = NULL;\n\n\tpath->p_tree_depth = depth;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_reinit_path(struct ocfs2_path *path, int keep_root)\n{\n\tint i, start = 0, depth = 0;\n\tstruct ocfs2_path_item *node;\n\n\tif (keep_root)\n\t\tstart = 1;\n\n\tfor(i = start; i < path_num_items(path); i++) {\n\t\tnode = &path->p_node[i];\n\n\t\tbrelse(node->bh);\n\t\tnode->bh = NULL;\n\t\tnode->el = NULL;\n\t}\n\n\t/*\n\t * Tree depth may change during truncate, or insert. If we're\n\t * keeping the root extent list, then make sure that our path\n\t * structure reflects the proper depth.\n\t */\n\tif (keep_root)\n\t\tdepth = le16_to_cpu(path_root_el(path)->l_tree_depth);\n\telse\n\t\tpath_root_access(path) = NULL;\n\n\tpath->p_tree_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_do_insert_extent",
          "args": [
            "handle",
            "et",
            "&split_rec",
            "&insert"
          ],
          "line": 4940
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_do_insert_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "4204-4314",
          "snippet": "static int ocfs2_do_insert_extent(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t  struct ocfs2_insert_type *type)\n{\n\tint ret, rotate = 0;\n\tu32 cpos;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el;\n\n\tel = et->et_root_el;\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(el->l_tree_depth) == 0) {\n\t\tocfs2_insert_at_leaf(et, insert_rec, el, type);\n\t\tgoto out_update_clusters;\n\t}\n\n\tright_path = ocfs2_new_path_from_et(et);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Determine the path to start with. Rotations need the\n\t * rightmost path, everything else can go directly to the\n\t * target leaf.\n\t */\n\tcpos = le32_to_cpu(insert_rec->e_cpos);\n\tif (type->ins_appending == APPEND_NONE &&\n\t    type->ins_contig == CONTIG_NONE) {\n\t\trotate = 1;\n\t\tcpos = UINT_MAX;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, right_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Rotations and appends need special treatment - they modify\n\t * parts of the tree's above them.\n\t *\n\t * Both might pass back a path immediate to the left of the\n\t * one being inserted to. This will be cause\n\t * ocfs2_insert_path() to modify the rightmost records of\n\t * left_path to account for an edge insert.\n\t *\n\t * XXX: When modifying this code, keep in mind that an insert\n\t * can wind up skipping both of these two special cases...\n\t */\n\tif (rotate) {\n\t\tret = ocfs2_rotate_tree_right(handle, et, type->ins_split,\n\t\t\t\t\t      le32_to_cpu(insert_rec->e_cpos),\n\t\t\t\t\t      right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * ocfs2_rotate_tree_right() might have extended the\n\t\t * transaction without re-journaling our tree root.\n\t\t */\n\t\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else if (type->ins_appending == APPEND_TAIL\n\t\t   && type->ins_contig != CONTIG_LEFT) {\n\t\tret = ocfs2_append_rec_to_path(handle, et, insert_rec,\n\t\t\t\t\t       right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_insert_path(handle, et, left_path, right_path,\n\t\t\t\tinsert_rec, type);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout_update_clusters:\n\tif (type->ins_split == SPLIT_NONE)\n\t\tocfs2_et_update_clusters(et,\n\t\t\t\t\t le16_to_cpu(insert_rec->e_leaf_clusters));\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\nout:\n\tocfs2_free_path(left_path);\n\tocfs2_free_path(right_path);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic int ocfs2_do_insert_extent(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t  struct ocfs2_insert_type *type)\n{\n\tint ret, rotate = 0;\n\tu32 cpos;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el;\n\n\tel = et->et_root_el;\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(el->l_tree_depth) == 0) {\n\t\tocfs2_insert_at_leaf(et, insert_rec, el, type);\n\t\tgoto out_update_clusters;\n\t}\n\n\tright_path = ocfs2_new_path_from_et(et);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Determine the path to start with. Rotations need the\n\t * rightmost path, everything else can go directly to the\n\t * target leaf.\n\t */\n\tcpos = le32_to_cpu(insert_rec->e_cpos);\n\tif (type->ins_appending == APPEND_NONE &&\n\t    type->ins_contig == CONTIG_NONE) {\n\t\trotate = 1;\n\t\tcpos = UINT_MAX;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, right_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Rotations and appends need special treatment - they modify\n\t * parts of the tree's above them.\n\t *\n\t * Both might pass back a path immediate to the left of the\n\t * one being inserted to. This will be cause\n\t * ocfs2_insert_path() to modify the rightmost records of\n\t * left_path to account for an edge insert.\n\t *\n\t * XXX: When modifying this code, keep in mind that an insert\n\t * can wind up skipping both of these two special cases...\n\t */\n\tif (rotate) {\n\t\tret = ocfs2_rotate_tree_right(handle, et, type->ins_split,\n\t\t\t\t\t      le32_to_cpu(insert_rec->e_cpos),\n\t\t\t\t\t      right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * ocfs2_rotate_tree_right() might have extended the\n\t\t * transaction without re-journaling our tree root.\n\t\t */\n\t\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else if (type->ins_appending == APPEND_TAIL\n\t\t   && type->ins_contig != CONTIG_LEFT) {\n\t\tret = ocfs2_append_rec_to_path(handle, et, insert_rec,\n\t\t\t\t\t       right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_insert_path(handle, et, left_path, right_path,\n\t\t\t\tinsert_rec, type);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout_update_clusters:\n\tif (type->ins_split == SPLIT_NONE)\n\t\tocfs2_et_update_clusters(et,\n\t\t\t\t\t le16_to_cpu(insert_rec->e_leaf_clusters));\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\nout:\n\tocfs2_free_path(left_path);\n\tocfs2_free_path(right_path);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "do_leftright"
          ],
          "line": 4936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_make_right_split_rec",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "&tmprec",
            "insert_range",
            "&rec"
          ],
          "line": 4931
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_make_right_split_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "4847-4865",
          "snippet": "static void ocfs2_make_right_split_rec(struct super_block *sb,\n\t\t\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t\t\t       u32 cpos,\n\t\t\t\t       struct ocfs2_extent_rec *rec)\n{\n\tu32 rec_cpos = le32_to_cpu(rec->e_cpos);\n\tu32 rec_range = rec_cpos + le16_to_cpu(rec->e_leaf_clusters);\n\n\tmemset(split_rec, 0, sizeof(struct ocfs2_extent_rec));\n\n\tsplit_rec->e_cpos = cpu_to_le32(cpos);\n\tsplit_rec->e_leaf_clusters = cpu_to_le16(rec_range - cpos);\n\n\tsplit_rec->e_blkno = rec->e_blkno;\n\tle64_add_cpu(&split_rec->e_blkno,\n\t\t     ocfs2_clusters_to_blocks(sb, cpos - rec_cpos));\n\n\tsplit_rec->e_flags = rec->e_flags;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic void ocfs2_make_right_split_rec(struct super_block *sb,\n\t\t\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t\t\t       u32 cpos,\n\t\t\t\t       struct ocfs2_extent_rec *rec)\n{\n\tu32 rec_cpos = le32_to_cpu(rec->e_cpos);\n\tu32 rec_range = rec_cpos + le16_to_cpu(rec->e_leaf_clusters);\n\n\tmemset(split_rec, 0, sizeof(struct ocfs2_extent_rec));\n\n\tsplit_rec->e_cpos = cpu_to_le32(cpos);\n\tsplit_rec->e_leaf_clusters = cpu_to_le16(rec_range - cpos);\n\n\tsplit_rec->e_blkno = rec->e_blkno;\n\tle64_add_cpu(&split_rec->e_blkno,\n\t\t     ocfs2_clusters_to_blocks(sb, cpos - rec_cpos));\n\n\tsplit_rec->e_flags = rec->e_flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rec.e_leaf_clusters"
          ],
          "line": 4918
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&insert",
            "0",
            "sizeof(struct ocfs2_insert_type)"
          ],
          "line": 4910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_grow_tree",
          "args": [
            "handle",
            "et",
            "&depth",
            "last_eb_bh",
            "meta_ac"
          ],
          "line": 4902
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_grow_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1510-1578",
          "snippet": "static int ocfs2_grow_tree(handle_t *handle, struct ocfs2_extent_tree *et,\n\t\t\t   int *final_depth, struct buffer_head **last_eb_bh,\n\t\t\t   struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret, shift;\n\tstruct ocfs2_extent_list *el = et->et_root_el;\n\tint depth = le16_to_cpu(el->l_tree_depth);\n\tstruct buffer_head *bh = NULL;\n\n\tBUG_ON(meta_ac == NULL);\n\n\tshift = ocfs2_find_branch_target(et, &bh);\n\tif (shift < 0) {\n\t\tret = shift;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* We traveled all the way to the bottom of the allocation tree\n\t * and didn't find room for any more extents - we need to add\n\t * another tree level */\n\tif (shift) {\n\t\tBUG_ON(bh);\n\t\ttrace_ocfs2_grow_tree(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tdepth);\n\n\t\t/* ocfs2_shift_tree_depth will return us a buffer with\n\t\t * the new extent block (so we can pass that to\n\t\t * ocfs2_add_branch). */\n\t\tret = ocfs2_shift_tree_depth(handle, et, meta_ac, &bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tdepth++;\n\t\tif (depth == 1) {\n\t\t\t/*\n\t\t\t * Special case: we have room now if we shifted from\n\t\t\t * tree_depth 0, so no more work needs to be done.\n\t\t\t *\n\t\t\t * We won't be calling add_branch, so pass\n\t\t\t * back *last_eb_bh as the new leaf. At depth\n\t\t\t * zero, it should always be null so there's\n\t\t\t * no reason to brelse.\n\t\t\t */\n\t\t\tBUG_ON(*last_eb_bh);\n\t\t\tget_bh(bh);\n\t\t\t*last_eb_bh = bh;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* call ocfs2_add_branch to add the final part of the tree with\n\t * the new data. */\n\tret = ocfs2_add_branch(handle, et, bh, last_eb_bh,\n\t\t\t       meta_ac);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout:\n\tif (final_depth)\n\t\t*final_depth = depth;\n\tbrelse(bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_grow_tree(handle_t *handle, struct ocfs2_extent_tree *et,\n\t\t\t   int *final_depth, struct buffer_head **last_eb_bh,\n\t\t\t   struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret, shift;\n\tstruct ocfs2_extent_list *el = et->et_root_el;\n\tint depth = le16_to_cpu(el->l_tree_depth);\n\tstruct buffer_head *bh = NULL;\n\n\tBUG_ON(meta_ac == NULL);\n\n\tshift = ocfs2_find_branch_target(et, &bh);\n\tif (shift < 0) {\n\t\tret = shift;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* We traveled all the way to the bottom of the allocation tree\n\t * and didn't find room for any more extents - we need to add\n\t * another tree level */\n\tif (shift) {\n\t\tBUG_ON(bh);\n\t\ttrace_ocfs2_grow_tree(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tdepth);\n\n\t\t/* ocfs2_shift_tree_depth will return us a buffer with\n\t\t * the new extent block (so we can pass that to\n\t\t * ocfs2_add_branch). */\n\t\tret = ocfs2_shift_tree_depth(handle, et, meta_ac, &bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tdepth++;\n\t\tif (depth == 1) {\n\t\t\t/*\n\t\t\t * Special case: we have room now if we shifted from\n\t\t\t * tree_depth 0, so no more work needs to be done.\n\t\t\t *\n\t\t\t * We won't be calling add_branch, so pass\n\t\t\t * back *last_eb_bh as the new leaf. At depth\n\t\t\t * zero, it should always be null so there's\n\t\t\t * no reason to brelse.\n\t\t\t */\n\t\t\tBUG_ON(*last_eb_bh);\n\t\t\tget_bh(bh);\n\t\t\t*last_eb_bh = bh;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* call ocfs2_add_branch to add the final part of the tree with\n\t * the new data. */\n\tret = ocfs2_add_branch(handle, et, bh, last_eb_bh,\n\t\t\t       meta_ac);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout:\n\tif (final_depth)\n\t\t*final_depth = depth;\n\tbrelse(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(*last_eb_bh)"
          ],
          "line": 4895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 4889
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_split_and_insert(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_path *path,\n\t\t\t\t  struct buffer_head **last_eb_bh,\n\t\t\t\t  int split_index,\n\t\t\t\t  struct ocfs2_extent_rec *orig_split_rec,\n\t\t\t\t  struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret = 0, depth;\n\tunsigned int insert_range, rec_range, do_leftright = 0;\n\tstruct ocfs2_extent_rec tmprec;\n\tstruct ocfs2_extent_list *rightmost_el;\n\tstruct ocfs2_extent_rec rec;\n\tstruct ocfs2_extent_rec split_rec = *orig_split_rec;\n\tstruct ocfs2_insert_type insert;\n\tstruct ocfs2_extent_block *eb;\n\nleftright:\n\t/*\n\t * Store a copy of the record on the stack - it might move\n\t * around as the tree is manipulated below.\n\t */\n\trec = path_leaf_el(path)->l_recs[split_index];\n\n\trightmost_el = et->et_root_el;\n\n\tdepth = le16_to_cpu(rightmost_el->l_tree_depth);\n\tif (depth) {\n\t\tBUG_ON(!(*last_eb_bh));\n\t\teb = (struct ocfs2_extent_block *) (*last_eb_bh)->b_data;\n\t\trightmost_el = &eb->h_list;\n\t}\n\n\tif (le16_to_cpu(rightmost_el->l_next_free_rec) ==\n\t    le16_to_cpu(rightmost_el->l_count)) {\n\t\tret = ocfs2_grow_tree(handle, et,\n\t\t\t\t      &depth, last_eb_bh, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemset(&insert, 0, sizeof(struct ocfs2_insert_type));\n\tinsert.ins_appending = APPEND_NONE;\n\tinsert.ins_contig = CONTIG_NONE;\n\tinsert.ins_tree_depth = depth;\n\n\tinsert_range = le32_to_cpu(split_rec.e_cpos) +\n\t\tle16_to_cpu(split_rec.e_leaf_clusters);\n\trec_range = le32_to_cpu(rec.e_cpos) +\n\t\tle16_to_cpu(rec.e_leaf_clusters);\n\n\tif (split_rec.e_cpos == rec.e_cpos) {\n\t\tinsert.ins_split = SPLIT_LEFT;\n\t} else if (insert_range == rec_range) {\n\t\tinsert.ins_split = SPLIT_RIGHT;\n\t} else {\n\t\t/*\n\t\t * Left/right split. We fake this as a right split\n\t\t * first and then make a second pass as a left split.\n\t\t */\n\t\tinsert.ins_split = SPLIT_RIGHT;\n\n\t\tocfs2_make_right_split_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t   &tmprec, insert_range, &rec);\n\n\t\tsplit_rec = tmprec;\n\n\t\tBUG_ON(do_leftright);\n\t\tdo_leftright = 1;\n\t}\n\n\tret = ocfs2_do_insert_extent(handle, et, &split_rec, &insert);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (do_leftright == 1) {\n\t\tu32 cpos;\n\t\tstruct ocfs2_extent_list *el;\n\n\t\tdo_leftright++;\n\t\tsplit_rec = *orig_split_rec;\n\n\t\tocfs2_reinit_path(path, 1);\n\n\t\tcpos = le32_to_cpu(split_rec.e_cpos);\n\t\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tel = path_leaf_el(path);\n\t\tsplit_index = ocfs2_search_extent_list(el, cpos);\n\t\tif (split_index == -1) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\"Owner %llu has an extent at cpos %u \"\n\t\t\t\t\t\"which can no longer be found.\\n\",\n\t\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t\tcpos);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto leftright;\n\t}\nout:\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_make_right_split_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "4847-4865",
    "snippet": "static void ocfs2_make_right_split_rec(struct super_block *sb,\n\t\t\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t\t\t       u32 cpos,\n\t\t\t\t       struct ocfs2_extent_rec *rec)\n{\n\tu32 rec_cpos = le32_to_cpu(rec->e_cpos);\n\tu32 rec_range = rec_cpos + le16_to_cpu(rec->e_leaf_clusters);\n\n\tmemset(split_rec, 0, sizeof(struct ocfs2_extent_rec));\n\n\tsplit_rec->e_cpos = cpu_to_le32(cpos);\n\tsplit_rec->e_leaf_clusters = cpu_to_le16(rec_range - cpos);\n\n\tsplit_rec->e_blkno = rec->e_blkno;\n\tle64_add_cpu(&split_rec->e_blkno,\n\t\t     ocfs2_clusters_to_blocks(sb, cpos - rec_cpos));\n\n\tsplit_rec->e_flags = rec->e_flags;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_add_cpu",
          "args": [
            "&split_rec->e_blkno",
            "ocfs2_clusters_to_blocks(sb, cpos - rec_cpos)"
          ],
          "line": 4861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "sb",
            "cpos - rec_cpos"
          ],
          "line": 4862
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "rec_range - cpos"
          ],
          "line": 4858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cpos"
          ],
          "line": 4857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "split_rec",
            "0",
            "sizeof(struct ocfs2_extent_rec)"
          ],
          "line": 4855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rec->e_leaf_clusters"
          ],
          "line": 4853
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 4852
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic void ocfs2_make_right_split_rec(struct super_block *sb,\n\t\t\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t\t\t       u32 cpos,\n\t\t\t\t       struct ocfs2_extent_rec *rec)\n{\n\tu32 rec_cpos = le32_to_cpu(rec->e_cpos);\n\tu32 rec_range = rec_cpos + le16_to_cpu(rec->e_leaf_clusters);\n\n\tmemset(split_rec, 0, sizeof(struct ocfs2_extent_rec));\n\n\tsplit_rec->e_cpos = cpu_to_le32(cpos);\n\tsplit_rec->e_leaf_clusters = cpu_to_le16(rec_range - cpos);\n\n\tsplit_rec->e_blkno = rec->e_blkno;\n\tle64_add_cpu(&split_rec->e_blkno,\n\t\t     ocfs2_clusters_to_blocks(sb, cpos - rec_cpos));\n\n\tsplit_rec->e_flags = rec->e_flags;\n}"
  },
  {
    "function_name": "ocfs2_add_clusters_in_btree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "4735-4845",
    "snippet": "int ocfs2_add_clusters_in_btree(handle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tu32 *logical_offset,\n\t\t\t\tu32 clusters_to_add,\n\t\t\t\tint mark_unwritten,\n\t\t\t\tstruct ocfs2_alloc_context *data_ac,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tenum ocfs2_alloc_restarted *reason_ret)\n{\n\tint status = 0, err = 0;\n\tint need_free = 0;\n\tint free_extents;\n\tenum ocfs2_alloc_restarted reason = RESTART_NONE;\n\tu32 bit_off, num_bits;\n\tu64 block;\n\tu8 flags = 0;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(et->et_ci));\n\n\tBUG_ON(!clusters_to_add);\n\n\tif (mark_unwritten)\n\t\tflags = OCFS2_EXT_UNWRITTEN;\n\n\tfree_extents = ocfs2_num_free_extents(osb, et);\n\tif (free_extents < 0) {\n\t\tstatus = free_extents;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* there are two cases which could cause us to EAGAIN in the\n\t * we-need-more-metadata case:\n\t * 1) we haven't reserved *any*\n\t * 2) we are so fragmented, we've needed to add metadata too\n\t *    many times. */\n\tif (!free_extents && !meta_ac) {\n\t\terr = -1;\n\t\tstatus = -EAGAIN;\n\t\treason = RESTART_META;\n\t\tgoto leave;\n\t} else if ((!free_extents)\n\t\t   && (ocfs2_alloc_context_bits_left(meta_ac)\n\t\t       < ocfs2_extend_meta_needed(et->et_root_el))) {\n\t\terr = -2;\n\t\tstatus = -EAGAIN;\n\t\treason = RESTART_META;\n\t\tgoto leave;\n\t}\n\n\tstatus = __ocfs2_claim_clusters(handle, data_ac, 1,\n\t\t\t\t\tclusters_to_add, &bit_off, &num_bits);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tBUG_ON(num_bits > clusters_to_add);\n\n\t/* reserve our write early -- insert_extent may update the tree root */\n\tstatus = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tneed_free = 1;\n\t\tgoto bail;\n\t}\n\n\tblock = ocfs2_clusters_to_blocks(osb->sb, bit_off);\n\ttrace_ocfs2_add_clusters_in_btree(\n\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t     bit_off, num_bits);\n\tstatus = ocfs2_insert_extent(handle, et, *logical_offset, block,\n\t\t\t\t     num_bits, flags, meta_ac);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tneed_free = 1;\n\t\tgoto bail;\n\t}\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\tclusters_to_add -= num_bits;\n\t*logical_offset += num_bits;\n\n\tif (clusters_to_add) {\n\t\terr = clusters_to_add;\n\t\tstatus = -EAGAIN;\n\t\treason = RESTART_TRANS;\n\t}\n\nbail:\n\tif (need_free) {\n\t\tif (data_ac->ac_which == OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_free_local_alloc_bits(osb, handle, data_ac,\n\t\t\t\t\tbit_off, num_bits);\n\t\telse\n\t\t\tocfs2_free_clusters(handle,\n\t\t\t\t\tdata_ac->ac_inode,\n\t\t\t\t\tdata_ac->ac_bh,\n\t\t\t\t\tocfs2_clusters_to_blocks(osb->sb, bit_off),\n\t\t\t\t\tnum_bits);\n\t}\n\nleave:\n\tif (reason_ret)\n\t\t*reason_ret = reason;\n\ttrace_ocfs2_add_clusters_in_btree_ret(status, reason, err);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ocfs2_add_clusters_in_btree_ret",
          "args": [
            "status",
            "reason",
            "err"
          ],
          "line": 4843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_clusters",
          "args": [
            "handle",
            "data_ac->ac_inode",
            "data_ac->ac_bh",
            "ocfs2_clusters_to_blocks(osb->sb, bit_off)",
            "num_bits"
          ],
          "line": 4833
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2591-2600",
          "snippet": "int ocfs2_free_clusters(handle_t *handle,\n\t\t\tstruct inode *bitmap_inode,\n\t\t\tstruct buffer_head *bitmap_bh,\n\t\t\tu64 start_blk,\n\t\t\tunsigned int num_clusters)\n{\n\treturn _ocfs2_free_clusters(handle, bitmap_inode, bitmap_bh,\n\t\t\t\t    start_blk, num_clusters,\n\t\t\t\t    _ocfs2_set_bit);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_free_clusters(handle_t *handle,\n\t\t\tstruct inode *bitmap_inode,\n\t\t\tstruct buffer_head *bitmap_bh,\n\t\t\tu64 start_blk,\n\t\t\tunsigned int num_clusters)\n{\n\treturn _ocfs2_free_clusters(handle, bitmap_inode, bitmap_bh,\n\t\t\t\t    start_blk, num_clusters,\n\t\t\t\t    _ocfs2_set_bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "osb->sb",
            "bit_off"
          ],
          "line": 4836
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_local_alloc_bits",
          "args": [
            "osb",
            "handle",
            "data_ac",
            "bit_off",
            "num_bits"
          ],
          "line": 4830
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_local_alloc_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "784-824",
          "snippet": "int ocfs2_free_local_alloc_bits(struct ocfs2_super *osb,\n\t\t\t\thandle_t *handle,\n\t\t\t\tstruct ocfs2_alloc_context *ac,\n\t\t\t\tu32 bit_off,\n\t\t\t\tu32 num_bits)\n{\n\tint status, start;\n\tu32 clear_bits;\n\tstruct inode *local_alloc_inode;\n\tvoid *bitmap;\n\tstruct ocfs2_dinode *alloc;\n\tstruct ocfs2_local_alloc *la;\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL);\n\n\tlocal_alloc_inode = ac->ac_inode;\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\tla = OCFS2_LOCAL_ALLOC(alloc);\n\n\tbitmap = la->la_bitmap;\n\tstart = bit_off - le32_to_cpu(la->la_bm_off);\n\tclear_bits = num_bits;\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\tINODE_CACHE(local_alloc_inode),\n\t\t\tosb->local_alloc_bh,\n\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\twhile (clear_bits--)\n\t\tocfs2_clear_bit(start++, bitmap);\n\n\tle32_add_cpu(&alloc->id1.bitmap1.i_used, -num_bits);\n\tocfs2_journal_dirty(handle, osb->local_alloc_bh);\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
            "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);",
            "static int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);",
            "static int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\nstatic int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);\nstatic int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode);\n\nint ocfs2_free_local_alloc_bits(struct ocfs2_super *osb,\n\t\t\t\thandle_t *handle,\n\t\t\t\tstruct ocfs2_alloc_context *ac,\n\t\t\t\tu32 bit_off,\n\t\t\t\tu32 num_bits)\n{\n\tint status, start;\n\tu32 clear_bits;\n\tstruct inode *local_alloc_inode;\n\tvoid *bitmap;\n\tstruct ocfs2_dinode *alloc;\n\tstruct ocfs2_local_alloc *la;\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL);\n\n\tlocal_alloc_inode = ac->ac_inode;\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\tla = OCFS2_LOCAL_ALLOC(alloc);\n\n\tbitmap = la->la_bitmap;\n\tstart = bit_off - le32_to_cpu(la->la_bm_off);\n\tclear_bits = num_bits;\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\tINODE_CACHE(local_alloc_inode),\n\t\t\tosb->local_alloc_bh,\n\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\twhile (clear_bits--)\n\t\tocfs2_clear_bit(start++, bitmap);\n\n\tle32_add_cpu(&alloc->id1.bitmap1.i_used, -num_bits);\n\tocfs2_journal_dirty(handle, osb->local_alloc_bh);\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "et->et_root_bh"
          ],
          "line": 4816
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 4811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_insert_extent",
          "args": [
            "handle",
            "et",
            "*logical_offset",
            "block",
            "num_bits",
            "flags",
            "meta_ac"
          ],
          "line": 4808
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_insert_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "4665-4726",
          "snippet": "int ocfs2_insert_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos,\n\t\t\tu64 start_blk,\n\t\t\tu32 new_clusters,\n\t\t\tu8 flags,\n\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint status;\n\tint uninitialized_var(free_records);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_insert_type insert = {0, };\n\tstruct ocfs2_extent_rec rec;\n\n\ttrace_ocfs2_insert_extent_start(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, new_clusters);\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.e_cpos = cpu_to_le32(cpos);\n\trec.e_blkno = cpu_to_le64(start_blk);\n\trec.e_leaf_clusters = cpu_to_le16(new_clusters);\n\trec.e_flags = flags;\n\tstatus = ocfs2_et_insert_check(et, &rec);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_figure_insert_type(et, &last_eb_bh, &rec,\n\t\t\t\t\t  &free_records, &insert);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_insert_extent(insert.ins_appending, insert.ins_contig,\n\t\t\t\t  insert.ins_contig_index, free_records,\n\t\t\t\t  insert.ins_tree_depth);\n\n\tif (insert.ins_contig == CONTIG_NONE && free_records == 0) {\n\t\tstatus = ocfs2_grow_tree(handle, et,\n\t\t\t\t\t &insert.ins_tree_depth, &last_eb_bh,\n\t\t\t\t\t meta_ac);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Finally, we can add clusters. This might rotate the tree for us. */\n\tstatus = ocfs2_do_insert_extent(handle, et, &rec, &insert);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_et_extent_map_insert(et, &rec);\n\nbail:\n\tbrelse(last_eb_bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_insert_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos,\n\t\t\tu64 start_blk,\n\t\t\tu32 new_clusters,\n\t\t\tu8 flags,\n\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint status;\n\tint uninitialized_var(free_records);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_insert_type insert = {0, };\n\tstruct ocfs2_extent_rec rec;\n\n\ttrace_ocfs2_insert_extent_start(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, new_clusters);\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.e_cpos = cpu_to_le32(cpos);\n\trec.e_blkno = cpu_to_le64(start_blk);\n\trec.e_leaf_clusters = cpu_to_le16(new_clusters);\n\trec.e_flags = flags;\n\tstatus = ocfs2_et_insert_check(et, &rec);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_figure_insert_type(et, &last_eb_bh, &rec,\n\t\t\t\t\t  &free_records, &insert);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_insert_extent(insert.ins_appending, insert.ins_contig,\n\t\t\t\t  insert.ins_contig_index, free_records,\n\t\t\t\t  insert.ins_tree_depth);\n\n\tif (insert.ins_contig == CONTIG_NONE && free_records == 0) {\n\t\tstatus = ocfs2_grow_tree(handle, et,\n\t\t\t\t\t &insert.ins_tree_depth, &last_eb_bh,\n\t\t\t\t\t meta_ac);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Finally, we can add clusters. This might rotate the tree for us. */\n\tstatus = ocfs2_do_insert_extent(handle, et, &rec, &insert);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_et_extent_map_insert(et, &rec);\n\nbail:\n\tbrelse(last_eb_bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_add_clusters_in_btree",
          "args": [
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "bit_off",
            "num_bits"
          ],
          "line": 4805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 4806
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 4799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_et_root_journal_access",
          "args": [
            "handle",
            "et",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 4796
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_root_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "529-535",
          "snippet": "static inline int ocfs2_et_root_journal_access(handle_t *handle,\n\t\t\t\t\t       struct ocfs2_extent_tree *et,\n\t\t\t\t\t       int type)\n{\n\treturn et->et_root_journal_access(handle, et->et_ci, et->et_root_bh,\n\t\t\t\t\t  type);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic inline int ocfs2_et_root_journal_access(handle_t *handle,\n\t\t\t\t\t       struct ocfs2_extent_tree *et,\n\t\t\t\t\t       int type)\n{\n\treturn et->et_root_journal_access(handle, et->et_ci, et->et_root_bh,\n\t\t\t\t\t  type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "num_bits > clusters_to_add"
          ],
          "line": 4793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 4789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_claim_clusters",
          "args": [
            "handle",
            "data_ac",
            "1",
            "clusters_to_add",
            "&bit_off",
            "&num_bits"
          ],
          "line": 4785
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_claim_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2302-2371",
          "snippet": "int __ocfs2_claim_clusters(handle_t *handle,\n\t\t\t   struct ocfs2_alloc_context *ac,\n\t\t\t   u32 min_clusters,\n\t\t\t   u32 max_clusters,\n\t\t\t   u32 *cluster_start,\n\t\t\t   u32 *num_clusters)\n{\n\tint status;\n\tunsigned int bits_wanted = max_clusters;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\tstruct ocfs2_super *osb = OCFS2_SB(ac->ac_inode->i_sb);\n\n\tBUG_ON(ac->ac_bits_given >= ac->ac_bits_wanted);\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL\n\t       && ac->ac_which != OCFS2_AC_USE_MAIN);\n\n\tif (ac->ac_which == OCFS2_AC_USE_LOCAL) {\n\t\tWARN_ON(min_clusters > 1);\n\n\t\tstatus = ocfs2_claim_local_alloc_bits(osb,\n\t\t\t\t\t\t      handle,\n\t\t\t\t\t\t      ac,\n\t\t\t\t\t\t      bits_wanted,\n\t\t\t\t\t\t      cluster_start,\n\t\t\t\t\t\t      num_clusters);\n\t\tif (!status)\n\t\t\tatomic_inc(&osb->alloc_stats.local_data);\n\t} else {\n\t\tif (min_clusters > (osb->bitmap_cpg - 1)) {\n\t\t\t/* The only paths asking for contiguousness\n\t\t\t * should know about this already. */\n\t\t\tmlog(ML_ERROR, \"minimum allocation requested %u exceeds \"\n\t\t\t     \"group bitmap size %u!\\n\", min_clusters,\n\t\t\t     osb->bitmap_cpg);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\t\t/* clamp the current request down to a realistic size. */\n\t\tif (bits_wanted > (osb->bitmap_cpg - 1))\n\t\t\tbits_wanted = osb->bitmap_cpg - 1;\n\n\t\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t\t   handle,\n\t\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t\t   min_clusters,\n\t\t\t\t\t\t   &res);\n\t\tif (!status) {\n\t\t\tBUG_ON(res.sr_blkno); /* cluster alloc can't set */\n\t\t\t*cluster_start =\n\t\t\t\tocfs2_desc_bitmap_to_cluster_off(ac->ac_inode,\n\t\t\t\t\t\t\t\t res.sr_bg_blkno,\n\t\t\t\t\t\t\t\t res.sr_bit_offset);\n\t\t\tatomic_inc(&osb->alloc_stats.bitmap_data);\n\t\t\t*num_clusters = res.sr_bits;\n\t\t}\n\t}\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tac->ac_bits_given += *num_clusters;\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint __ocfs2_claim_clusters(handle_t *handle,\n\t\t\t   struct ocfs2_alloc_context *ac,\n\t\t\t   u32 min_clusters,\n\t\t\t   u32 max_clusters,\n\t\t\t   u32 *cluster_start,\n\t\t\t   u32 *num_clusters)\n{\n\tint status;\n\tunsigned int bits_wanted = max_clusters;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\tstruct ocfs2_super *osb = OCFS2_SB(ac->ac_inode->i_sb);\n\n\tBUG_ON(ac->ac_bits_given >= ac->ac_bits_wanted);\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL\n\t       && ac->ac_which != OCFS2_AC_USE_MAIN);\n\n\tif (ac->ac_which == OCFS2_AC_USE_LOCAL) {\n\t\tWARN_ON(min_clusters > 1);\n\n\t\tstatus = ocfs2_claim_local_alloc_bits(osb,\n\t\t\t\t\t\t      handle,\n\t\t\t\t\t\t      ac,\n\t\t\t\t\t\t      bits_wanted,\n\t\t\t\t\t\t      cluster_start,\n\t\t\t\t\t\t      num_clusters);\n\t\tif (!status)\n\t\t\tatomic_inc(&osb->alloc_stats.local_data);\n\t} else {\n\t\tif (min_clusters > (osb->bitmap_cpg - 1)) {\n\t\t\t/* The only paths asking for contiguousness\n\t\t\t * should know about this already. */\n\t\t\tmlog(ML_ERROR, \"minimum allocation requested %u exceeds \"\n\t\t\t     \"group bitmap size %u!\\n\", min_clusters,\n\t\t\t     osb->bitmap_cpg);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\t\t/* clamp the current request down to a realistic size. */\n\t\tif (bits_wanted > (osb->bitmap_cpg - 1))\n\t\t\tbits_wanted = osb->bitmap_cpg - 1;\n\n\t\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t\t   handle,\n\t\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t\t   min_clusters,\n\t\t\t\t\t\t   &res);\n\t\tif (!status) {\n\t\t\tBUG_ON(res.sr_blkno); /* cluster alloc can't set */\n\t\t\t*cluster_start =\n\t\t\t\tocfs2_desc_bitmap_to_cluster_off(ac->ac_inode,\n\t\t\t\t\t\t\t\t res.sr_bg_blkno,\n\t\t\t\t\t\t\t\t res.sr_bit_offset);\n\t\t\tatomic_inc(&osb->alloc_stats.bitmap_data);\n\t\t\t*num_clusters = res.sr_bits;\n\t\t}\n\t}\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tac->ac_bits_given += *num_clusters;\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_meta_needed",
          "args": [
            "et->et_root_el"
          ],
          "line": 4778
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_meta_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "157-168",
          "snippet": "static inline int ocfs2_extend_meta_needed(struct ocfs2_extent_list *root_el)\n{\n\t/*\n\t * Rather than do all the work of determining how much we need\n\t * (involves a ton of reads and locks), just ask for the\n\t * maximal limit.  That's a tree depth shift.  So, one block for\n\t * level of the tree (current l_tree_depth), one block for the\n\t * new tree_depth==0 extent_block, and one block at the new\n\t * top-of-the tree.\n\t */\n\treturn le16_to_cpu(root_el->l_tree_depth) + 2;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_extend_meta_needed(struct ocfs2_extent_list *root_el)\n{\n\t/*\n\t * Rather than do all the work of determining how much we need\n\t * (involves a ton of reads and locks), just ask for the\n\t * maximal limit.  That's a tree depth shift.  So, one block for\n\t * level of the tree (current l_tree_depth), one block for the\n\t * new tree_depth==0 extent_block, and one block at the new\n\t * top-of-the tree.\n\t */\n\treturn le16_to_cpu(root_el->l_tree_depth) + 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_alloc_context_bits_left",
          "args": [
            "meta_ac"
          ],
          "line": 4777
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_alloc_context_bits_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.h",
          "lines": "67-70",
          "snippet": "static inline int ocfs2_alloc_context_bits_left(struct ocfs2_alloc_context *ac)\n{\n\treturn ac->ac_bits_wanted - ac->ac_bits_given;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_alloc_context_bits_left(struct ocfs2_alloc_context *ac)\n{\n\treturn ac->ac_bits_wanted - ac->ac_bits_given;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 4762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_num_free_extents",
          "args": [
            "osb",
            "et"
          ],
          "line": 4759
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_num_free_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "959-990",
          "snippet": "int ocfs2_num_free_extents(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_extent_tree *et)\n{\n\tint retval;\n\tstruct ocfs2_extent_list *el = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct buffer_head *eb_bh = NULL;\n\tu64 last_eb_blk = 0;\n\n\tel = et->et_root_el;\n\tlast_eb_blk = ocfs2_et_get_last_eb_blk(et);\n\n\tif (last_eb_blk) {\n\t\tretval = ocfs2_read_extent_block(et->et_ci, last_eb_blk,\n\t\t\t\t\t\t &eb_bh);\n\t\tif (retval < 0) {\n\t\t\tmlog_errno(retval);\n\t\t\tgoto bail;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\tBUG_ON(el->l_tree_depth != 0);\n\n\tretval = le16_to_cpu(el->l_count) - le16_to_cpu(el->l_next_free_rec);\nbail:\n\tbrelse(eb_bh);\n\n\ttrace_ocfs2_num_free_extents(retval);\n\treturn retval;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nint ocfs2_num_free_extents(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_extent_tree *et)\n{\n\tint retval;\n\tstruct ocfs2_extent_list *el = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct buffer_head *eb_bh = NULL;\n\tu64 last_eb_blk = 0;\n\n\tel = et->et_root_el;\n\tlast_eb_blk = ocfs2_et_get_last_eb_blk(et);\n\n\tif (last_eb_blk) {\n\t\tretval = ocfs2_read_extent_block(et->et_ci, last_eb_blk,\n\t\t\t\t\t\t &eb_bh);\n\t\tif (retval < 0) {\n\t\t\tmlog_errno(retval);\n\t\t\tgoto bail;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\tBUG_ON(el->l_tree_depth != 0);\n\n\tretval = le16_to_cpu(el->l_count) - le16_to_cpu(el->l_next_free_rec);\nbail:\n\tbrelse(eb_bh);\n\n\ttrace_ocfs2_num_free_extents(retval);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!clusters_to_add"
          ],
          "line": 4754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)"
          ],
          "line": 4752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 4752
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_add_clusters_in_btree(handle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tu32 *logical_offset,\n\t\t\t\tu32 clusters_to_add,\n\t\t\t\tint mark_unwritten,\n\t\t\t\tstruct ocfs2_alloc_context *data_ac,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tenum ocfs2_alloc_restarted *reason_ret)\n{\n\tint status = 0, err = 0;\n\tint need_free = 0;\n\tint free_extents;\n\tenum ocfs2_alloc_restarted reason = RESTART_NONE;\n\tu32 bit_off, num_bits;\n\tu64 block;\n\tu8 flags = 0;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(et->et_ci));\n\n\tBUG_ON(!clusters_to_add);\n\n\tif (mark_unwritten)\n\t\tflags = OCFS2_EXT_UNWRITTEN;\n\n\tfree_extents = ocfs2_num_free_extents(osb, et);\n\tif (free_extents < 0) {\n\t\tstatus = free_extents;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* there are two cases which could cause us to EAGAIN in the\n\t * we-need-more-metadata case:\n\t * 1) we haven't reserved *any*\n\t * 2) we are so fragmented, we've needed to add metadata too\n\t *    many times. */\n\tif (!free_extents && !meta_ac) {\n\t\terr = -1;\n\t\tstatus = -EAGAIN;\n\t\treason = RESTART_META;\n\t\tgoto leave;\n\t} else if ((!free_extents)\n\t\t   && (ocfs2_alloc_context_bits_left(meta_ac)\n\t\t       < ocfs2_extend_meta_needed(et->et_root_el))) {\n\t\terr = -2;\n\t\tstatus = -EAGAIN;\n\t\treason = RESTART_META;\n\t\tgoto leave;\n\t}\n\n\tstatus = __ocfs2_claim_clusters(handle, data_ac, 1,\n\t\t\t\t\tclusters_to_add, &bit_off, &num_bits);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tBUG_ON(num_bits > clusters_to_add);\n\n\t/* reserve our write early -- insert_extent may update the tree root */\n\tstatus = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tneed_free = 1;\n\t\tgoto bail;\n\t}\n\n\tblock = ocfs2_clusters_to_blocks(osb->sb, bit_off);\n\ttrace_ocfs2_add_clusters_in_btree(\n\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t     bit_off, num_bits);\n\tstatus = ocfs2_insert_extent(handle, et, *logical_offset, block,\n\t\t\t\t     num_bits, flags, meta_ac);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tneed_free = 1;\n\t\tgoto bail;\n\t}\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\tclusters_to_add -= num_bits;\n\t*logical_offset += num_bits;\n\n\tif (clusters_to_add) {\n\t\terr = clusters_to_add;\n\t\tstatus = -EAGAIN;\n\t\treason = RESTART_TRANS;\n\t}\n\nbail:\n\tif (need_free) {\n\t\tif (data_ac->ac_which == OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_free_local_alloc_bits(osb, handle, data_ac,\n\t\t\t\t\tbit_off, num_bits);\n\t\telse\n\t\t\tocfs2_free_clusters(handle,\n\t\t\t\t\tdata_ac->ac_inode,\n\t\t\t\t\tdata_ac->ac_bh,\n\t\t\t\t\tocfs2_clusters_to_blocks(osb->sb, bit_off),\n\t\t\t\t\tnum_bits);\n\t}\n\nleave:\n\tif (reason_ret)\n\t\t*reason_ret = reason;\n\ttrace_ocfs2_add_clusters_in_btree_ret(status, reason, err);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_insert_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "4665-4726",
    "snippet": "int ocfs2_insert_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos,\n\t\t\tu64 start_blk,\n\t\t\tu32 new_clusters,\n\t\t\tu8 flags,\n\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint status;\n\tint uninitialized_var(free_records);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_insert_type insert = {0, };\n\tstruct ocfs2_extent_rec rec;\n\n\ttrace_ocfs2_insert_extent_start(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, new_clusters);\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.e_cpos = cpu_to_le32(cpos);\n\trec.e_blkno = cpu_to_le64(start_blk);\n\trec.e_leaf_clusters = cpu_to_le16(new_clusters);\n\trec.e_flags = flags;\n\tstatus = ocfs2_et_insert_check(et, &rec);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_figure_insert_type(et, &last_eb_bh, &rec,\n\t\t\t\t\t  &free_records, &insert);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_insert_extent(insert.ins_appending, insert.ins_contig,\n\t\t\t\t  insert.ins_contig_index, free_records,\n\t\t\t\t  insert.ins_tree_depth);\n\n\tif (insert.ins_contig == CONTIG_NONE && free_records == 0) {\n\t\tstatus = ocfs2_grow_tree(handle, et,\n\t\t\t\t\t &insert.ins_tree_depth, &last_eb_bh,\n\t\t\t\t\t meta_ac);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Finally, we can add clusters. This might rotate the tree for us. */\n\tstatus = ocfs2_do_insert_extent(handle, et, &rec, &insert);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_et_extent_map_insert(et, &rec);\n\nbail:\n\tbrelse(last_eb_bh);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "last_eb_bh"
          ],
          "line": 4723
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_et_extent_map_insert",
          "args": [
            "et",
            "&rec"
          ],
          "line": 4720
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_extent_map_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "515-520",
          "snippet": "static inline void ocfs2_et_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\tif (et->et_ops->eo_extent_map_insert)\n\t\tet->et_ops->eo_extent_map_insert(et, rec);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic inline void ocfs2_et_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\tif (et->et_ops->eo_extent_map_insert)\n\t\tet->et_ops->eo_extent_map_insert(et, rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 4718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_do_insert_extent",
          "args": [
            "handle",
            "et",
            "&rec",
            "&insert"
          ],
          "line": 4716
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_do_insert_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "4204-4314",
          "snippet": "static int ocfs2_do_insert_extent(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t  struct ocfs2_insert_type *type)\n{\n\tint ret, rotate = 0;\n\tu32 cpos;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el;\n\n\tel = et->et_root_el;\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(el->l_tree_depth) == 0) {\n\t\tocfs2_insert_at_leaf(et, insert_rec, el, type);\n\t\tgoto out_update_clusters;\n\t}\n\n\tright_path = ocfs2_new_path_from_et(et);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Determine the path to start with. Rotations need the\n\t * rightmost path, everything else can go directly to the\n\t * target leaf.\n\t */\n\tcpos = le32_to_cpu(insert_rec->e_cpos);\n\tif (type->ins_appending == APPEND_NONE &&\n\t    type->ins_contig == CONTIG_NONE) {\n\t\trotate = 1;\n\t\tcpos = UINT_MAX;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, right_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Rotations and appends need special treatment - they modify\n\t * parts of the tree's above them.\n\t *\n\t * Both might pass back a path immediate to the left of the\n\t * one being inserted to. This will be cause\n\t * ocfs2_insert_path() to modify the rightmost records of\n\t * left_path to account for an edge insert.\n\t *\n\t * XXX: When modifying this code, keep in mind that an insert\n\t * can wind up skipping both of these two special cases...\n\t */\n\tif (rotate) {\n\t\tret = ocfs2_rotate_tree_right(handle, et, type->ins_split,\n\t\t\t\t\t      le32_to_cpu(insert_rec->e_cpos),\n\t\t\t\t\t      right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * ocfs2_rotate_tree_right() might have extended the\n\t\t * transaction without re-journaling our tree root.\n\t\t */\n\t\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else if (type->ins_appending == APPEND_TAIL\n\t\t   && type->ins_contig != CONTIG_LEFT) {\n\t\tret = ocfs2_append_rec_to_path(handle, et, insert_rec,\n\t\t\t\t\t       right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_insert_path(handle, et, left_path, right_path,\n\t\t\t\tinsert_rec, type);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout_update_clusters:\n\tif (type->ins_split == SPLIT_NONE)\n\t\tocfs2_et_update_clusters(et,\n\t\t\t\t\t le16_to_cpu(insert_rec->e_leaf_clusters));\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\nout:\n\tocfs2_free_path(left_path);\n\tocfs2_free_path(right_path);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic int ocfs2_do_insert_extent(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t  struct ocfs2_insert_type *type)\n{\n\tint ret, rotate = 0;\n\tu32 cpos;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el;\n\n\tel = et->et_root_el;\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(el->l_tree_depth) == 0) {\n\t\tocfs2_insert_at_leaf(et, insert_rec, el, type);\n\t\tgoto out_update_clusters;\n\t}\n\n\tright_path = ocfs2_new_path_from_et(et);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Determine the path to start with. Rotations need the\n\t * rightmost path, everything else can go directly to the\n\t * target leaf.\n\t */\n\tcpos = le32_to_cpu(insert_rec->e_cpos);\n\tif (type->ins_appending == APPEND_NONE &&\n\t    type->ins_contig == CONTIG_NONE) {\n\t\trotate = 1;\n\t\tcpos = UINT_MAX;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, right_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Rotations and appends need special treatment - they modify\n\t * parts of the tree's above them.\n\t *\n\t * Both might pass back a path immediate to the left of the\n\t * one being inserted to. This will be cause\n\t * ocfs2_insert_path() to modify the rightmost records of\n\t * left_path to account for an edge insert.\n\t *\n\t * XXX: When modifying this code, keep in mind that an insert\n\t * can wind up skipping both of these two special cases...\n\t */\n\tif (rotate) {\n\t\tret = ocfs2_rotate_tree_right(handle, et, type->ins_split,\n\t\t\t\t\t      le32_to_cpu(insert_rec->e_cpos),\n\t\t\t\t\t      right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * ocfs2_rotate_tree_right() might have extended the\n\t\t * transaction without re-journaling our tree root.\n\t\t */\n\t\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else if (type->ins_appending == APPEND_TAIL\n\t\t   && type->ins_contig != CONTIG_LEFT) {\n\t\tret = ocfs2_append_rec_to_path(handle, et, insert_rec,\n\t\t\t\t\t       right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_insert_path(handle, et, left_path, right_path,\n\t\t\t\tinsert_rec, type);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout_update_clusters:\n\tif (type->ins_split == SPLIT_NONE)\n\t\tocfs2_et_update_clusters(et,\n\t\t\t\t\t le16_to_cpu(insert_rec->e_leaf_clusters));\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\nout:\n\tocfs2_free_path(left_path);\n\tocfs2_free_path(right_path);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 4710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_grow_tree",
          "args": [
            "handle",
            "et",
            "&insert.ins_tree_depth",
            "&last_eb_bh",
            "meta_ac"
          ],
          "line": 4706
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_grow_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1510-1578",
          "snippet": "static int ocfs2_grow_tree(handle_t *handle, struct ocfs2_extent_tree *et,\n\t\t\t   int *final_depth, struct buffer_head **last_eb_bh,\n\t\t\t   struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret, shift;\n\tstruct ocfs2_extent_list *el = et->et_root_el;\n\tint depth = le16_to_cpu(el->l_tree_depth);\n\tstruct buffer_head *bh = NULL;\n\n\tBUG_ON(meta_ac == NULL);\n\n\tshift = ocfs2_find_branch_target(et, &bh);\n\tif (shift < 0) {\n\t\tret = shift;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* We traveled all the way to the bottom of the allocation tree\n\t * and didn't find room for any more extents - we need to add\n\t * another tree level */\n\tif (shift) {\n\t\tBUG_ON(bh);\n\t\ttrace_ocfs2_grow_tree(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tdepth);\n\n\t\t/* ocfs2_shift_tree_depth will return us a buffer with\n\t\t * the new extent block (so we can pass that to\n\t\t * ocfs2_add_branch). */\n\t\tret = ocfs2_shift_tree_depth(handle, et, meta_ac, &bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tdepth++;\n\t\tif (depth == 1) {\n\t\t\t/*\n\t\t\t * Special case: we have room now if we shifted from\n\t\t\t * tree_depth 0, so no more work needs to be done.\n\t\t\t *\n\t\t\t * We won't be calling add_branch, so pass\n\t\t\t * back *last_eb_bh as the new leaf. At depth\n\t\t\t * zero, it should always be null so there's\n\t\t\t * no reason to brelse.\n\t\t\t */\n\t\t\tBUG_ON(*last_eb_bh);\n\t\t\tget_bh(bh);\n\t\t\t*last_eb_bh = bh;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* call ocfs2_add_branch to add the final part of the tree with\n\t * the new data. */\n\tret = ocfs2_add_branch(handle, et, bh, last_eb_bh,\n\t\t\t       meta_ac);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout:\n\tif (final_depth)\n\t\t*final_depth = depth;\n\tbrelse(bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_grow_tree(handle_t *handle, struct ocfs2_extent_tree *et,\n\t\t\t   int *final_depth, struct buffer_head **last_eb_bh,\n\t\t\t   struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret, shift;\n\tstruct ocfs2_extent_list *el = et->et_root_el;\n\tint depth = le16_to_cpu(el->l_tree_depth);\n\tstruct buffer_head *bh = NULL;\n\n\tBUG_ON(meta_ac == NULL);\n\n\tshift = ocfs2_find_branch_target(et, &bh);\n\tif (shift < 0) {\n\t\tret = shift;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* We traveled all the way to the bottom of the allocation tree\n\t * and didn't find room for any more extents - we need to add\n\t * another tree level */\n\tif (shift) {\n\t\tBUG_ON(bh);\n\t\ttrace_ocfs2_grow_tree(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tdepth);\n\n\t\t/* ocfs2_shift_tree_depth will return us a buffer with\n\t\t * the new extent block (so we can pass that to\n\t\t * ocfs2_add_branch). */\n\t\tret = ocfs2_shift_tree_depth(handle, et, meta_ac, &bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tdepth++;\n\t\tif (depth == 1) {\n\t\t\t/*\n\t\t\t * Special case: we have room now if we shifted from\n\t\t\t * tree_depth 0, so no more work needs to be done.\n\t\t\t *\n\t\t\t * We won't be calling add_branch, so pass\n\t\t\t * back *last_eb_bh as the new leaf. At depth\n\t\t\t * zero, it should always be null so there's\n\t\t\t * no reason to brelse.\n\t\t\t */\n\t\t\tBUG_ON(*last_eb_bh);\n\t\t\tget_bh(bh);\n\t\t\t*last_eb_bh = bh;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* call ocfs2_add_branch to add the final part of the tree with\n\t * the new data. */\n\tret = ocfs2_add_branch(handle, et, bh, last_eb_bh,\n\t\t\t       meta_ac);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout:\n\tif (final_depth)\n\t\t*final_depth = depth;\n\tbrelse(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_insert_extent",
          "args": [
            "insert.ins_appending",
            "insert.ins_contig",
            "insert.ins_contig_index",
            "free_records",
            "insert.ins_tree_depth"
          ],
          "line": 4701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 4697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_figure_insert_type",
          "args": [
            "et",
            "&last_eb_bh",
            "&rec",
            "&free_records",
            "&insert"
          ],
          "line": 4694
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_figure_insert_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "4535-4658",
          "snippet": "static int ocfs2_figure_insert_type(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct buffer_head **last_eb_bh,\n\t\t\t\t    struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t    int *free_records,\n\t\t\t\t    struct ocfs2_insert_type *insert)\n{\n\tint ret;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *path = NULL;\n\tstruct buffer_head *bh = NULL;\n\n\tinsert->ins_split = SPLIT_NONE;\n\n\tel = et->et_root_el;\n\tinsert->ins_tree_depth = le16_to_cpu(el->l_tree_depth);\n\n\tif (el->l_tree_depth) {\n\t\t/*\n\t\t * If we have tree depth, we read in the\n\t\t * rightmost extent block ahead of time as\n\t\t * ocfs2_figure_insert_type() and ocfs2_add_branch()\n\t\t * may want it later.\n\t\t */\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\t/*\n\t * Unless we have a contiguous insert, we'll need to know if\n\t * there is room left in our allocation tree for another\n\t * extent record.\n\t *\n\t * XXX: This test is simplistic, we can search for empty\n\t * extent records too.\n\t */\n\t*free_records = le16_to_cpu(el->l_count) -\n\t\tle16_to_cpu(el->l_next_free_rec);\n\n\tif (!insert->ins_tree_depth) {\n\t\tocfs2_figure_contig_type(et, insert, el, insert_rec);\n\t\tocfs2_figure_appending_type(insert, el, insert_rec);\n\t\treturn 0;\n\t}\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * In the case that we're inserting past what the tree\n\t * currently accounts for, ocfs2_find_path() will return for\n\t * us the rightmost tree path. This is accounted for below in\n\t * the appending code.\n\t */\n\tret = ocfs2_find_path(et->et_ci, path, le32_to_cpu(insert_rec->e_cpos));\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\n\t/*\n\t * Now that we have the path, there's two things we want to determine:\n\t * 1) Contiguousness (also set contig_index if this is so)\n\t *\n\t * 2) Are we doing an append? We can trivially break this up\n         *     into two types of appends: simple record append, or a\n         *     rotate inside the tail leaf.\n\t */\n\tocfs2_figure_contig_type(et, insert, el, insert_rec);\n\n\t/*\n\t * The insert code isn't quite ready to deal with all cases of\n\t * left contiguousness. Specifically, if it's an insert into\n\t * the 1st record in a leaf, it will require the adjustment of\n\t * cluster count on the last record of the path directly to it's\n\t * left. For now, just catch that case and fool the layers\n\t * above us. This works just fine for tree_depth == 0, which\n\t * is why we allow that above.\n\t */\n\tif (insert->ins_contig == CONTIG_LEFT &&\n\t    insert->ins_contig_index == 0)\n\t\tinsert->ins_contig = CONTIG_NONE;\n\n\t/*\n\t * Ok, so we can simply compare against last_eb to figure out\n\t * whether the path doesn't exist. This will only happen in\n\t * the case that we're doing a tail append, so maybe we can\n\t * take advantage of that information somehow.\n\t */\n\tif (ocfs2_et_get_last_eb_blk(et) ==\n\t    path_leaf_bh(path)->b_blocknr) {\n\t\t/*\n\t\t * Ok, ocfs2_find_path() returned us the rightmost\n\t\t * tree path. This might be an appending insert. There are\n\t\t * two cases:\n\t\t *    1) We're doing a true append at the tail:\n\t\t *\t-This might even be off the end of the leaf\n\t\t *    2) We're \"appending\" by rotating in the tail\n\t\t */\n\t\tocfs2_figure_appending_type(insert, el, insert_rec);\n\t}\n\nout:\n\tocfs2_free_path(path);\n\n\tif (ret == 0)\n\t\t*last_eb_bh = bh;\n\telse\n\t\tbrelse(bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic int ocfs2_figure_insert_type(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct buffer_head **last_eb_bh,\n\t\t\t\t    struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t    int *free_records,\n\t\t\t\t    struct ocfs2_insert_type *insert)\n{\n\tint ret;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *path = NULL;\n\tstruct buffer_head *bh = NULL;\n\n\tinsert->ins_split = SPLIT_NONE;\n\n\tel = et->et_root_el;\n\tinsert->ins_tree_depth = le16_to_cpu(el->l_tree_depth);\n\n\tif (el->l_tree_depth) {\n\t\t/*\n\t\t * If we have tree depth, we read in the\n\t\t * rightmost extent block ahead of time as\n\t\t * ocfs2_figure_insert_type() and ocfs2_add_branch()\n\t\t * may want it later.\n\t\t */\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\t/*\n\t * Unless we have a contiguous insert, we'll need to know if\n\t * there is room left in our allocation tree for another\n\t * extent record.\n\t *\n\t * XXX: This test is simplistic, we can search for empty\n\t * extent records too.\n\t */\n\t*free_records = le16_to_cpu(el->l_count) -\n\t\tle16_to_cpu(el->l_next_free_rec);\n\n\tif (!insert->ins_tree_depth) {\n\t\tocfs2_figure_contig_type(et, insert, el, insert_rec);\n\t\tocfs2_figure_appending_type(insert, el, insert_rec);\n\t\treturn 0;\n\t}\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * In the case that we're inserting past what the tree\n\t * currently accounts for, ocfs2_find_path() will return for\n\t * us the rightmost tree path. This is accounted for below in\n\t * the appending code.\n\t */\n\tret = ocfs2_find_path(et->et_ci, path, le32_to_cpu(insert_rec->e_cpos));\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\n\t/*\n\t * Now that we have the path, there's two things we want to determine:\n\t * 1) Contiguousness (also set contig_index if this is so)\n\t *\n\t * 2) Are we doing an append? We can trivially break this up\n         *     into two types of appends: simple record append, or a\n         *     rotate inside the tail leaf.\n\t */\n\tocfs2_figure_contig_type(et, insert, el, insert_rec);\n\n\t/*\n\t * The insert code isn't quite ready to deal with all cases of\n\t * left contiguousness. Specifically, if it's an insert into\n\t * the 1st record in a leaf, it will require the adjustment of\n\t * cluster count on the last record of the path directly to it's\n\t * left. For now, just catch that case and fool the layers\n\t * above us. This works just fine for tree_depth == 0, which\n\t * is why we allow that above.\n\t */\n\tif (insert->ins_contig == CONTIG_LEFT &&\n\t    insert->ins_contig_index == 0)\n\t\tinsert->ins_contig = CONTIG_NONE;\n\n\t/*\n\t * Ok, so we can simply compare against last_eb to figure out\n\t * whether the path doesn't exist. This will only happen in\n\t * the case that we're doing a tail append, so maybe we can\n\t * take advantage of that information somehow.\n\t */\n\tif (ocfs2_et_get_last_eb_blk(et) ==\n\t    path_leaf_bh(path)->b_blocknr) {\n\t\t/*\n\t\t * Ok, ocfs2_find_path() returned us the rightmost\n\t\t * tree path. This might be an appending insert. There are\n\t\t * two cases:\n\t\t *    1) We're doing a true append at the tail:\n\t\t *\t-This might even be off the end of the leaf\n\t\t *    2) We're \"appending\" by rotating in the tail\n\t\t */\n\t\tocfs2_figure_appending_type(insert, el, insert_rec);\n\t}\n\nout:\n\tocfs2_free_path(path);\n\n\tif (ret == 0)\n\t\t*last_eb_bh = bh;\n\telse\n\t\tbrelse(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 4690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_et_insert_check",
          "args": [
            "et",
            "&rec"
          ],
          "line": 4688
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_insert_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "550-558",
          "snippet": "static inline int ocfs2_et_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_extent_rec *rec)\n{\n\tint ret = 0;\n\n\tif (et->et_ops->eo_insert_check)\n\t\tret = et->et_ops->eo_insert_check(et, rec);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic inline int ocfs2_et_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_extent_rec *rec)\n{\n\tint ret = 0;\n\n\tif (et->et_ops->eo_insert_check)\n\t\tret = et->et_ops->eo_insert_check(et, rec);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "new_clusters"
          ],
          "line": 4686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "start_blk"
          ],
          "line": 4685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cpos"
          ],
          "line": 4684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rec",
            "0",
            "sizeof(rec)"
          ],
          "line": 4683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_insert_extent_start",
          "args": [
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "cpos",
            "new_clusters"
          ],
          "line": 4679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 4680
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_insert_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos,\n\t\t\tu64 start_blk,\n\t\t\tu32 new_clusters,\n\t\t\tu8 flags,\n\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint status;\n\tint uninitialized_var(free_records);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_insert_type insert = {0, };\n\tstruct ocfs2_extent_rec rec;\n\n\ttrace_ocfs2_insert_extent_start(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, new_clusters);\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.e_cpos = cpu_to_le32(cpos);\n\trec.e_blkno = cpu_to_le64(start_blk);\n\trec.e_leaf_clusters = cpu_to_le16(new_clusters);\n\trec.e_flags = flags;\n\tstatus = ocfs2_et_insert_check(et, &rec);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_figure_insert_type(et, &last_eb_bh, &rec,\n\t\t\t\t\t  &free_records, &insert);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_insert_extent(insert.ins_appending, insert.ins_contig,\n\t\t\t\t  insert.ins_contig_index, free_records,\n\t\t\t\t  insert.ins_tree_depth);\n\n\tif (insert.ins_contig == CONTIG_NONE && free_records == 0) {\n\t\tstatus = ocfs2_grow_tree(handle, et,\n\t\t\t\t\t &insert.ins_tree_depth, &last_eb_bh,\n\t\t\t\t\t meta_ac);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Finally, we can add clusters. This might rotate the tree for us. */\n\tstatus = ocfs2_do_insert_extent(handle, et, &rec, &insert);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_et_extent_map_insert(et, &rec);\n\nbail:\n\tbrelse(last_eb_bh);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_figure_insert_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "4535-4658",
    "snippet": "static int ocfs2_figure_insert_type(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct buffer_head **last_eb_bh,\n\t\t\t\t    struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t    int *free_records,\n\t\t\t\t    struct ocfs2_insert_type *insert)\n{\n\tint ret;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *path = NULL;\n\tstruct buffer_head *bh = NULL;\n\n\tinsert->ins_split = SPLIT_NONE;\n\n\tel = et->et_root_el;\n\tinsert->ins_tree_depth = le16_to_cpu(el->l_tree_depth);\n\n\tif (el->l_tree_depth) {\n\t\t/*\n\t\t * If we have tree depth, we read in the\n\t\t * rightmost extent block ahead of time as\n\t\t * ocfs2_figure_insert_type() and ocfs2_add_branch()\n\t\t * may want it later.\n\t\t */\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\t/*\n\t * Unless we have a contiguous insert, we'll need to know if\n\t * there is room left in our allocation tree for another\n\t * extent record.\n\t *\n\t * XXX: This test is simplistic, we can search for empty\n\t * extent records too.\n\t */\n\t*free_records = le16_to_cpu(el->l_count) -\n\t\tle16_to_cpu(el->l_next_free_rec);\n\n\tif (!insert->ins_tree_depth) {\n\t\tocfs2_figure_contig_type(et, insert, el, insert_rec);\n\t\tocfs2_figure_appending_type(insert, el, insert_rec);\n\t\treturn 0;\n\t}\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * In the case that we're inserting past what the tree\n\t * currently accounts for, ocfs2_find_path() will return for\n\t * us the rightmost tree path. This is accounted for below in\n\t * the appending code.\n\t */\n\tret = ocfs2_find_path(et->et_ci, path, le32_to_cpu(insert_rec->e_cpos));\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\n\t/*\n\t * Now that we have the path, there's two things we want to determine:\n\t * 1) Contiguousness (also set contig_index if this is so)\n\t *\n\t * 2) Are we doing an append? We can trivially break this up\n         *     into two types of appends: simple record append, or a\n         *     rotate inside the tail leaf.\n\t */\n\tocfs2_figure_contig_type(et, insert, el, insert_rec);\n\n\t/*\n\t * The insert code isn't quite ready to deal with all cases of\n\t * left contiguousness. Specifically, if it's an insert into\n\t * the 1st record in a leaf, it will require the adjustment of\n\t * cluster count on the last record of the path directly to it's\n\t * left. For now, just catch that case and fool the layers\n\t * above us. This works just fine for tree_depth == 0, which\n\t * is why we allow that above.\n\t */\n\tif (insert->ins_contig == CONTIG_LEFT &&\n\t    insert->ins_contig_index == 0)\n\t\tinsert->ins_contig = CONTIG_NONE;\n\n\t/*\n\t * Ok, so we can simply compare against last_eb to figure out\n\t * whether the path doesn't exist. This will only happen in\n\t * the case that we're doing a tail append, so maybe we can\n\t * take advantage of that information somehow.\n\t */\n\tif (ocfs2_et_get_last_eb_blk(et) ==\n\t    path_leaf_bh(path)->b_blocknr) {\n\t\t/*\n\t\t * Ok, ocfs2_find_path() returned us the rightmost\n\t\t * tree path. This might be an appending insert. There are\n\t\t * two cases:\n\t\t *    1) We're doing a true append at the tail:\n\t\t *\t-This might even be off the end of the leaf\n\t\t *    2) We're \"appending\" by rotating in the tail\n\t\t */\n\t\tocfs2_figure_appending_type(insert, el, insert_rec);\n\t}\n\nout:\n\tocfs2_free_path(path);\n\n\tif (ret == 0)\n\t\t*last_eb_bh = bh;\n\telse\n\t\tbrelse(bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);",
      "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 4656
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "path"
          ],
          "line": 4651
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "609-615",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_figure_appending_type",
          "args": [
            "insert",
            "el",
            "insert_rec"
          ],
          "line": 4647
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_figure_appending_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "4488-4520",
          "snippet": "static void ocfs2_figure_appending_type(struct ocfs2_insert_type *insert,\n\t\t\t\t\tstruct ocfs2_extent_list *el,\n\t\t\t\t\tstruct ocfs2_extent_rec *insert_rec)\n{\n\tint i;\n\tu32 cpos = le32_to_cpu(insert_rec->e_cpos);\n\tstruct ocfs2_extent_rec *rec;\n\n\tinsert->ins_appending = APPEND_NONE;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (!el->l_next_free_rec)\n\t\tgoto set_tail_append;\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0])) {\n\t\t/* Were all records empty? */\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 1)\n\t\t\tgoto set_tail_append;\n\t}\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[i];\n\n\tif (cpos >=\n\t    (le32_to_cpu(rec->e_cpos) + le16_to_cpu(rec->e_leaf_clusters)))\n\t\tgoto set_tail_append;\n\n\treturn;\n\nset_tail_append:\n\tinsert->ins_appending = APPEND_TAIL;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_figure_appending_type(struct ocfs2_insert_type *insert,\n\t\t\t\t\tstruct ocfs2_extent_list *el,\n\t\t\t\t\tstruct ocfs2_extent_rec *insert_rec)\n{\n\tint i;\n\tu32 cpos = le32_to_cpu(insert_rec->e_cpos);\n\tstruct ocfs2_extent_rec *rec;\n\n\tinsert->ins_appending = APPEND_NONE;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (!el->l_next_free_rec)\n\t\tgoto set_tail_append;\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0])) {\n\t\t/* Were all records empty? */\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 1)\n\t\t\tgoto set_tail_append;\n\t}\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[i];\n\n\tif (cpos >=\n\t    (le32_to_cpu(rec->e_cpos) + le16_to_cpu(rec->e_leaf_clusters)))\n\t\tgoto set_tail_append;\n\n\treturn;\n\nset_tail_append:\n\tinsert->ins_appending = APPEND_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "path"
          ],
          "line": 4638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_et_get_last_eb_blk",
          "args": [
            "et"
          ],
          "line": 4637
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_get_last_eb_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "504-507",
          "snippet": "static inline u64 ocfs2_et_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\treturn et->et_ops->eo_get_last_eb_blk(et);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic inline u64 ocfs2_et_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\treturn et->et_ops->eo_get_last_eb_blk(et);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_figure_contig_type",
          "args": [
            "et",
            "insert",
            "el",
            "insert_rec"
          ],
          "line": 4616
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_figure_contig_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "4442-4476",
          "snippet": "static void ocfs2_figure_contig_type(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_insert_type *insert,\n\t\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t\t     struct ocfs2_extent_rec *insert_rec)\n{\n\tint i;\n\tenum ocfs2_contig_type contig_type = CONTIG_NONE;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\tcontig_type = ocfs2_et_extent_contig(et, &el->l_recs[i],\n\t\t\t\t\t\t     insert_rec);\n\t\tif (contig_type != CONTIG_NONE) {\n\t\t\tinsert->ins_contig_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tinsert->ins_contig = contig_type;\n\n\tif (insert->ins_contig != CONTIG_NONE) {\n\t\tstruct ocfs2_extent_rec *rec =\n\t\t\t\t&el->l_recs[insert->ins_contig_index];\n\t\tunsigned int len = le16_to_cpu(rec->e_leaf_clusters) +\n\t\t\t\t   le16_to_cpu(insert_rec->e_leaf_clusters);\n\n\t\t/*\n\t\t * Caller might want us to limit the size of extents, don't\n\t\t * calculate contiguousness if we might exceed that limit.\n\t\t */\n\t\tif (et->et_max_leaf_clusters &&\n\t\t    (len > et->et_max_leaf_clusters))\n\t\t\tinsert->ins_contig = CONTIG_NONE;\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_figure_contig_type(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_insert_type *insert,\n\t\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t\t     struct ocfs2_extent_rec *insert_rec)\n{\n\tint i;\n\tenum ocfs2_contig_type contig_type = CONTIG_NONE;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\tcontig_type = ocfs2_et_extent_contig(et, &el->l_recs[i],\n\t\t\t\t\t\t     insert_rec);\n\t\tif (contig_type != CONTIG_NONE) {\n\t\t\tinsert->ins_contig_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tinsert->ins_contig = contig_type;\n\n\tif (insert->ins_contig != CONTIG_NONE) {\n\t\tstruct ocfs2_extent_rec *rec =\n\t\t\t\t&el->l_recs[insert->ins_contig_index];\n\t\tunsigned int len = le16_to_cpu(rec->e_leaf_clusters) +\n\t\t\t\t   le16_to_cpu(insert_rec->e_leaf_clusters);\n\n\t\t/*\n\t\t * Caller might want us to limit the size of extents, don't\n\t\t * calculate contiguousness if we might exceed that limit.\n\t\t */\n\t\tif (et->et_max_leaf_clusters &&\n\t\t    (len > et->et_max_leaf_clusters))\n\t\t\tinsert->ins_contig = CONTIG_NONE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 4606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "et->et_ci",
            "path",
            "le32_to_cpu(insert_rec->e_cpos)"
          ],
          "line": 4600
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1885-1894",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "insert_rec->e_cpos"
          ],
          "line": 4600
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_et",
          "args": [
            "et"
          ],
          "line": 4587
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_et",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "713-717",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstruct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 4579
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_extent_block",
          "args": [
            "et->et_ci",
            "ocfs2_et_get_last_eb_blk(et)",
            "&bh"
          ],
          "line": 4559
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_extent_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "939-953",
          "snippet": "int ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic int ocfs2_figure_insert_type(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct buffer_head **last_eb_bh,\n\t\t\t\t    struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t    int *free_records,\n\t\t\t\t    struct ocfs2_insert_type *insert)\n{\n\tint ret;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *path = NULL;\n\tstruct buffer_head *bh = NULL;\n\n\tinsert->ins_split = SPLIT_NONE;\n\n\tel = et->et_root_el;\n\tinsert->ins_tree_depth = le16_to_cpu(el->l_tree_depth);\n\n\tif (el->l_tree_depth) {\n\t\t/*\n\t\t * If we have tree depth, we read in the\n\t\t * rightmost extent block ahead of time as\n\t\t * ocfs2_figure_insert_type() and ocfs2_add_branch()\n\t\t * may want it later.\n\t\t */\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\t/*\n\t * Unless we have a contiguous insert, we'll need to know if\n\t * there is room left in our allocation tree for another\n\t * extent record.\n\t *\n\t * XXX: This test is simplistic, we can search for empty\n\t * extent records too.\n\t */\n\t*free_records = le16_to_cpu(el->l_count) -\n\t\tle16_to_cpu(el->l_next_free_rec);\n\n\tif (!insert->ins_tree_depth) {\n\t\tocfs2_figure_contig_type(et, insert, el, insert_rec);\n\t\tocfs2_figure_appending_type(insert, el, insert_rec);\n\t\treturn 0;\n\t}\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * In the case that we're inserting past what the tree\n\t * currently accounts for, ocfs2_find_path() will return for\n\t * us the rightmost tree path. This is accounted for below in\n\t * the appending code.\n\t */\n\tret = ocfs2_find_path(et->et_ci, path, le32_to_cpu(insert_rec->e_cpos));\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\n\t/*\n\t * Now that we have the path, there's two things we want to determine:\n\t * 1) Contiguousness (also set contig_index if this is so)\n\t *\n\t * 2) Are we doing an append? We can trivially break this up\n         *     into two types of appends: simple record append, or a\n         *     rotate inside the tail leaf.\n\t */\n\tocfs2_figure_contig_type(et, insert, el, insert_rec);\n\n\t/*\n\t * The insert code isn't quite ready to deal with all cases of\n\t * left contiguousness. Specifically, if it's an insert into\n\t * the 1st record in a leaf, it will require the adjustment of\n\t * cluster count on the last record of the path directly to it's\n\t * left. For now, just catch that case and fool the layers\n\t * above us. This works just fine for tree_depth == 0, which\n\t * is why we allow that above.\n\t */\n\tif (insert->ins_contig == CONTIG_LEFT &&\n\t    insert->ins_contig_index == 0)\n\t\tinsert->ins_contig = CONTIG_NONE;\n\n\t/*\n\t * Ok, so we can simply compare against last_eb to figure out\n\t * whether the path doesn't exist. This will only happen in\n\t * the case that we're doing a tail append, so maybe we can\n\t * take advantage of that information somehow.\n\t */\n\tif (ocfs2_et_get_last_eb_blk(et) ==\n\t    path_leaf_bh(path)->b_blocknr) {\n\t\t/*\n\t\t * Ok, ocfs2_find_path() returned us the rightmost\n\t\t * tree path. This might be an appending insert. There are\n\t\t * two cases:\n\t\t *    1) We're doing a true append at the tail:\n\t\t *\t-This might even be off the end of the leaf\n\t\t *    2) We're \"appending\" by rotating in the tail\n\t\t */\n\t\tocfs2_figure_appending_type(insert, el, insert_rec);\n\t}\n\nout:\n\tocfs2_free_path(path);\n\n\tif (ret == 0)\n\t\t*last_eb_bh = bh;\n\telse\n\t\tbrelse(bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_figure_appending_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "4488-4520",
    "snippet": "static void ocfs2_figure_appending_type(struct ocfs2_insert_type *insert,\n\t\t\t\t\tstruct ocfs2_extent_list *el,\n\t\t\t\t\tstruct ocfs2_extent_rec *insert_rec)\n{\n\tint i;\n\tu32 cpos = le32_to_cpu(insert_rec->e_cpos);\n\tstruct ocfs2_extent_rec *rec;\n\n\tinsert->ins_appending = APPEND_NONE;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (!el->l_next_free_rec)\n\t\tgoto set_tail_append;\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0])) {\n\t\t/* Were all records empty? */\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 1)\n\t\t\tgoto set_tail_append;\n\t}\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[i];\n\n\tif (cpos >=\n\t    (le32_to_cpu(rec->e_cpos) + le16_to_cpu(rec->e_leaf_clusters)))\n\t\tgoto set_tail_append;\n\n\treturn;\n\nset_tail_append:\n\tinsert->ins_appending = APPEND_TAIL;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rec->e_leaf_clusters"
          ],
          "line": 4513
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 4513
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&el->l_recs[0]"
          ],
          "line": 4503
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "266-269",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le16_to_cpu(el->l_tree_depth) != 0"
          ],
          "line": 4498
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_figure_appending_type(struct ocfs2_insert_type *insert,\n\t\t\t\t\tstruct ocfs2_extent_list *el,\n\t\t\t\t\tstruct ocfs2_extent_rec *insert_rec)\n{\n\tint i;\n\tu32 cpos = le32_to_cpu(insert_rec->e_cpos);\n\tstruct ocfs2_extent_rec *rec;\n\n\tinsert->ins_appending = APPEND_NONE;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (!el->l_next_free_rec)\n\t\tgoto set_tail_append;\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0])) {\n\t\t/* Were all records empty? */\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 1)\n\t\t\tgoto set_tail_append;\n\t}\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[i];\n\n\tif (cpos >=\n\t    (le32_to_cpu(rec->e_cpos) + le16_to_cpu(rec->e_leaf_clusters)))\n\t\tgoto set_tail_append;\n\n\treturn;\n\nset_tail_append:\n\tinsert->ins_appending = APPEND_TAIL;\n}"
  },
  {
    "function_name": "ocfs2_figure_contig_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "4442-4476",
    "snippet": "static void ocfs2_figure_contig_type(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_insert_type *insert,\n\t\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t\t     struct ocfs2_extent_rec *insert_rec)\n{\n\tint i;\n\tenum ocfs2_contig_type contig_type = CONTIG_NONE;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\tcontig_type = ocfs2_et_extent_contig(et, &el->l_recs[i],\n\t\t\t\t\t\t     insert_rec);\n\t\tif (contig_type != CONTIG_NONE) {\n\t\t\tinsert->ins_contig_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tinsert->ins_contig = contig_type;\n\n\tif (insert->ins_contig != CONTIG_NONE) {\n\t\tstruct ocfs2_extent_rec *rec =\n\t\t\t\t&el->l_recs[insert->ins_contig_index];\n\t\tunsigned int len = le16_to_cpu(rec->e_leaf_clusters) +\n\t\t\t\t   le16_to_cpu(insert_rec->e_leaf_clusters);\n\n\t\t/*\n\t\t * Caller might want us to limit the size of extents, don't\n\t\t * calculate contiguousness if we might exceed that limit.\n\t\t */\n\t\tif (et->et_max_leaf_clusters &&\n\t\t    (len > et->et_max_leaf_clusters))\n\t\t\tinsert->ins_contig = CONTIG_NONE;\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "insert_rec->e_leaf_clusters"
          ],
          "line": 4466
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_et_extent_contig",
          "args": [
            "et",
            "&el->l_recs[i]",
            "insert_rec"
          ],
          "line": 4453
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_extent_contig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "537-548",
          "snippet": "static inline enum ocfs2_contig_type\n\tocfs2_et_extent_contig(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_extent_rec *rec,\n\t\t\t       struct ocfs2_extent_rec *insert_rec)\n{\n\tif (et->et_ops->eo_extent_contig)\n\t\treturn et->et_ops->eo_extent_contig(et, rec, insert_rec);\n\n\treturn ocfs2_extent_rec_contig(\n\t\t\t\tocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\trec, insert_rec);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic inline enum ocfs2_contig_type\n\tocfs2_et_extent_contig(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_extent_rec *rec,\n\t\t\t       struct ocfs2_extent_rec *insert_rec)\n{\n\tif (et->et_ops->eo_extent_contig)\n\t\treturn et->et_ops->eo_extent_contig(et, rec, insert_rec);\n\n\treturn ocfs2_extent_rec_contig(\n\t\t\t\tocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\trec, insert_rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le16_to_cpu(el->l_tree_depth) != 0"
          ],
          "line": 4450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_figure_contig_type(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_insert_type *insert,\n\t\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t\t     struct ocfs2_extent_rec *insert_rec)\n{\n\tint i;\n\tenum ocfs2_contig_type contig_type = CONTIG_NONE;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\tcontig_type = ocfs2_et_extent_contig(et, &el->l_recs[i],\n\t\t\t\t\t\t     insert_rec);\n\t\tif (contig_type != CONTIG_NONE) {\n\t\t\tinsert->ins_contig_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tinsert->ins_contig = contig_type;\n\n\tif (insert->ins_contig != CONTIG_NONE) {\n\t\tstruct ocfs2_extent_rec *rec =\n\t\t\t\t&el->l_recs[insert->ins_contig_index];\n\t\tunsigned int len = le16_to_cpu(rec->e_leaf_clusters) +\n\t\t\t\t   le16_to_cpu(insert_rec->e_leaf_clusters);\n\n\t\t/*\n\t\t * Caller might want us to limit the size of extents, don't\n\t\t * calculate contiguousness if we might exceed that limit.\n\t\t */\n\t\tif (et->et_max_leaf_clusters &&\n\t\t    (len > et->et_max_leaf_clusters))\n\t\t\tinsert->ins_contig = CONTIG_NONE;\n\t}\n}"
  },
  {
    "function_name": "ocfs2_figure_merge_contig_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "4316-4440",
    "snippet": "static enum ocfs2_contig_type\nocfs2_figure_merge_contig_type(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_path *path,\n\t\t\t       struct ocfs2_extent_list *el, int index,\n\t\t\t       struct ocfs2_extent_rec *split_rec)\n{\n\tint status;\n\tenum ocfs2_contig_type ret = CONTIG_NONE;\n\tu32 left_cpos, right_cpos;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_extent_list *new_el;\n\tstruct ocfs2_path *left_path = NULL, *right_path = NULL;\n\tstruct buffer_head *bh;\n\tstruct ocfs2_extent_block *eb;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\n\tif (index > 0) {\n\t\trec = &el->l_recs[index - 1];\n\t} else if (path->p_tree_depth > 0) {\n\t\tstatus = ocfs2_find_cpos_for_left_leaf(sb, path, &left_cpos);\n\t\tif (status)\n\t\t\tgoto out;\n\n\t\tif (left_cpos != 0) {\n\t\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\t\tif (!left_path)\n\t\t\t\tgoto out;\n\n\t\t\tstatus = ocfs2_find_path(et->et_ci, left_path,\n\t\t\t\t\t\t left_cpos);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\n\t\t\tnew_el = path_leaf_el(left_path);\n\n\t\t\tif (le16_to_cpu(new_el->l_next_free_rec) !=\n\t\t\t    le16_to_cpu(new_el->l_count)) {\n\t\t\t\tbh = path_leaf_bh(left_path);\n\t\t\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t\t\tocfs2_error(sb,\n\t\t\t\t\t    \"Extent block #%llu has an \"\n\t\t\t\t\t    \"invalid l_next_free_rec of \"\n\t\t\t\t\t    \"%d.  It should have \"\n\t\t\t\t\t    \"matched the l_count of %d\",\n\t\t\t\t\t    (unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t\t\t    le16_to_cpu(new_el->l_next_free_rec),\n\t\t\t\t\t    le16_to_cpu(new_el->l_count));\n\t\t\t\tstatus = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trec = &new_el->l_recs[\n\t\t\t\tle16_to_cpu(new_el->l_next_free_rec) - 1];\n\t\t}\n\t}\n\n\t/*\n\t * We're careful to check for an empty extent record here -\n\t * the merge code will know what to do if it sees one.\n\t */\n\tif (rec) {\n\t\tif (index == 1 && ocfs2_is_empty_extent(rec)) {\n\t\t\tif (split_rec->e_cpos == el->l_recs[index].e_cpos)\n\t\t\t\tret = CONTIG_RIGHT;\n\t\t} else {\n\t\t\tret = ocfs2_et_extent_contig(et, rec, split_rec);\n\t\t}\n\t}\n\n\trec = NULL;\n\tif (index < (le16_to_cpu(el->l_next_free_rec) - 1))\n\t\trec = &el->l_recs[index + 1];\n\telse if (le16_to_cpu(el->l_next_free_rec) == le16_to_cpu(el->l_count) &&\n\t\t path->p_tree_depth > 0) {\n\t\tstatus = ocfs2_find_cpos_for_right_leaf(sb, path, &right_cpos);\n\t\tif (status)\n\t\t\tgoto out;\n\n\t\tif (right_cpos == 0)\n\t\t\tgoto out;\n\n\t\tright_path = ocfs2_new_path_from_path(path);\n\t\tif (!right_path)\n\t\t\tgoto out;\n\n\t\tstatus = ocfs2_find_path(et->et_ci, right_path, right_cpos);\n\t\tif (status)\n\t\t\tgoto out;\n\n\t\tnew_el = path_leaf_el(right_path);\n\t\trec = &new_el->l_recs[0];\n\t\tif (ocfs2_is_empty_extent(rec)) {\n\t\t\tif (le16_to_cpu(new_el->l_next_free_rec) <= 1) {\n\t\t\t\tbh = path_leaf_bh(right_path);\n\t\t\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t\t\tocfs2_error(sb,\n\t\t\t\t\t    \"Extent block #%llu has an \"\n\t\t\t\t\t    \"invalid l_next_free_rec of %d\",\n\t\t\t\t\t    (unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t\t\t    le16_to_cpu(new_el->l_next_free_rec));\n\t\t\t\tstatus = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trec = &new_el->l_recs[1];\n\t\t}\n\t}\n\n\tif (rec) {\n\t\tenum ocfs2_contig_type contig_type;\n\n\t\tcontig_type = ocfs2_et_extent_contig(et, rec, split_rec);\n\n\t\tif (contig_type == CONTIG_LEFT && ret == CONTIG_RIGHT)\n\t\t\tret = CONTIG_LEFTRIGHT;\n\t\telse if (ret == CONTIG_NONE)\n\t\t\tret = contig_type;\n\t}\n\nout:\n\tif (left_path)\n\t\tocfs2_free_path(left_path);\n\tif (right_path)\n\t\tocfs2_free_path(right_path);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "right_path"
          ],
          "line": 4437
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "609-615",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_et_extent_contig",
          "args": [
            "et",
            "rec",
            "split_rec"
          ],
          "line": 4425
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_extent_contig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "537-548",
          "snippet": "static inline enum ocfs2_contig_type\n\tocfs2_et_extent_contig(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_extent_rec *rec,\n\t\t\t       struct ocfs2_extent_rec *insert_rec)\n{\n\tif (et->et_ops->eo_extent_contig)\n\t\treturn et->et_ops->eo_extent_contig(et, rec, insert_rec);\n\n\treturn ocfs2_extent_rec_contig(\n\t\t\t\tocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\trec, insert_rec);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic inline enum ocfs2_contig_type\n\tocfs2_et_extent_contig(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_extent_rec *rec,\n\t\t\t       struct ocfs2_extent_rec *insert_rec)\n{\n\tif (et->et_ops->eo_extent_contig)\n\t\treturn et->et_ops->eo_extent_contig(et, rec, insert_rec);\n\n\treturn ocfs2_extent_rec_contig(\n\t\t\t\tocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\trec, insert_rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "sb",
            "\"Extent block #%llu has an \"\n\t\t\t\t\t    \"invalid l_next_free_rec of %d\"",
            "(unsigned long long)le64_to_cpu(eb->h_blkno)",
            "le16_to_cpu(new_el->l_next_free_rec)"
          ],
          "line": 4410
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "new_el->l_next_free_rec"
          ],
          "line": 4414
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "eb->h_blkno"
          ],
          "line": 4413
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "right_path"
          ],
          "line": 4408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "rec"
          ],
          "line": 4406
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "266-269",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "right_path"
          ],
          "line": 4404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "et->et_ci",
            "right_path",
            "right_cpos"
          ],
          "line": 4400
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1885-1894",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_path",
          "args": [
            "path"
          ],
          "line": 4396
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "707-711",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_cpos_for_right_leaf",
          "args": [
            "sb",
            "path",
            "&right_cpos"
          ],
          "line": 4389
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_cpos_for_right_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2820-2888",
          "snippet": "int ocfs2_find_cpos_for_right_leaf(struct super_block *sb,\n\t\t\t\t   struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\t*cpos = 0;\n\n\tif (path->p_tree_depth == 0)\n\t\treturn 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tint next_free;\n\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just after the one in our\n\t\t * path.\n\t\t */\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == (next_free - 1)) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the rightmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The rightmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j + 1].e_cpos);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_find_cpos_for_right_leaf(struct super_block *sb,\n\t\t\t\t   struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\t*cpos = 0;\n\n\tif (path->p_tree_depth == 0)\n\t\treturn 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tint next_free;\n\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just after the one in our\n\t\t * path.\n\t\t */\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == (next_free - 1)) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the rightmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The rightmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j + 1].e_cpos);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "left_path"
          ],
          "line": 4353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "left_path"
          ],
          "line": 4349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_cpos_for_left_leaf",
          "args": [
            "sb",
            "path",
            "&left_cpos"
          ],
          "line": 4335
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_cpos_for_left_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2205-2272",
          "snippet": "int ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 4330
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic enum ocfs2_contig_type\nocfs2_figure_merge_contig_type(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_path *path,\n\t\t\t       struct ocfs2_extent_list *el, int index,\n\t\t\t       struct ocfs2_extent_rec *split_rec)\n{\n\tint status;\n\tenum ocfs2_contig_type ret = CONTIG_NONE;\n\tu32 left_cpos, right_cpos;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_extent_list *new_el;\n\tstruct ocfs2_path *left_path = NULL, *right_path = NULL;\n\tstruct buffer_head *bh;\n\tstruct ocfs2_extent_block *eb;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\n\tif (index > 0) {\n\t\trec = &el->l_recs[index - 1];\n\t} else if (path->p_tree_depth > 0) {\n\t\tstatus = ocfs2_find_cpos_for_left_leaf(sb, path, &left_cpos);\n\t\tif (status)\n\t\t\tgoto out;\n\n\t\tif (left_cpos != 0) {\n\t\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\t\tif (!left_path)\n\t\t\t\tgoto out;\n\n\t\t\tstatus = ocfs2_find_path(et->et_ci, left_path,\n\t\t\t\t\t\t left_cpos);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\n\t\t\tnew_el = path_leaf_el(left_path);\n\n\t\t\tif (le16_to_cpu(new_el->l_next_free_rec) !=\n\t\t\t    le16_to_cpu(new_el->l_count)) {\n\t\t\t\tbh = path_leaf_bh(left_path);\n\t\t\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t\t\tocfs2_error(sb,\n\t\t\t\t\t    \"Extent block #%llu has an \"\n\t\t\t\t\t    \"invalid l_next_free_rec of \"\n\t\t\t\t\t    \"%d.  It should have \"\n\t\t\t\t\t    \"matched the l_count of %d\",\n\t\t\t\t\t    (unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t\t\t    le16_to_cpu(new_el->l_next_free_rec),\n\t\t\t\t\t    le16_to_cpu(new_el->l_count));\n\t\t\t\tstatus = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trec = &new_el->l_recs[\n\t\t\t\tle16_to_cpu(new_el->l_next_free_rec) - 1];\n\t\t}\n\t}\n\n\t/*\n\t * We're careful to check for an empty extent record here -\n\t * the merge code will know what to do if it sees one.\n\t */\n\tif (rec) {\n\t\tif (index == 1 && ocfs2_is_empty_extent(rec)) {\n\t\t\tif (split_rec->e_cpos == el->l_recs[index].e_cpos)\n\t\t\t\tret = CONTIG_RIGHT;\n\t\t} else {\n\t\t\tret = ocfs2_et_extent_contig(et, rec, split_rec);\n\t\t}\n\t}\n\n\trec = NULL;\n\tif (index < (le16_to_cpu(el->l_next_free_rec) - 1))\n\t\trec = &el->l_recs[index + 1];\n\telse if (le16_to_cpu(el->l_next_free_rec) == le16_to_cpu(el->l_count) &&\n\t\t path->p_tree_depth > 0) {\n\t\tstatus = ocfs2_find_cpos_for_right_leaf(sb, path, &right_cpos);\n\t\tif (status)\n\t\t\tgoto out;\n\n\t\tif (right_cpos == 0)\n\t\t\tgoto out;\n\n\t\tright_path = ocfs2_new_path_from_path(path);\n\t\tif (!right_path)\n\t\t\tgoto out;\n\n\t\tstatus = ocfs2_find_path(et->et_ci, right_path, right_cpos);\n\t\tif (status)\n\t\t\tgoto out;\n\n\t\tnew_el = path_leaf_el(right_path);\n\t\trec = &new_el->l_recs[0];\n\t\tif (ocfs2_is_empty_extent(rec)) {\n\t\t\tif (le16_to_cpu(new_el->l_next_free_rec) <= 1) {\n\t\t\t\tbh = path_leaf_bh(right_path);\n\t\t\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t\t\tocfs2_error(sb,\n\t\t\t\t\t    \"Extent block #%llu has an \"\n\t\t\t\t\t    \"invalid l_next_free_rec of %d\",\n\t\t\t\t\t    (unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t\t\t    le16_to_cpu(new_el->l_next_free_rec));\n\t\t\t\tstatus = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trec = &new_el->l_recs[1];\n\t\t}\n\t}\n\n\tif (rec) {\n\t\tenum ocfs2_contig_type contig_type;\n\n\t\tcontig_type = ocfs2_et_extent_contig(et, rec, split_rec);\n\n\t\tif (contig_type == CONTIG_LEFT && ret == CONTIG_RIGHT)\n\t\t\tret = CONTIG_LEFTRIGHT;\n\t\telse if (ret == CONTIG_NONE)\n\t\t\tret = contig_type;\n\t}\n\nout:\n\tif (left_path)\n\t\tocfs2_free_path(left_path);\n\tif (right_path)\n\t\tocfs2_free_path(right_path);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_do_insert_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "4204-4314",
    "snippet": "static int ocfs2_do_insert_extent(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t  struct ocfs2_insert_type *type)\n{\n\tint ret, rotate = 0;\n\tu32 cpos;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el;\n\n\tel = et->et_root_el;\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(el->l_tree_depth) == 0) {\n\t\tocfs2_insert_at_leaf(et, insert_rec, el, type);\n\t\tgoto out_update_clusters;\n\t}\n\n\tright_path = ocfs2_new_path_from_et(et);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Determine the path to start with. Rotations need the\n\t * rightmost path, everything else can go directly to the\n\t * target leaf.\n\t */\n\tcpos = le32_to_cpu(insert_rec->e_cpos);\n\tif (type->ins_appending == APPEND_NONE &&\n\t    type->ins_contig == CONTIG_NONE) {\n\t\trotate = 1;\n\t\tcpos = UINT_MAX;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, right_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Rotations and appends need special treatment - they modify\n\t * parts of the tree's above them.\n\t *\n\t * Both might pass back a path immediate to the left of the\n\t * one being inserted to. This will be cause\n\t * ocfs2_insert_path() to modify the rightmost records of\n\t * left_path to account for an edge insert.\n\t *\n\t * XXX: When modifying this code, keep in mind that an insert\n\t * can wind up skipping both of these two special cases...\n\t */\n\tif (rotate) {\n\t\tret = ocfs2_rotate_tree_right(handle, et, type->ins_split,\n\t\t\t\t\t      le32_to_cpu(insert_rec->e_cpos),\n\t\t\t\t\t      right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * ocfs2_rotate_tree_right() might have extended the\n\t\t * transaction without re-journaling our tree root.\n\t\t */\n\t\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else if (type->ins_appending == APPEND_TAIL\n\t\t   && type->ins_contig != CONTIG_LEFT) {\n\t\tret = ocfs2_append_rec_to_path(handle, et, insert_rec,\n\t\t\t\t\t       right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_insert_path(handle, et, left_path, right_path,\n\t\t\t\tinsert_rec, type);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout_update_clusters:\n\tif (type->ins_split == SPLIT_NONE)\n\t\tocfs2_et_update_clusters(et,\n\t\t\t\t\t le16_to_cpu(insert_rec->e_leaf_clusters));\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\nout:\n\tocfs2_free_path(left_path);\n\tocfs2_free_path(right_path);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "right_path"
          ],
          "line": 4311
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "609-615",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "et->et_root_bh"
          ],
          "line": 4307
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_et_update_clusters",
          "args": [
            "et",
            "le16_to_cpu(insert_rec->e_leaf_clusters)"
          ],
          "line": 4304
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_update_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "509-513",
          "snippet": "static inline void ocfs2_et_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u32 clusters)\n{\n\tet->et_ops->eo_update_clusters(et, clusters);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic inline void ocfs2_et_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u32 clusters)\n{\n\tet->et_ops->eo_update_clusters(et, clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "insert_rec->e_leaf_clusters"
          ],
          "line": 4305
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_insert_path",
          "args": [
            "handle",
            "et",
            "left_path",
            "right_path",
            "insert_rec",
            "type"
          ],
          "line": 4295
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_insert_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "4123-4202",
          "snippet": "static int ocfs2_insert_path(handle_t *handle,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     struct ocfs2_path *left_path,\n\t\t\t     struct ocfs2_path *right_path,\n\t\t\t     struct ocfs2_extent_rec *insert_rec,\n\t\t\t     struct ocfs2_insert_type *insert)\n{\n\tint ret, subtree_index;\n\tstruct buffer_head *leaf_bh = path_leaf_bh(right_path);\n\n\tif (left_path) {\n\t\t/*\n\t\t * There's a chance that left_path got passed back to\n\t\t * us without being accounted for in the\n\t\t * journal. Extend our transaction here to be sure we\n\t\t * can change those blocks.\n\t\t */\n\t\tret = ocfs2_extend_trans(handle, left_path->p_tree_depth);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Pass both paths to the journal. The majority of inserts\n\t * will be touching all components anyway.\n\t */\n\tret = ocfs2_journal_access_path(et->et_ci, handle, right_path);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (insert->ins_split != SPLIT_NONE) {\n\t\t/*\n\t\t * We could call ocfs2_insert_at_leaf() for some types\n\t\t * of splits, but it's easier to just let one separate\n\t\t * function sort it all out.\n\t\t */\n\t\tocfs2_split_record(et, left_path, right_path,\n\t\t\t\t   insert_rec, insert->ins_split);\n\n\t\t/*\n\t\t * Split might have modified either leaf and we don't\n\t\t * have a guarantee that the later edge insert will\n\t\t * dirty this for us.\n\t\t */\n\t\tif (left_path)\n\t\t\tocfs2_journal_dirty(handle,\n\t\t\t\t\t    path_leaf_bh(left_path));\n\t} else\n\t\tocfs2_insert_at_leaf(et, insert_rec, path_leaf_el(right_path),\n\t\t\t\t     insert);\n\n\tocfs2_journal_dirty(handle, leaf_bh);\n\n\tif (left_path) {\n\t\t/*\n\t\t * The rotate code has indicated that we need to fix\n\t\t * up portions of the tree after the insert.\n\t\t *\n\t\t * XXX: Should we extend the transaction here?\n\t\t */\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t\tright_path);\n\t\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t\t   subtree_index);\n\t}\n\n\tret = 0;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic int ocfs2_insert_path(handle_t *handle,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     struct ocfs2_path *left_path,\n\t\t\t     struct ocfs2_path *right_path,\n\t\t\t     struct ocfs2_extent_rec *insert_rec,\n\t\t\t     struct ocfs2_insert_type *insert)\n{\n\tint ret, subtree_index;\n\tstruct buffer_head *leaf_bh = path_leaf_bh(right_path);\n\n\tif (left_path) {\n\t\t/*\n\t\t * There's a chance that left_path got passed back to\n\t\t * us without being accounted for in the\n\t\t * journal. Extend our transaction here to be sure we\n\t\t * can change those blocks.\n\t\t */\n\t\tret = ocfs2_extend_trans(handle, left_path->p_tree_depth);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Pass both paths to the journal. The majority of inserts\n\t * will be touching all components anyway.\n\t */\n\tret = ocfs2_journal_access_path(et->et_ci, handle, right_path);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (insert->ins_split != SPLIT_NONE) {\n\t\t/*\n\t\t * We could call ocfs2_insert_at_leaf() for some types\n\t\t * of splits, but it's easier to just let one separate\n\t\t * function sort it all out.\n\t\t */\n\t\tocfs2_split_record(et, left_path, right_path,\n\t\t\t\t   insert_rec, insert->ins_split);\n\n\t\t/*\n\t\t * Split might have modified either leaf and we don't\n\t\t * have a guarantee that the later edge insert will\n\t\t * dirty this for us.\n\t\t */\n\t\tif (left_path)\n\t\t\tocfs2_journal_dirty(handle,\n\t\t\t\t\t    path_leaf_bh(left_path));\n\t} else\n\t\tocfs2_insert_at_leaf(et, insert_rec, path_leaf_el(right_path),\n\t\t\t\t     insert);\n\n\tocfs2_journal_dirty(handle, leaf_bh);\n\n\tif (left_path) {\n\t\t/*\n\t\t * The rotate code has indicated that we need to fix\n\t\t * up portions of the tree after the insert.\n\t\t *\n\t\t * XXX: Should we extend the transaction here?\n\t\t */\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t\tright_path);\n\t\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t\t   subtree_index);\n\t}\n\n\tret = 0;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_append_rec_to_path",
          "args": [
            "handle",
            "et",
            "insert_rec",
            "right_path",
            "&left_path"
          ],
          "line": 4287
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_append_rec_to_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "3952-4035",
          "snippet": "static int ocfs2_append_rec_to_path(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t    struct ocfs2_path *right_path,\n\t\t\t\t    struct ocfs2_path **ret_left_path)\n{\n\tint ret, next_free;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *left_path = NULL;\n\n\t*ret_left_path = NULL;\n\n\t/*\n\t * This shouldn't happen for non-trees. The extent rec cluster\n\t * count manipulation below only works for interior nodes.\n\t */\n\tBUG_ON(right_path->p_tree_depth == 0);\n\n\t/*\n\t * If our appending insert is at the leftmost edge of a leaf,\n\t * then we might need to update the rightmost records of the\n\t * neighboring path.\n\t */\n\tel = path_leaf_el(right_path);\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\tif (next_free == 0 ||\n\t    (next_free == 1 && ocfs2_is_empty_extent(&el->l_recs[0]))) {\n\t\tu32 left_cpos;\n\n\t\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\t    right_path, &left_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\ttrace_ocfs2_append_rec_to_path(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tle32_to_cpu(insert_rec->e_cpos),\n\t\t\tleft_cpos);\n\n\t\t/*\n\t\t * No need to worry if the append is already in the\n\t\t * leftmost leaf.\n\t\t */\n\t\tif (left_cpos) {\n\t\t\tleft_path = ocfs2_new_path_from_path(right_path);\n\t\t\tif (!left_path) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_find_path(et->et_ci, left_path,\n\t\t\t\t\t      left_cpos);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * ocfs2_insert_path() will pass the left_path to the\n\t\t\t * journal for us.\n\t\t\t */\n\t\t}\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, right_path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_adjust_rightmost_records(handle, et, right_path, insert_rec);\n\n\t*ret_left_path = left_path;\n\tret = 0;\nout:\n\tif (ret != 0)\n\t\tocfs2_free_path(left_path);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic int ocfs2_append_rec_to_path(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t    struct ocfs2_path *right_path,\n\t\t\t\t    struct ocfs2_path **ret_left_path)\n{\n\tint ret, next_free;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *left_path = NULL;\n\n\t*ret_left_path = NULL;\n\n\t/*\n\t * This shouldn't happen for non-trees. The extent rec cluster\n\t * count manipulation below only works for interior nodes.\n\t */\n\tBUG_ON(right_path->p_tree_depth == 0);\n\n\t/*\n\t * If our appending insert is at the leftmost edge of a leaf,\n\t * then we might need to update the rightmost records of the\n\t * neighboring path.\n\t */\n\tel = path_leaf_el(right_path);\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\tif (next_free == 0 ||\n\t    (next_free == 1 && ocfs2_is_empty_extent(&el->l_recs[0]))) {\n\t\tu32 left_cpos;\n\n\t\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\t    right_path, &left_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\ttrace_ocfs2_append_rec_to_path(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tle32_to_cpu(insert_rec->e_cpos),\n\t\t\tleft_cpos);\n\n\t\t/*\n\t\t * No need to worry if the append is already in the\n\t\t * leftmost leaf.\n\t\t */\n\t\tif (left_cpos) {\n\t\t\tleft_path = ocfs2_new_path_from_path(right_path);\n\t\t\tif (!left_path) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_find_path(et->et_ci, left_path,\n\t\t\t\t\t      left_cpos);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * ocfs2_insert_path() will pass the left_path to the\n\t\t\t * journal for us.\n\t\t\t */\n\t\t}\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, right_path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_adjust_rightmost_records(handle, et, right_path, insert_rec);\n\n\t*ret_left_path = left_path;\n\tret = 0;\nout:\n\tif (ret != 0)\n\t\tocfs2_free_path(left_path);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_et_root_journal_access",
          "args": [
            "handle",
            "et",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 4279
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_root_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "529-535",
          "snippet": "static inline int ocfs2_et_root_journal_access(handle_t *handle,\n\t\t\t\t\t       struct ocfs2_extent_tree *et,\n\t\t\t\t\t       int type)\n{\n\treturn et->et_root_journal_access(handle, et->et_ci, et->et_root_bh,\n\t\t\t\t\t  type);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic inline int ocfs2_et_root_journal_access(handle_t *handle,\n\t\t\t\t\t       struct ocfs2_extent_tree *et,\n\t\t\t\t\t       int type)\n{\n\treturn et->et_root_journal_access(handle, et->et_ci, et->et_root_bh,\n\t\t\t\t\t  type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rotate_tree_right",
          "args": [
            "handle",
            "et",
            "type->ins_split",
            "le32_to_cpu(insert_rec->e_cpos)",
            "right_path",
            "&left_path"
          ],
          "line": 4267
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rotate_tree_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2358-2517",
          "snippet": "static int ocfs2_rotate_tree_right(handle_t *handle,\n\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t   enum ocfs2_split_type split,\n\t\t\t\t   u32 insert_cpos,\n\t\t\t\t   struct ocfs2_path *right_path,\n\t\t\t\t   struct ocfs2_path **ret_left_path)\n{\n\tint ret, start, orig_credits = handle->h_buffer_credits;\n\tu32 cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\n\t*ret_left_path = NULL;\n\n\tleft_path = ocfs2_new_path_from_path(right_path);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_cpos_for_left_leaf(sb, right_path, &cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_rotate_tree_right(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tinsert_cpos, cpos);\n\n\t/*\n\t * What we want to do here is:\n\t *\n\t * 1) Start with the rightmost path.\n\t *\n\t * 2) Determine a path to the leaf block directly to the left\n\t *    of that leaf.\n\t *\n\t * 3) Determine the 'subtree root' - the lowest level tree node\n\t *    which contains a path to both leaves.\n\t *\n\t * 4) Rotate the subtree.\n\t *\n\t * 5) Find the next subtree by considering the left path to be\n\t *    the new right path.\n\t *\n\t * The check at the top of this while loop also accepts\n\t * insert_cpos == cpos because cpos is only a _theoretical_\n\t * value to get us the left path - insert_cpos might very well\n\t * be filling that hole.\n\t *\n\t * Stop at a cpos of '0' because we either started at the\n\t * leftmost branch (i.e., a tree with one branch and a\n\t * rotation inside of it), or we've gone as far as we can in\n\t * rotating subtrees.\n\t */\n\twhile (cpos && insert_cpos <= cpos) {\n\t\ttrace_ocfs2_rotate_tree_right(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tinsert_cpos, cpos);\n\n\t\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tmlog_bug_on_msg(path_leaf_bh(left_path) ==\n\t\t\t\tpath_leaf_bh(right_path),\n\t\t\t\t\"Owner %llu: error during insert of %u \"\n\t\t\t\t\"(left path cpos %u) results in two identical \"\n\t\t\t\t\"paths ending at %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tinsert_cpos, cpos,\n\t\t\t\t(unsigned long long)\n\t\t\t\tpath_leaf_bh(left_path)->b_blocknr);\n\n\t\tif (split == SPLIT_NONE &&\n\t\t    ocfs2_rotate_requires_path_adjustment(left_path,\n\t\t\t\t\t\t\t  insert_cpos)) {\n\n\t\t\t/*\n\t\t\t * We've rotated the tree as much as we\n\t\t\t * should. The rest is up to\n\t\t\t * ocfs2_insert_path() to complete, after the\n\t\t\t * record insertion. We indicate this\n\t\t\t * situation by returning the left path.\n\t\t\t *\n\t\t\t * The reason we don't adjust the records here\n\t\t\t * before the record insert is that an error\n\t\t\t * later might break the rule where a parent\n\t\t\t * record e_cpos will reflect the actual\n\t\t\t * e_cpos of the 1st nonempty record of the\n\t\t\t * child list.\n\t\t\t */\n\t\t\t*ret_left_path = left_path;\n\t\t\tgoto out_ret_path;\n\t\t}\n\n\t\tstart = ocfs2_find_subtree_root(et, left_path, right_path);\n\n\t\ttrace_ocfs2_rotate_subtree(start,\n\t\t\t(unsigned long long)\n\t\t\tright_path->p_node[start].bh->b_blocknr,\n\t\t\tright_path->p_tree_depth);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, start,\n\t\t\t\t\t\t      orig_credits, right_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_subtree_right(handle, et, left_path,\n\t\t\t\t\t\t right_path, start);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (split != SPLIT_NONE &&\n\t\t    ocfs2_leftmost_rec_contains(path_leaf_el(right_path),\n\t\t\t\t\t\tinsert_cpos)) {\n\t\t\t/*\n\t\t\t * A rotate moves the rightmost left leaf\n\t\t\t * record over to the leftmost right leaf\n\t\t\t * slot. If we're doing an extent split\n\t\t\t * instead of a real insert, then we have to\n\t\t\t * check that the extent to be split wasn't\n\t\t\t * just moved over. If it was, then we can\n\t\t\t * exit here, passing left_path back -\n\t\t\t * ocfs2_split_extent() is smart enough to\n\t\t\t * search both leaves.\n\t\t\t */\n\t\t\t*ret_left_path = left_path;\n\t\t\tgoto out_ret_path;\n\t\t}\n\n\t\t/*\n\t\t * There is no need to re-read the next right path\n\t\t * as we know that it'll be our current left\n\t\t * path. Optimize by copying values instead.\n\t\t */\n\t\tocfs2_mv_path(right_path, left_path);\n\n\t\tret = ocfs2_find_cpos_for_left_leaf(sb, right_path, &cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tocfs2_free_path(left_path);\n\nout_ret_path:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_rotate_tree_right(handle_t *handle,\n\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t   enum ocfs2_split_type split,\n\t\t\t\t   u32 insert_cpos,\n\t\t\t\t   struct ocfs2_path *right_path,\n\t\t\t\t   struct ocfs2_path **ret_left_path)\n{\n\tint ret, start, orig_credits = handle->h_buffer_credits;\n\tu32 cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\n\t*ret_left_path = NULL;\n\n\tleft_path = ocfs2_new_path_from_path(right_path);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_cpos_for_left_leaf(sb, right_path, &cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_rotate_tree_right(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tinsert_cpos, cpos);\n\n\t/*\n\t * What we want to do here is:\n\t *\n\t * 1) Start with the rightmost path.\n\t *\n\t * 2) Determine a path to the leaf block directly to the left\n\t *    of that leaf.\n\t *\n\t * 3) Determine the 'subtree root' - the lowest level tree node\n\t *    which contains a path to both leaves.\n\t *\n\t * 4) Rotate the subtree.\n\t *\n\t * 5) Find the next subtree by considering the left path to be\n\t *    the new right path.\n\t *\n\t * The check at the top of this while loop also accepts\n\t * insert_cpos == cpos because cpos is only a _theoretical_\n\t * value to get us the left path - insert_cpos might very well\n\t * be filling that hole.\n\t *\n\t * Stop at a cpos of '0' because we either started at the\n\t * leftmost branch (i.e., a tree with one branch and a\n\t * rotation inside of it), or we've gone as far as we can in\n\t * rotating subtrees.\n\t */\n\twhile (cpos && insert_cpos <= cpos) {\n\t\ttrace_ocfs2_rotate_tree_right(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tinsert_cpos, cpos);\n\n\t\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tmlog_bug_on_msg(path_leaf_bh(left_path) ==\n\t\t\t\tpath_leaf_bh(right_path),\n\t\t\t\t\"Owner %llu: error during insert of %u \"\n\t\t\t\t\"(left path cpos %u) results in two identical \"\n\t\t\t\t\"paths ending at %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tinsert_cpos, cpos,\n\t\t\t\t(unsigned long long)\n\t\t\t\tpath_leaf_bh(left_path)->b_blocknr);\n\n\t\tif (split == SPLIT_NONE &&\n\t\t    ocfs2_rotate_requires_path_adjustment(left_path,\n\t\t\t\t\t\t\t  insert_cpos)) {\n\n\t\t\t/*\n\t\t\t * We've rotated the tree as much as we\n\t\t\t * should. The rest is up to\n\t\t\t * ocfs2_insert_path() to complete, after the\n\t\t\t * record insertion. We indicate this\n\t\t\t * situation by returning the left path.\n\t\t\t *\n\t\t\t * The reason we don't adjust the records here\n\t\t\t * before the record insert is that an error\n\t\t\t * later might break the rule where a parent\n\t\t\t * record e_cpos will reflect the actual\n\t\t\t * e_cpos of the 1st nonempty record of the\n\t\t\t * child list.\n\t\t\t */\n\t\t\t*ret_left_path = left_path;\n\t\t\tgoto out_ret_path;\n\t\t}\n\n\t\tstart = ocfs2_find_subtree_root(et, left_path, right_path);\n\n\t\ttrace_ocfs2_rotate_subtree(start,\n\t\t\t(unsigned long long)\n\t\t\tright_path->p_node[start].bh->b_blocknr,\n\t\t\tright_path->p_tree_depth);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, start,\n\t\t\t\t\t\t      orig_credits, right_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_subtree_right(handle, et, left_path,\n\t\t\t\t\t\t right_path, start);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (split != SPLIT_NONE &&\n\t\t    ocfs2_leftmost_rec_contains(path_leaf_el(right_path),\n\t\t\t\t\t\tinsert_cpos)) {\n\t\t\t/*\n\t\t\t * A rotate moves the rightmost left leaf\n\t\t\t * record over to the leftmost right leaf\n\t\t\t * slot. If we're doing an extent split\n\t\t\t * instead of a real insert, then we have to\n\t\t\t * check that the extent to be split wasn't\n\t\t\t * just moved over. If it was, then we can\n\t\t\t * exit here, passing left_path back -\n\t\t\t * ocfs2_split_extent() is smart enough to\n\t\t\t * search both leaves.\n\t\t\t */\n\t\t\t*ret_left_path = left_path;\n\t\t\tgoto out_ret_path;\n\t\t}\n\n\t\t/*\n\t\t * There is no need to re-read the next right path\n\t\t * as we know that it'll be our current left\n\t\t * path. Optimize by copying values instead.\n\t\t */\n\t\tocfs2_mv_path(right_path, left_path);\n\n\t\tret = ocfs2_find_cpos_for_left_leaf(sb, right_path, &cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tocfs2_free_path(left_path);\n\nout_ret_path:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "insert_rec->e_cpos"
          ],
          "line": 4268
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "et->et_ci",
            "right_path",
            "cpos"
          ],
          "line": 4248
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1885-1894",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_et",
          "args": [
            "et"
          ],
          "line": 4229
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_et",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "713-717",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstruct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_insert_at_leaf",
          "args": [
            "et",
            "insert_rec",
            "el",
            "type"
          ],
          "line": 4225
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_insert_at_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "3825-3912",
          "snippet": "static void ocfs2_insert_at_leaf(struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t struct ocfs2_extent_list *el,\n\t\t\t\t struct ocfs2_insert_type *insert)\n{\n\tint i = insert->ins_contig_index;\n\tunsigned int range;\n\tstruct ocfs2_extent_rec *rec;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (insert->ins_split != SPLIT_NONE) {\n\t\ti = ocfs2_search_extent_list(el, le32_to_cpu(insert_rec->e_cpos));\n\t\tBUG_ON(i == -1);\n\t\trec = &el->l_recs[i];\n\t\tocfs2_subtract_from_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\tinsert->ins_split, rec,\n\t\t\t\t\tinsert_rec);\n\t\tgoto rotate;\n\t}\n\n\t/*\n\t * Contiguous insert - either left or right.\n\t */\n\tif (insert->ins_contig != CONTIG_NONE) {\n\t\trec = &el->l_recs[i];\n\t\tif (insert->ins_contig == CONTIG_LEFT) {\n\t\t\trec->e_blkno = insert_rec->e_blkno;\n\t\t\trec->e_cpos = insert_rec->e_cpos;\n\t\t}\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\treturn;\n\t}\n\n\t/*\n\t * Handle insert into an empty leaf.\n\t */\n\tif (le16_to_cpu(el->l_next_free_rec) == 0 ||\n\t    ((le16_to_cpu(el->l_next_free_rec) == 1) &&\n\t     ocfs2_is_empty_extent(&el->l_recs[0]))) {\n\t\tel->l_recs[0] = *insert_rec;\n\t\tel->l_next_free_rec = cpu_to_le16(1);\n\t\treturn;\n\t}\n\n\t/*\n\t * Appending insert.\n\t */\n\tif (insert->ins_appending == APPEND_TAIL) {\n\t\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\trec = &el->l_recs[i];\n\t\trange = le32_to_cpu(rec->e_cpos)\n\t\t\t+ le16_to_cpu(rec->e_leaf_clusters);\n\t\tBUG_ON(le32_to_cpu(insert_rec->e_cpos) < range);\n\n\t\tmlog_bug_on_msg(le16_to_cpu(el->l_next_free_rec) >=\n\t\t\t\tle16_to_cpu(el->l_count),\n\t\t\t\t\"owner %llu, depth %u, count %u, next free %u, \"\n\t\t\t\t\"rec.cpos %u, rec.clusters %u, \"\n\t\t\t\t\"insert.cpos %u, insert.clusters %u\\n\",\n\t\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tle16_to_cpu(el->l_tree_depth),\n\t\t\t\tle16_to_cpu(el->l_count),\n\t\t\t\tle16_to_cpu(el->l_next_free_rec),\n\t\t\t\tle32_to_cpu(el->l_recs[i].e_cpos),\n\t\t\t\tle16_to_cpu(el->l_recs[i].e_leaf_clusters),\n\t\t\t\tle32_to_cpu(insert_rec->e_cpos),\n\t\t\t\tle16_to_cpu(insert_rec->e_leaf_clusters));\n\t\ti++;\n\t\tel->l_recs[i] = *insert_rec;\n\t\tle16_add_cpu(&el->l_next_free_rec, 1);\n\t\treturn;\n\t}\n\nrotate:\n\t/*\n\t * Ok, we have to rotate.\n\t *\n\t * At this point, it is safe to assume that inserting into an\n\t * empty leaf and appending to a leaf have both been handled\n\t * above.\n\t *\n\t * This leaf needs to have space, either by the empty 1st\n\t * extent record, or by virtue of an l_next_rec < l_count.\n\t */\n\tocfs2_rotate_leaf(el, insert_rec);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_insert_at_leaf(struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t struct ocfs2_extent_list *el,\n\t\t\t\t struct ocfs2_insert_type *insert)\n{\n\tint i = insert->ins_contig_index;\n\tunsigned int range;\n\tstruct ocfs2_extent_rec *rec;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (insert->ins_split != SPLIT_NONE) {\n\t\ti = ocfs2_search_extent_list(el, le32_to_cpu(insert_rec->e_cpos));\n\t\tBUG_ON(i == -1);\n\t\trec = &el->l_recs[i];\n\t\tocfs2_subtract_from_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\tinsert->ins_split, rec,\n\t\t\t\t\tinsert_rec);\n\t\tgoto rotate;\n\t}\n\n\t/*\n\t * Contiguous insert - either left or right.\n\t */\n\tif (insert->ins_contig != CONTIG_NONE) {\n\t\trec = &el->l_recs[i];\n\t\tif (insert->ins_contig == CONTIG_LEFT) {\n\t\t\trec->e_blkno = insert_rec->e_blkno;\n\t\t\trec->e_cpos = insert_rec->e_cpos;\n\t\t}\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\treturn;\n\t}\n\n\t/*\n\t * Handle insert into an empty leaf.\n\t */\n\tif (le16_to_cpu(el->l_next_free_rec) == 0 ||\n\t    ((le16_to_cpu(el->l_next_free_rec) == 1) &&\n\t     ocfs2_is_empty_extent(&el->l_recs[0]))) {\n\t\tel->l_recs[0] = *insert_rec;\n\t\tel->l_next_free_rec = cpu_to_le16(1);\n\t\treturn;\n\t}\n\n\t/*\n\t * Appending insert.\n\t */\n\tif (insert->ins_appending == APPEND_TAIL) {\n\t\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\trec = &el->l_recs[i];\n\t\trange = le32_to_cpu(rec->e_cpos)\n\t\t\t+ le16_to_cpu(rec->e_leaf_clusters);\n\t\tBUG_ON(le32_to_cpu(insert_rec->e_cpos) < range);\n\n\t\tmlog_bug_on_msg(le16_to_cpu(el->l_next_free_rec) >=\n\t\t\t\tle16_to_cpu(el->l_count),\n\t\t\t\t\"owner %llu, depth %u, count %u, next free %u, \"\n\t\t\t\t\"rec.cpos %u, rec.clusters %u, \"\n\t\t\t\t\"insert.cpos %u, insert.clusters %u\\n\",\n\t\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tle16_to_cpu(el->l_tree_depth),\n\t\t\t\tle16_to_cpu(el->l_count),\n\t\t\t\tle16_to_cpu(el->l_next_free_rec),\n\t\t\t\tle32_to_cpu(el->l_recs[i].e_cpos),\n\t\t\t\tle16_to_cpu(el->l_recs[i].e_leaf_clusters),\n\t\t\t\tle32_to_cpu(insert_rec->e_cpos),\n\t\t\t\tle16_to_cpu(insert_rec->e_leaf_clusters));\n\t\ti++;\n\t\tel->l_recs[i] = *insert_rec;\n\t\tle16_add_cpu(&el->l_next_free_rec, 1);\n\t\treturn;\n\t}\n\nrotate:\n\t/*\n\t * Ok, we have to rotate.\n\t *\n\t * At this point, it is safe to assume that inserting into an\n\t * empty leaf and appending to a leaf have both been handled\n\t * above.\n\t *\n\t * This leaf needs to have space, either by the empty 1st\n\t * extent record, or by virtue of an l_next_rec < l_count.\n\t */\n\tocfs2_rotate_leaf(el, insert_rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic int ocfs2_do_insert_extent(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t  struct ocfs2_insert_type *type)\n{\n\tint ret, rotate = 0;\n\tu32 cpos;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el;\n\n\tel = et->et_root_el;\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(el->l_tree_depth) == 0) {\n\t\tocfs2_insert_at_leaf(et, insert_rec, el, type);\n\t\tgoto out_update_clusters;\n\t}\n\n\tright_path = ocfs2_new_path_from_et(et);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Determine the path to start with. Rotations need the\n\t * rightmost path, everything else can go directly to the\n\t * target leaf.\n\t */\n\tcpos = le32_to_cpu(insert_rec->e_cpos);\n\tif (type->ins_appending == APPEND_NONE &&\n\t    type->ins_contig == CONTIG_NONE) {\n\t\trotate = 1;\n\t\tcpos = UINT_MAX;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, right_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Rotations and appends need special treatment - they modify\n\t * parts of the tree's above them.\n\t *\n\t * Both might pass back a path immediate to the left of the\n\t * one being inserted to. This will be cause\n\t * ocfs2_insert_path() to modify the rightmost records of\n\t * left_path to account for an edge insert.\n\t *\n\t * XXX: When modifying this code, keep in mind that an insert\n\t * can wind up skipping both of these two special cases...\n\t */\n\tif (rotate) {\n\t\tret = ocfs2_rotate_tree_right(handle, et, type->ins_split,\n\t\t\t\t\t      le32_to_cpu(insert_rec->e_cpos),\n\t\t\t\t\t      right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * ocfs2_rotate_tree_right() might have extended the\n\t\t * transaction without re-journaling our tree root.\n\t\t */\n\t\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else if (type->ins_appending == APPEND_TAIL\n\t\t   && type->ins_contig != CONTIG_LEFT) {\n\t\tret = ocfs2_append_rec_to_path(handle, et, insert_rec,\n\t\t\t\t\t       right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_insert_path(handle, et, left_path, right_path,\n\t\t\t\tinsert_rec, type);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout_update_clusters:\n\tif (type->ins_split == SPLIT_NONE)\n\t\tocfs2_et_update_clusters(et,\n\t\t\t\t\t le16_to_cpu(insert_rec->e_leaf_clusters));\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\nout:\n\tocfs2_free_path(left_path);\n\tocfs2_free_path(right_path);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_insert_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "4123-4202",
    "snippet": "static int ocfs2_insert_path(handle_t *handle,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     struct ocfs2_path *left_path,\n\t\t\t     struct ocfs2_path *right_path,\n\t\t\t     struct ocfs2_extent_rec *insert_rec,\n\t\t\t     struct ocfs2_insert_type *insert)\n{\n\tint ret, subtree_index;\n\tstruct buffer_head *leaf_bh = path_leaf_bh(right_path);\n\n\tif (left_path) {\n\t\t/*\n\t\t * There's a chance that left_path got passed back to\n\t\t * us without being accounted for in the\n\t\t * journal. Extend our transaction here to be sure we\n\t\t * can change those blocks.\n\t\t */\n\t\tret = ocfs2_extend_trans(handle, left_path->p_tree_depth);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Pass both paths to the journal. The majority of inserts\n\t * will be touching all components anyway.\n\t */\n\tret = ocfs2_journal_access_path(et->et_ci, handle, right_path);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (insert->ins_split != SPLIT_NONE) {\n\t\t/*\n\t\t * We could call ocfs2_insert_at_leaf() for some types\n\t\t * of splits, but it's easier to just let one separate\n\t\t * function sort it all out.\n\t\t */\n\t\tocfs2_split_record(et, left_path, right_path,\n\t\t\t\t   insert_rec, insert->ins_split);\n\n\t\t/*\n\t\t * Split might have modified either leaf and we don't\n\t\t * have a guarantee that the later edge insert will\n\t\t * dirty this for us.\n\t\t */\n\t\tif (left_path)\n\t\t\tocfs2_journal_dirty(handle,\n\t\t\t\t\t    path_leaf_bh(left_path));\n\t} else\n\t\tocfs2_insert_at_leaf(et, insert_rec, path_leaf_el(right_path),\n\t\t\t\t     insert);\n\n\tocfs2_journal_dirty(handle, leaf_bh);\n\n\tif (left_path) {\n\t\t/*\n\t\t * The rotate code has indicated that we need to fix\n\t\t * up portions of the tree after the insert.\n\t\t *\n\t\t * XXX: Should we extend the transaction here?\n\t\t */\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t\tright_path);\n\t\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t\t   subtree_index);\n\t}\n\n\tret = 0;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_complete_edge_insert",
          "args": [
            "handle",
            "left_path",
            "right_path",
            "subtree_index"
          ],
          "line": 4195
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_complete_edge_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2030-2099",
          "snippet": "static void ocfs2_complete_edge_insert(handle_t *handle,\n\t\t\t\t       struct ocfs2_path *left_path,\n\t\t\t\t       struct ocfs2_path *right_path,\n\t\t\t\t       int subtree_index)\n{\n\tint i, idx;\n\tstruct ocfs2_extent_list *el, *left_el, *right_el;\n\tstruct ocfs2_extent_rec *left_rec, *right_rec;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\n\t/*\n\t * Update the counts and position values within all the\n\t * interior nodes to reflect the leaf rotation we just did.\n\t *\n\t * The root node is handled below the loop.\n\t *\n\t * We begin the loop with right_el and left_el pointing to the\n\t * leaf lists and work our way up.\n\t *\n\t * NOTE: within this loop, left_el and right_el always refer\n\t * to the *child* lists.\n\t */\n\tleft_el = path_leaf_el(left_path);\n\tright_el = path_leaf_el(right_path);\n\tfor(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {\n\t\ttrace_ocfs2_complete_edge_insert(i);\n\n\t\t/*\n\t\t * One nice property of knowing that all of these\n\t\t * nodes are below the root is that we only deal with\n\t\t * the leftmost right node record and the rightmost\n\t\t * left node record.\n\t\t */\n\t\tel = left_path->p_node[i].el;\n\t\tidx = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\t\tleft_rec = &el->l_recs[idx];\n\n\t\tel = right_path->p_node[i].el;\n\t\tright_rec = &el->l_recs[0];\n\n\t\tocfs2_adjust_adjacent_records(left_rec, left_el, right_rec,\n\t\t\t\t\t      right_el);\n\n\t\tocfs2_journal_dirty(handle, left_path->p_node[i].bh);\n\t\tocfs2_journal_dirty(handle, right_path->p_node[i].bh);\n\n\t\t/*\n\t\t * Setup our list pointers now so that the current\n\t\t * parents become children in the next iteration.\n\t\t */\n\t\tleft_el = left_path->p_node[i].el;\n\t\tright_el = right_path->p_node[i].el;\n\t}\n\n\t/*\n\t * At the root node, adjust the two adjacent records which\n\t * begin our path to the leaves.\n\t */\n\n\tel = left_path->p_node[subtree_index].el;\n\tleft_el = left_path->p_node[subtree_index + 1].el;\n\tright_el = right_path->p_node[subtree_index + 1].el;\n\n\tocfs2_adjust_root_records(el, left_el, right_el,\n\t\t\t\t  left_path->p_node[subtree_index + 1].bh->b_blocknr);\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\n\tocfs2_journal_dirty(handle, root_bh);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_complete_edge_insert(handle_t *handle,\n\t\t\t\t       struct ocfs2_path *left_path,\n\t\t\t\t       struct ocfs2_path *right_path,\n\t\t\t\t       int subtree_index)\n{\n\tint i, idx;\n\tstruct ocfs2_extent_list *el, *left_el, *right_el;\n\tstruct ocfs2_extent_rec *left_rec, *right_rec;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\n\t/*\n\t * Update the counts and position values within all the\n\t * interior nodes to reflect the leaf rotation we just did.\n\t *\n\t * The root node is handled below the loop.\n\t *\n\t * We begin the loop with right_el and left_el pointing to the\n\t * leaf lists and work our way up.\n\t *\n\t * NOTE: within this loop, left_el and right_el always refer\n\t * to the *child* lists.\n\t */\n\tleft_el = path_leaf_el(left_path);\n\tright_el = path_leaf_el(right_path);\n\tfor(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {\n\t\ttrace_ocfs2_complete_edge_insert(i);\n\n\t\t/*\n\t\t * One nice property of knowing that all of these\n\t\t * nodes are below the root is that we only deal with\n\t\t * the leftmost right node record and the rightmost\n\t\t * left node record.\n\t\t */\n\t\tel = left_path->p_node[i].el;\n\t\tidx = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\t\tleft_rec = &el->l_recs[idx];\n\n\t\tel = right_path->p_node[i].el;\n\t\tright_rec = &el->l_recs[0];\n\n\t\tocfs2_adjust_adjacent_records(left_rec, left_el, right_rec,\n\t\t\t\t\t      right_el);\n\n\t\tocfs2_journal_dirty(handle, left_path->p_node[i].bh);\n\t\tocfs2_journal_dirty(handle, right_path->p_node[i].bh);\n\n\t\t/*\n\t\t * Setup our list pointers now so that the current\n\t\t * parents become children in the next iteration.\n\t\t */\n\t\tleft_el = left_path->p_node[i].el;\n\t\tright_el = right_path->p_node[i].el;\n\t}\n\n\t/*\n\t * At the root node, adjust the two adjacent records which\n\t * begin our path to the leaves.\n\t */\n\n\tel = left_path->p_node[subtree_index].el;\n\tleft_el = left_path->p_node[subtree_index + 1].el;\n\tright_el = right_path->p_node[subtree_index + 1].el;\n\n\tocfs2_adjust_root_records(el, left_el, right_el,\n\t\t\t\t  left_path->p_node[subtree_index + 1].bh->b_blocknr);\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\n\tocfs2_journal_dirty(handle, root_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_subtree_root",
          "args": [
            "et",
            "left_path",
            "right_path"
          ],
          "line": 4193
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_subtree_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1737-1765",
          "snippet": "int ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "leaf_bh"
          ],
          "line": 4184
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_insert_at_leaf",
          "args": [
            "et",
            "insert_rec",
            "path_leaf_el(right_path)",
            "insert"
          ],
          "line": 4181
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_insert_at_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "3825-3912",
          "snippet": "static void ocfs2_insert_at_leaf(struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t struct ocfs2_extent_list *el,\n\t\t\t\t struct ocfs2_insert_type *insert)\n{\n\tint i = insert->ins_contig_index;\n\tunsigned int range;\n\tstruct ocfs2_extent_rec *rec;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (insert->ins_split != SPLIT_NONE) {\n\t\ti = ocfs2_search_extent_list(el, le32_to_cpu(insert_rec->e_cpos));\n\t\tBUG_ON(i == -1);\n\t\trec = &el->l_recs[i];\n\t\tocfs2_subtract_from_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\tinsert->ins_split, rec,\n\t\t\t\t\tinsert_rec);\n\t\tgoto rotate;\n\t}\n\n\t/*\n\t * Contiguous insert - either left or right.\n\t */\n\tif (insert->ins_contig != CONTIG_NONE) {\n\t\trec = &el->l_recs[i];\n\t\tif (insert->ins_contig == CONTIG_LEFT) {\n\t\t\trec->e_blkno = insert_rec->e_blkno;\n\t\t\trec->e_cpos = insert_rec->e_cpos;\n\t\t}\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\treturn;\n\t}\n\n\t/*\n\t * Handle insert into an empty leaf.\n\t */\n\tif (le16_to_cpu(el->l_next_free_rec) == 0 ||\n\t    ((le16_to_cpu(el->l_next_free_rec) == 1) &&\n\t     ocfs2_is_empty_extent(&el->l_recs[0]))) {\n\t\tel->l_recs[0] = *insert_rec;\n\t\tel->l_next_free_rec = cpu_to_le16(1);\n\t\treturn;\n\t}\n\n\t/*\n\t * Appending insert.\n\t */\n\tif (insert->ins_appending == APPEND_TAIL) {\n\t\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\trec = &el->l_recs[i];\n\t\trange = le32_to_cpu(rec->e_cpos)\n\t\t\t+ le16_to_cpu(rec->e_leaf_clusters);\n\t\tBUG_ON(le32_to_cpu(insert_rec->e_cpos) < range);\n\n\t\tmlog_bug_on_msg(le16_to_cpu(el->l_next_free_rec) >=\n\t\t\t\tle16_to_cpu(el->l_count),\n\t\t\t\t\"owner %llu, depth %u, count %u, next free %u, \"\n\t\t\t\t\"rec.cpos %u, rec.clusters %u, \"\n\t\t\t\t\"insert.cpos %u, insert.clusters %u\\n\",\n\t\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tle16_to_cpu(el->l_tree_depth),\n\t\t\t\tle16_to_cpu(el->l_count),\n\t\t\t\tle16_to_cpu(el->l_next_free_rec),\n\t\t\t\tle32_to_cpu(el->l_recs[i].e_cpos),\n\t\t\t\tle16_to_cpu(el->l_recs[i].e_leaf_clusters),\n\t\t\t\tle32_to_cpu(insert_rec->e_cpos),\n\t\t\t\tle16_to_cpu(insert_rec->e_leaf_clusters));\n\t\ti++;\n\t\tel->l_recs[i] = *insert_rec;\n\t\tle16_add_cpu(&el->l_next_free_rec, 1);\n\t\treturn;\n\t}\n\nrotate:\n\t/*\n\t * Ok, we have to rotate.\n\t *\n\t * At this point, it is safe to assume that inserting into an\n\t * empty leaf and appending to a leaf have both been handled\n\t * above.\n\t *\n\t * This leaf needs to have space, either by the empty 1st\n\t * extent record, or by virtue of an l_next_rec < l_count.\n\t */\n\tocfs2_rotate_leaf(el, insert_rec);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_insert_at_leaf(struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t struct ocfs2_extent_list *el,\n\t\t\t\t struct ocfs2_insert_type *insert)\n{\n\tint i = insert->ins_contig_index;\n\tunsigned int range;\n\tstruct ocfs2_extent_rec *rec;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (insert->ins_split != SPLIT_NONE) {\n\t\ti = ocfs2_search_extent_list(el, le32_to_cpu(insert_rec->e_cpos));\n\t\tBUG_ON(i == -1);\n\t\trec = &el->l_recs[i];\n\t\tocfs2_subtract_from_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\tinsert->ins_split, rec,\n\t\t\t\t\tinsert_rec);\n\t\tgoto rotate;\n\t}\n\n\t/*\n\t * Contiguous insert - either left or right.\n\t */\n\tif (insert->ins_contig != CONTIG_NONE) {\n\t\trec = &el->l_recs[i];\n\t\tif (insert->ins_contig == CONTIG_LEFT) {\n\t\t\trec->e_blkno = insert_rec->e_blkno;\n\t\t\trec->e_cpos = insert_rec->e_cpos;\n\t\t}\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\treturn;\n\t}\n\n\t/*\n\t * Handle insert into an empty leaf.\n\t */\n\tif (le16_to_cpu(el->l_next_free_rec) == 0 ||\n\t    ((le16_to_cpu(el->l_next_free_rec) == 1) &&\n\t     ocfs2_is_empty_extent(&el->l_recs[0]))) {\n\t\tel->l_recs[0] = *insert_rec;\n\t\tel->l_next_free_rec = cpu_to_le16(1);\n\t\treturn;\n\t}\n\n\t/*\n\t * Appending insert.\n\t */\n\tif (insert->ins_appending == APPEND_TAIL) {\n\t\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\trec = &el->l_recs[i];\n\t\trange = le32_to_cpu(rec->e_cpos)\n\t\t\t+ le16_to_cpu(rec->e_leaf_clusters);\n\t\tBUG_ON(le32_to_cpu(insert_rec->e_cpos) < range);\n\n\t\tmlog_bug_on_msg(le16_to_cpu(el->l_next_free_rec) >=\n\t\t\t\tle16_to_cpu(el->l_count),\n\t\t\t\t\"owner %llu, depth %u, count %u, next free %u, \"\n\t\t\t\t\"rec.cpos %u, rec.clusters %u, \"\n\t\t\t\t\"insert.cpos %u, insert.clusters %u\\n\",\n\t\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tle16_to_cpu(el->l_tree_depth),\n\t\t\t\tle16_to_cpu(el->l_count),\n\t\t\t\tle16_to_cpu(el->l_next_free_rec),\n\t\t\t\tle32_to_cpu(el->l_recs[i].e_cpos),\n\t\t\t\tle16_to_cpu(el->l_recs[i].e_leaf_clusters),\n\t\t\t\tle32_to_cpu(insert_rec->e_cpos),\n\t\t\t\tle16_to_cpu(insert_rec->e_leaf_clusters));\n\t\ti++;\n\t\tel->l_recs[i] = *insert_rec;\n\t\tle16_add_cpu(&el->l_next_free_rec, 1);\n\t\treturn;\n\t}\n\nrotate:\n\t/*\n\t * Ok, we have to rotate.\n\t *\n\t * At this point, it is safe to assume that inserting into an\n\t * empty leaf and appending to a leaf have both been handled\n\t * above.\n\t *\n\t * This leaf needs to have space, either by the empty 1st\n\t * extent record, or by virtue of an l_next_rec < l_count.\n\t */\n\tocfs2_rotate_leaf(el, insert_rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "right_path"
          ],
          "line": 4181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "left_path"
          ],
          "line": 4179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_split_record",
          "args": [
            "et",
            "left_path",
            "right_path",
            "insert_rec",
            "insert->ins_split"
          ],
          "line": 4169
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_split_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "4037-4113",
          "snippet": "static void ocfs2_split_record(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_path *left_path,\n\t\t\t       struct ocfs2_path *right_path,\n\t\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t\t       enum ocfs2_split_type split)\n{\n\tint index;\n\tu32 cpos = le32_to_cpu(split_rec->e_cpos);\n\tstruct ocfs2_extent_list *left_el = NULL, *right_el, *insert_el, *el;\n\tstruct ocfs2_extent_rec *rec, *tmprec;\n\n\tright_el = path_leaf_el(right_path);\n\tif (left_path)\n\t\tleft_el = path_leaf_el(left_path);\n\n\tel = right_el;\n\tinsert_el = right_el;\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index != -1) {\n\t\tif (index == 0 && left_path) {\n\t\t\tBUG_ON(ocfs2_is_empty_extent(&el->l_recs[0]));\n\n\t\t\t/*\n\t\t\t * This typically means that the record\n\t\t\t * started in the left path but moved to the\n\t\t\t * right as a result of rotation. We either\n\t\t\t * move the existing record to the left, or we\n\t\t\t * do the later insert there.\n\t\t\t *\n\t\t\t * In this case, the left path should always\n\t\t\t * exist as the rotate code will have passed\n\t\t\t * it back for a post-insert update.\n\t\t\t */\n\n\t\t\tif (split == SPLIT_LEFT) {\n\t\t\t\t/*\n\t\t\t\t * It's a left split. Since we know\n\t\t\t\t * that the rotate code gave us an\n\t\t\t\t * empty extent in the left path, we\n\t\t\t\t * can just do the insert there.\n\t\t\t\t */\n\t\t\t\tinsert_el = left_el;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Right split - we have to move the\n\t\t\t\t * existing record over to the left\n\t\t\t\t * leaf. The insert will be into the\n\t\t\t\t * newly created empty extent in the\n\t\t\t\t * right leaf.\n\t\t\t\t */\n\t\t\t\ttmprec = &right_el->l_recs[index];\n\t\t\t\tocfs2_rotate_leaf(left_el, tmprec);\n\t\t\t\tel = left_el;\n\n\t\t\t\tmemset(tmprec, 0, sizeof(*tmprec));\n\t\t\t\tindex = ocfs2_search_extent_list(left_el, cpos);\n\t\t\t\tBUG_ON(index == -1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBUG_ON(!left_path);\n\t\tBUG_ON(!ocfs2_is_empty_extent(&left_el->l_recs[0]));\n\t\t/*\n\t\t * Left path is easy - we can just allow the insert to\n\t\t * happen.\n\t\t */\n\t\tel = left_el;\n\t\tinsert_el = left_el;\n\t\tindex = ocfs2_search_extent_list(el, cpos);\n\t\tBUG_ON(index == -1);\n\t}\n\n\trec = &el->l_recs[index];\n\tocfs2_subtract_from_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\tsplit, rec, split_rec);\n\tocfs2_rotate_leaf(insert_el, split_rec);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_split_record(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_path *left_path,\n\t\t\t       struct ocfs2_path *right_path,\n\t\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t\t       enum ocfs2_split_type split)\n{\n\tint index;\n\tu32 cpos = le32_to_cpu(split_rec->e_cpos);\n\tstruct ocfs2_extent_list *left_el = NULL, *right_el, *insert_el, *el;\n\tstruct ocfs2_extent_rec *rec, *tmprec;\n\n\tright_el = path_leaf_el(right_path);\n\tif (left_path)\n\t\tleft_el = path_leaf_el(left_path);\n\n\tel = right_el;\n\tinsert_el = right_el;\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index != -1) {\n\t\tif (index == 0 && left_path) {\n\t\t\tBUG_ON(ocfs2_is_empty_extent(&el->l_recs[0]));\n\n\t\t\t/*\n\t\t\t * This typically means that the record\n\t\t\t * started in the left path but moved to the\n\t\t\t * right as a result of rotation. We either\n\t\t\t * move the existing record to the left, or we\n\t\t\t * do the later insert there.\n\t\t\t *\n\t\t\t * In this case, the left path should always\n\t\t\t * exist as the rotate code will have passed\n\t\t\t * it back for a post-insert update.\n\t\t\t */\n\n\t\t\tif (split == SPLIT_LEFT) {\n\t\t\t\t/*\n\t\t\t\t * It's a left split. Since we know\n\t\t\t\t * that the rotate code gave us an\n\t\t\t\t * empty extent in the left path, we\n\t\t\t\t * can just do the insert there.\n\t\t\t\t */\n\t\t\t\tinsert_el = left_el;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Right split - we have to move the\n\t\t\t\t * existing record over to the left\n\t\t\t\t * leaf. The insert will be into the\n\t\t\t\t * newly created empty extent in the\n\t\t\t\t * right leaf.\n\t\t\t\t */\n\t\t\t\ttmprec = &right_el->l_recs[index];\n\t\t\t\tocfs2_rotate_leaf(left_el, tmprec);\n\t\t\t\tel = left_el;\n\n\t\t\t\tmemset(tmprec, 0, sizeof(*tmprec));\n\t\t\t\tindex = ocfs2_search_extent_list(left_el, cpos);\n\t\t\t\tBUG_ON(index == -1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBUG_ON(!left_path);\n\t\tBUG_ON(!ocfs2_is_empty_extent(&left_el->l_recs[0]));\n\t\t/*\n\t\t * Left path is easy - we can just allow the insert to\n\t\t * happen.\n\t\t */\n\t\tel = left_el;\n\t\tinsert_el = left_el;\n\t\tindex = ocfs2_search_extent_list(el, cpos);\n\t\tBUG_ON(index == -1);\n\t}\n\n\trec = &el->l_recs[index];\n\tocfs2_subtract_from_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\tsplit, rec, split_rec);\n\tocfs2_rotate_leaf(insert_el, split_rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_path",
          "args": [
            "et->et_ci",
            "handle",
            "right_path"
          ],
          "line": 4157
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "746-765",
          "snippet": "int ocfs2_journal_access_path(struct ocfs2_caching_info *ci,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_path *path)\n{\n\tint i, ret = 0;\n\n\tif (!path)\n\t\tgoto out;\n\n\tfor(i = 0; i < path_num_items(path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, ci, path, i);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_journal_access_path(struct ocfs2_caching_info *ci,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_path *path)\n{\n\tint i, ret = 0;\n\n\tif (!path)\n\t\tgoto out;\n\n\tfor(i = 0; i < path_num_items(path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, ci, path, i);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_trans",
          "args": [
            "handle",
            "left_path->p_tree_depth"
          ],
          "line": 4140
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "426-463",
          "snippet": "int ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "right_path"
          ],
          "line": 4131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic int ocfs2_insert_path(handle_t *handle,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     struct ocfs2_path *left_path,\n\t\t\t     struct ocfs2_path *right_path,\n\t\t\t     struct ocfs2_extent_rec *insert_rec,\n\t\t\t     struct ocfs2_insert_type *insert)\n{\n\tint ret, subtree_index;\n\tstruct buffer_head *leaf_bh = path_leaf_bh(right_path);\n\n\tif (left_path) {\n\t\t/*\n\t\t * There's a chance that left_path got passed back to\n\t\t * us without being accounted for in the\n\t\t * journal. Extend our transaction here to be sure we\n\t\t * can change those blocks.\n\t\t */\n\t\tret = ocfs2_extend_trans(handle, left_path->p_tree_depth);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Pass both paths to the journal. The majority of inserts\n\t * will be touching all components anyway.\n\t */\n\tret = ocfs2_journal_access_path(et->et_ci, handle, right_path);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (insert->ins_split != SPLIT_NONE) {\n\t\t/*\n\t\t * We could call ocfs2_insert_at_leaf() for some types\n\t\t * of splits, but it's easier to just let one separate\n\t\t * function sort it all out.\n\t\t */\n\t\tocfs2_split_record(et, left_path, right_path,\n\t\t\t\t   insert_rec, insert->ins_split);\n\n\t\t/*\n\t\t * Split might have modified either leaf and we don't\n\t\t * have a guarantee that the later edge insert will\n\t\t * dirty this for us.\n\t\t */\n\t\tif (left_path)\n\t\t\tocfs2_journal_dirty(handle,\n\t\t\t\t\t    path_leaf_bh(left_path));\n\t} else\n\t\tocfs2_insert_at_leaf(et, insert_rec, path_leaf_el(right_path),\n\t\t\t\t     insert);\n\n\tocfs2_journal_dirty(handle, leaf_bh);\n\n\tif (left_path) {\n\t\t/*\n\t\t * The rotate code has indicated that we need to fix\n\t\t * up portions of the tree after the insert.\n\t\t *\n\t\t * XXX: Should we extend the transaction here?\n\t\t */\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t\tright_path);\n\t\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t\t   subtree_index);\n\t}\n\n\tret = 0;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_split_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "4037-4113",
    "snippet": "static void ocfs2_split_record(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_path *left_path,\n\t\t\t       struct ocfs2_path *right_path,\n\t\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t\t       enum ocfs2_split_type split)\n{\n\tint index;\n\tu32 cpos = le32_to_cpu(split_rec->e_cpos);\n\tstruct ocfs2_extent_list *left_el = NULL, *right_el, *insert_el, *el;\n\tstruct ocfs2_extent_rec *rec, *tmprec;\n\n\tright_el = path_leaf_el(right_path);\n\tif (left_path)\n\t\tleft_el = path_leaf_el(left_path);\n\n\tel = right_el;\n\tinsert_el = right_el;\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index != -1) {\n\t\tif (index == 0 && left_path) {\n\t\t\tBUG_ON(ocfs2_is_empty_extent(&el->l_recs[0]));\n\n\t\t\t/*\n\t\t\t * This typically means that the record\n\t\t\t * started in the left path but moved to the\n\t\t\t * right as a result of rotation. We either\n\t\t\t * move the existing record to the left, or we\n\t\t\t * do the later insert there.\n\t\t\t *\n\t\t\t * In this case, the left path should always\n\t\t\t * exist as the rotate code will have passed\n\t\t\t * it back for a post-insert update.\n\t\t\t */\n\n\t\t\tif (split == SPLIT_LEFT) {\n\t\t\t\t/*\n\t\t\t\t * It's a left split. Since we know\n\t\t\t\t * that the rotate code gave us an\n\t\t\t\t * empty extent in the left path, we\n\t\t\t\t * can just do the insert there.\n\t\t\t\t */\n\t\t\t\tinsert_el = left_el;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Right split - we have to move the\n\t\t\t\t * existing record over to the left\n\t\t\t\t * leaf. The insert will be into the\n\t\t\t\t * newly created empty extent in the\n\t\t\t\t * right leaf.\n\t\t\t\t */\n\t\t\t\ttmprec = &right_el->l_recs[index];\n\t\t\t\tocfs2_rotate_leaf(left_el, tmprec);\n\t\t\t\tel = left_el;\n\n\t\t\t\tmemset(tmprec, 0, sizeof(*tmprec));\n\t\t\t\tindex = ocfs2_search_extent_list(left_el, cpos);\n\t\t\t\tBUG_ON(index == -1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBUG_ON(!left_path);\n\t\tBUG_ON(!ocfs2_is_empty_extent(&left_el->l_recs[0]));\n\t\t/*\n\t\t * Left path is easy - we can just allow the insert to\n\t\t * happen.\n\t\t */\n\t\tel = left_el;\n\t\tinsert_el = left_el;\n\t\tindex = ocfs2_search_extent_list(el, cpos);\n\t\tBUG_ON(index == -1);\n\t}\n\n\trec = &el->l_recs[index];\n\tocfs2_subtract_from_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\tsplit, rec, split_rec);\n\tocfs2_rotate_leaf(insert_el, split_rec);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_rotate_leaf",
          "args": [
            "insert_el",
            "split_rec"
          ],
          "line": 4112
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rotate_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1598-1675",
          "snippet": "static void ocfs2_rotate_leaf(struct ocfs2_extent_list *el,\n\t\t\t      struct ocfs2_extent_rec *insert_rec)\n{\n\tint i, insert_index, next_free, has_empty, num_bytes;\n\tu32 insert_cpos = le32_to_cpu(insert_rec->e_cpos);\n\tstruct ocfs2_extent_rec *rec;\n\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\thas_empty = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\tBUG_ON(!next_free);\n\n\t/* The tree code before us didn't allow enough room in the leaf. */\n\tBUG_ON(el->l_next_free_rec == el->l_count && !has_empty);\n\n\t/*\n\t * The easiest way to approach this is to just remove the\n\t * empty extent and temporarily decrement next_free.\n\t */\n\tif (has_empty) {\n\t\t/*\n\t\t * If next_free was 1 (only an empty extent), this\n\t\t * loop won't execute, which is fine. We still want\n\t\t * the decrement above to happen.\n\t\t */\n\t\tfor(i = 0; i < (next_free - 1); i++)\n\t\t\tel->l_recs[i] = el->l_recs[i+1];\n\n\t\tnext_free--;\n\t}\n\n\t/*\n\t * Figure out what the new record index should be.\n\t */\n\tfor(i = 0; i < next_free; i++) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (insert_cpos < le32_to_cpu(rec->e_cpos))\n\t\t\tbreak;\n\t}\n\tinsert_index = i;\n\n\ttrace_ocfs2_rotate_leaf(insert_cpos, insert_index,\n\t\t\t\thas_empty, next_free,\n\t\t\t\tle16_to_cpu(el->l_count));\n\n\tBUG_ON(insert_index < 0);\n\tBUG_ON(insert_index >= le16_to_cpu(el->l_count));\n\tBUG_ON(insert_index > next_free);\n\n\t/*\n\t * No need to memmove if we're just adding to the tail.\n\t */\n\tif (insert_index != next_free) {\n\t\tBUG_ON(next_free >= le16_to_cpu(el->l_count));\n\n\t\tnum_bytes = next_free - insert_index;\n\t\tnum_bytes *= sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[insert_index + 1],\n\t\t\t&el->l_recs[insert_index],\n\t\t\tnum_bytes);\n\t}\n\n\t/*\n\t * Either we had an empty extent, and need to re-increment or\n\t * there was no empty extent on a non full rightmost leaf node,\n\t * in which case we still need to increment.\n\t */\n\tnext_free++;\n\tel->l_next_free_rec = cpu_to_le16(next_free);\n\t/*\n\t * Make sure none of the math above just messed up our tree.\n\t */\n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) > le16_to_cpu(el->l_count));\n\n\tel->l_recs[insert_index] = *insert_rec;\n\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_rotate_leaf(struct ocfs2_extent_list *el,\n\t\t\t      struct ocfs2_extent_rec *insert_rec)\n{\n\tint i, insert_index, next_free, has_empty, num_bytes;\n\tu32 insert_cpos = le32_to_cpu(insert_rec->e_cpos);\n\tstruct ocfs2_extent_rec *rec;\n\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\thas_empty = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\tBUG_ON(!next_free);\n\n\t/* The tree code before us didn't allow enough room in the leaf. */\n\tBUG_ON(el->l_next_free_rec == el->l_count && !has_empty);\n\n\t/*\n\t * The easiest way to approach this is to just remove the\n\t * empty extent and temporarily decrement next_free.\n\t */\n\tif (has_empty) {\n\t\t/*\n\t\t * If next_free was 1 (only an empty extent), this\n\t\t * loop won't execute, which is fine. We still want\n\t\t * the decrement above to happen.\n\t\t */\n\t\tfor(i = 0; i < (next_free - 1); i++)\n\t\t\tel->l_recs[i] = el->l_recs[i+1];\n\n\t\tnext_free--;\n\t}\n\n\t/*\n\t * Figure out what the new record index should be.\n\t */\n\tfor(i = 0; i < next_free; i++) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (insert_cpos < le32_to_cpu(rec->e_cpos))\n\t\t\tbreak;\n\t}\n\tinsert_index = i;\n\n\ttrace_ocfs2_rotate_leaf(insert_cpos, insert_index,\n\t\t\t\thas_empty, next_free,\n\t\t\t\tle16_to_cpu(el->l_count));\n\n\tBUG_ON(insert_index < 0);\n\tBUG_ON(insert_index >= le16_to_cpu(el->l_count));\n\tBUG_ON(insert_index > next_free);\n\n\t/*\n\t * No need to memmove if we're just adding to the tail.\n\t */\n\tif (insert_index != next_free) {\n\t\tBUG_ON(next_free >= le16_to_cpu(el->l_count));\n\n\t\tnum_bytes = next_free - insert_index;\n\t\tnum_bytes *= sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[insert_index + 1],\n\t\t\t&el->l_recs[insert_index],\n\t\t\tnum_bytes);\n\t}\n\n\t/*\n\t * Either we had an empty extent, and need to re-increment or\n\t * there was no empty extent on a non full rightmost leaf node,\n\t * in which case we still need to increment.\n\t */\n\tnext_free++;\n\tel->l_next_free_rec = cpu_to_le16(next_free);\n\t/*\n\t * Make sure none of the math above just messed up our tree.\n\t */\n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) > le16_to_cpu(el->l_count));\n\n\tel->l_recs[insert_index] = *insert_rec;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_subtract_from_rec",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "split",
            "rec",
            "split_rec"
          ],
          "line": 4110
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_subtract_from_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "3790-3818",
          "snippet": "static void ocfs2_subtract_from_rec(struct super_block *sb,\n\t\t\t\t    enum ocfs2_split_type split,\n\t\t\t\t    struct ocfs2_extent_rec *rec,\n\t\t\t\t    struct ocfs2_extent_rec *split_rec)\n{\n\tu64 len_blocks;\n\n\tlen_blocks = ocfs2_clusters_to_blocks(sb,\n\t\t\t\tle16_to_cpu(split_rec->e_leaf_clusters));\n\n\tif (split == SPLIT_LEFT) {\n\t\t/*\n\t\t * Region is on the left edge of the existing\n\t\t * record.\n\t\t */\n\t\tle32_add_cpu(&rec->e_cpos,\n\t\t\t     le16_to_cpu(split_rec->e_leaf_clusters));\n\t\tle64_add_cpu(&rec->e_blkno, len_blocks);\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     -le16_to_cpu(split_rec->e_leaf_clusters));\n\t} else {\n\t\t/*\n\t\t * Region is on the right edge of the existing\n\t\t * record.\n\t\t */\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     -le16_to_cpu(split_rec->e_leaf_clusters));\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic void ocfs2_subtract_from_rec(struct super_block *sb,\n\t\t\t\t    enum ocfs2_split_type split,\n\t\t\t\t    struct ocfs2_extent_rec *rec,\n\t\t\t\t    struct ocfs2_extent_rec *split_rec)\n{\n\tu64 len_blocks;\n\n\tlen_blocks = ocfs2_clusters_to_blocks(sb,\n\t\t\t\tle16_to_cpu(split_rec->e_leaf_clusters));\n\n\tif (split == SPLIT_LEFT) {\n\t\t/*\n\t\t * Region is on the left edge of the existing\n\t\t * record.\n\t\t */\n\t\tle32_add_cpu(&rec->e_cpos,\n\t\t\t     le16_to_cpu(split_rec->e_leaf_clusters));\n\t\tle64_add_cpu(&rec->e_blkno, len_blocks);\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     -le16_to_cpu(split_rec->e_leaf_clusters));\n\t} else {\n\t\t/*\n\t\t * Region is on the right edge of the existing\n\t\t * record.\n\t\t */\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     -le16_to_cpu(split_rec->e_leaf_clusters));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 4110
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "index == -1"
          ],
          "line": 4106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_search_extent_list",
          "args": [
            "el",
            "cpos"
          ],
          "line": 4105
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_search_extent_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "773-795",
          "snippet": "int ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nint ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ocfs2_is_empty_extent(&left_el->l_recs[0])"
          ],
          "line": 4098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&left_el->l_recs[0]"
          ],
          "line": 4098
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "266-269",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!left_path"
          ],
          "line": 4097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "index == -1"
          ],
          "line": 4093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tmprec",
            "0",
            "sizeof(*tmprec)"
          ],
          "line": 4091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ocfs2_is_empty_extent(&el->l_recs[0])"
          ],
          "line": 4057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "left_path"
          ],
          "line": 4050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "right_path"
          ],
          "line": 4048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "split_rec->e_cpos"
          ],
          "line": 4044
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_split_record(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_path *left_path,\n\t\t\t       struct ocfs2_path *right_path,\n\t\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t\t       enum ocfs2_split_type split)\n{\n\tint index;\n\tu32 cpos = le32_to_cpu(split_rec->e_cpos);\n\tstruct ocfs2_extent_list *left_el = NULL, *right_el, *insert_el, *el;\n\tstruct ocfs2_extent_rec *rec, *tmprec;\n\n\tright_el = path_leaf_el(right_path);\n\tif (left_path)\n\t\tleft_el = path_leaf_el(left_path);\n\n\tel = right_el;\n\tinsert_el = right_el;\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index != -1) {\n\t\tif (index == 0 && left_path) {\n\t\t\tBUG_ON(ocfs2_is_empty_extent(&el->l_recs[0]));\n\n\t\t\t/*\n\t\t\t * This typically means that the record\n\t\t\t * started in the left path but moved to the\n\t\t\t * right as a result of rotation. We either\n\t\t\t * move the existing record to the left, or we\n\t\t\t * do the later insert there.\n\t\t\t *\n\t\t\t * In this case, the left path should always\n\t\t\t * exist as the rotate code will have passed\n\t\t\t * it back for a post-insert update.\n\t\t\t */\n\n\t\t\tif (split == SPLIT_LEFT) {\n\t\t\t\t/*\n\t\t\t\t * It's a left split. Since we know\n\t\t\t\t * that the rotate code gave us an\n\t\t\t\t * empty extent in the left path, we\n\t\t\t\t * can just do the insert there.\n\t\t\t\t */\n\t\t\t\tinsert_el = left_el;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Right split - we have to move the\n\t\t\t\t * existing record over to the left\n\t\t\t\t * leaf. The insert will be into the\n\t\t\t\t * newly created empty extent in the\n\t\t\t\t * right leaf.\n\t\t\t\t */\n\t\t\t\ttmprec = &right_el->l_recs[index];\n\t\t\t\tocfs2_rotate_leaf(left_el, tmprec);\n\t\t\t\tel = left_el;\n\n\t\t\t\tmemset(tmprec, 0, sizeof(*tmprec));\n\t\t\t\tindex = ocfs2_search_extent_list(left_el, cpos);\n\t\t\t\tBUG_ON(index == -1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBUG_ON(!left_path);\n\t\tBUG_ON(!ocfs2_is_empty_extent(&left_el->l_recs[0]));\n\t\t/*\n\t\t * Left path is easy - we can just allow the insert to\n\t\t * happen.\n\t\t */\n\t\tel = left_el;\n\t\tinsert_el = left_el;\n\t\tindex = ocfs2_search_extent_list(el, cpos);\n\t\tBUG_ON(index == -1);\n\t}\n\n\trec = &el->l_recs[index];\n\tocfs2_subtract_from_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\tsplit, rec, split_rec);\n\tocfs2_rotate_leaf(insert_el, split_rec);\n}"
  },
  {
    "function_name": "ocfs2_append_rec_to_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "3952-4035",
    "snippet": "static int ocfs2_append_rec_to_path(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t    struct ocfs2_path *right_path,\n\t\t\t\t    struct ocfs2_path **ret_left_path)\n{\n\tint ret, next_free;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *left_path = NULL;\n\n\t*ret_left_path = NULL;\n\n\t/*\n\t * This shouldn't happen for non-trees. The extent rec cluster\n\t * count manipulation below only works for interior nodes.\n\t */\n\tBUG_ON(right_path->p_tree_depth == 0);\n\n\t/*\n\t * If our appending insert is at the leftmost edge of a leaf,\n\t * then we might need to update the rightmost records of the\n\t * neighboring path.\n\t */\n\tel = path_leaf_el(right_path);\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\tif (next_free == 0 ||\n\t    (next_free == 1 && ocfs2_is_empty_extent(&el->l_recs[0]))) {\n\t\tu32 left_cpos;\n\n\t\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\t    right_path, &left_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\ttrace_ocfs2_append_rec_to_path(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tle32_to_cpu(insert_rec->e_cpos),\n\t\t\tleft_cpos);\n\n\t\t/*\n\t\t * No need to worry if the append is already in the\n\t\t * leftmost leaf.\n\t\t */\n\t\tif (left_cpos) {\n\t\t\tleft_path = ocfs2_new_path_from_path(right_path);\n\t\t\tif (!left_path) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_find_path(et->et_ci, left_path,\n\t\t\t\t\t      left_cpos);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * ocfs2_insert_path() will pass the left_path to the\n\t\t\t * journal for us.\n\t\t\t */\n\t\t}\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, right_path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_adjust_rightmost_records(handle, et, right_path, insert_rec);\n\n\t*ret_left_path = left_path;\n\tret = 0;\nout:\n\tif (ret != 0)\n\t\tocfs2_free_path(left_path);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "left_path"
          ],
          "line": 4032
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "609-615",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_adjust_rightmost_records",
          "args": [
            "handle",
            "et",
            "right_path",
            "insert_rec"
          ],
          "line": 4026
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_adjust_rightmost_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "3914-3950",
          "snippet": "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec)\n{\n\tint ret, i, next_free;\n\tstruct buffer_head *bh;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\t/*\n\t * Update everything except the leaf block.\n\t */\n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tbh = path->p_node[i].bh;\n\t\tel = path->p_node[i].el;\n\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tif (next_free == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has a bad extent list\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci));\n\t\t\tret = -EIO;\n\t\t\treturn;\n\t\t}\n\n\t\trec = &el->l_recs[next_free - 1];\n\n\t\trec->e_int_clusters = insert_rec->e_cpos;\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec)\n{\n\tint ret, i, next_free;\n\tstruct buffer_head *bh;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\t/*\n\t * Update everything except the leaf block.\n\t */\n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tbh = path->p_node[i].bh;\n\t\tel = path->p_node[i].el;\n\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tif (next_free == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has a bad extent list\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci));\n\t\t\tret = -EIO;\n\t\t\treturn;\n\t\t}\n\n\t\trec = &el->l_recs[next_free - 1];\n\n\t\trec->e_int_clusters = insert_rec->e_cpos;\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_path",
          "args": [
            "et->et_ci",
            "handle",
            "right_path"
          ],
          "line": 4020
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "746-765",
          "snippet": "int ocfs2_journal_access_path(struct ocfs2_caching_info *ci,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_path *path)\n{\n\tint i, ret = 0;\n\n\tif (!path)\n\t\tgoto out;\n\n\tfor(i = 0; i < path_num_items(path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, ci, path, i);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_journal_access_path(struct ocfs2_caching_info *ci,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_path *path)\n{\n\tint i, ret = 0;\n\n\tif (!path)\n\t\tgoto out;\n\n\tfor(i = 0; i < path_num_items(path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, ci, path, i);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "et->et_ci",
            "left_path",
            "left_cpos"
          ],
          "line": 4006
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1885-1894",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_path",
          "args": [
            "right_path"
          ],
          "line": 3999
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "707-711",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_append_rec_to_path",
          "args": [
            "(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci)",
            "le32_to_cpu(insert_rec->e_cpos)",
            "left_cpos"
          ],
          "line": 3988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "insert_rec->e_cpos"
          ],
          "line": 3991
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 3990
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_cpos_for_left_leaf",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "right_path",
            "&left_cpos"
          ],
          "line": 3981
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_cpos_for_left_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2205-2272",
          "snippet": "int ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 3981
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&el->l_recs[0]"
          ],
          "line": 3978
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "266-269",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 3976
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "right_path"
          ],
          "line": 3975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "right_path->p_tree_depth == 0"
          ],
          "line": 3968
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic int ocfs2_append_rec_to_path(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t    struct ocfs2_path *right_path,\n\t\t\t\t    struct ocfs2_path **ret_left_path)\n{\n\tint ret, next_free;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *left_path = NULL;\n\n\t*ret_left_path = NULL;\n\n\t/*\n\t * This shouldn't happen for non-trees. The extent rec cluster\n\t * count manipulation below only works for interior nodes.\n\t */\n\tBUG_ON(right_path->p_tree_depth == 0);\n\n\t/*\n\t * If our appending insert is at the leftmost edge of a leaf,\n\t * then we might need to update the rightmost records of the\n\t * neighboring path.\n\t */\n\tel = path_leaf_el(right_path);\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\tif (next_free == 0 ||\n\t    (next_free == 1 && ocfs2_is_empty_extent(&el->l_recs[0]))) {\n\t\tu32 left_cpos;\n\n\t\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\t    right_path, &left_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\ttrace_ocfs2_append_rec_to_path(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tle32_to_cpu(insert_rec->e_cpos),\n\t\t\tleft_cpos);\n\n\t\t/*\n\t\t * No need to worry if the append is already in the\n\t\t * leftmost leaf.\n\t\t */\n\t\tif (left_cpos) {\n\t\t\tleft_path = ocfs2_new_path_from_path(right_path);\n\t\t\tif (!left_path) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_find_path(et->et_ci, left_path,\n\t\t\t\t\t      left_cpos);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * ocfs2_insert_path() will pass the left_path to the\n\t\t\t * journal for us.\n\t\t\t */\n\t\t}\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, right_path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_adjust_rightmost_records(handle, et, right_path, insert_rec);\n\n\t*ret_left_path = left_path;\n\tret = 0;\nout:\n\tif (ret != 0)\n\t\tocfs2_free_path(left_path);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_adjust_rightmost_records",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "3914-3950",
    "snippet": "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec)\n{\n\tint ret, i, next_free;\n\tstruct buffer_head *bh;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\t/*\n\t * Update everything except the leaf block.\n\t */\n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tbh = path->p_node[i].bh;\n\t\tel = path->p_node[i].el;\n\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tif (next_free == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has a bad extent list\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci));\n\t\t\tret = -EIO;\n\t\t\treturn;\n\t\t}\n\n\t\trec = &el->l_recs[next_free - 1];\n\n\t\trec->e_int_clusters = insert_rec->e_cpos;\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "bh"
          ],
          "line": 3948
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&rec->e_int_clusters",
            "-le32_to_cpu(rec->e_cpos)"
          ],
          "line": 3945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 3946
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&rec->e_int_clusters",
            "le16_to_cpu(insert_rec->e_leaf_clusters)"
          ],
          "line": 3943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "insert_rec->e_leaf_clusters"
          ],
          "line": 3944
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "\"Owner %llu has a bad extent list\"",
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)"
          ],
          "line": 3933
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 3935
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 3933
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec)\n{\n\tint ret, i, next_free;\n\tstruct buffer_head *bh;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\t/*\n\t * Update everything except the leaf block.\n\t */\n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tbh = path->p_node[i].bh;\n\t\tel = path->p_node[i].el;\n\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tif (next_free == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has a bad extent list\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci));\n\t\t\tret = -EIO;\n\t\t\treturn;\n\t\t}\n\n\t\trec = &el->l_recs[next_free - 1];\n\n\t\trec->e_int_clusters = insert_rec->e_cpos;\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_insert_at_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "3825-3912",
    "snippet": "static void ocfs2_insert_at_leaf(struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t struct ocfs2_extent_list *el,\n\t\t\t\t struct ocfs2_insert_type *insert)\n{\n\tint i = insert->ins_contig_index;\n\tunsigned int range;\n\tstruct ocfs2_extent_rec *rec;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (insert->ins_split != SPLIT_NONE) {\n\t\ti = ocfs2_search_extent_list(el, le32_to_cpu(insert_rec->e_cpos));\n\t\tBUG_ON(i == -1);\n\t\trec = &el->l_recs[i];\n\t\tocfs2_subtract_from_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\tinsert->ins_split, rec,\n\t\t\t\t\tinsert_rec);\n\t\tgoto rotate;\n\t}\n\n\t/*\n\t * Contiguous insert - either left or right.\n\t */\n\tif (insert->ins_contig != CONTIG_NONE) {\n\t\trec = &el->l_recs[i];\n\t\tif (insert->ins_contig == CONTIG_LEFT) {\n\t\t\trec->e_blkno = insert_rec->e_blkno;\n\t\t\trec->e_cpos = insert_rec->e_cpos;\n\t\t}\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\treturn;\n\t}\n\n\t/*\n\t * Handle insert into an empty leaf.\n\t */\n\tif (le16_to_cpu(el->l_next_free_rec) == 0 ||\n\t    ((le16_to_cpu(el->l_next_free_rec) == 1) &&\n\t     ocfs2_is_empty_extent(&el->l_recs[0]))) {\n\t\tel->l_recs[0] = *insert_rec;\n\t\tel->l_next_free_rec = cpu_to_le16(1);\n\t\treturn;\n\t}\n\n\t/*\n\t * Appending insert.\n\t */\n\tif (insert->ins_appending == APPEND_TAIL) {\n\t\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\trec = &el->l_recs[i];\n\t\trange = le32_to_cpu(rec->e_cpos)\n\t\t\t+ le16_to_cpu(rec->e_leaf_clusters);\n\t\tBUG_ON(le32_to_cpu(insert_rec->e_cpos) < range);\n\n\t\tmlog_bug_on_msg(le16_to_cpu(el->l_next_free_rec) >=\n\t\t\t\tle16_to_cpu(el->l_count),\n\t\t\t\t\"owner %llu, depth %u, count %u, next free %u, \"\n\t\t\t\t\"rec.cpos %u, rec.clusters %u, \"\n\t\t\t\t\"insert.cpos %u, insert.clusters %u\\n\",\n\t\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tle16_to_cpu(el->l_tree_depth),\n\t\t\t\tle16_to_cpu(el->l_count),\n\t\t\t\tle16_to_cpu(el->l_next_free_rec),\n\t\t\t\tle32_to_cpu(el->l_recs[i].e_cpos),\n\t\t\t\tle16_to_cpu(el->l_recs[i].e_leaf_clusters),\n\t\t\t\tle32_to_cpu(insert_rec->e_cpos),\n\t\t\t\tle16_to_cpu(insert_rec->e_leaf_clusters));\n\t\ti++;\n\t\tel->l_recs[i] = *insert_rec;\n\t\tle16_add_cpu(&el->l_next_free_rec, 1);\n\t\treturn;\n\t}\n\nrotate:\n\t/*\n\t * Ok, we have to rotate.\n\t *\n\t * At this point, it is safe to assume that inserting into an\n\t * empty leaf and appending to a leaf have both been handled\n\t * above.\n\t *\n\t * This leaf needs to have space, either by the empty 1st\n\t * extent record, or by virtue of an l_next_rec < l_count.\n\t */\n\tocfs2_rotate_leaf(el, insert_rec);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_rotate_leaf",
          "args": [
            "el",
            "insert_rec"
          ],
          "line": 3911
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rotate_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1598-1675",
          "snippet": "static void ocfs2_rotate_leaf(struct ocfs2_extent_list *el,\n\t\t\t      struct ocfs2_extent_rec *insert_rec)\n{\n\tint i, insert_index, next_free, has_empty, num_bytes;\n\tu32 insert_cpos = le32_to_cpu(insert_rec->e_cpos);\n\tstruct ocfs2_extent_rec *rec;\n\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\thas_empty = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\tBUG_ON(!next_free);\n\n\t/* The tree code before us didn't allow enough room in the leaf. */\n\tBUG_ON(el->l_next_free_rec == el->l_count && !has_empty);\n\n\t/*\n\t * The easiest way to approach this is to just remove the\n\t * empty extent and temporarily decrement next_free.\n\t */\n\tif (has_empty) {\n\t\t/*\n\t\t * If next_free was 1 (only an empty extent), this\n\t\t * loop won't execute, which is fine. We still want\n\t\t * the decrement above to happen.\n\t\t */\n\t\tfor(i = 0; i < (next_free - 1); i++)\n\t\t\tel->l_recs[i] = el->l_recs[i+1];\n\n\t\tnext_free--;\n\t}\n\n\t/*\n\t * Figure out what the new record index should be.\n\t */\n\tfor(i = 0; i < next_free; i++) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (insert_cpos < le32_to_cpu(rec->e_cpos))\n\t\t\tbreak;\n\t}\n\tinsert_index = i;\n\n\ttrace_ocfs2_rotate_leaf(insert_cpos, insert_index,\n\t\t\t\thas_empty, next_free,\n\t\t\t\tle16_to_cpu(el->l_count));\n\n\tBUG_ON(insert_index < 0);\n\tBUG_ON(insert_index >= le16_to_cpu(el->l_count));\n\tBUG_ON(insert_index > next_free);\n\n\t/*\n\t * No need to memmove if we're just adding to the tail.\n\t */\n\tif (insert_index != next_free) {\n\t\tBUG_ON(next_free >= le16_to_cpu(el->l_count));\n\n\t\tnum_bytes = next_free - insert_index;\n\t\tnum_bytes *= sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[insert_index + 1],\n\t\t\t&el->l_recs[insert_index],\n\t\t\tnum_bytes);\n\t}\n\n\t/*\n\t * Either we had an empty extent, and need to re-increment or\n\t * there was no empty extent on a non full rightmost leaf node,\n\t * in which case we still need to increment.\n\t */\n\tnext_free++;\n\tel->l_next_free_rec = cpu_to_le16(next_free);\n\t/*\n\t * Make sure none of the math above just messed up our tree.\n\t */\n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) > le16_to_cpu(el->l_count));\n\n\tel->l_recs[insert_index] = *insert_rec;\n\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_rotate_leaf(struct ocfs2_extent_list *el,\n\t\t\t      struct ocfs2_extent_rec *insert_rec)\n{\n\tint i, insert_index, next_free, has_empty, num_bytes;\n\tu32 insert_cpos = le32_to_cpu(insert_rec->e_cpos);\n\tstruct ocfs2_extent_rec *rec;\n\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\thas_empty = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\tBUG_ON(!next_free);\n\n\t/* The tree code before us didn't allow enough room in the leaf. */\n\tBUG_ON(el->l_next_free_rec == el->l_count && !has_empty);\n\n\t/*\n\t * The easiest way to approach this is to just remove the\n\t * empty extent and temporarily decrement next_free.\n\t */\n\tif (has_empty) {\n\t\t/*\n\t\t * If next_free was 1 (only an empty extent), this\n\t\t * loop won't execute, which is fine. We still want\n\t\t * the decrement above to happen.\n\t\t */\n\t\tfor(i = 0; i < (next_free - 1); i++)\n\t\t\tel->l_recs[i] = el->l_recs[i+1];\n\n\t\tnext_free--;\n\t}\n\n\t/*\n\t * Figure out what the new record index should be.\n\t */\n\tfor(i = 0; i < next_free; i++) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (insert_cpos < le32_to_cpu(rec->e_cpos))\n\t\t\tbreak;\n\t}\n\tinsert_index = i;\n\n\ttrace_ocfs2_rotate_leaf(insert_cpos, insert_index,\n\t\t\t\thas_empty, next_free,\n\t\t\t\tle16_to_cpu(el->l_count));\n\n\tBUG_ON(insert_index < 0);\n\tBUG_ON(insert_index >= le16_to_cpu(el->l_count));\n\tBUG_ON(insert_index > next_free);\n\n\t/*\n\t * No need to memmove if we're just adding to the tail.\n\t */\n\tif (insert_index != next_free) {\n\t\tBUG_ON(next_free >= le16_to_cpu(el->l_count));\n\n\t\tnum_bytes = next_free - insert_index;\n\t\tnum_bytes *= sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[insert_index + 1],\n\t\t\t&el->l_recs[insert_index],\n\t\t\tnum_bytes);\n\t}\n\n\t/*\n\t * Either we had an empty extent, and need to re-increment or\n\t * there was no empty extent on a non full rightmost leaf node,\n\t * in which case we still need to increment.\n\t */\n\tnext_free++;\n\tel->l_next_free_rec = cpu_to_le16(next_free);\n\t/*\n\t * Make sure none of the math above just messed up our tree.\n\t */\n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) > le16_to_cpu(el->l_count));\n\n\tel->l_recs[insert_index] = *insert_rec;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&el->l_next_free_rec",
            "1"
          ],
          "line": 3896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "le16_to_cpu(el->l_next_free_rec) >=\n\t\t\t\tle16_to_cpu(el->l_count)",
            "\"owner %llu, depth %u, count %u, next free %u, \"\n\t\t\t\t\"rec.cpos %u, rec.clusters %u, \"\n\t\t\t\t\"insert.cpos %u, insert.clusters %u\\n\"",
            "ocfs2_metadata_cache_owner(et->et_ci)",
            "le16_to_cpu(el->l_tree_depth)",
            "le16_to_cpu(el->l_count)",
            "le16_to_cpu(el->l_next_free_rec)",
            "le32_to_cpu(el->l_recs[i].e_cpos)",
            "le16_to_cpu(el->l_recs[i].e_leaf_clusters)",
            "le32_to_cpu(insert_rec->e_cpos)",
            "le16_to_cpu(insert_rec->e_leaf_clusters)"
          ],
          "line": 3881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "insert_rec->e_leaf_clusters"
          ],
          "line": 3893
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "insert_rec->e_cpos"
          ],
          "line": 3892
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 3886
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le32_to_cpu(insert_rec->e_cpos) < range"
          ],
          "line": 3879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 3867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&el->l_recs[0]"
          ],
          "line": 3865
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "266-269",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&rec->e_leaf_clusters",
            "le16_to_cpu(insert_rec->e_leaf_clusters)"
          ],
          "line": 3855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_subtract_from_rec",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "insert->ins_split",
            "rec",
            "insert_rec"
          ],
          "line": 3840
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_subtract_from_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "3790-3818",
          "snippet": "static void ocfs2_subtract_from_rec(struct super_block *sb,\n\t\t\t\t    enum ocfs2_split_type split,\n\t\t\t\t    struct ocfs2_extent_rec *rec,\n\t\t\t\t    struct ocfs2_extent_rec *split_rec)\n{\n\tu64 len_blocks;\n\n\tlen_blocks = ocfs2_clusters_to_blocks(sb,\n\t\t\t\tle16_to_cpu(split_rec->e_leaf_clusters));\n\n\tif (split == SPLIT_LEFT) {\n\t\t/*\n\t\t * Region is on the left edge of the existing\n\t\t * record.\n\t\t */\n\t\tle32_add_cpu(&rec->e_cpos,\n\t\t\t     le16_to_cpu(split_rec->e_leaf_clusters));\n\t\tle64_add_cpu(&rec->e_blkno, len_blocks);\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     -le16_to_cpu(split_rec->e_leaf_clusters));\n\t} else {\n\t\t/*\n\t\t * Region is on the right edge of the existing\n\t\t * record.\n\t\t */\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     -le16_to_cpu(split_rec->e_leaf_clusters));\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic void ocfs2_subtract_from_rec(struct super_block *sb,\n\t\t\t\t    enum ocfs2_split_type split,\n\t\t\t\t    struct ocfs2_extent_rec *rec,\n\t\t\t\t    struct ocfs2_extent_rec *split_rec)\n{\n\tu64 len_blocks;\n\n\tlen_blocks = ocfs2_clusters_to_blocks(sb,\n\t\t\t\tle16_to_cpu(split_rec->e_leaf_clusters));\n\n\tif (split == SPLIT_LEFT) {\n\t\t/*\n\t\t * Region is on the left edge of the existing\n\t\t * record.\n\t\t */\n\t\tle32_add_cpu(&rec->e_cpos,\n\t\t\t     le16_to_cpu(split_rec->e_leaf_clusters));\n\t\tle64_add_cpu(&rec->e_blkno, len_blocks);\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     -le16_to_cpu(split_rec->e_leaf_clusters));\n\t} else {\n\t\t/*\n\t\t * Region is on the right edge of the existing\n\t\t * record.\n\t\t */\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     -le16_to_cpu(split_rec->e_leaf_clusters));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 3840
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "i == -1"
          ],
          "line": 3838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_search_extent_list",
          "args": [
            "el",
            "le32_to_cpu(insert_rec->e_cpos)"
          ],
          "line": 3837
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_search_extent_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "773-795",
          "snippet": "int ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nint ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le16_to_cpu(el->l_tree_depth) != 0"
          ],
          "line": 3834
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_insert_at_leaf(struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t struct ocfs2_extent_list *el,\n\t\t\t\t struct ocfs2_insert_type *insert)\n{\n\tint i = insert->ins_contig_index;\n\tunsigned int range;\n\tstruct ocfs2_extent_rec *rec;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (insert->ins_split != SPLIT_NONE) {\n\t\ti = ocfs2_search_extent_list(el, le32_to_cpu(insert_rec->e_cpos));\n\t\tBUG_ON(i == -1);\n\t\trec = &el->l_recs[i];\n\t\tocfs2_subtract_from_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\tinsert->ins_split, rec,\n\t\t\t\t\tinsert_rec);\n\t\tgoto rotate;\n\t}\n\n\t/*\n\t * Contiguous insert - either left or right.\n\t */\n\tif (insert->ins_contig != CONTIG_NONE) {\n\t\trec = &el->l_recs[i];\n\t\tif (insert->ins_contig == CONTIG_LEFT) {\n\t\t\trec->e_blkno = insert_rec->e_blkno;\n\t\t\trec->e_cpos = insert_rec->e_cpos;\n\t\t}\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\treturn;\n\t}\n\n\t/*\n\t * Handle insert into an empty leaf.\n\t */\n\tif (le16_to_cpu(el->l_next_free_rec) == 0 ||\n\t    ((le16_to_cpu(el->l_next_free_rec) == 1) &&\n\t     ocfs2_is_empty_extent(&el->l_recs[0]))) {\n\t\tel->l_recs[0] = *insert_rec;\n\t\tel->l_next_free_rec = cpu_to_le16(1);\n\t\treturn;\n\t}\n\n\t/*\n\t * Appending insert.\n\t */\n\tif (insert->ins_appending == APPEND_TAIL) {\n\t\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\trec = &el->l_recs[i];\n\t\trange = le32_to_cpu(rec->e_cpos)\n\t\t\t+ le16_to_cpu(rec->e_leaf_clusters);\n\t\tBUG_ON(le32_to_cpu(insert_rec->e_cpos) < range);\n\n\t\tmlog_bug_on_msg(le16_to_cpu(el->l_next_free_rec) >=\n\t\t\t\tle16_to_cpu(el->l_count),\n\t\t\t\t\"owner %llu, depth %u, count %u, next free %u, \"\n\t\t\t\t\"rec.cpos %u, rec.clusters %u, \"\n\t\t\t\t\"insert.cpos %u, insert.clusters %u\\n\",\n\t\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tle16_to_cpu(el->l_tree_depth),\n\t\t\t\tle16_to_cpu(el->l_count),\n\t\t\t\tle16_to_cpu(el->l_next_free_rec),\n\t\t\t\tle32_to_cpu(el->l_recs[i].e_cpos),\n\t\t\t\tle16_to_cpu(el->l_recs[i].e_leaf_clusters),\n\t\t\t\tle32_to_cpu(insert_rec->e_cpos),\n\t\t\t\tle16_to_cpu(insert_rec->e_leaf_clusters));\n\t\ti++;\n\t\tel->l_recs[i] = *insert_rec;\n\t\tle16_add_cpu(&el->l_next_free_rec, 1);\n\t\treturn;\n\t}\n\nrotate:\n\t/*\n\t * Ok, we have to rotate.\n\t *\n\t * At this point, it is safe to assume that inserting into an\n\t * empty leaf and appending to a leaf have both been handled\n\t * above.\n\t *\n\t * This leaf needs to have space, either by the empty 1st\n\t * extent record, or by virtue of an l_next_rec < l_count.\n\t */\n\tocfs2_rotate_leaf(el, insert_rec);\n}"
  },
  {
    "function_name": "ocfs2_subtract_from_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "3790-3818",
    "snippet": "static void ocfs2_subtract_from_rec(struct super_block *sb,\n\t\t\t\t    enum ocfs2_split_type split,\n\t\t\t\t    struct ocfs2_extent_rec *rec,\n\t\t\t\t    struct ocfs2_extent_rec *split_rec)\n{\n\tu64 len_blocks;\n\n\tlen_blocks = ocfs2_clusters_to_blocks(sb,\n\t\t\t\tle16_to_cpu(split_rec->e_leaf_clusters));\n\n\tif (split == SPLIT_LEFT) {\n\t\t/*\n\t\t * Region is on the left edge of the existing\n\t\t * record.\n\t\t */\n\t\tle32_add_cpu(&rec->e_cpos,\n\t\t\t     le16_to_cpu(split_rec->e_leaf_clusters));\n\t\tle64_add_cpu(&rec->e_blkno, len_blocks);\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     -le16_to_cpu(split_rec->e_leaf_clusters));\n\t} else {\n\t\t/*\n\t\t * Region is on the right edge of the existing\n\t\t * record.\n\t\t */\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     -le16_to_cpu(split_rec->e_leaf_clusters));\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&rec->e_leaf_clusters",
            "-le16_to_cpu(split_rec->e_leaf_clusters)"
          ],
          "line": 3815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "split_rec->e_leaf_clusters"
          ],
          "line": 3816
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&rec->e_leaf_clusters",
            "-le16_to_cpu(split_rec->e_leaf_clusters)"
          ],
          "line": 3808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_add_cpu",
          "args": [
            "&rec->e_blkno",
            "len_blocks"
          ],
          "line": 3807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&rec->e_cpos",
            "le16_to_cpu(split_rec->e_leaf_clusters)"
          ],
          "line": 3805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "sb",
            "le16_to_cpu(split_rec->e_leaf_clusters)"
          ],
          "line": 3797
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic void ocfs2_subtract_from_rec(struct super_block *sb,\n\t\t\t\t    enum ocfs2_split_type split,\n\t\t\t\t    struct ocfs2_extent_rec *rec,\n\t\t\t\t    struct ocfs2_extent_rec *split_rec)\n{\n\tu64 len_blocks;\n\n\tlen_blocks = ocfs2_clusters_to_blocks(sb,\n\t\t\t\tle16_to_cpu(split_rec->e_leaf_clusters));\n\n\tif (split == SPLIT_LEFT) {\n\t\t/*\n\t\t * Region is on the left edge of the existing\n\t\t * record.\n\t\t */\n\t\tle32_add_cpu(&rec->e_cpos,\n\t\t\t     le16_to_cpu(split_rec->e_leaf_clusters));\n\t\tle64_add_cpu(&rec->e_blkno, len_blocks);\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     -le16_to_cpu(split_rec->e_leaf_clusters));\n\t} else {\n\t\t/*\n\t\t * Region is on the right edge of the existing\n\t\t * record.\n\t\t */\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     -le16_to_cpu(split_rec->e_leaf_clusters));\n\t}\n}"
  },
  {
    "function_name": "ocfs2_try_to_merge_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "3655-3788",
    "snippet": "static int ocfs2_try_to_merge_extent(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_path *path,\n\t\t\t\t     int split_index,\n\t\t\t\t     struct ocfs2_extent_rec *split_rec,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t     struct ocfs2_merge_ctxt *ctxt)\n{\n\tint ret = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[split_index];\n\n\tBUG_ON(ctxt->c_contig_type == CONTIG_NONE);\n\n\tif (ctxt->c_split_covers_rec && ctxt->c_has_empty_extent) {\n\t\t/*\n\t\t * The merge code will need to create an empty\n\t\t * extent to take the place of the newly\n\t\t * emptied slot. Remove any pre-existing empty\n\t\t * extents - having more than one in a leaf is\n\t\t * illegal.\n\t\t */\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tsplit_index--;\n\t\trec = &el->l_recs[split_index];\n\t}\n\n\tif (ctxt->c_contig_type == CONTIG_LEFTRIGHT) {\n\t\t/*\n\t\t * Left-right contig implies this.\n\t\t */\n\t\tBUG_ON(!ctxt->c_split_covers_rec);\n\n\t\t/*\n\t\t * Since the leftright insert always covers the entire\n\t\t * extent, this call will delete the insert record\n\t\t * entirely, resulting in an empty extent record added to\n\t\t * the extent block.\n\t\t *\n\t\t * Since the adding of an empty extent shifts\n\t\t * everything back to the right, there's no need to\n\t\t * update split_index here.\n\t\t *\n\t\t * When the split_index is zero, we need to merge it to the\n\t\t * prevoius extent block. It is more efficient and easier\n\t\t * if we do merge_right first and merge_left later.\n\t\t */\n\t\tret = ocfs2_merge_rec_right(path, handle, et, split_rec,\n\t\t\t\t\t    split_index);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * We can only get this from logic error above.\n\t\t */\n\t\tBUG_ON(!ocfs2_is_empty_extent(&el->l_recs[0]));\n\n\t\t/* The merge left us with an empty extent, remove it. */\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\trec = &el->l_recs[split_index];\n\n\t\t/*\n\t\t * Note that we don't pass split_rec here on purpose -\n\t\t * we've merged it into the rec already.\n\t\t */\n\t\tret = ocfs2_merge_rec_left(path, handle, et, rec,\n\t\t\t\t\t   dealloc, split_index);\n\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\t/*\n\t\t * Error from this last rotate is not critical, so\n\t\t * print but don't bubble it up.\n\t\t */\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tret = 0;\n\t} else {\n\t\t/*\n\t\t * Merge a record to the left or right.\n\t\t *\n\t\t * 'contig_type' is relative to the existing record,\n\t\t * so for example, if we're \"right contig\", it's to\n\t\t * the record on the left (hence the left merge).\n\t\t */\n\t\tif (ctxt->c_contig_type == CONTIG_RIGHT) {\n\t\t\tret = ocfs2_merge_rec_left(path, handle, et,\n\t\t\t\t\t\t   split_rec, dealloc,\n\t\t\t\t\t\t   split_index);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tret = ocfs2_merge_rec_right(path, handle,\n\t\t\t\t\t\t    et, split_rec,\n\t\t\t\t\t\t    split_index);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (ctxt->c_split_covers_rec) {\n\t\t\t/*\n\t\t\t * The merge may have left an empty extent in\n\t\t\t * our leaf. Try to rotate it away.\n\t\t\t */\n\t\t\tret = ocfs2_rotate_tree_left(handle, et, path,\n\t\t\t\t\t\t     dealloc);\n\t\t\tif (ret)\n\t\t\t\tmlog_errno(ret);\n\t\t\tret = 0;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rotate_tree_left",
          "args": [
            "handle",
            "et",
            "path",
            "dealloc"
          ],
          "line": 3778
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rotate_tree_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "3149-3259",
          "snippet": "static int ocfs2_rotate_tree_left(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_path *path,\n\t\t\t\t  struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, orig_credits = handle->h_buffer_credits;\n\tstruct ocfs2_path *tmp_path = NULL, *restart_path = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\tel = path_leaf_el(path);\n\tif (!ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn 0;\n\n\tif (path->p_tree_depth == 0) {\nrightmost_no_delete:\n\t\t/*\n\t\t * Inline extents. This is trivially handled, so do\n\t\t * it up front.\n\t\t */\n\t\tret = ocfs2_rotate_rightmost_leaf_left(handle, et, path);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Handle rightmost branch now. There's several cases:\n\t *  1) simple rotation leaving records in there. That's trivial.\n\t *  2) rotation requiring a branch delete - there's no more\n\t *     records left. Two cases of this:\n\t *     a) There are branches to the left.\n\t *     b) This is also the leftmost (the only) branch.\n\t *\n\t *  1) is handled via ocfs2_rotate_rightmost_leaf_left()\n\t *  2a) we need the left branch so that we can update it with the unlink\n\t *  2b) we need to bring the root back to inline extents.\n\t */\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\tel = &eb->h_list;\n\tif (eb->h_next_leaf_blk == 0) {\n\t\t/*\n\t\t * This gets a bit tricky if we're going to delete the\n\t\t * rightmost path. Get the other cases out of the way\n\t\t * 1st.\n\t\t */\n\t\tif (le16_to_cpu(el->l_next_free_rec) > 1)\n\t\t\tgoto rightmost_no_delete;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tret = -EIO;\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has empty extent block at %llu\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    (unsigned long long)le64_to_cpu(eb->h_blkno));\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * XXX: The caller can not trust \"path\" any more after\n\t\t * this as it will have been deleted. What do we do?\n\t\t *\n\t\t * In theory the rotate-for-merge code will never get\n\t\t * here because it'll always ask for a rotate in a\n\t\t * nonempty list.\n\t\t */\n\n\t\tret = ocfs2_remove_rightmost_path(handle, et, path,\n\t\t\t\t\t\t  dealloc);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Now we can loop, remembering the path we get from -EAGAIN\n\t * and restarting from there.\n\t */\ntry_rotate:\n\tret = __ocfs2_rotate_tree_left(handle, et, orig_credits, path,\n\t\t\t\t       dealloc, &restart_path);\n\tif (ret && ret != -EAGAIN) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (ret == -EAGAIN) {\n\t\ttmp_path = restart_path;\n\t\trestart_path = NULL;\n\n\t\tret = __ocfs2_rotate_tree_left(handle, et, orig_credits,\n\t\t\t\t\t       tmp_path, dealloc,\n\t\t\t\t\t       &restart_path);\n\t\tif (ret && ret != -EAGAIN) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tocfs2_free_path(tmp_path);\n\t\ttmp_path = NULL;\n\n\t\tif (ret == 0)\n\t\t\tgoto try_rotate;\n\t}\n\nout:\n\tocfs2_free_path(tmp_path);\n\tocfs2_free_path(restart_path);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_rotate_tree_left(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_path *path,\n\t\t\t\t  struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, orig_credits = handle->h_buffer_credits;\n\tstruct ocfs2_path *tmp_path = NULL, *restart_path = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\tel = path_leaf_el(path);\n\tif (!ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn 0;\n\n\tif (path->p_tree_depth == 0) {\nrightmost_no_delete:\n\t\t/*\n\t\t * Inline extents. This is trivially handled, so do\n\t\t * it up front.\n\t\t */\n\t\tret = ocfs2_rotate_rightmost_leaf_left(handle, et, path);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Handle rightmost branch now. There's several cases:\n\t *  1) simple rotation leaving records in there. That's trivial.\n\t *  2) rotation requiring a branch delete - there's no more\n\t *     records left. Two cases of this:\n\t *     a) There are branches to the left.\n\t *     b) This is also the leftmost (the only) branch.\n\t *\n\t *  1) is handled via ocfs2_rotate_rightmost_leaf_left()\n\t *  2a) we need the left branch so that we can update it with the unlink\n\t *  2b) we need to bring the root back to inline extents.\n\t */\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\tel = &eb->h_list;\n\tif (eb->h_next_leaf_blk == 0) {\n\t\t/*\n\t\t * This gets a bit tricky if we're going to delete the\n\t\t * rightmost path. Get the other cases out of the way\n\t\t * 1st.\n\t\t */\n\t\tif (le16_to_cpu(el->l_next_free_rec) > 1)\n\t\t\tgoto rightmost_no_delete;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tret = -EIO;\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has empty extent block at %llu\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    (unsigned long long)le64_to_cpu(eb->h_blkno));\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * XXX: The caller can not trust \"path\" any more after\n\t\t * this as it will have been deleted. What do we do?\n\t\t *\n\t\t * In theory the rotate-for-merge code will never get\n\t\t * here because it'll always ask for a rotate in a\n\t\t * nonempty list.\n\t\t */\n\n\t\tret = ocfs2_remove_rightmost_path(handle, et, path,\n\t\t\t\t\t\t  dealloc);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Now we can loop, remembering the path we get from -EAGAIN\n\t * and restarting from there.\n\t */\ntry_rotate:\n\tret = __ocfs2_rotate_tree_left(handle, et, orig_credits, path,\n\t\t\t\t       dealloc, &restart_path);\n\tif (ret && ret != -EAGAIN) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (ret == -EAGAIN) {\n\t\ttmp_path = restart_path;\n\t\trestart_path = NULL;\n\n\t\tret = __ocfs2_rotate_tree_left(handle, et, orig_credits,\n\t\t\t\t\t       tmp_path, dealloc,\n\t\t\t\t\t       &restart_path);\n\t\tif (ret && ret != -EAGAIN) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tocfs2_free_path(tmp_path);\n\t\ttmp_path = NULL;\n\n\t\tif (ret == 0)\n\t\t\tgoto try_rotate;\n\t}\n\nout:\n\tocfs2_free_path(tmp_path);\n\tocfs2_free_path(restart_path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_merge_rec_right",
          "args": [
            "path",
            "handle",
            "et",
            "split_rec",
            "split_index"
          ],
          "line": 3764
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_merge_rec_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "3347-3459",
          "snippet": "static int ocfs2_merge_rec_right(struct ocfs2_path *left_path,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_extent_rec *split_rec,\n\t\t\t\t int index)\n{\n\tint ret, next_free, i;\n\tunsigned int split_clusters = le16_to_cpu(split_rec->e_leaf_clusters);\n\tstruct ocfs2_extent_rec *left_rec;\n\tstruct ocfs2_extent_rec *right_rec;\n\tstruct ocfs2_extent_list *right_el;\n\tstruct ocfs2_path *right_path = NULL;\n\tint subtree_index = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(left_path);\n\tstruct buffer_head *bh = path_leaf_bh(left_path);\n\tstruct buffer_head *root_bh = NULL;\n\n\tBUG_ON(index >= le16_to_cpu(el->l_next_free_rec));\n\tleft_rec = &el->l_recs[index];\n\n\tif (index == le16_to_cpu(el->l_next_free_rec) - 1 &&\n\t    le16_to_cpu(el->l_next_free_rec) == le16_to_cpu(el->l_count)) {\n\t\t/* we meet with a cross extent block merge. */\n\t\tret = ocfs2_get_right_path(et, left_path, &right_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tright_el = path_leaf_el(right_path);\n\t\tnext_free = le16_to_cpu(right_el->l_next_free_rec);\n\t\tBUG_ON(next_free <= 0);\n\t\tright_rec = &right_el->l_recs[0];\n\t\tif (ocfs2_is_empty_extent(right_rec)) {\n\t\t\tBUG_ON(next_free <= 1);\n\t\t\tright_rec = &right_el->l_recs[1];\n\t\t}\n\n\t\tBUG_ON(le32_to_cpu(left_rec->e_cpos) +\n\t\t       le16_to_cpu(left_rec->e_leaf_clusters) !=\n\t\t       le32_to_cpu(right_rec->e_cpos));\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t\tright_path);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, subtree_index,\n\t\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t\t      right_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\troot_bh = left_path->p_node[subtree_index].bh;\n\t\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t\t   subtree_index);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = subtree_index + 1;\n\t\t     i < path_num_items(right_path); i++) {\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   right_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   left_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tBUG_ON(index == le16_to_cpu(el->l_next_free_rec) - 1);\n\t\tright_rec = &el->l_recs[index + 1];\n\t}\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, left_path,\n\t\t\t\t\t   path_num_items(left_path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tle16_add_cpu(&left_rec->e_leaf_clusters, -split_clusters);\n\n\tle32_add_cpu(&right_rec->e_cpos, -split_clusters);\n\tle64_add_cpu(&right_rec->e_blkno,\n\t\t     -ocfs2_clusters_to_blocks(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t       split_clusters));\n\tle16_add_cpu(&right_rec->e_leaf_clusters, split_clusters);\n\n\tocfs2_cleanup_merge(el, index);\n\n\tocfs2_journal_dirty(handle, bh);\n\tif (right_path) {\n\t\tocfs2_journal_dirty(handle, path_leaf_bh(right_path));\n\t\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t\t   subtree_index);\n\t}\nout:\n\tif (right_path)\n\t\tocfs2_free_path(right_path);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_merge_rec_right(struct ocfs2_path *left_path,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_extent_rec *split_rec,\n\t\t\t\t int index)\n{\n\tint ret, next_free, i;\n\tunsigned int split_clusters = le16_to_cpu(split_rec->e_leaf_clusters);\n\tstruct ocfs2_extent_rec *left_rec;\n\tstruct ocfs2_extent_rec *right_rec;\n\tstruct ocfs2_extent_list *right_el;\n\tstruct ocfs2_path *right_path = NULL;\n\tint subtree_index = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(left_path);\n\tstruct buffer_head *bh = path_leaf_bh(left_path);\n\tstruct buffer_head *root_bh = NULL;\n\n\tBUG_ON(index >= le16_to_cpu(el->l_next_free_rec));\n\tleft_rec = &el->l_recs[index];\n\n\tif (index == le16_to_cpu(el->l_next_free_rec) - 1 &&\n\t    le16_to_cpu(el->l_next_free_rec) == le16_to_cpu(el->l_count)) {\n\t\t/* we meet with a cross extent block merge. */\n\t\tret = ocfs2_get_right_path(et, left_path, &right_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tright_el = path_leaf_el(right_path);\n\t\tnext_free = le16_to_cpu(right_el->l_next_free_rec);\n\t\tBUG_ON(next_free <= 0);\n\t\tright_rec = &right_el->l_recs[0];\n\t\tif (ocfs2_is_empty_extent(right_rec)) {\n\t\t\tBUG_ON(next_free <= 1);\n\t\t\tright_rec = &right_el->l_recs[1];\n\t\t}\n\n\t\tBUG_ON(le32_to_cpu(left_rec->e_cpos) +\n\t\t       le16_to_cpu(left_rec->e_leaf_clusters) !=\n\t\t       le32_to_cpu(right_rec->e_cpos));\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t\tright_path);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, subtree_index,\n\t\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t\t      right_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\troot_bh = left_path->p_node[subtree_index].bh;\n\t\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t\t   subtree_index);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = subtree_index + 1;\n\t\t     i < path_num_items(right_path); i++) {\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   right_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   left_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tBUG_ON(index == le16_to_cpu(el->l_next_free_rec) - 1);\n\t\tright_rec = &el->l_recs[index + 1];\n\t}\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, left_path,\n\t\t\t\t\t   path_num_items(left_path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tle16_add_cpu(&left_rec->e_leaf_clusters, -split_clusters);\n\n\tle32_add_cpu(&right_rec->e_cpos, -split_clusters);\n\tle64_add_cpu(&right_rec->e_blkno,\n\t\t     -ocfs2_clusters_to_blocks(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t       split_clusters));\n\tle16_add_cpu(&right_rec->e_leaf_clusters, split_clusters);\n\n\tocfs2_cleanup_merge(el, index);\n\n\tocfs2_journal_dirty(handle, bh);\n\tif (right_path) {\n\t\tocfs2_journal_dirty(handle, path_leaf_bh(right_path));\n\t\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t\t   subtree_index);\n\t}\nout:\n\tif (right_path)\n\t\tocfs2_free_path(right_path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_merge_rec_left",
          "args": [
            "path",
            "handle",
            "et",
            "split_rec",
            "dealloc",
            "split_index"
          ],
          "line": 3756
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_merge_rec_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "3514-3653",
          "snippet": "static int ocfs2_merge_rec_left(struct ocfs2_path *right_path,\n\t\t\t\thandle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_extent_rec *split_rec,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\tint index)\n{\n\tint ret, i, subtree_index = 0, has_empty_extent = 0;\n\tunsigned int split_clusters = le16_to_cpu(split_rec->e_leaf_clusters);\n\tstruct ocfs2_extent_rec *left_rec;\n\tstruct ocfs2_extent_rec *right_rec;\n\tstruct ocfs2_extent_list *el = path_leaf_el(right_path);\n\tstruct buffer_head *bh = path_leaf_bh(right_path);\n\tstruct buffer_head *root_bh = NULL;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *left_el;\n\n\tBUG_ON(index < 0);\n\n\tright_rec = &el->l_recs[index];\n\tif (index == 0) {\n\t\t/* we meet with a cross extent block merge. */\n\t\tret = ocfs2_get_left_path(et, right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tleft_el = path_leaf_el(left_path);\n\t\tBUG_ON(le16_to_cpu(left_el->l_next_free_rec) !=\n\t\t       le16_to_cpu(left_el->l_count));\n\n\t\tleft_rec = &left_el->l_recs[\n\t\t\t\tle16_to_cpu(left_el->l_next_free_rec) - 1];\n\t\tBUG_ON(le32_to_cpu(left_rec->e_cpos) +\n\t\t       le16_to_cpu(left_rec->e_leaf_clusters) !=\n\t\t       le32_to_cpu(split_rec->e_cpos));\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t\tright_path);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, subtree_index,\n\t\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t\t      left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\troot_bh = left_path->p_node[subtree_index].bh;\n\t\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t\t   subtree_index);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = subtree_index + 1;\n\t\t     i < path_num_items(right_path); i++) {\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   right_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   left_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tleft_rec = &el->l_recs[index - 1];\n\t\tif (ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\t\thas_empty_extent = 1;\n\t}\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t   path_num_items(right_path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (has_empty_extent && index == 1) {\n\t\t/*\n\t\t * The easy case - we can just plop the record right in.\n\t\t */\n\t\t*left_rec = *split_rec;\n\n\t\thas_empty_extent = 0;\n\t} else\n\t\tle16_add_cpu(&left_rec->e_leaf_clusters, split_clusters);\n\n\tle32_add_cpu(&right_rec->e_cpos, split_clusters);\n\tle64_add_cpu(&right_rec->e_blkno,\n\t\t     ocfs2_clusters_to_blocks(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t      split_clusters));\n\tle16_add_cpu(&right_rec->e_leaf_clusters, -split_clusters);\n\n\tocfs2_cleanup_merge(el, index);\n\n\tocfs2_journal_dirty(handle, bh);\n\tif (left_path) {\n\t\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\n\t\t/*\n\t\t * In the situation that the right_rec is empty and the extent\n\t\t * block is empty also,  ocfs2_complete_edge_insert can't handle\n\t\t * it and we need to delete the right extent block.\n\t\t */\n\t\tif (le16_to_cpu(right_rec->e_leaf_clusters) == 0 &&\n\t\t    le16_to_cpu(el->l_next_free_rec) == 1) {\n\n\t\t\tret = ocfs2_remove_rightmost_path(handle, et,\n\t\t\t\t\t\t\t  right_path,\n\t\t\t\t\t\t\t  dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Now the rightmost extent block has been deleted.\n\t\t\t * So we use the new rightmost path.\n\t\t\t */\n\t\t\tocfs2_mv_path(right_path, left_path);\n\t\t\tleft_path = NULL;\n\t\t} else\n\t\t\tocfs2_complete_edge_insert(handle, left_path,\n\t\t\t\t\t\t   right_path, subtree_index);\n\t}\nout:\n\tif (left_path)\n\t\tocfs2_free_path(left_path);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_merge_rec_left(struct ocfs2_path *right_path,\n\t\t\t\thandle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_extent_rec *split_rec,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\tint index)\n{\n\tint ret, i, subtree_index = 0, has_empty_extent = 0;\n\tunsigned int split_clusters = le16_to_cpu(split_rec->e_leaf_clusters);\n\tstruct ocfs2_extent_rec *left_rec;\n\tstruct ocfs2_extent_rec *right_rec;\n\tstruct ocfs2_extent_list *el = path_leaf_el(right_path);\n\tstruct buffer_head *bh = path_leaf_bh(right_path);\n\tstruct buffer_head *root_bh = NULL;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *left_el;\n\n\tBUG_ON(index < 0);\n\n\tright_rec = &el->l_recs[index];\n\tif (index == 0) {\n\t\t/* we meet with a cross extent block merge. */\n\t\tret = ocfs2_get_left_path(et, right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tleft_el = path_leaf_el(left_path);\n\t\tBUG_ON(le16_to_cpu(left_el->l_next_free_rec) !=\n\t\t       le16_to_cpu(left_el->l_count));\n\n\t\tleft_rec = &left_el->l_recs[\n\t\t\t\tle16_to_cpu(left_el->l_next_free_rec) - 1];\n\t\tBUG_ON(le32_to_cpu(left_rec->e_cpos) +\n\t\t       le16_to_cpu(left_rec->e_leaf_clusters) !=\n\t\t       le32_to_cpu(split_rec->e_cpos));\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t\tright_path);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, subtree_index,\n\t\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t\t      left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\troot_bh = left_path->p_node[subtree_index].bh;\n\t\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t\t   subtree_index);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = subtree_index + 1;\n\t\t     i < path_num_items(right_path); i++) {\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   right_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   left_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tleft_rec = &el->l_recs[index - 1];\n\t\tif (ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\t\thas_empty_extent = 1;\n\t}\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t   path_num_items(right_path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (has_empty_extent && index == 1) {\n\t\t/*\n\t\t * The easy case - we can just plop the record right in.\n\t\t */\n\t\t*left_rec = *split_rec;\n\n\t\thas_empty_extent = 0;\n\t} else\n\t\tle16_add_cpu(&left_rec->e_leaf_clusters, split_clusters);\n\n\tle32_add_cpu(&right_rec->e_cpos, split_clusters);\n\tle64_add_cpu(&right_rec->e_blkno,\n\t\t     ocfs2_clusters_to_blocks(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t      split_clusters));\n\tle16_add_cpu(&right_rec->e_leaf_clusters, -split_clusters);\n\n\tocfs2_cleanup_merge(el, index);\n\n\tocfs2_journal_dirty(handle, bh);\n\tif (left_path) {\n\t\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\n\t\t/*\n\t\t * In the situation that the right_rec is empty and the extent\n\t\t * block is empty also,  ocfs2_complete_edge_insert can't handle\n\t\t * it and we need to delete the right extent block.\n\t\t */\n\t\tif (le16_to_cpu(right_rec->e_leaf_clusters) == 0 &&\n\t\t    le16_to_cpu(el->l_next_free_rec) == 1) {\n\n\t\t\tret = ocfs2_remove_rightmost_path(handle, et,\n\t\t\t\t\t\t\t  right_path,\n\t\t\t\t\t\t\t  dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Now the rightmost extent block has been deleted.\n\t\t\t * So we use the new rightmost path.\n\t\t\t */\n\t\t\tocfs2_mv_path(right_path, left_path);\n\t\t\tleft_path = NULL;\n\t\t} else\n\t\t\tocfs2_complete_edge_insert(handle, left_path,\n\t\t\t\t\t\t   right_path, subtree_index);\n\t}\nout:\n\tif (left_path)\n\t\tocfs2_free_path(left_path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ocfs2_is_empty_extent(&el->l_recs[0])"
          ],
          "line": 3716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&el->l_recs[0]"
          ],
          "line": 3716
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "266-269",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ctxt->c_split_covers_rec"
          ],
          "line": 3690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ctxt->c_contig_type == CONTIG_NONE"
          ],
          "line": 3667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 3664
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_try_to_merge_extent(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_path *path,\n\t\t\t\t     int split_index,\n\t\t\t\t     struct ocfs2_extent_rec *split_rec,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t     struct ocfs2_merge_ctxt *ctxt)\n{\n\tint ret = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[split_index];\n\n\tBUG_ON(ctxt->c_contig_type == CONTIG_NONE);\n\n\tif (ctxt->c_split_covers_rec && ctxt->c_has_empty_extent) {\n\t\t/*\n\t\t * The merge code will need to create an empty\n\t\t * extent to take the place of the newly\n\t\t * emptied slot. Remove any pre-existing empty\n\t\t * extents - having more than one in a leaf is\n\t\t * illegal.\n\t\t */\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tsplit_index--;\n\t\trec = &el->l_recs[split_index];\n\t}\n\n\tif (ctxt->c_contig_type == CONTIG_LEFTRIGHT) {\n\t\t/*\n\t\t * Left-right contig implies this.\n\t\t */\n\t\tBUG_ON(!ctxt->c_split_covers_rec);\n\n\t\t/*\n\t\t * Since the leftright insert always covers the entire\n\t\t * extent, this call will delete the insert record\n\t\t * entirely, resulting in an empty extent record added to\n\t\t * the extent block.\n\t\t *\n\t\t * Since the adding of an empty extent shifts\n\t\t * everything back to the right, there's no need to\n\t\t * update split_index here.\n\t\t *\n\t\t * When the split_index is zero, we need to merge it to the\n\t\t * prevoius extent block. It is more efficient and easier\n\t\t * if we do merge_right first and merge_left later.\n\t\t */\n\t\tret = ocfs2_merge_rec_right(path, handle, et, split_rec,\n\t\t\t\t\t    split_index);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * We can only get this from logic error above.\n\t\t */\n\t\tBUG_ON(!ocfs2_is_empty_extent(&el->l_recs[0]));\n\n\t\t/* The merge left us with an empty extent, remove it. */\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\trec = &el->l_recs[split_index];\n\n\t\t/*\n\t\t * Note that we don't pass split_rec here on purpose -\n\t\t * we've merged it into the rec already.\n\t\t */\n\t\tret = ocfs2_merge_rec_left(path, handle, et, rec,\n\t\t\t\t\t   dealloc, split_index);\n\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\t/*\n\t\t * Error from this last rotate is not critical, so\n\t\t * print but don't bubble it up.\n\t\t */\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tret = 0;\n\t} else {\n\t\t/*\n\t\t * Merge a record to the left or right.\n\t\t *\n\t\t * 'contig_type' is relative to the existing record,\n\t\t * so for example, if we're \"right contig\", it's to\n\t\t * the record on the left (hence the left merge).\n\t\t */\n\t\tif (ctxt->c_contig_type == CONTIG_RIGHT) {\n\t\t\tret = ocfs2_merge_rec_left(path, handle, et,\n\t\t\t\t\t\t   split_rec, dealloc,\n\t\t\t\t\t\t   split_index);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tret = ocfs2_merge_rec_right(path, handle,\n\t\t\t\t\t\t    et, split_rec,\n\t\t\t\t\t\t    split_index);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (ctxt->c_split_covers_rec) {\n\t\t\t/*\n\t\t\t * The merge may have left an empty extent in\n\t\t\t * our leaf. Try to rotate it away.\n\t\t\t */\n\t\t\tret = ocfs2_rotate_tree_left(handle, et, path,\n\t\t\t\t\t\t     dealloc);\n\t\t\tif (ret)\n\t\t\t\tmlog_errno(ret);\n\t\t\tret = 0;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_merge_rec_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "3514-3653",
    "snippet": "static int ocfs2_merge_rec_left(struct ocfs2_path *right_path,\n\t\t\t\thandle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_extent_rec *split_rec,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\tint index)\n{\n\tint ret, i, subtree_index = 0, has_empty_extent = 0;\n\tunsigned int split_clusters = le16_to_cpu(split_rec->e_leaf_clusters);\n\tstruct ocfs2_extent_rec *left_rec;\n\tstruct ocfs2_extent_rec *right_rec;\n\tstruct ocfs2_extent_list *el = path_leaf_el(right_path);\n\tstruct buffer_head *bh = path_leaf_bh(right_path);\n\tstruct buffer_head *root_bh = NULL;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *left_el;\n\n\tBUG_ON(index < 0);\n\n\tright_rec = &el->l_recs[index];\n\tif (index == 0) {\n\t\t/* we meet with a cross extent block merge. */\n\t\tret = ocfs2_get_left_path(et, right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tleft_el = path_leaf_el(left_path);\n\t\tBUG_ON(le16_to_cpu(left_el->l_next_free_rec) !=\n\t\t       le16_to_cpu(left_el->l_count));\n\n\t\tleft_rec = &left_el->l_recs[\n\t\t\t\tle16_to_cpu(left_el->l_next_free_rec) - 1];\n\t\tBUG_ON(le32_to_cpu(left_rec->e_cpos) +\n\t\t       le16_to_cpu(left_rec->e_leaf_clusters) !=\n\t\t       le32_to_cpu(split_rec->e_cpos));\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t\tright_path);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, subtree_index,\n\t\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t\t      left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\troot_bh = left_path->p_node[subtree_index].bh;\n\t\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t\t   subtree_index);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = subtree_index + 1;\n\t\t     i < path_num_items(right_path); i++) {\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   right_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   left_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tleft_rec = &el->l_recs[index - 1];\n\t\tif (ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\t\thas_empty_extent = 1;\n\t}\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t   path_num_items(right_path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (has_empty_extent && index == 1) {\n\t\t/*\n\t\t * The easy case - we can just plop the record right in.\n\t\t */\n\t\t*left_rec = *split_rec;\n\n\t\thas_empty_extent = 0;\n\t} else\n\t\tle16_add_cpu(&left_rec->e_leaf_clusters, split_clusters);\n\n\tle32_add_cpu(&right_rec->e_cpos, split_clusters);\n\tle64_add_cpu(&right_rec->e_blkno,\n\t\t     ocfs2_clusters_to_blocks(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t      split_clusters));\n\tle16_add_cpu(&right_rec->e_leaf_clusters, -split_clusters);\n\n\tocfs2_cleanup_merge(el, index);\n\n\tocfs2_journal_dirty(handle, bh);\n\tif (left_path) {\n\t\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\n\t\t/*\n\t\t * In the situation that the right_rec is empty and the extent\n\t\t * block is empty also,  ocfs2_complete_edge_insert can't handle\n\t\t * it and we need to delete the right extent block.\n\t\t */\n\t\tif (le16_to_cpu(right_rec->e_leaf_clusters) == 0 &&\n\t\t    le16_to_cpu(el->l_next_free_rec) == 1) {\n\n\t\t\tret = ocfs2_remove_rightmost_path(handle, et,\n\t\t\t\t\t\t\t  right_path,\n\t\t\t\t\t\t\t  dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Now the rightmost extent block has been deleted.\n\t\t\t * So we use the new rightmost path.\n\t\t\t */\n\t\t\tocfs2_mv_path(right_path, left_path);\n\t\t\tleft_path = NULL;\n\t\t} else\n\t\t\tocfs2_complete_edge_insert(handle, left_path,\n\t\t\t\t\t\t   right_path, subtree_index);\n\t}\nout:\n\tif (left_path)\n\t\tocfs2_free_path(left_path);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "left_path"
          ],
          "line": 3651
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "609-615",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_complete_edge_insert",
          "args": [
            "handle",
            "left_path",
            "right_path",
            "subtree_index"
          ],
          "line": 3646
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_complete_edge_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2030-2099",
          "snippet": "static void ocfs2_complete_edge_insert(handle_t *handle,\n\t\t\t\t       struct ocfs2_path *left_path,\n\t\t\t\t       struct ocfs2_path *right_path,\n\t\t\t\t       int subtree_index)\n{\n\tint i, idx;\n\tstruct ocfs2_extent_list *el, *left_el, *right_el;\n\tstruct ocfs2_extent_rec *left_rec, *right_rec;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\n\t/*\n\t * Update the counts and position values within all the\n\t * interior nodes to reflect the leaf rotation we just did.\n\t *\n\t * The root node is handled below the loop.\n\t *\n\t * We begin the loop with right_el and left_el pointing to the\n\t * leaf lists and work our way up.\n\t *\n\t * NOTE: within this loop, left_el and right_el always refer\n\t * to the *child* lists.\n\t */\n\tleft_el = path_leaf_el(left_path);\n\tright_el = path_leaf_el(right_path);\n\tfor(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {\n\t\ttrace_ocfs2_complete_edge_insert(i);\n\n\t\t/*\n\t\t * One nice property of knowing that all of these\n\t\t * nodes are below the root is that we only deal with\n\t\t * the leftmost right node record and the rightmost\n\t\t * left node record.\n\t\t */\n\t\tel = left_path->p_node[i].el;\n\t\tidx = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\t\tleft_rec = &el->l_recs[idx];\n\n\t\tel = right_path->p_node[i].el;\n\t\tright_rec = &el->l_recs[0];\n\n\t\tocfs2_adjust_adjacent_records(left_rec, left_el, right_rec,\n\t\t\t\t\t      right_el);\n\n\t\tocfs2_journal_dirty(handle, left_path->p_node[i].bh);\n\t\tocfs2_journal_dirty(handle, right_path->p_node[i].bh);\n\n\t\t/*\n\t\t * Setup our list pointers now so that the current\n\t\t * parents become children in the next iteration.\n\t\t */\n\t\tleft_el = left_path->p_node[i].el;\n\t\tright_el = right_path->p_node[i].el;\n\t}\n\n\t/*\n\t * At the root node, adjust the two adjacent records which\n\t * begin our path to the leaves.\n\t */\n\n\tel = left_path->p_node[subtree_index].el;\n\tleft_el = left_path->p_node[subtree_index + 1].el;\n\tright_el = right_path->p_node[subtree_index + 1].el;\n\n\tocfs2_adjust_root_records(el, left_el, right_el,\n\t\t\t\t  left_path->p_node[subtree_index + 1].bh->b_blocknr);\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\n\tocfs2_journal_dirty(handle, root_bh);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_complete_edge_insert(handle_t *handle,\n\t\t\t\t       struct ocfs2_path *left_path,\n\t\t\t\t       struct ocfs2_path *right_path,\n\t\t\t\t       int subtree_index)\n{\n\tint i, idx;\n\tstruct ocfs2_extent_list *el, *left_el, *right_el;\n\tstruct ocfs2_extent_rec *left_rec, *right_rec;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\n\t/*\n\t * Update the counts and position values within all the\n\t * interior nodes to reflect the leaf rotation we just did.\n\t *\n\t * The root node is handled below the loop.\n\t *\n\t * We begin the loop with right_el and left_el pointing to the\n\t * leaf lists and work our way up.\n\t *\n\t * NOTE: within this loop, left_el and right_el always refer\n\t * to the *child* lists.\n\t */\n\tleft_el = path_leaf_el(left_path);\n\tright_el = path_leaf_el(right_path);\n\tfor(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {\n\t\ttrace_ocfs2_complete_edge_insert(i);\n\n\t\t/*\n\t\t * One nice property of knowing that all of these\n\t\t * nodes are below the root is that we only deal with\n\t\t * the leftmost right node record and the rightmost\n\t\t * left node record.\n\t\t */\n\t\tel = left_path->p_node[i].el;\n\t\tidx = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\t\tleft_rec = &el->l_recs[idx];\n\n\t\tel = right_path->p_node[i].el;\n\t\tright_rec = &el->l_recs[0];\n\n\t\tocfs2_adjust_adjacent_records(left_rec, left_el, right_rec,\n\t\t\t\t\t      right_el);\n\n\t\tocfs2_journal_dirty(handle, left_path->p_node[i].bh);\n\t\tocfs2_journal_dirty(handle, right_path->p_node[i].bh);\n\n\t\t/*\n\t\t * Setup our list pointers now so that the current\n\t\t * parents become children in the next iteration.\n\t\t */\n\t\tleft_el = left_path->p_node[i].el;\n\t\tright_el = right_path->p_node[i].el;\n\t}\n\n\t/*\n\t * At the root node, adjust the two adjacent records which\n\t * begin our path to the leaves.\n\t */\n\n\tel = left_path->p_node[subtree_index].el;\n\tleft_el = left_path->p_node[subtree_index + 1].el;\n\tright_el = right_path->p_node[subtree_index + 1].el;\n\n\tocfs2_adjust_root_records(el, left_el, right_el,\n\t\t\t\t  left_path->p_node[subtree_index + 1].bh->b_blocknr);\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\n\tocfs2_journal_dirty(handle, root_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mv_path",
          "args": [
            "right_path",
            "left_path"
          ],
          "line": 3643
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mv_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "647-663",
          "snippet": "static void ocfs2_mv_path(struct ocfs2_path *dest, struct ocfs2_path *src)\n{\n\tint i;\n\n\tBUG_ON(path_root_bh(dest) != path_root_bh(src));\n\tBUG_ON(path_root_access(dest) != path_root_access(src));\n\n\tfor(i = 1; i < OCFS2_MAX_PATH_DEPTH; i++) {\n\t\tbrelse(dest->p_node[i].bh);\n\n\t\tdest->p_node[i].bh = src->p_node[i].bh;\n\t\tdest->p_node[i].el = src->p_node[i].el;\n\n\t\tsrc->p_node[i].bh = NULL;\n\t\tsrc->p_node[i].el = NULL;\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_mv_path(struct ocfs2_path *dest, struct ocfs2_path *src)\n{\n\tint i;\n\n\tBUG_ON(path_root_bh(dest) != path_root_bh(src));\n\tBUG_ON(path_root_access(dest) != path_root_access(src));\n\n\tfor(i = 1; i < OCFS2_MAX_PATH_DEPTH; i++) {\n\t\tbrelse(dest->p_node[i].bh);\n\n\t\tdest->p_node[i].bh = src->p_node[i].bh;\n\t\tdest->p_node[i].el = src->p_node[i].el;\n\n\t\tsrc->p_node[i].bh = NULL;\n\t\tsrc->p_node[i].el = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_rightmost_path",
          "args": [
            "handle",
            "et",
            "right_path",
            "dealloc"
          ],
          "line": 3632
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_rightmost_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "3031-3131",
          "snippet": "static int ocfs2_remove_rightmost_path(handle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_path *path,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, subtree_index;\n\tu32 cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\n\tret = ocfs2_et_sanity_check(et);\n\tif (ret)\n\t\tgoto out;\n\t/*\n\t * There's two ways we handle this depending on\n\t * whether path is the only existing one.\n\t */\n\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t      path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t    path, &cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (cpos) {\n\t\t/*\n\t\t * We have a path to the left of this one - it needs\n\t\t * an update too.\n\t\t */\n\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\tif (!left_path) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path, path);\n\n\t\tocfs2_unlink_subtree(handle, et, left_path, path,\n\t\t\t\t     subtree_index, dealloc);\n\t\tret = ocfs2_update_edge_lengths(handle, et, subtree_index,\n\t\t\t\t\t\tleft_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\t} else {\n\t\t/*\n\t\t * 'path' is also the leftmost path which\n\t\t * means it must be the only one. This gets\n\t\t * handled differently because we want to\n\t\t * revert the root back to having extents\n\t\t * in-line.\n\t\t */\n\t\tocfs2_unlink_path(handle, et, dealloc, path, 1);\n\n\t\tel = et->et_root_el;\n\t\tel->l_tree_depth = 0;\n\t\tel->l_next_free_rec = 0;\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\n\t\tocfs2_et_set_last_eb_blk(et, 0);\n\t}\n\n\tocfs2_journal_dirty(handle, path_root_bh(path));\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_remove_rightmost_path(handle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_path *path,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, subtree_index;\n\tu32 cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\n\tret = ocfs2_et_sanity_check(et);\n\tif (ret)\n\t\tgoto out;\n\t/*\n\t * There's two ways we handle this depending on\n\t * whether path is the only existing one.\n\t */\n\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t      path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t    path, &cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (cpos) {\n\t\t/*\n\t\t * We have a path to the left of this one - it needs\n\t\t * an update too.\n\t\t */\n\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\tif (!left_path) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path, path);\n\n\t\tocfs2_unlink_subtree(handle, et, left_path, path,\n\t\t\t\t     subtree_index, dealloc);\n\t\tret = ocfs2_update_edge_lengths(handle, et, subtree_index,\n\t\t\t\t\t\tleft_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\t} else {\n\t\t/*\n\t\t * 'path' is also the leftmost path which\n\t\t * means it must be the only one. This gets\n\t\t * handled differently because we want to\n\t\t * revert the root back to having extents\n\t\t * in-line.\n\t\t */\n\t\tocfs2_unlink_path(handle, et, dealloc, path, 1);\n\n\t\tel = et->et_root_el;\n\t\tel->l_tree_depth = 0;\n\t\tel->l_next_free_rec = 0;\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\n\t\tocfs2_et_set_last_eb_blk(et, 0);\n\t}\n\n\tocfs2_journal_dirty(handle, path_root_bh(path));\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 3630
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "path_leaf_bh(left_path)"
          ],
          "line": 3622
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "left_path"
          ],
          "line": 3622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cleanup_merge",
          "args": [
            "el",
            "index"
          ],
          "line": 3618
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cleanup_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "3261-3291",
          "snippet": "static void ocfs2_cleanup_merge(struct ocfs2_extent_list *el,\n\t\t\t\tint index)\n{\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[index];\n\tunsigned int size;\n\n\tif (rec->e_leaf_clusters == 0) {\n\t\t/*\n\t\t * We consumed all of the merged-from record. An empty\n\t\t * extent cannot exist anywhere but the 1st array\n\t\t * position, so move things over if the merged-from\n\t\t * record doesn't occupy that position.\n\t\t *\n\t\t * This creates a new empty extent so the caller\n\t\t * should be smart enough to have removed any existing\n\t\t * ones.\n\t\t */\n\t\tif (index > 0) {\n\t\t\tBUG_ON(ocfs2_is_empty_extent(&el->l_recs[0]));\n\t\t\tsize = index * sizeof(struct ocfs2_extent_rec);\n\t\t\tmemmove(&el->l_recs[1], &el->l_recs[0], size);\n\t\t}\n\n\t\t/*\n\t\t * Always memset - the caller doesn't check whether it\n\t\t * created an empty extent, so there could be junk in\n\t\t * the other fields.\n\t\t */\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic void ocfs2_cleanup_merge(struct ocfs2_extent_list *el,\n\t\t\t\tint index)\n{\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[index];\n\tunsigned int size;\n\n\tif (rec->e_leaf_clusters == 0) {\n\t\t/*\n\t\t * We consumed all of the merged-from record. An empty\n\t\t * extent cannot exist anywhere but the 1st array\n\t\t * position, so move things over if the merged-from\n\t\t * record doesn't occupy that position.\n\t\t *\n\t\t * This creates a new empty extent so the caller\n\t\t * should be smart enough to have removed any existing\n\t\t * ones.\n\t\t */\n\t\tif (index > 0) {\n\t\t\tBUG_ON(ocfs2_is_empty_extent(&el->l_recs[0]));\n\t\t\tsize = index * sizeof(struct ocfs2_extent_rec);\n\t\t\tmemmove(&el->l_recs[1], &el->l_recs[0], size);\n\t\t}\n\n\t\t/*\n\t\t * Always memset - the caller doesn't check whether it\n\t\t * created an empty extent, so there could be junk in\n\t\t * the other fields.\n\t\t */\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&right_rec->e_leaf_clusters",
            "-split_clusters"
          ],
          "line": 3616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_add_cpu",
          "args": [
            "&right_rec->e_blkno",
            "ocfs2_clusters_to_blocks(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t      split_clusters)"
          ],
          "line": 3613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "split_clusters"
          ],
          "line": 3614
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 3614
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&right_rec->e_cpos",
            "split_clusters"
          ],
          "line": 3612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&left_rec->e_leaf_clusters",
            "split_clusters"
          ],
          "line": 3610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_path_bh_journal_access",
          "args": [
            "handle",
            "et->et_ci",
            "right_path",
            "path_num_items(right_path) - 1"
          ],
          "line": 3595
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_path_bh_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "726-741",
          "snippet": "int ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_num_items",
          "args": [
            "right_path"
          ],
          "line": 3596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&el->l_recs[0]"
          ],
          "line": 3591
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "266-269",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_num_items",
          "args": [
            "right_path"
          ],
          "line": 3574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "root_bh != right_path->p_node[subtree_index].bh"
          ],
          "line": 3564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_rotate_transaction",
          "args": [
            "handle",
            "subtree_index",
            "handle->h_buffer_credits",
            "left_path"
          ],
          "line": 3555
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_rotate_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2279-2291",
          "snippet": "static int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,\n\t\t\t\t\t   int op_credits,\n\t\t\t\t\t   struct ocfs2_path *path)\n{\n\tint ret = 0;\n\tint credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;\n\n\tif (handle->h_buffer_credits < credits)\n\t\tret = ocfs2_extend_trans(handle,\n\t\t\t\t\t credits - handle->h_buffer_credits);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,\n\t\t\t\t\t   int op_credits,\n\t\t\t\t\t   struct ocfs2_path *path)\n{\n\tint ret = 0;\n\tint credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;\n\n\tif (handle->h_buffer_credits < credits)\n\t\tret = ocfs2_extend_trans(handle,\n\t\t\t\t\t credits - handle->h_buffer_credits);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_subtree_root",
          "args": [
            "et",
            "left_path",
            "right_path"
          ],
          "line": 3552
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_subtree_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1737-1765",
          "snippet": "int ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le32_to_cpu(left_rec->e_cpos) +\n\t\t       le16_to_cpu(left_rec->e_leaf_clusters) !=\n\t\t       le32_to_cpu(split_rec->e_cpos)"
          ],
          "line": 3548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "split_rec->e_cpos"
          ],
          "line": 3550
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le16_to_cpu(left_el->l_next_free_rec) !=\n\t\t       le16_to_cpu(left_el->l_count)"
          ],
          "line": 3543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "left_path"
          ],
          "line": 3542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_left_path",
          "args": [
            "et",
            "right_path",
            "&left_path"
          ],
          "line": 3536
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_left_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "3461-3502",
          "snippet": "static int ocfs2_get_left_path(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_path *right_path,\n\t\t\t       struct ocfs2_path **ret_left_path)\n{\n\tint ret;\n\tu32 left_cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\n\t*ret_left_path = NULL;\n\n\t/* This function shouldn't be called for non-trees. */\n\tBUG_ON(right_path->p_tree_depth == 0);\n\n\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t    right_path, &left_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* This function shouldn't be called for the leftmost leaf. */\n\tBUG_ON(left_cpos == 0);\n\n\tleft_path = ocfs2_new_path_from_path(right_path);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, left_path, left_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_left_path = left_path;\nout:\n\tif (ret)\n\t\tocfs2_free_path(left_path);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_get_left_path(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_path *right_path,\n\t\t\t       struct ocfs2_path **ret_left_path)\n{\n\tint ret;\n\tu32 left_cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\n\t*ret_left_path = NULL;\n\n\t/* This function shouldn't be called for non-trees. */\n\tBUG_ON(right_path->p_tree_depth == 0);\n\n\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t    right_path, &left_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* This function shouldn't be called for the leftmost leaf. */\n\tBUG_ON(left_cpos == 0);\n\n\tleft_path = ocfs2_new_path_from_path(right_path);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, left_path, left_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_left_path = left_path;\nout:\n\tif (ret)\n\t\tocfs2_free_path(left_path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "index < 0"
          ],
          "line": 3531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "right_path"
          ],
          "line": 3526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "right_path"
          ],
          "line": 3525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_merge_rec_left(struct ocfs2_path *right_path,\n\t\t\t\thandle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_extent_rec *split_rec,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\tint index)\n{\n\tint ret, i, subtree_index = 0, has_empty_extent = 0;\n\tunsigned int split_clusters = le16_to_cpu(split_rec->e_leaf_clusters);\n\tstruct ocfs2_extent_rec *left_rec;\n\tstruct ocfs2_extent_rec *right_rec;\n\tstruct ocfs2_extent_list *el = path_leaf_el(right_path);\n\tstruct buffer_head *bh = path_leaf_bh(right_path);\n\tstruct buffer_head *root_bh = NULL;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *left_el;\n\n\tBUG_ON(index < 0);\n\n\tright_rec = &el->l_recs[index];\n\tif (index == 0) {\n\t\t/* we meet with a cross extent block merge. */\n\t\tret = ocfs2_get_left_path(et, right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tleft_el = path_leaf_el(left_path);\n\t\tBUG_ON(le16_to_cpu(left_el->l_next_free_rec) !=\n\t\t       le16_to_cpu(left_el->l_count));\n\n\t\tleft_rec = &left_el->l_recs[\n\t\t\t\tle16_to_cpu(left_el->l_next_free_rec) - 1];\n\t\tBUG_ON(le32_to_cpu(left_rec->e_cpos) +\n\t\t       le16_to_cpu(left_rec->e_leaf_clusters) !=\n\t\t       le32_to_cpu(split_rec->e_cpos));\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t\tright_path);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, subtree_index,\n\t\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t\t      left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\troot_bh = left_path->p_node[subtree_index].bh;\n\t\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t\t   subtree_index);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = subtree_index + 1;\n\t\t     i < path_num_items(right_path); i++) {\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   right_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   left_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tleft_rec = &el->l_recs[index - 1];\n\t\tif (ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\t\thas_empty_extent = 1;\n\t}\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t   path_num_items(right_path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (has_empty_extent && index == 1) {\n\t\t/*\n\t\t * The easy case - we can just plop the record right in.\n\t\t */\n\t\t*left_rec = *split_rec;\n\n\t\thas_empty_extent = 0;\n\t} else\n\t\tle16_add_cpu(&left_rec->e_leaf_clusters, split_clusters);\n\n\tle32_add_cpu(&right_rec->e_cpos, split_clusters);\n\tle64_add_cpu(&right_rec->e_blkno,\n\t\t     ocfs2_clusters_to_blocks(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t      split_clusters));\n\tle16_add_cpu(&right_rec->e_leaf_clusters, -split_clusters);\n\n\tocfs2_cleanup_merge(el, index);\n\n\tocfs2_journal_dirty(handle, bh);\n\tif (left_path) {\n\t\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\n\t\t/*\n\t\t * In the situation that the right_rec is empty and the extent\n\t\t * block is empty also,  ocfs2_complete_edge_insert can't handle\n\t\t * it and we need to delete the right extent block.\n\t\t */\n\t\tif (le16_to_cpu(right_rec->e_leaf_clusters) == 0 &&\n\t\t    le16_to_cpu(el->l_next_free_rec) == 1) {\n\n\t\t\tret = ocfs2_remove_rightmost_path(handle, et,\n\t\t\t\t\t\t\t  right_path,\n\t\t\t\t\t\t\t  dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Now the rightmost extent block has been deleted.\n\t\t\t * So we use the new rightmost path.\n\t\t\t */\n\t\t\tocfs2_mv_path(right_path, left_path);\n\t\t\tleft_path = NULL;\n\t\t} else\n\t\t\tocfs2_complete_edge_insert(handle, left_path,\n\t\t\t\t\t\t   right_path, subtree_index);\n\t}\nout:\n\tif (left_path)\n\t\tocfs2_free_path(left_path);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_get_left_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "3461-3502",
    "snippet": "static int ocfs2_get_left_path(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_path *right_path,\n\t\t\t       struct ocfs2_path **ret_left_path)\n{\n\tint ret;\n\tu32 left_cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\n\t*ret_left_path = NULL;\n\n\t/* This function shouldn't be called for non-trees. */\n\tBUG_ON(right_path->p_tree_depth == 0);\n\n\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t    right_path, &left_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* This function shouldn't be called for the leftmost leaf. */\n\tBUG_ON(left_cpos == 0);\n\n\tleft_path = ocfs2_new_path_from_path(right_path);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, left_path, left_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_left_path = left_path;\nout:\n\tif (ret)\n\t\tocfs2_free_path(left_path);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "left_path"
          ],
          "line": 3500
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "609-615",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "et->et_ci",
            "left_path",
            "left_cpos"
          ],
          "line": 3491
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1885-1894",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_path",
          "args": [
            "right_path"
          ],
          "line": 3484
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "707-711",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "left_cpos == 0"
          ],
          "line": 3482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_cpos_for_left_leaf",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "right_path",
            "&left_cpos"
          ],
          "line": 3474
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_cpos_for_left_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2205-2272",
          "snippet": "int ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 3474
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "right_path->p_tree_depth == 0"
          ],
          "line": 3472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_get_left_path(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_path *right_path,\n\t\t\t       struct ocfs2_path **ret_left_path)\n{\n\tint ret;\n\tu32 left_cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\n\t*ret_left_path = NULL;\n\n\t/* This function shouldn't be called for non-trees. */\n\tBUG_ON(right_path->p_tree_depth == 0);\n\n\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t    right_path, &left_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* This function shouldn't be called for the leftmost leaf. */\n\tBUG_ON(left_cpos == 0);\n\n\tleft_path = ocfs2_new_path_from_path(right_path);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, left_path, left_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_left_path = left_path;\nout:\n\tif (ret)\n\t\tocfs2_free_path(left_path);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_merge_rec_right",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "3347-3459",
    "snippet": "static int ocfs2_merge_rec_right(struct ocfs2_path *left_path,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_extent_rec *split_rec,\n\t\t\t\t int index)\n{\n\tint ret, next_free, i;\n\tunsigned int split_clusters = le16_to_cpu(split_rec->e_leaf_clusters);\n\tstruct ocfs2_extent_rec *left_rec;\n\tstruct ocfs2_extent_rec *right_rec;\n\tstruct ocfs2_extent_list *right_el;\n\tstruct ocfs2_path *right_path = NULL;\n\tint subtree_index = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(left_path);\n\tstruct buffer_head *bh = path_leaf_bh(left_path);\n\tstruct buffer_head *root_bh = NULL;\n\n\tBUG_ON(index >= le16_to_cpu(el->l_next_free_rec));\n\tleft_rec = &el->l_recs[index];\n\n\tif (index == le16_to_cpu(el->l_next_free_rec) - 1 &&\n\t    le16_to_cpu(el->l_next_free_rec) == le16_to_cpu(el->l_count)) {\n\t\t/* we meet with a cross extent block merge. */\n\t\tret = ocfs2_get_right_path(et, left_path, &right_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tright_el = path_leaf_el(right_path);\n\t\tnext_free = le16_to_cpu(right_el->l_next_free_rec);\n\t\tBUG_ON(next_free <= 0);\n\t\tright_rec = &right_el->l_recs[0];\n\t\tif (ocfs2_is_empty_extent(right_rec)) {\n\t\t\tBUG_ON(next_free <= 1);\n\t\t\tright_rec = &right_el->l_recs[1];\n\t\t}\n\n\t\tBUG_ON(le32_to_cpu(left_rec->e_cpos) +\n\t\t       le16_to_cpu(left_rec->e_leaf_clusters) !=\n\t\t       le32_to_cpu(right_rec->e_cpos));\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t\tright_path);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, subtree_index,\n\t\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t\t      right_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\troot_bh = left_path->p_node[subtree_index].bh;\n\t\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t\t   subtree_index);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = subtree_index + 1;\n\t\t     i < path_num_items(right_path); i++) {\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   right_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   left_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tBUG_ON(index == le16_to_cpu(el->l_next_free_rec) - 1);\n\t\tright_rec = &el->l_recs[index + 1];\n\t}\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, left_path,\n\t\t\t\t\t   path_num_items(left_path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tle16_add_cpu(&left_rec->e_leaf_clusters, -split_clusters);\n\n\tle32_add_cpu(&right_rec->e_cpos, -split_clusters);\n\tle64_add_cpu(&right_rec->e_blkno,\n\t\t     -ocfs2_clusters_to_blocks(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t       split_clusters));\n\tle16_add_cpu(&right_rec->e_leaf_clusters, split_clusters);\n\n\tocfs2_cleanup_merge(el, index);\n\n\tocfs2_journal_dirty(handle, bh);\n\tif (right_path) {\n\t\tocfs2_journal_dirty(handle, path_leaf_bh(right_path));\n\t\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t\t   subtree_index);\n\t}\nout:\n\tif (right_path)\n\t\tocfs2_free_path(right_path);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "right_path"
          ],
          "line": 3457
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "609-615",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_complete_edge_insert",
          "args": [
            "handle",
            "left_path",
            "right_path",
            "subtree_index"
          ],
          "line": 3452
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_complete_edge_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2030-2099",
          "snippet": "static void ocfs2_complete_edge_insert(handle_t *handle,\n\t\t\t\t       struct ocfs2_path *left_path,\n\t\t\t\t       struct ocfs2_path *right_path,\n\t\t\t\t       int subtree_index)\n{\n\tint i, idx;\n\tstruct ocfs2_extent_list *el, *left_el, *right_el;\n\tstruct ocfs2_extent_rec *left_rec, *right_rec;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\n\t/*\n\t * Update the counts and position values within all the\n\t * interior nodes to reflect the leaf rotation we just did.\n\t *\n\t * The root node is handled below the loop.\n\t *\n\t * We begin the loop with right_el and left_el pointing to the\n\t * leaf lists and work our way up.\n\t *\n\t * NOTE: within this loop, left_el and right_el always refer\n\t * to the *child* lists.\n\t */\n\tleft_el = path_leaf_el(left_path);\n\tright_el = path_leaf_el(right_path);\n\tfor(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {\n\t\ttrace_ocfs2_complete_edge_insert(i);\n\n\t\t/*\n\t\t * One nice property of knowing that all of these\n\t\t * nodes are below the root is that we only deal with\n\t\t * the leftmost right node record and the rightmost\n\t\t * left node record.\n\t\t */\n\t\tel = left_path->p_node[i].el;\n\t\tidx = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\t\tleft_rec = &el->l_recs[idx];\n\n\t\tel = right_path->p_node[i].el;\n\t\tright_rec = &el->l_recs[0];\n\n\t\tocfs2_adjust_adjacent_records(left_rec, left_el, right_rec,\n\t\t\t\t\t      right_el);\n\n\t\tocfs2_journal_dirty(handle, left_path->p_node[i].bh);\n\t\tocfs2_journal_dirty(handle, right_path->p_node[i].bh);\n\n\t\t/*\n\t\t * Setup our list pointers now so that the current\n\t\t * parents become children in the next iteration.\n\t\t */\n\t\tleft_el = left_path->p_node[i].el;\n\t\tright_el = right_path->p_node[i].el;\n\t}\n\n\t/*\n\t * At the root node, adjust the two adjacent records which\n\t * begin our path to the leaves.\n\t */\n\n\tel = left_path->p_node[subtree_index].el;\n\tleft_el = left_path->p_node[subtree_index + 1].el;\n\tright_el = right_path->p_node[subtree_index + 1].el;\n\n\tocfs2_adjust_root_records(el, left_el, right_el,\n\t\t\t\t  left_path->p_node[subtree_index + 1].bh->b_blocknr);\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\n\tocfs2_journal_dirty(handle, root_bh);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_complete_edge_insert(handle_t *handle,\n\t\t\t\t       struct ocfs2_path *left_path,\n\t\t\t\t       struct ocfs2_path *right_path,\n\t\t\t\t       int subtree_index)\n{\n\tint i, idx;\n\tstruct ocfs2_extent_list *el, *left_el, *right_el;\n\tstruct ocfs2_extent_rec *left_rec, *right_rec;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\n\t/*\n\t * Update the counts and position values within all the\n\t * interior nodes to reflect the leaf rotation we just did.\n\t *\n\t * The root node is handled below the loop.\n\t *\n\t * We begin the loop with right_el and left_el pointing to the\n\t * leaf lists and work our way up.\n\t *\n\t * NOTE: within this loop, left_el and right_el always refer\n\t * to the *child* lists.\n\t */\n\tleft_el = path_leaf_el(left_path);\n\tright_el = path_leaf_el(right_path);\n\tfor(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {\n\t\ttrace_ocfs2_complete_edge_insert(i);\n\n\t\t/*\n\t\t * One nice property of knowing that all of these\n\t\t * nodes are below the root is that we only deal with\n\t\t * the leftmost right node record and the rightmost\n\t\t * left node record.\n\t\t */\n\t\tel = left_path->p_node[i].el;\n\t\tidx = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\t\tleft_rec = &el->l_recs[idx];\n\n\t\tel = right_path->p_node[i].el;\n\t\tright_rec = &el->l_recs[0];\n\n\t\tocfs2_adjust_adjacent_records(left_rec, left_el, right_rec,\n\t\t\t\t\t      right_el);\n\n\t\tocfs2_journal_dirty(handle, left_path->p_node[i].bh);\n\t\tocfs2_journal_dirty(handle, right_path->p_node[i].bh);\n\n\t\t/*\n\t\t * Setup our list pointers now so that the current\n\t\t * parents become children in the next iteration.\n\t\t */\n\t\tleft_el = left_path->p_node[i].el;\n\t\tright_el = right_path->p_node[i].el;\n\t}\n\n\t/*\n\t * At the root node, adjust the two adjacent records which\n\t * begin our path to the leaves.\n\t */\n\n\tel = left_path->p_node[subtree_index].el;\n\tleft_el = left_path->p_node[subtree_index + 1].el;\n\tright_el = right_path->p_node[subtree_index + 1].el;\n\n\tocfs2_adjust_root_records(el, left_el, right_el,\n\t\t\t\t  left_path->p_node[subtree_index + 1].bh->b_blocknr);\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\n\tocfs2_journal_dirty(handle, root_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "path_leaf_bh(right_path)"
          ],
          "line": 3451
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "right_path"
          ],
          "line": 3451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cleanup_merge",
          "args": [
            "el",
            "index"
          ],
          "line": 3447
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cleanup_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "3261-3291",
          "snippet": "static void ocfs2_cleanup_merge(struct ocfs2_extent_list *el,\n\t\t\t\tint index)\n{\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[index];\n\tunsigned int size;\n\n\tif (rec->e_leaf_clusters == 0) {\n\t\t/*\n\t\t * We consumed all of the merged-from record. An empty\n\t\t * extent cannot exist anywhere but the 1st array\n\t\t * position, so move things over if the merged-from\n\t\t * record doesn't occupy that position.\n\t\t *\n\t\t * This creates a new empty extent so the caller\n\t\t * should be smart enough to have removed any existing\n\t\t * ones.\n\t\t */\n\t\tif (index > 0) {\n\t\t\tBUG_ON(ocfs2_is_empty_extent(&el->l_recs[0]));\n\t\t\tsize = index * sizeof(struct ocfs2_extent_rec);\n\t\t\tmemmove(&el->l_recs[1], &el->l_recs[0], size);\n\t\t}\n\n\t\t/*\n\t\t * Always memset - the caller doesn't check whether it\n\t\t * created an empty extent, so there could be junk in\n\t\t * the other fields.\n\t\t */\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic void ocfs2_cleanup_merge(struct ocfs2_extent_list *el,\n\t\t\t\tint index)\n{\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[index];\n\tunsigned int size;\n\n\tif (rec->e_leaf_clusters == 0) {\n\t\t/*\n\t\t * We consumed all of the merged-from record. An empty\n\t\t * extent cannot exist anywhere but the 1st array\n\t\t * position, so move things over if the merged-from\n\t\t * record doesn't occupy that position.\n\t\t *\n\t\t * This creates a new empty extent so the caller\n\t\t * should be smart enough to have removed any existing\n\t\t * ones.\n\t\t */\n\t\tif (index > 0) {\n\t\t\tBUG_ON(ocfs2_is_empty_extent(&el->l_recs[0]));\n\t\t\tsize = index * sizeof(struct ocfs2_extent_rec);\n\t\t\tmemmove(&el->l_recs[1], &el->l_recs[0], size);\n\t\t}\n\n\t\t/*\n\t\t * Always memset - the caller doesn't check whether it\n\t\t * created an empty extent, so there could be junk in\n\t\t * the other fields.\n\t\t */\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&right_rec->e_leaf_clusters",
            "split_clusters"
          ],
          "line": 3445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_add_cpu",
          "args": [
            "&right_rec->e_blkno",
            "-ocfs2_clusters_to_blocks(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t       split_clusters)"
          ],
          "line": 3442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "split_clusters"
          ],
          "line": 3443
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 3443
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&right_rec->e_cpos",
            "-split_clusters"
          ],
          "line": 3441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&left_rec->e_leaf_clusters",
            "-split_clusters"
          ],
          "line": 3439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_path_bh_journal_access",
          "args": [
            "handle",
            "et->et_ci",
            "left_path",
            "path_num_items(left_path) - 1"
          ],
          "line": 3432
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_path_bh_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "726-741",
          "snippet": "int ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_num_items",
          "args": [
            "left_path"
          ],
          "line": 3433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "index == le16_to_cpu(el->l_next_free_rec) - 1"
          ],
          "line": 3428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 3428
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_num_items",
          "args": [
            "right_path"
          ],
          "line": 3411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "root_bh != right_path->p_node[subtree_index].bh"
          ],
          "line": 3401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_rotate_transaction",
          "args": [
            "handle",
            "subtree_index",
            "handle->h_buffer_credits",
            "right_path"
          ],
          "line": 3392
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_rotate_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2279-2291",
          "snippet": "static int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,\n\t\t\t\t\t   int op_credits,\n\t\t\t\t\t   struct ocfs2_path *path)\n{\n\tint ret = 0;\n\tint credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;\n\n\tif (handle->h_buffer_credits < credits)\n\t\tret = ocfs2_extend_trans(handle,\n\t\t\t\t\t credits - handle->h_buffer_credits);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,\n\t\t\t\t\t   int op_credits,\n\t\t\t\t\t   struct ocfs2_path *path)\n{\n\tint ret = 0;\n\tint credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;\n\n\tif (handle->h_buffer_credits < credits)\n\t\tret = ocfs2_extend_trans(handle,\n\t\t\t\t\t credits - handle->h_buffer_credits);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_subtree_root",
          "args": [
            "et",
            "left_path",
            "right_path"
          ],
          "line": 3389
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_subtree_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1737-1765",
          "snippet": "int ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le32_to_cpu(left_rec->e_cpos) +\n\t\t       le16_to_cpu(left_rec->e_leaf_clusters) !=\n\t\t       le32_to_cpu(right_rec->e_cpos)"
          ],
          "line": 3385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "right_rec->e_cpos"
          ],
          "line": 3387
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "next_free <= 1"
          ],
          "line": 3381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "right_rec"
          ],
          "line": 3380
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "266-269",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "next_free <= 0"
          ],
          "line": 3378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "right_path"
          ],
          "line": 3376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_right_path",
          "args": [
            "et",
            "left_path",
            "&right_path"
          ],
          "line": 3370
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_right_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "3293-3338",
          "snippet": "static int ocfs2_get_right_path(struct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_path *left_path,\n\t\t\t\tstruct ocfs2_path **ret_right_path)\n{\n\tint ret;\n\tu32 right_cpos;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct ocfs2_extent_list *left_el;\n\n\t*ret_right_path = NULL;\n\n\t/* This function shouldn't be called for non-trees. */\n\tBUG_ON(left_path->p_tree_depth == 0);\n\n\tleft_el = path_leaf_el(left_path);\n\tBUG_ON(left_el->l_next_free_rec != left_el->l_count);\n\n\tret = ocfs2_find_cpos_for_right_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t     left_path, &right_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* This function shouldn't be called for the rightmost leaf. */\n\tBUG_ON(right_cpos == 0);\n\n\tright_path = ocfs2_new_path_from_path(left_path);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, right_path, right_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_right_path = right_path;\nout:\n\tif (ret)\n\t\tocfs2_free_path(right_path);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_get_right_path(struct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_path *left_path,\n\t\t\t\tstruct ocfs2_path **ret_right_path)\n{\n\tint ret;\n\tu32 right_cpos;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct ocfs2_extent_list *left_el;\n\n\t*ret_right_path = NULL;\n\n\t/* This function shouldn't be called for non-trees. */\n\tBUG_ON(left_path->p_tree_depth == 0);\n\n\tleft_el = path_leaf_el(left_path);\n\tBUG_ON(left_el->l_next_free_rec != left_el->l_count);\n\n\tret = ocfs2_find_cpos_for_right_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t     left_path, &right_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* This function shouldn't be called for the rightmost leaf. */\n\tBUG_ON(right_cpos == 0);\n\n\tright_path = ocfs2_new_path_from_path(left_path);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, right_path, right_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_right_path = right_path;\nout:\n\tif (ret)\n\t\tocfs2_free_path(right_path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "index >= le16_to_cpu(el->l_next_free_rec)"
          ],
          "line": 3364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "left_path"
          ],
          "line": 3361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "left_path"
          ],
          "line": 3360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_merge_rec_right(struct ocfs2_path *left_path,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_extent_rec *split_rec,\n\t\t\t\t int index)\n{\n\tint ret, next_free, i;\n\tunsigned int split_clusters = le16_to_cpu(split_rec->e_leaf_clusters);\n\tstruct ocfs2_extent_rec *left_rec;\n\tstruct ocfs2_extent_rec *right_rec;\n\tstruct ocfs2_extent_list *right_el;\n\tstruct ocfs2_path *right_path = NULL;\n\tint subtree_index = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(left_path);\n\tstruct buffer_head *bh = path_leaf_bh(left_path);\n\tstruct buffer_head *root_bh = NULL;\n\n\tBUG_ON(index >= le16_to_cpu(el->l_next_free_rec));\n\tleft_rec = &el->l_recs[index];\n\n\tif (index == le16_to_cpu(el->l_next_free_rec) - 1 &&\n\t    le16_to_cpu(el->l_next_free_rec) == le16_to_cpu(el->l_count)) {\n\t\t/* we meet with a cross extent block merge. */\n\t\tret = ocfs2_get_right_path(et, left_path, &right_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tright_el = path_leaf_el(right_path);\n\t\tnext_free = le16_to_cpu(right_el->l_next_free_rec);\n\t\tBUG_ON(next_free <= 0);\n\t\tright_rec = &right_el->l_recs[0];\n\t\tif (ocfs2_is_empty_extent(right_rec)) {\n\t\t\tBUG_ON(next_free <= 1);\n\t\t\tright_rec = &right_el->l_recs[1];\n\t\t}\n\n\t\tBUG_ON(le32_to_cpu(left_rec->e_cpos) +\n\t\t       le16_to_cpu(left_rec->e_leaf_clusters) !=\n\t\t       le32_to_cpu(right_rec->e_cpos));\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t\tright_path);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, subtree_index,\n\t\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t\t      right_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\troot_bh = left_path->p_node[subtree_index].bh;\n\t\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t\t   subtree_index);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = subtree_index + 1;\n\t\t     i < path_num_items(right_path); i++) {\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   right_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   left_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tBUG_ON(index == le16_to_cpu(el->l_next_free_rec) - 1);\n\t\tright_rec = &el->l_recs[index + 1];\n\t}\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, left_path,\n\t\t\t\t\t   path_num_items(left_path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tle16_add_cpu(&left_rec->e_leaf_clusters, -split_clusters);\n\n\tle32_add_cpu(&right_rec->e_cpos, -split_clusters);\n\tle64_add_cpu(&right_rec->e_blkno,\n\t\t     -ocfs2_clusters_to_blocks(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t       split_clusters));\n\tle16_add_cpu(&right_rec->e_leaf_clusters, split_clusters);\n\n\tocfs2_cleanup_merge(el, index);\n\n\tocfs2_journal_dirty(handle, bh);\n\tif (right_path) {\n\t\tocfs2_journal_dirty(handle, path_leaf_bh(right_path));\n\t\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t\t   subtree_index);\n\t}\nout:\n\tif (right_path)\n\t\tocfs2_free_path(right_path);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_get_right_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "3293-3338",
    "snippet": "static int ocfs2_get_right_path(struct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_path *left_path,\n\t\t\t\tstruct ocfs2_path **ret_right_path)\n{\n\tint ret;\n\tu32 right_cpos;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct ocfs2_extent_list *left_el;\n\n\t*ret_right_path = NULL;\n\n\t/* This function shouldn't be called for non-trees. */\n\tBUG_ON(left_path->p_tree_depth == 0);\n\n\tleft_el = path_leaf_el(left_path);\n\tBUG_ON(left_el->l_next_free_rec != left_el->l_count);\n\n\tret = ocfs2_find_cpos_for_right_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t     left_path, &right_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* This function shouldn't be called for the rightmost leaf. */\n\tBUG_ON(right_cpos == 0);\n\n\tright_path = ocfs2_new_path_from_path(left_path);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, right_path, right_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_right_path = right_path;\nout:\n\tif (ret)\n\t\tocfs2_free_path(right_path);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "right_path"
          ],
          "line": 3336
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "609-615",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "et->et_ci",
            "right_path",
            "right_cpos"
          ],
          "line": 3327
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1885-1894",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_path",
          "args": [
            "left_path"
          ],
          "line": 3320
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "707-711",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "right_cpos == 0"
          ],
          "line": 3318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_cpos_for_right_leaf",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "left_path",
            "&right_cpos"
          ],
          "line": 3310
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_cpos_for_right_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2820-2888",
          "snippet": "int ocfs2_find_cpos_for_right_leaf(struct super_block *sb,\n\t\t\t\t   struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\t*cpos = 0;\n\n\tif (path->p_tree_depth == 0)\n\t\treturn 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tint next_free;\n\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just after the one in our\n\t\t * path.\n\t\t */\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == (next_free - 1)) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the rightmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The rightmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j + 1].e_cpos);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_find_cpos_for_right_leaf(struct super_block *sb,\n\t\t\t\t   struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\t*cpos = 0;\n\n\tif (path->p_tree_depth == 0)\n\t\treturn 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tint next_free;\n\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just after the one in our\n\t\t * path.\n\t\t */\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == (next_free - 1)) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the rightmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The rightmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j + 1].e_cpos);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 3310
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "left_el->l_next_free_rec != left_el->l_count"
          ],
          "line": 3308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "left_path"
          ],
          "line": 3307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "left_path->p_tree_depth == 0"
          ],
          "line": 3305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_get_right_path(struct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_path *left_path,\n\t\t\t\tstruct ocfs2_path **ret_right_path)\n{\n\tint ret;\n\tu32 right_cpos;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct ocfs2_extent_list *left_el;\n\n\t*ret_right_path = NULL;\n\n\t/* This function shouldn't be called for non-trees. */\n\tBUG_ON(left_path->p_tree_depth == 0);\n\n\tleft_el = path_leaf_el(left_path);\n\tBUG_ON(left_el->l_next_free_rec != left_el->l_count);\n\n\tret = ocfs2_find_cpos_for_right_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t     left_path, &right_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* This function shouldn't be called for the rightmost leaf. */\n\tBUG_ON(right_cpos == 0);\n\n\tright_path = ocfs2_new_path_from_path(left_path);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, right_path, right_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_right_path = right_path;\nout:\n\tif (ret)\n\t\tocfs2_free_path(right_path);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_cleanup_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "3261-3291",
    "snippet": "static void ocfs2_cleanup_merge(struct ocfs2_extent_list *el,\n\t\t\t\tint index)\n{\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[index];\n\tunsigned int size;\n\n\tif (rec->e_leaf_clusters == 0) {\n\t\t/*\n\t\t * We consumed all of the merged-from record. An empty\n\t\t * extent cannot exist anywhere but the 1st array\n\t\t * position, so move things over if the merged-from\n\t\t * record doesn't occupy that position.\n\t\t *\n\t\t * This creates a new empty extent so the caller\n\t\t * should be smart enough to have removed any existing\n\t\t * ones.\n\t\t */\n\t\tif (index > 0) {\n\t\t\tBUG_ON(ocfs2_is_empty_extent(&el->l_recs[0]));\n\t\t\tsize = index * sizeof(struct ocfs2_extent_rec);\n\t\t\tmemmove(&el->l_recs[1], &el->l_recs[0], size);\n\t\t}\n\n\t\t/*\n\t\t * Always memset - the caller doesn't check whether it\n\t\t * created an empty extent, so there could be junk in\n\t\t * the other fields.\n\t\t */\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&el->l_recs[0]",
            "0",
            "sizeof(struct ocfs2_extent_rec)"
          ],
          "line": 3289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&el->l_recs[1]",
            "&el->l_recs[0]",
            "size"
          ],
          "line": 3281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ocfs2_is_empty_extent(&el->l_recs[0])"
          ],
          "line": 3279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&el->l_recs[0]"
          ],
          "line": 3279
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "266-269",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic void ocfs2_cleanup_merge(struct ocfs2_extent_list *el,\n\t\t\t\tint index)\n{\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[index];\n\tunsigned int size;\n\n\tif (rec->e_leaf_clusters == 0) {\n\t\t/*\n\t\t * We consumed all of the merged-from record. An empty\n\t\t * extent cannot exist anywhere but the 1st array\n\t\t * position, so move things over if the merged-from\n\t\t * record doesn't occupy that position.\n\t\t *\n\t\t * This creates a new empty extent so the caller\n\t\t * should be smart enough to have removed any existing\n\t\t * ones.\n\t\t */\n\t\tif (index > 0) {\n\t\t\tBUG_ON(ocfs2_is_empty_extent(&el->l_recs[0]));\n\t\t\tsize = index * sizeof(struct ocfs2_extent_rec);\n\t\t\tmemmove(&el->l_recs[1], &el->l_recs[0], size);\n\t\t}\n\n\t\t/*\n\t\t * Always memset - the caller doesn't check whether it\n\t\t * created an empty extent, so there could be junk in\n\t\t * the other fields.\n\t\t */\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\t}\n}"
  },
  {
    "function_name": "ocfs2_rotate_tree_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "3149-3259",
    "snippet": "static int ocfs2_rotate_tree_left(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_path *path,\n\t\t\t\t  struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, orig_credits = handle->h_buffer_credits;\n\tstruct ocfs2_path *tmp_path = NULL, *restart_path = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\tel = path_leaf_el(path);\n\tif (!ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn 0;\n\n\tif (path->p_tree_depth == 0) {\nrightmost_no_delete:\n\t\t/*\n\t\t * Inline extents. This is trivially handled, so do\n\t\t * it up front.\n\t\t */\n\t\tret = ocfs2_rotate_rightmost_leaf_left(handle, et, path);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Handle rightmost branch now. There's several cases:\n\t *  1) simple rotation leaving records in there. That's trivial.\n\t *  2) rotation requiring a branch delete - there's no more\n\t *     records left. Two cases of this:\n\t *     a) There are branches to the left.\n\t *     b) This is also the leftmost (the only) branch.\n\t *\n\t *  1) is handled via ocfs2_rotate_rightmost_leaf_left()\n\t *  2a) we need the left branch so that we can update it with the unlink\n\t *  2b) we need to bring the root back to inline extents.\n\t */\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\tel = &eb->h_list;\n\tif (eb->h_next_leaf_blk == 0) {\n\t\t/*\n\t\t * This gets a bit tricky if we're going to delete the\n\t\t * rightmost path. Get the other cases out of the way\n\t\t * 1st.\n\t\t */\n\t\tif (le16_to_cpu(el->l_next_free_rec) > 1)\n\t\t\tgoto rightmost_no_delete;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tret = -EIO;\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has empty extent block at %llu\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    (unsigned long long)le64_to_cpu(eb->h_blkno));\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * XXX: The caller can not trust \"path\" any more after\n\t\t * this as it will have been deleted. What do we do?\n\t\t *\n\t\t * In theory the rotate-for-merge code will never get\n\t\t * here because it'll always ask for a rotate in a\n\t\t * nonempty list.\n\t\t */\n\n\t\tret = ocfs2_remove_rightmost_path(handle, et, path,\n\t\t\t\t\t\t  dealloc);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Now we can loop, remembering the path we get from -EAGAIN\n\t * and restarting from there.\n\t */\ntry_rotate:\n\tret = __ocfs2_rotate_tree_left(handle, et, orig_credits, path,\n\t\t\t\t       dealloc, &restart_path);\n\tif (ret && ret != -EAGAIN) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (ret == -EAGAIN) {\n\t\ttmp_path = restart_path;\n\t\trestart_path = NULL;\n\n\t\tret = __ocfs2_rotate_tree_left(handle, et, orig_credits,\n\t\t\t\t\t       tmp_path, dealloc,\n\t\t\t\t\t       &restart_path);\n\t\tif (ret && ret != -EAGAIN) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tocfs2_free_path(tmp_path);\n\t\ttmp_path = NULL;\n\n\t\tif (ret == 0)\n\t\t\tgoto try_rotate;\n\t}\n\nout:\n\tocfs2_free_path(tmp_path);\n\tocfs2_free_path(restart_path);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "restart_path"
          ],
          "line": 3257
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "609-615",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_rotate_tree_left",
          "args": [
            "handle",
            "et",
            "orig_credits",
            "tmp_path",
            "dealloc",
            "&restart_path"
          ],
          "line": 3240
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_rotate_tree_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2915-3029",
          "snippet": "static int __ocfs2_rotate_tree_left(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    int orig_credits,\n\t\t\t\t    struct ocfs2_path *path,\n\t\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t    struct ocfs2_path **empty_extent_path)\n{\n\tint ret, subtree_root, deleted;\n\tu32 right_cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\n\tBUG_ON(!ocfs2_is_empty_extent(&(path_leaf_el(path)->l_recs[0])));\n\n\t*empty_extent_path = NULL;\n\n\tret = ocfs2_find_cpos_for_right_leaf(sb, path, &right_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tleft_path = ocfs2_new_path_from_path(path);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_cp_path(left_path, path);\n\n\tright_path = ocfs2_new_path_from_path(path);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (right_cpos) {\n\t\tret = ocfs2_find_path(et->et_ci, right_path, right_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tsubtree_root = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t       right_path);\n\n\t\ttrace_ocfs2_rotate_subtree(subtree_root,\n\t\t     (unsigned long long)\n\t\t     right_path->p_node[subtree_root].bh->b_blocknr,\n\t\t     right_path->p_tree_depth);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, subtree_root,\n\t\t\t\t\t\t      orig_credits, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Caller might still want to make changes to the\n\t\t * tree root, so re-add it to the journal here.\n\t\t */\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   left_path, 0);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_subtree_left(handle, et, left_path,\n\t\t\t\t\t\tright_path, subtree_root,\n\t\t\t\t\t\tdealloc, &deleted);\n\t\tif (ret == -EAGAIN) {\n\t\t\t/*\n\t\t\t * The rotation has to temporarily stop due to\n\t\t\t * the right subtree having an empty\n\t\t\t * extent. Pass it back to the caller for a\n\t\t\t * fixup.\n\t\t\t */\n\t\t\t*empty_extent_path = right_path;\n\t\t\tright_path = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * The subtree rotate might have removed records on\n\t\t * the rightmost edge. If so, then rotation is\n\t\t * complete.\n\t\t */\n\t\tif (deleted)\n\t\t\tbreak;\n\n\t\tocfs2_mv_path(left_path, right_path);\n\n\t\tret = ocfs2_find_cpos_for_right_leaf(sb, left_path,\n\t\t\t\t\t\t     &right_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tocfs2_free_path(right_path);\n\tocfs2_free_path(left_path);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int __ocfs2_rotate_tree_left(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    int orig_credits,\n\t\t\t\t    struct ocfs2_path *path,\n\t\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t    struct ocfs2_path **empty_extent_path)\n{\n\tint ret, subtree_root, deleted;\n\tu32 right_cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\n\tBUG_ON(!ocfs2_is_empty_extent(&(path_leaf_el(path)->l_recs[0])));\n\n\t*empty_extent_path = NULL;\n\n\tret = ocfs2_find_cpos_for_right_leaf(sb, path, &right_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tleft_path = ocfs2_new_path_from_path(path);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_cp_path(left_path, path);\n\n\tright_path = ocfs2_new_path_from_path(path);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (right_cpos) {\n\t\tret = ocfs2_find_path(et->et_ci, right_path, right_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tsubtree_root = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t       right_path);\n\n\t\ttrace_ocfs2_rotate_subtree(subtree_root,\n\t\t     (unsigned long long)\n\t\t     right_path->p_node[subtree_root].bh->b_blocknr,\n\t\t     right_path->p_tree_depth);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, subtree_root,\n\t\t\t\t\t\t      orig_credits, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Caller might still want to make changes to the\n\t\t * tree root, so re-add it to the journal here.\n\t\t */\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   left_path, 0);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_subtree_left(handle, et, left_path,\n\t\t\t\t\t\tright_path, subtree_root,\n\t\t\t\t\t\tdealloc, &deleted);\n\t\tif (ret == -EAGAIN) {\n\t\t\t/*\n\t\t\t * The rotation has to temporarily stop due to\n\t\t\t * the right subtree having an empty\n\t\t\t * extent. Pass it back to the caller for a\n\t\t\t * fixup.\n\t\t\t */\n\t\t\t*empty_extent_path = right_path;\n\t\t\tright_path = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * The subtree rotate might have removed records on\n\t\t * the rightmost edge. If so, then rotation is\n\t\t * complete.\n\t\t */\n\t\tif (deleted)\n\t\t\tbreak;\n\n\t\tocfs2_mv_path(left_path, right_path);\n\n\t\tret = ocfs2_find_cpos_for_right_leaf(sb, left_path,\n\t\t\t\t\t\t     &right_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tocfs2_free_path(right_path);\n\tocfs2_free_path(left_path);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_rightmost_path",
          "args": [
            "handle",
            "et",
            "path",
            "dealloc"
          ],
          "line": 3217
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_rightmost_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "3031-3131",
          "snippet": "static int ocfs2_remove_rightmost_path(handle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_path *path,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, subtree_index;\n\tu32 cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\n\tret = ocfs2_et_sanity_check(et);\n\tif (ret)\n\t\tgoto out;\n\t/*\n\t * There's two ways we handle this depending on\n\t * whether path is the only existing one.\n\t */\n\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t      path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t    path, &cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (cpos) {\n\t\t/*\n\t\t * We have a path to the left of this one - it needs\n\t\t * an update too.\n\t\t */\n\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\tif (!left_path) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path, path);\n\n\t\tocfs2_unlink_subtree(handle, et, left_path, path,\n\t\t\t\t     subtree_index, dealloc);\n\t\tret = ocfs2_update_edge_lengths(handle, et, subtree_index,\n\t\t\t\t\t\tleft_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\t} else {\n\t\t/*\n\t\t * 'path' is also the leftmost path which\n\t\t * means it must be the only one. This gets\n\t\t * handled differently because we want to\n\t\t * revert the root back to having extents\n\t\t * in-line.\n\t\t */\n\t\tocfs2_unlink_path(handle, et, dealloc, path, 1);\n\n\t\tel = et->et_root_el;\n\t\tel->l_tree_depth = 0;\n\t\tel->l_next_free_rec = 0;\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\n\t\tocfs2_et_set_last_eb_blk(et, 0);\n\t}\n\n\tocfs2_journal_dirty(handle, path_root_bh(path));\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_remove_rightmost_path(handle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_path *path,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, subtree_index;\n\tu32 cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\n\tret = ocfs2_et_sanity_check(et);\n\tif (ret)\n\t\tgoto out;\n\t/*\n\t * There's two ways we handle this depending on\n\t * whether path is the only existing one.\n\t */\n\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t      path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t    path, &cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (cpos) {\n\t\t/*\n\t\t * We have a path to the left of this one - it needs\n\t\t * an update too.\n\t\t */\n\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\tif (!left_path) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path, path);\n\n\t\tocfs2_unlink_subtree(handle, et, left_path, path,\n\t\t\t\t     subtree_index, dealloc);\n\t\tret = ocfs2_update_edge_lengths(handle, et, subtree_index,\n\t\t\t\t\t\tleft_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\t} else {\n\t\t/*\n\t\t * 'path' is also the leftmost path which\n\t\t * means it must be the only one. This gets\n\t\t * handled differently because we want to\n\t\t * revert the root back to having extents\n\t\t * in-line.\n\t\t */\n\t\tocfs2_unlink_path(handle, et, dealloc, path, 1);\n\n\t\tel = et->et_root_el;\n\t\tel->l_tree_depth = 0;\n\t\tel->l_next_free_rec = 0;\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\n\t\tocfs2_et_set_last_eb_blk(et, 0);\n\t}\n\n\tocfs2_journal_dirty(handle, path_root_bh(path));\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "\"Owner %llu has empty extent block at %llu\"",
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "(unsigned long long)le64_to_cpu(eb->h_blkno)"
          ],
          "line": 3201
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "eb->h_blkno"
          ],
          "line": 3204
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 3203
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 3201
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 3199
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "path"
          ],
          "line": 3188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rotate_rightmost_leaf_left",
          "args": [
            "handle",
            "et",
            "path"
          ],
          "line": 3169
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rotate_rightmost_leaf_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2890-2913",
          "snippet": "static int ocfs2_rotate_rightmost_leaf_left(handle_t *handle,\n\t\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t\t    struct ocfs2_path *path)\n{\n\tint ret;\n\tstruct buffer_head *bh = path_leaf_bh(path);\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\n\tif (!ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn 0;\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, path,\n\t\t\t\t\t   path_num_items(path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_remove_empty_extent(el);\n\tocfs2_journal_dirty(handle, bh);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_rotate_rightmost_leaf_left(handle_t *handle,\n\t\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t\t    struct ocfs2_path *path)\n{\n\tint ret;\n\tstruct buffer_head *bh = path_leaf_bh(path);\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\n\tif (!ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn 0;\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, path,\n\t\t\t\t\t   path_num_items(path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_remove_empty_extent(el);\n\tocfs2_journal_dirty(handle, bh);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&el->l_recs[0]"
          ],
          "line": 3160
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "266-269",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 3159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_rotate_tree_left(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_path *path,\n\t\t\t\t  struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, orig_credits = handle->h_buffer_credits;\n\tstruct ocfs2_path *tmp_path = NULL, *restart_path = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\tel = path_leaf_el(path);\n\tif (!ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn 0;\n\n\tif (path->p_tree_depth == 0) {\nrightmost_no_delete:\n\t\t/*\n\t\t * Inline extents. This is trivially handled, so do\n\t\t * it up front.\n\t\t */\n\t\tret = ocfs2_rotate_rightmost_leaf_left(handle, et, path);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Handle rightmost branch now. There's several cases:\n\t *  1) simple rotation leaving records in there. That's trivial.\n\t *  2) rotation requiring a branch delete - there's no more\n\t *     records left. Two cases of this:\n\t *     a) There are branches to the left.\n\t *     b) This is also the leftmost (the only) branch.\n\t *\n\t *  1) is handled via ocfs2_rotate_rightmost_leaf_left()\n\t *  2a) we need the left branch so that we can update it with the unlink\n\t *  2b) we need to bring the root back to inline extents.\n\t */\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\tel = &eb->h_list;\n\tif (eb->h_next_leaf_blk == 0) {\n\t\t/*\n\t\t * This gets a bit tricky if we're going to delete the\n\t\t * rightmost path. Get the other cases out of the way\n\t\t * 1st.\n\t\t */\n\t\tif (le16_to_cpu(el->l_next_free_rec) > 1)\n\t\t\tgoto rightmost_no_delete;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tret = -EIO;\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has empty extent block at %llu\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    (unsigned long long)le64_to_cpu(eb->h_blkno));\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * XXX: The caller can not trust \"path\" any more after\n\t\t * this as it will have been deleted. What do we do?\n\t\t *\n\t\t * In theory the rotate-for-merge code will never get\n\t\t * here because it'll always ask for a rotate in a\n\t\t * nonempty list.\n\t\t */\n\n\t\tret = ocfs2_remove_rightmost_path(handle, et, path,\n\t\t\t\t\t\t  dealloc);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Now we can loop, remembering the path we get from -EAGAIN\n\t * and restarting from there.\n\t */\ntry_rotate:\n\tret = __ocfs2_rotate_tree_left(handle, et, orig_credits, path,\n\t\t\t\t       dealloc, &restart_path);\n\tif (ret && ret != -EAGAIN) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (ret == -EAGAIN) {\n\t\ttmp_path = restart_path;\n\t\trestart_path = NULL;\n\n\t\tret = __ocfs2_rotate_tree_left(handle, et, orig_credits,\n\t\t\t\t\t       tmp_path, dealloc,\n\t\t\t\t\t       &restart_path);\n\t\tif (ret && ret != -EAGAIN) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tocfs2_free_path(tmp_path);\n\t\ttmp_path = NULL;\n\n\t\tif (ret == 0)\n\t\t\tgoto try_rotate;\n\t}\n\nout:\n\tocfs2_free_path(tmp_path);\n\tocfs2_free_path(restart_path);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_remove_rightmost_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "3031-3131",
    "snippet": "static int ocfs2_remove_rightmost_path(handle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_path *path,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, subtree_index;\n\tu32 cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\n\tret = ocfs2_et_sanity_check(et);\n\tif (ret)\n\t\tgoto out;\n\t/*\n\t * There's two ways we handle this depending on\n\t * whether path is the only existing one.\n\t */\n\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t      path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t    path, &cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (cpos) {\n\t\t/*\n\t\t * We have a path to the left of this one - it needs\n\t\t * an update too.\n\t\t */\n\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\tif (!left_path) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path, path);\n\n\t\tocfs2_unlink_subtree(handle, et, left_path, path,\n\t\t\t\t     subtree_index, dealloc);\n\t\tret = ocfs2_update_edge_lengths(handle, et, subtree_index,\n\t\t\t\t\t\tleft_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\t} else {\n\t\t/*\n\t\t * 'path' is also the leftmost path which\n\t\t * means it must be the only one. This gets\n\t\t * handled differently because we want to\n\t\t * revert the root back to having extents\n\t\t * in-line.\n\t\t */\n\t\tocfs2_unlink_path(handle, et, dealloc, path, 1);\n\n\t\tel = et->et_root_el;\n\t\tel->l_tree_depth = 0;\n\t\tel->l_next_free_rec = 0;\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\n\t\tocfs2_et_set_last_eb_blk(et, 0);\n\t}\n\n\tocfs2_journal_dirty(handle, path_root_bh(path));\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "left_path"
          ],
          "line": 3129
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "609-615",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "path_root_bh(path)"
          ],
          "line": 3126
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_root_bh",
          "args": [
            "path"
          ],
          "line": 3126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_et_set_last_eb_blk",
          "args": [
            "et",
            "0"
          ],
          "line": 3123
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_set_last_eb_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "498-502",
          "snippet": "static inline void ocfs2_et_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u64 new_last_eb_blk)\n{\n\tet->et_ops->eo_set_last_eb_blk(et, new_last_eb_blk);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic inline void ocfs2_et_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u64 new_last_eb_blk)\n{\n\tet->et_ops->eo_set_last_eb_blk(et, new_last_eb_blk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&el->l_recs[0]",
            "0",
            "sizeof(struct ocfs2_extent_rec)"
          ],
          "line": 3121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_unlink_path",
          "args": [
            "handle",
            "et",
            "dealloc",
            "path",
            "1"
          ],
          "line": 3116
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlink_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2574-2617",
          "snippet": "static void ocfs2_unlink_path(handle_t *handle,\n\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t      struct ocfs2_path *path, int unlink_start)\n{\n\tint ret, i;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct buffer_head *bh;\n\n\tfor(i = unlink_start; i < path_num_items(path); i++) {\n\t\tbh = path->p_node[i].bh;\n\n\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t/*\n\t\t * Not all nodes might have had their final count\n\t\t * decremented by the caller - handle this here.\n\t\t */\n\t\tel = &eb->h_list;\n\t\tif (le16_to_cpu(el->l_next_free_rec) > 1) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Inode %llu, attempted to remove extent block \"\n\t\t\t     \"%llu with %u records\\n\",\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t     (unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t     le16_to_cpu(el->l_next_free_rec));\n\n\t\t\tocfs2_journal_dirty(handle, bh);\n\t\t\tocfs2_remove_from_cache(et->et_ci, bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\tel->l_next_free_rec = 0;\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\n\t\tret = ocfs2_cache_extent_block_free(dealloc, eb);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t\tocfs2_remove_from_cache(et->et_ci, bh);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic void ocfs2_unlink_path(handle_t *handle,\n\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t      struct ocfs2_path *path, int unlink_start)\n{\n\tint ret, i;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct buffer_head *bh;\n\n\tfor(i = unlink_start; i < path_num_items(path); i++) {\n\t\tbh = path->p_node[i].bh;\n\n\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t/*\n\t\t * Not all nodes might have had their final count\n\t\t * decremented by the caller - handle this here.\n\t\t */\n\t\tel = &eb->h_list;\n\t\tif (le16_to_cpu(el->l_next_free_rec) > 1) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Inode %llu, attempted to remove extent block \"\n\t\t\t     \"%llu with %u records\\n\",\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t     (unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t     le16_to_cpu(el->l_next_free_rec));\n\n\t\t\tocfs2_journal_dirty(handle, bh);\n\t\t\tocfs2_remove_from_cache(et->et_ci, bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\tel->l_next_free_rec = 0;\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\n\t\tret = ocfs2_cache_extent_block_free(dealloc, eb);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t\tocfs2_remove_from_cache(et->et_ci, bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "eb->h_blkno"
          ],
          "line": 3107
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "left_path"
          ],
          "line": 3106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_update_edge_lengths",
          "args": [
            "handle",
            "et",
            "subtree_index",
            "left_path"
          ],
          "line": 3099
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_edge_lengths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2519-2572",
          "snippet": "static int ocfs2_update_edge_lengths(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     int subtree_index, struct ocfs2_path *path)\n{\n\tint i, idx, ret;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_block *eb;\n\tu32 range;\n\n\t/*\n\t * In normal tree rotation process, we will never touch the\n\t * tree branch above subtree_index and ocfs2_extend_rotate_transaction\n\t * doesn't reserve the credits for them either.\n\t *\n\t * But we do have a special case here which will update the rightmost\n\t * records for all the bh in the path.\n\t * So we have to allocate extra credits and access them.\n\t */\n\tret = ocfs2_extend_trans(handle, subtree_index);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Path should always be rightmost. */\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\tBUG_ON(eb->h_next_leaf_blk != 0ULL);\n\n\tel = &eb->h_list;\n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) == 0);\n\tidx = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[idx];\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tel = path->p_node[i].el;\n\t\tidx = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\trec = &el->l_recs[idx];\n\n\t\trec->e_int_clusters = cpu_to_le32(range);\n\t\tle32_add_cpu(&rec->e_int_clusters, -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, path->p_node[i].bh);\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_update_edge_lengths(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     int subtree_index, struct ocfs2_path *path)\n{\n\tint i, idx, ret;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_block *eb;\n\tu32 range;\n\n\t/*\n\t * In normal tree rotation process, we will never touch the\n\t * tree branch above subtree_index and ocfs2_extend_rotate_transaction\n\t * doesn't reserve the credits for them either.\n\t *\n\t * But we do have a special case here which will update the rightmost\n\t * records for all the bh in the path.\n\t * So we have to allocate extra credits and access them.\n\t */\n\tret = ocfs2_extend_trans(handle, subtree_index);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Path should always be rightmost. */\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\tBUG_ON(eb->h_next_leaf_blk != 0ULL);\n\n\tel = &eb->h_list;\n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) == 0);\n\tidx = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[idx];\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tel = path->p_node[i].el;\n\t\tidx = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\trec = &el->l_recs[idx];\n\n\t\trec->e_int_clusters = cpu_to_le32(range);\n\t\tle32_add_cpu(&rec->e_int_clusters, -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, path->p_node[i].bh);\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_unlink_subtree",
          "args": [
            "handle",
            "et",
            "left_path",
            "path",
            "subtree_index",
            "dealloc"
          ],
          "line": 3097
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlink_subtree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2619-2653",
          "snippet": "static void ocfs2_unlink_subtree(handle_t *handle,\n\t\t\t\t struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_path *left_path,\n\t\t\t\t struct ocfs2_path *right_path,\n\t\t\t\t int subtree_index,\n\t\t\t\t struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint i;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\tstruct ocfs2_extent_list *root_el = left_path->p_node[subtree_index].el;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_block *eb;\n\n\tel = path_leaf_el(left_path);\n\n\teb = (struct ocfs2_extent_block *)right_path->p_node[subtree_index + 1].bh->b_data;\n\n\tfor(i = 1; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\tif (root_el->l_recs[i].e_blkno == eb->h_blkno)\n\t\t\tbreak;\n\n\tBUG_ON(i >= le16_to_cpu(root_el->l_next_free_rec));\n\n\tmemset(&root_el->l_recs[i], 0, sizeof(struct ocfs2_extent_rec));\n\tle16_add_cpu(&root_el->l_next_free_rec, -1);\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\teb->h_next_leaf_blk = 0;\n\n\tocfs2_journal_dirty(handle, root_bh);\n\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\n\tocfs2_unlink_path(handle, et, dealloc, right_path,\n\t\t\t  subtree_index + 1);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic void ocfs2_unlink_subtree(handle_t *handle,\n\t\t\t\t struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_path *left_path,\n\t\t\t\t struct ocfs2_path *right_path,\n\t\t\t\t int subtree_index,\n\t\t\t\t struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint i;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\tstruct ocfs2_extent_list *root_el = left_path->p_node[subtree_index].el;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_block *eb;\n\n\tel = path_leaf_el(left_path);\n\n\teb = (struct ocfs2_extent_block *)right_path->p_node[subtree_index + 1].bh->b_data;\n\n\tfor(i = 1; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\tif (root_el->l_recs[i].e_blkno == eb->h_blkno)\n\t\t\tbreak;\n\n\tBUG_ON(i >= le16_to_cpu(root_el->l_next_free_rec));\n\n\tmemset(&root_el->l_recs[i], 0, sizeof(struct ocfs2_extent_rec));\n\tle16_add_cpu(&root_el->l_next_free_rec, -1);\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\teb->h_next_leaf_blk = 0;\n\n\tocfs2_journal_dirty(handle, root_bh);\n\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\n\tocfs2_unlink_path(handle, et, dealloc, right_path,\n\t\t\t  subtree_index + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_subtree_root",
          "args": [
            "et",
            "left_path",
            "path"
          ],
          "line": 3095
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_subtree_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1737-1765",
          "snippet": "int ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_path",
          "args": [
            "et->et_ci",
            "handle",
            "left_path"
          ],
          "line": 3089
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "746-765",
          "snippet": "int ocfs2_journal_access_path(struct ocfs2_caching_info *ci,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_path *path)\n{\n\tint i, ret = 0;\n\n\tif (!path)\n\t\tgoto out;\n\n\tfor(i = 0; i < path_num_items(path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, ci, path, i);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_journal_access_path(struct ocfs2_caching_info *ci,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_path *path)\n{\n\tint i, ret = 0;\n\n\tif (!path)\n\t\tgoto out;\n\n\tfor(i = 0; i < path_num_items(path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, ci, path, i);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "et->et_ci",
            "left_path",
            "cpos"
          ],
          "line": 3083
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1885-1894",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_path",
          "args": [
            "path"
          ],
          "line": 3076
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "707-711",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_cpos_for_left_leaf",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "path",
            "&cpos"
          ],
          "line": 3064
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_cpos_for_left_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2205-2272",
          "snippet": "int ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 3064
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_rotate_transaction",
          "args": [
            "handle",
            "0",
            "handle->h_buffer_credits",
            "path"
          ],
          "line": 3050
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_rotate_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2279-2291",
          "snippet": "static int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,\n\t\t\t\t\t   int op_credits,\n\t\t\t\t\t   struct ocfs2_path *path)\n{\n\tint ret = 0;\n\tint credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;\n\n\tif (handle->h_buffer_credits < credits)\n\t\tret = ocfs2_extend_trans(handle,\n\t\t\t\t\t credits - handle->h_buffer_credits);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,\n\t\t\t\t\t   int op_credits,\n\t\t\t\t\t   struct ocfs2_path *path)\n{\n\tint ret = 0;\n\tint credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;\n\n\tif (handle->h_buffer_credits < credits)\n\t\tret = ocfs2_extend_trans(handle,\n\t\t\t\t\t credits - handle->h_buffer_credits);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_et_sanity_check",
          "args": [
            "et"
          ],
          "line": 3043
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_sanity_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "560-567",
          "snippet": "static inline int ocfs2_et_sanity_check(struct ocfs2_extent_tree *et)\n{\n\tint ret = 0;\n\n\tif (et->et_ops->eo_sanity_check)\n\t\tret = et->et_ops->eo_sanity_check(et);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic inline int ocfs2_et_sanity_check(struct ocfs2_extent_tree *et)\n{\n\tint ret = 0;\n\n\tif (et->et_ops->eo_sanity_check)\n\t\tret = et->et_ops->eo_sanity_check(et);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_remove_rightmost_path(handle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_path *path,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, subtree_index;\n\tu32 cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\n\tret = ocfs2_et_sanity_check(et);\n\tif (ret)\n\t\tgoto out;\n\t/*\n\t * There's two ways we handle this depending on\n\t * whether path is the only existing one.\n\t */\n\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t      path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t    path, &cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (cpos) {\n\t\t/*\n\t\t * We have a path to the left of this one - it needs\n\t\t * an update too.\n\t\t */\n\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\tif (!left_path) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path, path);\n\n\t\tocfs2_unlink_subtree(handle, et, left_path, path,\n\t\t\t\t     subtree_index, dealloc);\n\t\tret = ocfs2_update_edge_lengths(handle, et, subtree_index,\n\t\t\t\t\t\tleft_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\t} else {\n\t\t/*\n\t\t * 'path' is also the leftmost path which\n\t\t * means it must be the only one. This gets\n\t\t * handled differently because we want to\n\t\t * revert the root back to having extents\n\t\t * in-line.\n\t\t */\n\t\tocfs2_unlink_path(handle, et, dealloc, path, 1);\n\n\t\tel = et->et_root_el;\n\t\tel->l_tree_depth = 0;\n\t\tel->l_next_free_rec = 0;\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\n\t\tocfs2_et_set_last_eb_blk(et, 0);\n\t}\n\n\tocfs2_journal_dirty(handle, path_root_bh(path));\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n}"
  },
  {
    "function_name": "__ocfs2_rotate_tree_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "2915-3029",
    "snippet": "static int __ocfs2_rotate_tree_left(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    int orig_credits,\n\t\t\t\t    struct ocfs2_path *path,\n\t\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t    struct ocfs2_path **empty_extent_path)\n{\n\tint ret, subtree_root, deleted;\n\tu32 right_cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\n\tBUG_ON(!ocfs2_is_empty_extent(&(path_leaf_el(path)->l_recs[0])));\n\n\t*empty_extent_path = NULL;\n\n\tret = ocfs2_find_cpos_for_right_leaf(sb, path, &right_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tleft_path = ocfs2_new_path_from_path(path);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_cp_path(left_path, path);\n\n\tright_path = ocfs2_new_path_from_path(path);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (right_cpos) {\n\t\tret = ocfs2_find_path(et->et_ci, right_path, right_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tsubtree_root = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t       right_path);\n\n\t\ttrace_ocfs2_rotate_subtree(subtree_root,\n\t\t     (unsigned long long)\n\t\t     right_path->p_node[subtree_root].bh->b_blocknr,\n\t\t     right_path->p_tree_depth);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, subtree_root,\n\t\t\t\t\t\t      orig_credits, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Caller might still want to make changes to the\n\t\t * tree root, so re-add it to the journal here.\n\t\t */\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   left_path, 0);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_subtree_left(handle, et, left_path,\n\t\t\t\t\t\tright_path, subtree_root,\n\t\t\t\t\t\tdealloc, &deleted);\n\t\tif (ret == -EAGAIN) {\n\t\t\t/*\n\t\t\t * The rotation has to temporarily stop due to\n\t\t\t * the right subtree having an empty\n\t\t\t * extent. Pass it back to the caller for a\n\t\t\t * fixup.\n\t\t\t */\n\t\t\t*empty_extent_path = right_path;\n\t\t\tright_path = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * The subtree rotate might have removed records on\n\t\t * the rightmost edge. If so, then rotation is\n\t\t * complete.\n\t\t */\n\t\tif (deleted)\n\t\t\tbreak;\n\n\t\tocfs2_mv_path(left_path, right_path);\n\n\t\tret = ocfs2_find_cpos_for_right_leaf(sb, left_path,\n\t\t\t\t\t\t     &right_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tocfs2_free_path(right_path);\n\tocfs2_free_path(left_path);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "left_path"
          ],
          "line": 3026
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "609-615",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_cpos_for_right_leaf",
          "args": [
            "sb",
            "left_path",
            "&right_cpos"
          ],
          "line": 3016
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_cpos_for_right_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2820-2888",
          "snippet": "int ocfs2_find_cpos_for_right_leaf(struct super_block *sb,\n\t\t\t\t   struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\t*cpos = 0;\n\n\tif (path->p_tree_depth == 0)\n\t\treturn 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tint next_free;\n\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just after the one in our\n\t\t * path.\n\t\t */\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == (next_free - 1)) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the rightmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The rightmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j + 1].e_cpos);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_find_cpos_for_right_leaf(struct super_block *sb,\n\t\t\t\t   struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\t*cpos = 0;\n\n\tif (path->p_tree_depth == 0)\n\t\treturn 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tint next_free;\n\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just after the one in our\n\t\t * path.\n\t\t */\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == (next_free - 1)) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the rightmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The rightmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j + 1].e_cpos);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mv_path",
          "args": [
            "left_path",
            "right_path"
          ],
          "line": 3014
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mv_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "647-663",
          "snippet": "static void ocfs2_mv_path(struct ocfs2_path *dest, struct ocfs2_path *src)\n{\n\tint i;\n\n\tBUG_ON(path_root_bh(dest) != path_root_bh(src));\n\tBUG_ON(path_root_access(dest) != path_root_access(src));\n\n\tfor(i = 1; i < OCFS2_MAX_PATH_DEPTH; i++) {\n\t\tbrelse(dest->p_node[i].bh);\n\n\t\tdest->p_node[i].bh = src->p_node[i].bh;\n\t\tdest->p_node[i].el = src->p_node[i].el;\n\n\t\tsrc->p_node[i].bh = NULL;\n\t\tsrc->p_node[i].el = NULL;\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_mv_path(struct ocfs2_path *dest, struct ocfs2_path *src)\n{\n\tint i;\n\n\tBUG_ON(path_root_bh(dest) != path_root_bh(src));\n\tBUG_ON(path_root_access(dest) != path_root_access(src));\n\n\tfor(i = 1; i < OCFS2_MAX_PATH_DEPTH; i++) {\n\t\tbrelse(dest->p_node[i].bh);\n\n\t\tdest->p_node[i].bh = src->p_node[i].bh;\n\t\tdest->p_node[i].el = src->p_node[i].el;\n\n\t\tsrc->p_node[i].bh = NULL;\n\t\tsrc->p_node[i].el = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rotate_subtree_left",
          "args": [
            "handle",
            "et",
            "left_path",
            "right_path",
            "subtree_root",
            "dealloc",
            "&deleted"
          ],
          "line": 2987
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rotate_subtree_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2655-2809",
          "snippet": "static int ocfs2_rotate_subtree_left(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_path *left_path,\n\t\t\t\t     struct ocfs2_path *right_path,\n\t\t\t\t     int subtree_index,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t     int *deleted)\n{\n\tint ret, i, del_right_subtree = 0, right_has_empty = 0;\n\tstruct buffer_head *root_bh, *et_root_bh = path_root_bh(right_path);\n\tstruct ocfs2_extent_list *right_leaf_el, *left_leaf_el;\n\tstruct ocfs2_extent_block *eb;\n\n\t*deleted = 0;\n\n\tright_leaf_el = path_leaf_el(right_path);\n\tleft_leaf_el = path_leaf_el(left_path);\n\troot_bh = left_path->p_node[subtree_index].bh;\n\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\tif (!ocfs2_is_empty_extent(&left_leaf_el->l_recs[0]))\n\t\treturn 0;\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(right_path)->b_data;\n\tif (ocfs2_is_empty_extent(&right_leaf_el->l_recs[0])) {\n\t\t/*\n\t\t * It's legal for us to proceed if the right leaf is\n\t\t * the rightmost one and it has an empty extent. There\n\t\t * are two cases to handle - whether the leaf will be\n\t\t * empty after removal or not. If the leaf isn't empty\n\t\t * then just remove the empty extent up front. The\n\t\t * next block will handle empty leaves by flagging\n\t\t * them for unlink.\n\t\t *\n\t\t * Non rightmost leaves will throw -EAGAIN and the\n\t\t * caller can manually move the subtree and retry.\n\t\t */\n\n\t\tif (eb->h_next_leaf_blk != 0ULL)\n\t\t\treturn -EAGAIN;\n\n\t\tif (le16_to_cpu(right_leaf_el->l_next_free_rec) > 1) {\n\t\t\tret = ocfs2_journal_access_eb(handle, et->et_ci,\n\t\t\t\t\t\t      path_leaf_bh(right_path),\n\t\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tocfs2_remove_empty_extent(right_leaf_el);\n\t\t} else\n\t\t\tright_has_empty = 1;\n\t}\n\n\tif (eb->h_next_leaf_blk == 0ULL &&\n\t    le16_to_cpu(right_leaf_el->l_next_free_rec) == 1) {\n\t\t/*\n\t\t * We have to update i_last_eb_blk during the meta\n\t\t * data delete.\n\t\t */\n\t\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdel_right_subtree = 1;\n\t}\n\n\t/*\n\t * Getting here with an empty extent in the right path implies\n\t * that it's the rightmost path and will be deleted.\n\t */\n\tBUG_ON(right_has_empty && !del_right_subtree);\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t   subtree_index);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tfor(i = subtree_index + 1; i < path_num_items(right_path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   right_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   left_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!right_has_empty) {\n\t\t/*\n\t\t * Only do this if we're moving a real\n\t\t * record. Otherwise, the action is delayed until\n\t\t * after removal of the right path in which case we\n\t\t * can do a simple shift to remove the empty extent.\n\t\t */\n\t\tocfs2_rotate_leaf(left_leaf_el, &right_leaf_el->l_recs[0]);\n\t\tmemset(&right_leaf_el->l_recs[0], 0,\n\t\t       sizeof(struct ocfs2_extent_rec));\n\t}\n\tif (eb->h_next_leaf_blk == 0ULL) {\n\t\t/*\n\t\t * Move recs over to get rid of empty extent, decrease\n\t\t * next_free. This is allowed to remove the last\n\t\t * extent in our leaf (setting l_next_free_rec to\n\t\t * zero) - the delete code below won't care.\n\t\t */\n\t\tocfs2_remove_empty_extent(right_leaf_el);\n\t}\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\tocfs2_journal_dirty(handle, path_leaf_bh(right_path));\n\n\tif (del_right_subtree) {\n\t\tocfs2_unlink_subtree(handle, et, left_path, right_path,\n\t\t\t\t     subtree_index, dealloc);\n\t\tret = ocfs2_update_edge_lengths(handle, et, subtree_index,\n\t\t\t\t\t\tleft_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\n\t\t/*\n\t\t * Removal of the extent in the left leaf was skipped\n\t\t * above so we could delete the right path\n\t\t * 1st.\n\t\t */\n\t\tif (right_has_empty)\n\t\t\tocfs2_remove_empty_extent(left_leaf_el);\n\n\t\tocfs2_journal_dirty(handle, et_root_bh);\n\n\t\t*deleted = 1;\n\t} else\n\t\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t\t   subtree_index);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_rotate_subtree_left(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_path *left_path,\n\t\t\t\t     struct ocfs2_path *right_path,\n\t\t\t\t     int subtree_index,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t     int *deleted)\n{\n\tint ret, i, del_right_subtree = 0, right_has_empty = 0;\n\tstruct buffer_head *root_bh, *et_root_bh = path_root_bh(right_path);\n\tstruct ocfs2_extent_list *right_leaf_el, *left_leaf_el;\n\tstruct ocfs2_extent_block *eb;\n\n\t*deleted = 0;\n\n\tright_leaf_el = path_leaf_el(right_path);\n\tleft_leaf_el = path_leaf_el(left_path);\n\troot_bh = left_path->p_node[subtree_index].bh;\n\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\tif (!ocfs2_is_empty_extent(&left_leaf_el->l_recs[0]))\n\t\treturn 0;\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(right_path)->b_data;\n\tif (ocfs2_is_empty_extent(&right_leaf_el->l_recs[0])) {\n\t\t/*\n\t\t * It's legal for us to proceed if the right leaf is\n\t\t * the rightmost one and it has an empty extent. There\n\t\t * are two cases to handle - whether the leaf will be\n\t\t * empty after removal or not. If the leaf isn't empty\n\t\t * then just remove the empty extent up front. The\n\t\t * next block will handle empty leaves by flagging\n\t\t * them for unlink.\n\t\t *\n\t\t * Non rightmost leaves will throw -EAGAIN and the\n\t\t * caller can manually move the subtree and retry.\n\t\t */\n\n\t\tif (eb->h_next_leaf_blk != 0ULL)\n\t\t\treturn -EAGAIN;\n\n\t\tif (le16_to_cpu(right_leaf_el->l_next_free_rec) > 1) {\n\t\t\tret = ocfs2_journal_access_eb(handle, et->et_ci,\n\t\t\t\t\t\t      path_leaf_bh(right_path),\n\t\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tocfs2_remove_empty_extent(right_leaf_el);\n\t\t} else\n\t\t\tright_has_empty = 1;\n\t}\n\n\tif (eb->h_next_leaf_blk == 0ULL &&\n\t    le16_to_cpu(right_leaf_el->l_next_free_rec) == 1) {\n\t\t/*\n\t\t * We have to update i_last_eb_blk during the meta\n\t\t * data delete.\n\t\t */\n\t\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdel_right_subtree = 1;\n\t}\n\n\t/*\n\t * Getting here with an empty extent in the right path implies\n\t * that it's the rightmost path and will be deleted.\n\t */\n\tBUG_ON(right_has_empty && !del_right_subtree);\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t   subtree_index);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tfor(i = subtree_index + 1; i < path_num_items(right_path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   right_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   left_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!right_has_empty) {\n\t\t/*\n\t\t * Only do this if we're moving a real\n\t\t * record. Otherwise, the action is delayed until\n\t\t * after removal of the right path in which case we\n\t\t * can do a simple shift to remove the empty extent.\n\t\t */\n\t\tocfs2_rotate_leaf(left_leaf_el, &right_leaf_el->l_recs[0]);\n\t\tmemset(&right_leaf_el->l_recs[0], 0,\n\t\t       sizeof(struct ocfs2_extent_rec));\n\t}\n\tif (eb->h_next_leaf_blk == 0ULL) {\n\t\t/*\n\t\t * Move recs over to get rid of empty extent, decrease\n\t\t * next_free. This is allowed to remove the last\n\t\t * extent in our leaf (setting l_next_free_rec to\n\t\t * zero) - the delete code below won't care.\n\t\t */\n\t\tocfs2_remove_empty_extent(right_leaf_el);\n\t}\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\tocfs2_journal_dirty(handle, path_leaf_bh(right_path));\n\n\tif (del_right_subtree) {\n\t\tocfs2_unlink_subtree(handle, et, left_path, right_path,\n\t\t\t\t     subtree_index, dealloc);\n\t\tret = ocfs2_update_edge_lengths(handle, et, subtree_index,\n\t\t\t\t\t\tleft_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\n\t\t/*\n\t\t * Removal of the extent in the left leaf was skipped\n\t\t * above so we could delete the right path\n\t\t * 1st.\n\t\t */\n\t\tif (right_has_empty)\n\t\t\tocfs2_remove_empty_extent(left_leaf_el);\n\n\t\tocfs2_journal_dirty(handle, et_root_bh);\n\n\t\t*deleted = 1;\n\t} else\n\t\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t\t   subtree_index);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_path_bh_journal_access",
          "args": [
            "handle",
            "et->et_ci",
            "left_path",
            "0"
          ],
          "line": 2980
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_path_bh_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "726-741",
          "snippet": "int ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_rotate_transaction",
          "args": [
            "handle",
            "subtree_root",
            "orig_credits",
            "left_path"
          ],
          "line": 2969
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_rotate_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2279-2291",
          "snippet": "static int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,\n\t\t\t\t\t   int op_credits,\n\t\t\t\t\t   struct ocfs2_path *path)\n{\n\tint ret = 0;\n\tint credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;\n\n\tif (handle->h_buffer_credits < credits)\n\t\tret = ocfs2_extend_trans(handle,\n\t\t\t\t\t credits - handle->h_buffer_credits);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,\n\t\t\t\t\t   int op_credits,\n\t\t\t\t\t   struct ocfs2_path *path)\n{\n\tint ret = 0;\n\tint credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;\n\n\tif (handle->h_buffer_credits < credits)\n\t\tret = ocfs2_extend_trans(handle,\n\t\t\t\t\t credits - handle->h_buffer_credits);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_rotate_subtree",
          "args": [
            "subtree_root",
            "(unsigned long long)\n\t\t     right_path->p_node[subtree_root].bh->b_blocknr",
            "right_path->p_tree_depth"
          ],
          "line": 2964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_subtree_root",
          "args": [
            "et",
            "left_path",
            "right_path"
          ],
          "line": 2961
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_subtree_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1737-1765",
          "snippet": "int ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "et->et_ci",
            "right_path",
            "right_cpos"
          ],
          "line": 2955
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1885-1894",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_path",
          "args": [
            "path"
          ],
          "line": 2947
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "707-711",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_cp_path",
          "args": [
            "left_path",
            "path"
          ],
          "line": 2945
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cp_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "624-641",
          "snippet": "static void ocfs2_cp_path(struct ocfs2_path *dest, struct ocfs2_path *src)\n{\n\tint i;\n\n\tBUG_ON(path_root_bh(dest) != path_root_bh(src));\n\tBUG_ON(path_root_el(dest) != path_root_el(src));\n\tBUG_ON(path_root_access(dest) != path_root_access(src));\n\n\tocfs2_reinit_path(dest, 1);\n\n\tfor(i = 1; i < OCFS2_MAX_PATH_DEPTH; i++) {\n\t\tdest->p_node[i].bh = src->p_node[i].bh;\n\t\tdest->p_node[i].el = src->p_node[i].el;\n\n\t\tif (dest->p_node[i].bh)\n\t\t\tget_bh(dest->p_node[i].bh);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_cp_path(struct ocfs2_path *dest, struct ocfs2_path *src)\n{\n\tint i;\n\n\tBUG_ON(path_root_bh(dest) != path_root_bh(src));\n\tBUG_ON(path_root_el(dest) != path_root_el(src));\n\tBUG_ON(path_root_access(dest) != path_root_access(src));\n\n\tocfs2_reinit_path(dest, 1);\n\n\tfor(i = 1; i < OCFS2_MAX_PATH_DEPTH; i++) {\n\t\tdest->p_node[i].bh = src->p_node[i].bh;\n\t\tdest->p_node[i].el = src->p_node[i].el;\n\n\t\tif (dest->p_node[i].bh)\n\t\t\tget_bh(dest->p_node[i].bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ocfs2_is_empty_extent(&(path_leaf_el(path)->l_recs[0]))"
          ],
          "line": 2928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&(path_leaf_el(path)->l_recs[0])"
          ],
          "line": 2928
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "266-269",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 2928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 2926
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int __ocfs2_rotate_tree_left(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    int orig_credits,\n\t\t\t\t    struct ocfs2_path *path,\n\t\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t    struct ocfs2_path **empty_extent_path)\n{\n\tint ret, subtree_root, deleted;\n\tu32 right_cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\n\tBUG_ON(!ocfs2_is_empty_extent(&(path_leaf_el(path)->l_recs[0])));\n\n\t*empty_extent_path = NULL;\n\n\tret = ocfs2_find_cpos_for_right_leaf(sb, path, &right_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tleft_path = ocfs2_new_path_from_path(path);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_cp_path(left_path, path);\n\n\tright_path = ocfs2_new_path_from_path(path);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (right_cpos) {\n\t\tret = ocfs2_find_path(et->et_ci, right_path, right_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tsubtree_root = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t       right_path);\n\n\t\ttrace_ocfs2_rotate_subtree(subtree_root,\n\t\t     (unsigned long long)\n\t\t     right_path->p_node[subtree_root].bh->b_blocknr,\n\t\t     right_path->p_tree_depth);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, subtree_root,\n\t\t\t\t\t\t      orig_credits, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Caller might still want to make changes to the\n\t\t * tree root, so re-add it to the journal here.\n\t\t */\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   left_path, 0);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_subtree_left(handle, et, left_path,\n\t\t\t\t\t\tright_path, subtree_root,\n\t\t\t\t\t\tdealloc, &deleted);\n\t\tif (ret == -EAGAIN) {\n\t\t\t/*\n\t\t\t * The rotation has to temporarily stop due to\n\t\t\t * the right subtree having an empty\n\t\t\t * extent. Pass it back to the caller for a\n\t\t\t * fixup.\n\t\t\t */\n\t\t\t*empty_extent_path = right_path;\n\t\t\tright_path = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * The subtree rotate might have removed records on\n\t\t * the rightmost edge. If so, then rotation is\n\t\t * complete.\n\t\t */\n\t\tif (deleted)\n\t\t\tbreak;\n\n\t\tocfs2_mv_path(left_path, right_path);\n\n\t\tret = ocfs2_find_cpos_for_right_leaf(sb, left_path,\n\t\t\t\t\t\t     &right_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tocfs2_free_path(right_path);\n\tocfs2_free_path(left_path);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_rotate_rightmost_leaf_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "2890-2913",
    "snippet": "static int ocfs2_rotate_rightmost_leaf_left(handle_t *handle,\n\t\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t\t    struct ocfs2_path *path)\n{\n\tint ret;\n\tstruct buffer_head *bh = path_leaf_bh(path);\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\n\tif (!ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn 0;\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, path,\n\t\t\t\t\t   path_num_items(path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_remove_empty_extent(el);\n\tocfs2_journal_dirty(handle, bh);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "bh"
          ],
          "line": 2909
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_empty_extent",
          "args": [
            "el"
          ],
          "line": 2908
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1677-1691",
          "snippet": "static void ocfs2_remove_empty_extent(struct ocfs2_extent_list *el)\n{\n\tint size, num_recs = le16_to_cpu(el->l_next_free_rec);\n\n\tBUG_ON(num_recs == 0);\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0])) {\n\t\tnum_recs--;\n\t\tsize = num_recs * sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[0], &el->l_recs[1], size);\n\t\tmemset(&el->l_recs[num_recs], 0,\n\t\t       sizeof(struct ocfs2_extent_rec));\n\t\tel->l_next_free_rec = cpu_to_le16(num_recs);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_remove_empty_extent(struct ocfs2_extent_list *el)\n{\n\tint size, num_recs = le16_to_cpu(el->l_next_free_rec);\n\n\tBUG_ON(num_recs == 0);\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0])) {\n\t\tnum_recs--;\n\t\tsize = num_recs * sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[0], &el->l_recs[1], size);\n\t\tmemset(&el->l_recs[num_recs], 0,\n\t\t       sizeof(struct ocfs2_extent_rec));\n\t\tel->l_next_free_rec = cpu_to_le16(num_recs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_path_bh_journal_access",
          "args": [
            "handle",
            "et->et_ci",
            "path",
            "path_num_items(path) - 1"
          ],
          "line": 2901
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_path_bh_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "726-741",
          "snippet": "int ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_num_items",
          "args": [
            "path"
          ],
          "line": 2902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&el->l_recs[0]"
          ],
          "line": 2898
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "266-269",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 2896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "path"
          ],
          "line": 2895
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_rotate_rightmost_leaf_left(handle_t *handle,\n\t\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t\t    struct ocfs2_path *path)\n{\n\tint ret;\n\tstruct buffer_head *bh = path_leaf_bh(path);\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\n\tif (!ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn 0;\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, path,\n\t\t\t\t\t   path_num_items(path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_remove_empty_extent(el);\n\tocfs2_journal_dirty(handle, bh);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_find_cpos_for_right_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "2820-2888",
    "snippet": "int ocfs2_find_cpos_for_right_leaf(struct super_block *sb,\n\t\t\t\t   struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\t*cpos = 0;\n\n\tif (path->p_tree_depth == 0)\n\t\treturn 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tint next_free;\n\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just after the one in our\n\t\t * path.\n\t\t */\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == (next_free - 1)) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the rightmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The rightmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j + 1].e_cpos);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "sb",
            "\"Invalid extent tree at extent block %llu\\n\"",
            "(unsigned long long)blkno"
          ],
          "line": 2875
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "el->l_recs[j + 1].e_cpos"
          ],
          "line": 2866
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "el->l_recs[j].e_blkno"
          ],
          "line": 2847
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 2846
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "path"
          ],
          "line": 2832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_find_cpos_for_right_leaf(struct super_block *sb,\n\t\t\t\t   struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\t*cpos = 0;\n\n\tif (path->p_tree_depth == 0)\n\t\treturn 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tint next_free;\n\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just after the one in our\n\t\t * path.\n\t\t */\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == (next_free - 1)) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the rightmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The rightmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j + 1].e_cpos);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_rotate_subtree_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "2655-2809",
    "snippet": "static int ocfs2_rotate_subtree_left(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_path *left_path,\n\t\t\t\t     struct ocfs2_path *right_path,\n\t\t\t\t     int subtree_index,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t     int *deleted)\n{\n\tint ret, i, del_right_subtree = 0, right_has_empty = 0;\n\tstruct buffer_head *root_bh, *et_root_bh = path_root_bh(right_path);\n\tstruct ocfs2_extent_list *right_leaf_el, *left_leaf_el;\n\tstruct ocfs2_extent_block *eb;\n\n\t*deleted = 0;\n\n\tright_leaf_el = path_leaf_el(right_path);\n\tleft_leaf_el = path_leaf_el(left_path);\n\troot_bh = left_path->p_node[subtree_index].bh;\n\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\tif (!ocfs2_is_empty_extent(&left_leaf_el->l_recs[0]))\n\t\treturn 0;\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(right_path)->b_data;\n\tif (ocfs2_is_empty_extent(&right_leaf_el->l_recs[0])) {\n\t\t/*\n\t\t * It's legal for us to proceed if the right leaf is\n\t\t * the rightmost one and it has an empty extent. There\n\t\t * are two cases to handle - whether the leaf will be\n\t\t * empty after removal or not. If the leaf isn't empty\n\t\t * then just remove the empty extent up front. The\n\t\t * next block will handle empty leaves by flagging\n\t\t * them for unlink.\n\t\t *\n\t\t * Non rightmost leaves will throw -EAGAIN and the\n\t\t * caller can manually move the subtree and retry.\n\t\t */\n\n\t\tif (eb->h_next_leaf_blk != 0ULL)\n\t\t\treturn -EAGAIN;\n\n\t\tif (le16_to_cpu(right_leaf_el->l_next_free_rec) > 1) {\n\t\t\tret = ocfs2_journal_access_eb(handle, et->et_ci,\n\t\t\t\t\t\t      path_leaf_bh(right_path),\n\t\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tocfs2_remove_empty_extent(right_leaf_el);\n\t\t} else\n\t\t\tright_has_empty = 1;\n\t}\n\n\tif (eb->h_next_leaf_blk == 0ULL &&\n\t    le16_to_cpu(right_leaf_el->l_next_free_rec) == 1) {\n\t\t/*\n\t\t * We have to update i_last_eb_blk during the meta\n\t\t * data delete.\n\t\t */\n\t\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdel_right_subtree = 1;\n\t}\n\n\t/*\n\t * Getting here with an empty extent in the right path implies\n\t * that it's the rightmost path and will be deleted.\n\t */\n\tBUG_ON(right_has_empty && !del_right_subtree);\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t   subtree_index);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tfor(i = subtree_index + 1; i < path_num_items(right_path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   right_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   left_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!right_has_empty) {\n\t\t/*\n\t\t * Only do this if we're moving a real\n\t\t * record. Otherwise, the action is delayed until\n\t\t * after removal of the right path in which case we\n\t\t * can do a simple shift to remove the empty extent.\n\t\t */\n\t\tocfs2_rotate_leaf(left_leaf_el, &right_leaf_el->l_recs[0]);\n\t\tmemset(&right_leaf_el->l_recs[0], 0,\n\t\t       sizeof(struct ocfs2_extent_rec));\n\t}\n\tif (eb->h_next_leaf_blk == 0ULL) {\n\t\t/*\n\t\t * Move recs over to get rid of empty extent, decrease\n\t\t * next_free. This is allowed to remove the last\n\t\t * extent in our leaf (setting l_next_free_rec to\n\t\t * zero) - the delete code below won't care.\n\t\t */\n\t\tocfs2_remove_empty_extent(right_leaf_el);\n\t}\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\tocfs2_journal_dirty(handle, path_leaf_bh(right_path));\n\n\tif (del_right_subtree) {\n\t\tocfs2_unlink_subtree(handle, et, left_path, right_path,\n\t\t\t\t     subtree_index, dealloc);\n\t\tret = ocfs2_update_edge_lengths(handle, et, subtree_index,\n\t\t\t\t\t\tleft_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\n\t\t/*\n\t\t * Removal of the extent in the left leaf was skipped\n\t\t * above so we could delete the right path\n\t\t * 1st.\n\t\t */\n\t\tif (right_has_empty)\n\t\t\tocfs2_remove_empty_extent(left_leaf_el);\n\n\t\tocfs2_journal_dirty(handle, et_root_bh);\n\n\t\t*deleted = 1;\n\t} else\n\t\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t\t   subtree_index);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_complete_edge_insert",
          "args": [
            "handle",
            "left_path",
            "right_path",
            "subtree_index"
          ],
          "line": 2804
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_complete_edge_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2030-2099",
          "snippet": "static void ocfs2_complete_edge_insert(handle_t *handle,\n\t\t\t\t       struct ocfs2_path *left_path,\n\t\t\t\t       struct ocfs2_path *right_path,\n\t\t\t\t       int subtree_index)\n{\n\tint i, idx;\n\tstruct ocfs2_extent_list *el, *left_el, *right_el;\n\tstruct ocfs2_extent_rec *left_rec, *right_rec;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\n\t/*\n\t * Update the counts and position values within all the\n\t * interior nodes to reflect the leaf rotation we just did.\n\t *\n\t * The root node is handled below the loop.\n\t *\n\t * We begin the loop with right_el and left_el pointing to the\n\t * leaf lists and work our way up.\n\t *\n\t * NOTE: within this loop, left_el and right_el always refer\n\t * to the *child* lists.\n\t */\n\tleft_el = path_leaf_el(left_path);\n\tright_el = path_leaf_el(right_path);\n\tfor(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {\n\t\ttrace_ocfs2_complete_edge_insert(i);\n\n\t\t/*\n\t\t * One nice property of knowing that all of these\n\t\t * nodes are below the root is that we only deal with\n\t\t * the leftmost right node record and the rightmost\n\t\t * left node record.\n\t\t */\n\t\tel = left_path->p_node[i].el;\n\t\tidx = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\t\tleft_rec = &el->l_recs[idx];\n\n\t\tel = right_path->p_node[i].el;\n\t\tright_rec = &el->l_recs[0];\n\n\t\tocfs2_adjust_adjacent_records(left_rec, left_el, right_rec,\n\t\t\t\t\t      right_el);\n\n\t\tocfs2_journal_dirty(handle, left_path->p_node[i].bh);\n\t\tocfs2_journal_dirty(handle, right_path->p_node[i].bh);\n\n\t\t/*\n\t\t * Setup our list pointers now so that the current\n\t\t * parents become children in the next iteration.\n\t\t */\n\t\tleft_el = left_path->p_node[i].el;\n\t\tright_el = right_path->p_node[i].el;\n\t}\n\n\t/*\n\t * At the root node, adjust the two adjacent records which\n\t * begin our path to the leaves.\n\t */\n\n\tel = left_path->p_node[subtree_index].el;\n\tleft_el = left_path->p_node[subtree_index + 1].el;\n\tright_el = right_path->p_node[subtree_index + 1].el;\n\n\tocfs2_adjust_root_records(el, left_el, right_el,\n\t\t\t\t  left_path->p_node[subtree_index + 1].bh->b_blocknr);\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\n\tocfs2_journal_dirty(handle, root_bh);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_complete_edge_insert(handle_t *handle,\n\t\t\t\t       struct ocfs2_path *left_path,\n\t\t\t\t       struct ocfs2_path *right_path,\n\t\t\t\t       int subtree_index)\n{\n\tint i, idx;\n\tstruct ocfs2_extent_list *el, *left_el, *right_el;\n\tstruct ocfs2_extent_rec *left_rec, *right_rec;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\n\t/*\n\t * Update the counts and position values within all the\n\t * interior nodes to reflect the leaf rotation we just did.\n\t *\n\t * The root node is handled below the loop.\n\t *\n\t * We begin the loop with right_el and left_el pointing to the\n\t * leaf lists and work our way up.\n\t *\n\t * NOTE: within this loop, left_el and right_el always refer\n\t * to the *child* lists.\n\t */\n\tleft_el = path_leaf_el(left_path);\n\tright_el = path_leaf_el(right_path);\n\tfor(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {\n\t\ttrace_ocfs2_complete_edge_insert(i);\n\n\t\t/*\n\t\t * One nice property of knowing that all of these\n\t\t * nodes are below the root is that we only deal with\n\t\t * the leftmost right node record and the rightmost\n\t\t * left node record.\n\t\t */\n\t\tel = left_path->p_node[i].el;\n\t\tidx = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\t\tleft_rec = &el->l_recs[idx];\n\n\t\tel = right_path->p_node[i].el;\n\t\tright_rec = &el->l_recs[0];\n\n\t\tocfs2_adjust_adjacent_records(left_rec, left_el, right_rec,\n\t\t\t\t\t      right_el);\n\n\t\tocfs2_journal_dirty(handle, left_path->p_node[i].bh);\n\t\tocfs2_journal_dirty(handle, right_path->p_node[i].bh);\n\n\t\t/*\n\t\t * Setup our list pointers now so that the current\n\t\t * parents become children in the next iteration.\n\t\t */\n\t\tleft_el = left_path->p_node[i].el;\n\t\tright_el = right_path->p_node[i].el;\n\t}\n\n\t/*\n\t * At the root node, adjust the two adjacent records which\n\t * begin our path to the leaves.\n\t */\n\n\tel = left_path->p_node[subtree_index].el;\n\tleft_el = left_path->p_node[subtree_index + 1].el;\n\tright_el = right_path->p_node[subtree_index + 1].el;\n\n\tocfs2_adjust_root_records(el, left_el, right_el,\n\t\t\t\t  left_path->p_node[subtree_index + 1].bh->b_blocknr);\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\n\tocfs2_journal_dirty(handle, root_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "et_root_bh"
          ],
          "line": 2800
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_empty_extent",
          "args": [
            "left_leaf_el"
          ],
          "line": 2798
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1677-1691",
          "snippet": "static void ocfs2_remove_empty_extent(struct ocfs2_extent_list *el)\n{\n\tint size, num_recs = le16_to_cpu(el->l_next_free_rec);\n\n\tBUG_ON(num_recs == 0);\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0])) {\n\t\tnum_recs--;\n\t\tsize = num_recs * sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[0], &el->l_recs[1], size);\n\t\tmemset(&el->l_recs[num_recs], 0,\n\t\t       sizeof(struct ocfs2_extent_rec));\n\t\tel->l_next_free_rec = cpu_to_le16(num_recs);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_remove_empty_extent(struct ocfs2_extent_list *el)\n{\n\tint size, num_recs = le16_to_cpu(el->l_next_free_rec);\n\n\tBUG_ON(num_recs == 0);\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0])) {\n\t\tnum_recs--;\n\t\tsize = num_recs * sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[0], &el->l_recs[1], size);\n\t\tmemset(&el->l_recs[num_recs], 0,\n\t\t       sizeof(struct ocfs2_extent_rec));\n\t\tel->l_next_free_rec = cpu_to_le16(num_recs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_et_set_last_eb_blk",
          "args": [
            "et",
            "le64_to_cpu(eb->h_blkno)"
          ],
          "line": 2790
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_set_last_eb_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "498-502",
          "snippet": "static inline void ocfs2_et_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u64 new_last_eb_blk)\n{\n\tet->et_ops->eo_set_last_eb_blk(et, new_last_eb_blk);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic inline void ocfs2_et_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u64 new_last_eb_blk)\n{\n\tet->et_ops->eo_set_last_eb_blk(et, new_last_eb_blk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "eb->h_blkno"
          ],
          "line": 2790
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "left_path"
          ],
          "line": 2789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_update_edge_lengths",
          "args": [
            "handle",
            "et",
            "subtree_index",
            "left_path"
          ],
          "line": 2782
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_edge_lengths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2519-2572",
          "snippet": "static int ocfs2_update_edge_lengths(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     int subtree_index, struct ocfs2_path *path)\n{\n\tint i, idx, ret;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_block *eb;\n\tu32 range;\n\n\t/*\n\t * In normal tree rotation process, we will never touch the\n\t * tree branch above subtree_index and ocfs2_extend_rotate_transaction\n\t * doesn't reserve the credits for them either.\n\t *\n\t * But we do have a special case here which will update the rightmost\n\t * records for all the bh in the path.\n\t * So we have to allocate extra credits and access them.\n\t */\n\tret = ocfs2_extend_trans(handle, subtree_index);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Path should always be rightmost. */\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\tBUG_ON(eb->h_next_leaf_blk != 0ULL);\n\n\tel = &eb->h_list;\n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) == 0);\n\tidx = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[idx];\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tel = path->p_node[i].el;\n\t\tidx = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\trec = &el->l_recs[idx];\n\n\t\trec->e_int_clusters = cpu_to_le32(range);\n\t\tle32_add_cpu(&rec->e_int_clusters, -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, path->p_node[i].bh);\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_update_edge_lengths(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     int subtree_index, struct ocfs2_path *path)\n{\n\tint i, idx, ret;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_block *eb;\n\tu32 range;\n\n\t/*\n\t * In normal tree rotation process, we will never touch the\n\t * tree branch above subtree_index and ocfs2_extend_rotate_transaction\n\t * doesn't reserve the credits for them either.\n\t *\n\t * But we do have a special case here which will update the rightmost\n\t * records for all the bh in the path.\n\t * So we have to allocate extra credits and access them.\n\t */\n\tret = ocfs2_extend_trans(handle, subtree_index);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Path should always be rightmost. */\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\tBUG_ON(eb->h_next_leaf_blk != 0ULL);\n\n\tel = &eb->h_list;\n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) == 0);\n\tidx = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[idx];\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tel = path->p_node[i].el;\n\t\tidx = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\trec = &el->l_recs[idx];\n\n\t\trec->e_int_clusters = cpu_to_le32(range);\n\t\tle32_add_cpu(&rec->e_int_clusters, -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, path->p_node[i].bh);\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_unlink_subtree",
          "args": [
            "handle",
            "et",
            "left_path",
            "right_path",
            "subtree_index",
            "dealloc"
          ],
          "line": 2780
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlink_subtree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2619-2653",
          "snippet": "static void ocfs2_unlink_subtree(handle_t *handle,\n\t\t\t\t struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_path *left_path,\n\t\t\t\t struct ocfs2_path *right_path,\n\t\t\t\t int subtree_index,\n\t\t\t\t struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint i;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\tstruct ocfs2_extent_list *root_el = left_path->p_node[subtree_index].el;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_block *eb;\n\n\tel = path_leaf_el(left_path);\n\n\teb = (struct ocfs2_extent_block *)right_path->p_node[subtree_index + 1].bh->b_data;\n\n\tfor(i = 1; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\tif (root_el->l_recs[i].e_blkno == eb->h_blkno)\n\t\t\tbreak;\n\n\tBUG_ON(i >= le16_to_cpu(root_el->l_next_free_rec));\n\n\tmemset(&root_el->l_recs[i], 0, sizeof(struct ocfs2_extent_rec));\n\tle16_add_cpu(&root_el->l_next_free_rec, -1);\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\teb->h_next_leaf_blk = 0;\n\n\tocfs2_journal_dirty(handle, root_bh);\n\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\n\tocfs2_unlink_path(handle, et, dealloc, right_path,\n\t\t\t  subtree_index + 1);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic void ocfs2_unlink_subtree(handle_t *handle,\n\t\t\t\t struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_path *left_path,\n\t\t\t\t struct ocfs2_path *right_path,\n\t\t\t\t int subtree_index,\n\t\t\t\t struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint i;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\tstruct ocfs2_extent_list *root_el = left_path->p_node[subtree_index].el;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_block *eb;\n\n\tel = path_leaf_el(left_path);\n\n\teb = (struct ocfs2_extent_block *)right_path->p_node[subtree_index + 1].bh->b_data;\n\n\tfor(i = 1; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\tif (root_el->l_recs[i].e_blkno == eb->h_blkno)\n\t\t\tbreak;\n\n\tBUG_ON(i >= le16_to_cpu(root_el->l_next_free_rec));\n\n\tmemset(&root_el->l_recs[i], 0, sizeof(struct ocfs2_extent_rec));\n\tle16_add_cpu(&root_el->l_next_free_rec, -1);\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\teb->h_next_leaf_blk = 0;\n\n\tocfs2_journal_dirty(handle, root_bh);\n\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\n\tocfs2_unlink_path(handle, et, dealloc, right_path,\n\t\t\t  subtree_index + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "right_path"
          ],
          "line": 2777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "left_path"
          ],
          "line": 2776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&right_leaf_el->l_recs[0]",
            "0",
            "sizeof(struct ocfs2_extent_rec)"
          ],
          "line": 2763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rotate_leaf",
          "args": [
            "left_leaf_el",
            "&right_leaf_el->l_recs[0]"
          ],
          "line": 2762
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rotate_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1598-1675",
          "snippet": "static void ocfs2_rotate_leaf(struct ocfs2_extent_list *el,\n\t\t\t      struct ocfs2_extent_rec *insert_rec)\n{\n\tint i, insert_index, next_free, has_empty, num_bytes;\n\tu32 insert_cpos = le32_to_cpu(insert_rec->e_cpos);\n\tstruct ocfs2_extent_rec *rec;\n\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\thas_empty = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\tBUG_ON(!next_free);\n\n\t/* The tree code before us didn't allow enough room in the leaf. */\n\tBUG_ON(el->l_next_free_rec == el->l_count && !has_empty);\n\n\t/*\n\t * The easiest way to approach this is to just remove the\n\t * empty extent and temporarily decrement next_free.\n\t */\n\tif (has_empty) {\n\t\t/*\n\t\t * If next_free was 1 (only an empty extent), this\n\t\t * loop won't execute, which is fine. We still want\n\t\t * the decrement above to happen.\n\t\t */\n\t\tfor(i = 0; i < (next_free - 1); i++)\n\t\t\tel->l_recs[i] = el->l_recs[i+1];\n\n\t\tnext_free--;\n\t}\n\n\t/*\n\t * Figure out what the new record index should be.\n\t */\n\tfor(i = 0; i < next_free; i++) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (insert_cpos < le32_to_cpu(rec->e_cpos))\n\t\t\tbreak;\n\t}\n\tinsert_index = i;\n\n\ttrace_ocfs2_rotate_leaf(insert_cpos, insert_index,\n\t\t\t\thas_empty, next_free,\n\t\t\t\tle16_to_cpu(el->l_count));\n\n\tBUG_ON(insert_index < 0);\n\tBUG_ON(insert_index >= le16_to_cpu(el->l_count));\n\tBUG_ON(insert_index > next_free);\n\n\t/*\n\t * No need to memmove if we're just adding to the tail.\n\t */\n\tif (insert_index != next_free) {\n\t\tBUG_ON(next_free >= le16_to_cpu(el->l_count));\n\n\t\tnum_bytes = next_free - insert_index;\n\t\tnum_bytes *= sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[insert_index + 1],\n\t\t\t&el->l_recs[insert_index],\n\t\t\tnum_bytes);\n\t}\n\n\t/*\n\t * Either we had an empty extent, and need to re-increment or\n\t * there was no empty extent on a non full rightmost leaf node,\n\t * in which case we still need to increment.\n\t */\n\tnext_free++;\n\tel->l_next_free_rec = cpu_to_le16(next_free);\n\t/*\n\t * Make sure none of the math above just messed up our tree.\n\t */\n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) > le16_to_cpu(el->l_count));\n\n\tel->l_recs[insert_index] = *insert_rec;\n\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_rotate_leaf(struct ocfs2_extent_list *el,\n\t\t\t      struct ocfs2_extent_rec *insert_rec)\n{\n\tint i, insert_index, next_free, has_empty, num_bytes;\n\tu32 insert_cpos = le32_to_cpu(insert_rec->e_cpos);\n\tstruct ocfs2_extent_rec *rec;\n\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\thas_empty = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\tBUG_ON(!next_free);\n\n\t/* The tree code before us didn't allow enough room in the leaf. */\n\tBUG_ON(el->l_next_free_rec == el->l_count && !has_empty);\n\n\t/*\n\t * The easiest way to approach this is to just remove the\n\t * empty extent and temporarily decrement next_free.\n\t */\n\tif (has_empty) {\n\t\t/*\n\t\t * If next_free was 1 (only an empty extent), this\n\t\t * loop won't execute, which is fine. We still want\n\t\t * the decrement above to happen.\n\t\t */\n\t\tfor(i = 0; i < (next_free - 1); i++)\n\t\t\tel->l_recs[i] = el->l_recs[i+1];\n\n\t\tnext_free--;\n\t}\n\n\t/*\n\t * Figure out what the new record index should be.\n\t */\n\tfor(i = 0; i < next_free; i++) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (insert_cpos < le32_to_cpu(rec->e_cpos))\n\t\t\tbreak;\n\t}\n\tinsert_index = i;\n\n\ttrace_ocfs2_rotate_leaf(insert_cpos, insert_index,\n\t\t\t\thas_empty, next_free,\n\t\t\t\tle16_to_cpu(el->l_count));\n\n\tBUG_ON(insert_index < 0);\n\tBUG_ON(insert_index >= le16_to_cpu(el->l_count));\n\tBUG_ON(insert_index > next_free);\n\n\t/*\n\t * No need to memmove if we're just adding to the tail.\n\t */\n\tif (insert_index != next_free) {\n\t\tBUG_ON(next_free >= le16_to_cpu(el->l_count));\n\n\t\tnum_bytes = next_free - insert_index;\n\t\tnum_bytes *= sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[insert_index + 1],\n\t\t\t&el->l_recs[insert_index],\n\t\t\tnum_bytes);\n\t}\n\n\t/*\n\t * Either we had an empty extent, and need to re-increment or\n\t * there was no empty extent on a non full rightmost leaf node,\n\t * in which case we still need to increment.\n\t */\n\tnext_free++;\n\tel->l_next_free_rec = cpu_to_le16(next_free);\n\t/*\n\t * Make sure none of the math above just messed up our tree.\n\t */\n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) > le16_to_cpu(el->l_count));\n\n\tel->l_recs[insert_index] = *insert_rec;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_path_bh_journal_access",
          "args": [
            "handle",
            "et->et_ci",
            "left_path",
            "i"
          ],
          "line": 2747
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_path_bh_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "726-741",
          "snippet": "int ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_num_items",
          "args": [
            "right_path"
          ],
          "line": 2739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "right_has_empty && !del_right_subtree"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_et_root_journal_access",
          "args": [
            "handle",
            "et",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 2716
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_root_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "529-535",
          "snippet": "static inline int ocfs2_et_root_journal_access(handle_t *handle,\n\t\t\t\t\t       struct ocfs2_extent_tree *et,\n\t\t\t\t\t       int type)\n{\n\treturn et->et_root_journal_access(handle, et->et_ci, et->et_root_bh,\n\t\t\t\t\t  type);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic inline int ocfs2_et_root_journal_access(handle_t *handle,\n\t\t\t\t\t       struct ocfs2_extent_tree *et,\n\t\t\t\t\t       int type)\n{\n\treturn et->et_root_journal_access(handle, et->et_ci, et->et_root_bh,\n\t\t\t\t\t  type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "right_leaf_el->l_next_free_rec"
          ],
          "line": 2711
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_eb",
          "args": [
            "handle",
            "et->et_ci",
            "path_leaf_bh(right_path)",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 2697
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_eb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "716-720",
          "snippet": "int ocfs2_journal_access_eb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &eb_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers eb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_extent_block, h_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers eb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_extent_block, h_check),\n};\n\nint ocfs2_journal_access_eb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &eb_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "right_path"
          ],
          "line": 2698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&right_leaf_el->l_recs[0]"
          ],
          "line": 2679
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "266-269",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "right_path"
          ],
          "line": 2678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "root_bh != right_path->p_node[subtree_index].bh"
          ],
          "line": 2673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "left_path"
          ],
          "line": 2671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "right_path"
          ],
          "line": 2670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_bh",
          "args": [
            "right_path"
          ],
          "line": 2664
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_rotate_subtree_left(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_path *left_path,\n\t\t\t\t     struct ocfs2_path *right_path,\n\t\t\t\t     int subtree_index,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t     int *deleted)\n{\n\tint ret, i, del_right_subtree = 0, right_has_empty = 0;\n\tstruct buffer_head *root_bh, *et_root_bh = path_root_bh(right_path);\n\tstruct ocfs2_extent_list *right_leaf_el, *left_leaf_el;\n\tstruct ocfs2_extent_block *eb;\n\n\t*deleted = 0;\n\n\tright_leaf_el = path_leaf_el(right_path);\n\tleft_leaf_el = path_leaf_el(left_path);\n\troot_bh = left_path->p_node[subtree_index].bh;\n\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\tif (!ocfs2_is_empty_extent(&left_leaf_el->l_recs[0]))\n\t\treturn 0;\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(right_path)->b_data;\n\tif (ocfs2_is_empty_extent(&right_leaf_el->l_recs[0])) {\n\t\t/*\n\t\t * It's legal for us to proceed if the right leaf is\n\t\t * the rightmost one and it has an empty extent. There\n\t\t * are two cases to handle - whether the leaf will be\n\t\t * empty after removal or not. If the leaf isn't empty\n\t\t * then just remove the empty extent up front. The\n\t\t * next block will handle empty leaves by flagging\n\t\t * them for unlink.\n\t\t *\n\t\t * Non rightmost leaves will throw -EAGAIN and the\n\t\t * caller can manually move the subtree and retry.\n\t\t */\n\n\t\tif (eb->h_next_leaf_blk != 0ULL)\n\t\t\treturn -EAGAIN;\n\n\t\tif (le16_to_cpu(right_leaf_el->l_next_free_rec) > 1) {\n\t\t\tret = ocfs2_journal_access_eb(handle, et->et_ci,\n\t\t\t\t\t\t      path_leaf_bh(right_path),\n\t\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tocfs2_remove_empty_extent(right_leaf_el);\n\t\t} else\n\t\t\tright_has_empty = 1;\n\t}\n\n\tif (eb->h_next_leaf_blk == 0ULL &&\n\t    le16_to_cpu(right_leaf_el->l_next_free_rec) == 1) {\n\t\t/*\n\t\t * We have to update i_last_eb_blk during the meta\n\t\t * data delete.\n\t\t */\n\t\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdel_right_subtree = 1;\n\t}\n\n\t/*\n\t * Getting here with an empty extent in the right path implies\n\t * that it's the rightmost path and will be deleted.\n\t */\n\tBUG_ON(right_has_empty && !del_right_subtree);\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t   subtree_index);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tfor(i = subtree_index + 1; i < path_num_items(right_path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   right_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   left_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!right_has_empty) {\n\t\t/*\n\t\t * Only do this if we're moving a real\n\t\t * record. Otherwise, the action is delayed until\n\t\t * after removal of the right path in which case we\n\t\t * can do a simple shift to remove the empty extent.\n\t\t */\n\t\tocfs2_rotate_leaf(left_leaf_el, &right_leaf_el->l_recs[0]);\n\t\tmemset(&right_leaf_el->l_recs[0], 0,\n\t\t       sizeof(struct ocfs2_extent_rec));\n\t}\n\tif (eb->h_next_leaf_blk == 0ULL) {\n\t\t/*\n\t\t * Move recs over to get rid of empty extent, decrease\n\t\t * next_free. This is allowed to remove the last\n\t\t * extent in our leaf (setting l_next_free_rec to\n\t\t * zero) - the delete code below won't care.\n\t\t */\n\t\tocfs2_remove_empty_extent(right_leaf_el);\n\t}\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\tocfs2_journal_dirty(handle, path_leaf_bh(right_path));\n\n\tif (del_right_subtree) {\n\t\tocfs2_unlink_subtree(handle, et, left_path, right_path,\n\t\t\t\t     subtree_index, dealloc);\n\t\tret = ocfs2_update_edge_lengths(handle, et, subtree_index,\n\t\t\t\t\t\tleft_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\n\t\t/*\n\t\t * Removal of the extent in the left leaf was skipped\n\t\t * above so we could delete the right path\n\t\t * 1st.\n\t\t */\n\t\tif (right_has_empty)\n\t\t\tocfs2_remove_empty_extent(left_leaf_el);\n\n\t\tocfs2_journal_dirty(handle, et_root_bh);\n\n\t\t*deleted = 1;\n\t} else\n\t\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t\t   subtree_index);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_unlink_subtree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "2619-2653",
    "snippet": "static void ocfs2_unlink_subtree(handle_t *handle,\n\t\t\t\t struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_path *left_path,\n\t\t\t\t struct ocfs2_path *right_path,\n\t\t\t\t int subtree_index,\n\t\t\t\t struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint i;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\tstruct ocfs2_extent_list *root_el = left_path->p_node[subtree_index].el;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_block *eb;\n\n\tel = path_leaf_el(left_path);\n\n\teb = (struct ocfs2_extent_block *)right_path->p_node[subtree_index + 1].bh->b_data;\n\n\tfor(i = 1; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\tif (root_el->l_recs[i].e_blkno == eb->h_blkno)\n\t\t\tbreak;\n\n\tBUG_ON(i >= le16_to_cpu(root_el->l_next_free_rec));\n\n\tmemset(&root_el->l_recs[i], 0, sizeof(struct ocfs2_extent_rec));\n\tle16_add_cpu(&root_el->l_next_free_rec, -1);\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\teb->h_next_leaf_blk = 0;\n\n\tocfs2_journal_dirty(handle, root_bh);\n\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\n\tocfs2_unlink_path(handle, et, dealloc, right_path,\n\t\t\t  subtree_index + 1);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_unlink_path",
          "args": [
            "handle",
            "et",
            "dealloc",
            "right_path",
            "subtree_index + 1"
          ],
          "line": 2651
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlink_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2574-2617",
          "snippet": "static void ocfs2_unlink_path(handle_t *handle,\n\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t      struct ocfs2_path *path, int unlink_start)\n{\n\tint ret, i;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct buffer_head *bh;\n\n\tfor(i = unlink_start; i < path_num_items(path); i++) {\n\t\tbh = path->p_node[i].bh;\n\n\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t/*\n\t\t * Not all nodes might have had their final count\n\t\t * decremented by the caller - handle this here.\n\t\t */\n\t\tel = &eb->h_list;\n\t\tif (le16_to_cpu(el->l_next_free_rec) > 1) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Inode %llu, attempted to remove extent block \"\n\t\t\t     \"%llu with %u records\\n\",\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t     (unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t     le16_to_cpu(el->l_next_free_rec));\n\n\t\t\tocfs2_journal_dirty(handle, bh);\n\t\t\tocfs2_remove_from_cache(et->et_ci, bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\tel->l_next_free_rec = 0;\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\n\t\tret = ocfs2_cache_extent_block_free(dealloc, eb);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t\tocfs2_remove_from_cache(et->et_ci, bh);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic void ocfs2_unlink_path(handle_t *handle,\n\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t      struct ocfs2_path *path, int unlink_start)\n{\n\tint ret, i;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct buffer_head *bh;\n\n\tfor(i = unlink_start; i < path_num_items(path); i++) {\n\t\tbh = path->p_node[i].bh;\n\n\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t/*\n\t\t * Not all nodes might have had their final count\n\t\t * decremented by the caller - handle this here.\n\t\t */\n\t\tel = &eb->h_list;\n\t\tif (le16_to_cpu(el->l_next_free_rec) > 1) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Inode %llu, attempted to remove extent block \"\n\t\t\t     \"%llu with %u records\\n\",\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t     (unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t     le16_to_cpu(el->l_next_free_rec));\n\n\t\t\tocfs2_journal_dirty(handle, bh);\n\t\t\tocfs2_remove_from_cache(et->et_ci, bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\tel->l_next_free_rec = 0;\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\n\t\tret = ocfs2_cache_extent_block_free(dealloc, eb);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t\tocfs2_remove_from_cache(et->et_ci, bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "path_leaf_bh(left_path)"
          ],
          "line": 2649
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "left_path"
          ],
          "line": 2649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "left_path"
          ],
          "line": 2645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&root_el->l_next_free_rec",
            "-1"
          ],
          "line": 2643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&root_el->l_recs[i]",
            "0",
            "sizeof(struct ocfs2_extent_rec)"
          ],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "i >= le16_to_cpu(root_el->l_next_free_rec)"
          ],
          "line": 2640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "root_el->l_next_free_rec"
          ],
          "line": 2640
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "left_path"
          ],
          "line": 2632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic void ocfs2_unlink_subtree(handle_t *handle,\n\t\t\t\t struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_path *left_path,\n\t\t\t\t struct ocfs2_path *right_path,\n\t\t\t\t int subtree_index,\n\t\t\t\t struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint i;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\tstruct ocfs2_extent_list *root_el = left_path->p_node[subtree_index].el;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_block *eb;\n\n\tel = path_leaf_el(left_path);\n\n\teb = (struct ocfs2_extent_block *)right_path->p_node[subtree_index + 1].bh->b_data;\n\n\tfor(i = 1; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\tif (root_el->l_recs[i].e_blkno == eb->h_blkno)\n\t\t\tbreak;\n\n\tBUG_ON(i >= le16_to_cpu(root_el->l_next_free_rec));\n\n\tmemset(&root_el->l_recs[i], 0, sizeof(struct ocfs2_extent_rec));\n\tle16_add_cpu(&root_el->l_next_free_rec, -1);\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\teb->h_next_leaf_blk = 0;\n\n\tocfs2_journal_dirty(handle, root_bh);\n\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\n\tocfs2_unlink_path(handle, et, dealloc, right_path,\n\t\t\t  subtree_index + 1);\n}"
  },
  {
    "function_name": "ocfs2_unlink_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "2574-2617",
    "snippet": "static void ocfs2_unlink_path(handle_t *handle,\n\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t      struct ocfs2_path *path, int unlink_start)\n{\n\tint ret, i;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct buffer_head *bh;\n\n\tfor(i = unlink_start; i < path_num_items(path); i++) {\n\t\tbh = path->p_node[i].bh;\n\n\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t/*\n\t\t * Not all nodes might have had their final count\n\t\t * decremented by the caller - handle this here.\n\t\t */\n\t\tel = &eb->h_list;\n\t\tif (le16_to_cpu(el->l_next_free_rec) > 1) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Inode %llu, attempted to remove extent block \"\n\t\t\t     \"%llu with %u records\\n\",\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t     (unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t     le16_to_cpu(el->l_next_free_rec));\n\n\t\t\tocfs2_journal_dirty(handle, bh);\n\t\t\tocfs2_remove_from_cache(et->et_ci, bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\tel->l_next_free_rec = 0;\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\n\t\tret = ocfs2_cache_extent_block_free(dealloc, eb);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t\tocfs2_remove_from_cache(et->et_ci, bh);\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_remove_from_cache",
          "args": [
            "et->et_ci",
            "bh"
          ],
          "line": 2615
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_from_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "603-609",
          "snippet": "void ocfs2_remove_from_cache(struct ocfs2_caching_info *ci,\n\t\t\t     struct buffer_head *bh)\n{\n\tsector_t block = bh->b_blocknr;\n\n\tocfs2_remove_block_from_cache(ci, block);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_remove_from_cache(struct ocfs2_caching_info *ci,\n\t\t\t     struct buffer_head *bh)\n{\n\tsector_t block = bh->b_blocknr;\n\n\tocfs2_remove_block_from_cache(ci, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cache_extent_block_free",
          "args": [
            "dealloc",
            "eb"
          ],
          "line": 2611
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cache_extent_block_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6579-6587",
          "snippet": "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb)\n{\n\treturn ocfs2_cache_block_dealloc(ctxt, EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t le16_to_cpu(eb->h_suballoc_slot),\n\t\t\t\t\t le64_to_cpu(eb->h_suballoc_loc),\n\t\t\t\t\t le64_to_cpu(eb->h_blkno),\n\t\t\t\t\t le16_to_cpu(eb->h_suballoc_bit));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb)\n{\n\treturn ocfs2_cache_block_dealloc(ctxt, EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t le16_to_cpu(eb->h_suballoc_slot),\n\t\t\t\t\t le64_to_cpu(eb->h_suballoc_loc),\n\t\t\t\t\t le64_to_cpu(eb->h_blkno),\n\t\t\t\t\t le16_to_cpu(eb->h_suballoc_bit));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "bh"
          ],
          "line": 2609
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&el->l_recs[0]",
            "0",
            "sizeof(struct ocfs2_extent_rec)"
          ],
          "line": 2607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Inode %llu, attempted to remove extent block \"\n\t\t\t     \"%llu with %u records\\n\"",
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "(unsigned long long)le64_to_cpu(eb->h_blkno)",
            "le16_to_cpu(el->l_next_free_rec)"
          ],
          "line": 2594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 2599
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "eb->h_blkno"
          ],
          "line": 2598
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 2597
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_num_items",
          "args": [
            "path"
          ],
          "line": 2584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic void ocfs2_unlink_path(handle_t *handle,\n\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t      struct ocfs2_path *path, int unlink_start)\n{\n\tint ret, i;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct buffer_head *bh;\n\n\tfor(i = unlink_start; i < path_num_items(path); i++) {\n\t\tbh = path->p_node[i].bh;\n\n\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t/*\n\t\t * Not all nodes might have had their final count\n\t\t * decremented by the caller - handle this here.\n\t\t */\n\t\tel = &eb->h_list;\n\t\tif (le16_to_cpu(el->l_next_free_rec) > 1) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Inode %llu, attempted to remove extent block \"\n\t\t\t     \"%llu with %u records\\n\",\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t     (unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t     le16_to_cpu(el->l_next_free_rec));\n\n\t\t\tocfs2_journal_dirty(handle, bh);\n\t\t\tocfs2_remove_from_cache(et->et_ci, bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\tel->l_next_free_rec = 0;\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\n\t\tret = ocfs2_cache_extent_block_free(dealloc, eb);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t\tocfs2_remove_from_cache(et->et_ci, bh);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_update_edge_lengths",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "2519-2572",
    "snippet": "static int ocfs2_update_edge_lengths(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     int subtree_index, struct ocfs2_path *path)\n{\n\tint i, idx, ret;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_block *eb;\n\tu32 range;\n\n\t/*\n\t * In normal tree rotation process, we will never touch the\n\t * tree branch above subtree_index and ocfs2_extend_rotate_transaction\n\t * doesn't reserve the credits for them either.\n\t *\n\t * But we do have a special case here which will update the rightmost\n\t * records for all the bh in the path.\n\t * So we have to allocate extra credits and access them.\n\t */\n\tret = ocfs2_extend_trans(handle, subtree_index);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Path should always be rightmost. */\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\tBUG_ON(eb->h_next_leaf_blk != 0ULL);\n\n\tel = &eb->h_list;\n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) == 0);\n\tidx = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[idx];\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tel = path->p_node[i].el;\n\t\tidx = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\trec = &el->l_recs[idx];\n\n\t\trec->e_int_clusters = cpu_to_le32(range);\n\t\tle32_add_cpu(&rec->e_int_clusters, -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, path->p_node[i].bh);\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "path->p_node[i].bh"
          ],
          "line": 2568
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&rec->e_int_clusters",
            "-le32_to_cpu(rec->e_cpos)"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 2566
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "range"
          ],
          "line": 2565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 2562
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_rec_clusters",
          "args": [
            "el",
            "rec"
          ],
          "line": 2558
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rec_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "246-260",
          "snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le16_to_cpu(el->l_next_free_rec) == 0"
          ],
          "line": 2555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "eb->h_next_leaf_blk != 0ULL"
          ],
          "line": 2552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "path"
          ],
          "line": 2551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_path",
          "args": [
            "et->et_ci",
            "handle",
            "path"
          ],
          "line": 2544
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "746-765",
          "snippet": "int ocfs2_journal_access_path(struct ocfs2_caching_info *ci,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_path *path)\n{\n\tint i, ret = 0;\n\n\tif (!path)\n\t\tgoto out;\n\n\tfor(i = 0; i < path_num_items(path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, ci, path, i);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_journal_access_path(struct ocfs2_caching_info *ci,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_path *path)\n{\n\tint i, ret = 0;\n\n\tif (!path)\n\t\tgoto out;\n\n\tfor(i = 0; i < path_num_items(path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, ci, path, i);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_trans",
          "args": [
            "handle",
            "subtree_index"
          ],
          "line": 2538
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "426-463",
          "snippet": "int ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_update_edge_lengths(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     int subtree_index, struct ocfs2_path *path)\n{\n\tint i, idx, ret;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_block *eb;\n\tu32 range;\n\n\t/*\n\t * In normal tree rotation process, we will never touch the\n\t * tree branch above subtree_index and ocfs2_extend_rotate_transaction\n\t * doesn't reserve the credits for them either.\n\t *\n\t * But we do have a special case here which will update the rightmost\n\t * records for all the bh in the path.\n\t * So we have to allocate extra credits and access them.\n\t */\n\tret = ocfs2_extend_trans(handle, subtree_index);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Path should always be rightmost. */\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\tBUG_ON(eb->h_next_leaf_blk != 0ULL);\n\n\tel = &eb->h_list;\n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) == 0);\n\tidx = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[idx];\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tel = path->p_node[i].el;\n\t\tidx = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\trec = &el->l_recs[idx];\n\n\t\trec->e_int_clusters = cpu_to_le32(range);\n\t\tle32_add_cpu(&rec->e_int_clusters, -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, path->p_node[i].bh);\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_rotate_tree_right",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "2358-2517",
    "snippet": "static int ocfs2_rotate_tree_right(handle_t *handle,\n\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t   enum ocfs2_split_type split,\n\t\t\t\t   u32 insert_cpos,\n\t\t\t\t   struct ocfs2_path *right_path,\n\t\t\t\t   struct ocfs2_path **ret_left_path)\n{\n\tint ret, start, orig_credits = handle->h_buffer_credits;\n\tu32 cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\n\t*ret_left_path = NULL;\n\n\tleft_path = ocfs2_new_path_from_path(right_path);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_cpos_for_left_leaf(sb, right_path, &cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_rotate_tree_right(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tinsert_cpos, cpos);\n\n\t/*\n\t * What we want to do here is:\n\t *\n\t * 1) Start with the rightmost path.\n\t *\n\t * 2) Determine a path to the leaf block directly to the left\n\t *    of that leaf.\n\t *\n\t * 3) Determine the 'subtree root' - the lowest level tree node\n\t *    which contains a path to both leaves.\n\t *\n\t * 4) Rotate the subtree.\n\t *\n\t * 5) Find the next subtree by considering the left path to be\n\t *    the new right path.\n\t *\n\t * The check at the top of this while loop also accepts\n\t * insert_cpos == cpos because cpos is only a _theoretical_\n\t * value to get us the left path - insert_cpos might very well\n\t * be filling that hole.\n\t *\n\t * Stop at a cpos of '0' because we either started at the\n\t * leftmost branch (i.e., a tree with one branch and a\n\t * rotation inside of it), or we've gone as far as we can in\n\t * rotating subtrees.\n\t */\n\twhile (cpos && insert_cpos <= cpos) {\n\t\ttrace_ocfs2_rotate_tree_right(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tinsert_cpos, cpos);\n\n\t\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tmlog_bug_on_msg(path_leaf_bh(left_path) ==\n\t\t\t\tpath_leaf_bh(right_path),\n\t\t\t\t\"Owner %llu: error during insert of %u \"\n\t\t\t\t\"(left path cpos %u) results in two identical \"\n\t\t\t\t\"paths ending at %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tinsert_cpos, cpos,\n\t\t\t\t(unsigned long long)\n\t\t\t\tpath_leaf_bh(left_path)->b_blocknr);\n\n\t\tif (split == SPLIT_NONE &&\n\t\t    ocfs2_rotate_requires_path_adjustment(left_path,\n\t\t\t\t\t\t\t  insert_cpos)) {\n\n\t\t\t/*\n\t\t\t * We've rotated the tree as much as we\n\t\t\t * should. The rest is up to\n\t\t\t * ocfs2_insert_path() to complete, after the\n\t\t\t * record insertion. We indicate this\n\t\t\t * situation by returning the left path.\n\t\t\t *\n\t\t\t * The reason we don't adjust the records here\n\t\t\t * before the record insert is that an error\n\t\t\t * later might break the rule where a parent\n\t\t\t * record e_cpos will reflect the actual\n\t\t\t * e_cpos of the 1st nonempty record of the\n\t\t\t * child list.\n\t\t\t */\n\t\t\t*ret_left_path = left_path;\n\t\t\tgoto out_ret_path;\n\t\t}\n\n\t\tstart = ocfs2_find_subtree_root(et, left_path, right_path);\n\n\t\ttrace_ocfs2_rotate_subtree(start,\n\t\t\t(unsigned long long)\n\t\t\tright_path->p_node[start].bh->b_blocknr,\n\t\t\tright_path->p_tree_depth);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, start,\n\t\t\t\t\t\t      orig_credits, right_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_subtree_right(handle, et, left_path,\n\t\t\t\t\t\t right_path, start);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (split != SPLIT_NONE &&\n\t\t    ocfs2_leftmost_rec_contains(path_leaf_el(right_path),\n\t\t\t\t\t\tinsert_cpos)) {\n\t\t\t/*\n\t\t\t * A rotate moves the rightmost left leaf\n\t\t\t * record over to the leftmost right leaf\n\t\t\t * slot. If we're doing an extent split\n\t\t\t * instead of a real insert, then we have to\n\t\t\t * check that the extent to be split wasn't\n\t\t\t * just moved over. If it was, then we can\n\t\t\t * exit here, passing left_path back -\n\t\t\t * ocfs2_split_extent() is smart enough to\n\t\t\t * search both leaves.\n\t\t\t */\n\t\t\t*ret_left_path = left_path;\n\t\t\tgoto out_ret_path;\n\t\t}\n\n\t\t/*\n\t\t * There is no need to re-read the next right path\n\t\t * as we know that it'll be our current left\n\t\t * path. Optimize by copying values instead.\n\t\t */\n\t\tocfs2_mv_path(right_path, left_path);\n\n\t\tret = ocfs2_find_cpos_for_left_leaf(sb, right_path, &cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tocfs2_free_path(left_path);\n\nout_ret_path:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "left_path"
          ],
          "line": 2513
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "609-615",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_cpos_for_left_leaf",
          "args": [
            "sb",
            "right_path",
            "&cpos"
          ],
          "line": 2505
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_cpos_for_left_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2205-2272",
          "snippet": "int ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mv_path",
          "args": [
            "right_path",
            "left_path"
          ],
          "line": 2503
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mv_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "647-663",
          "snippet": "static void ocfs2_mv_path(struct ocfs2_path *dest, struct ocfs2_path *src)\n{\n\tint i;\n\n\tBUG_ON(path_root_bh(dest) != path_root_bh(src));\n\tBUG_ON(path_root_access(dest) != path_root_access(src));\n\n\tfor(i = 1; i < OCFS2_MAX_PATH_DEPTH; i++) {\n\t\tbrelse(dest->p_node[i].bh);\n\n\t\tdest->p_node[i].bh = src->p_node[i].bh;\n\t\tdest->p_node[i].el = src->p_node[i].el;\n\n\t\tsrc->p_node[i].bh = NULL;\n\t\tsrc->p_node[i].el = NULL;\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_mv_path(struct ocfs2_path *dest, struct ocfs2_path *src)\n{\n\tint i;\n\n\tBUG_ON(path_root_bh(dest) != path_root_bh(src));\n\tBUG_ON(path_root_access(dest) != path_root_access(src));\n\n\tfor(i = 1; i < OCFS2_MAX_PATH_DEPTH; i++) {\n\t\tbrelse(dest->p_node[i].bh);\n\n\t\tdest->p_node[i].bh = src->p_node[i].bh;\n\t\tdest->p_node[i].el = src->p_node[i].el;\n\n\t\tsrc->p_node[i].bh = NULL;\n\t\tsrc->p_node[i].el = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_leftmost_rec_contains",
          "args": [
            "path_leaf_el(right_path)",
            "insert_cpos"
          ],
          "line": 2481
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leftmost_rec_contains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2319-2340",
          "snippet": "static int ocfs2_leftmost_rec_contains(struct ocfs2_extent_list *el, u32 cpos)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\tunsigned int range;\n\tstruct ocfs2_extent_rec *rec;\n\n\tif (next_free == 0)\n\t\treturn 0;\n\n\trec = &el->l_recs[0];\n\tif (ocfs2_is_empty_extent(rec)) {\n\t\t/* Empty list. */\n\t\tif (next_free == 1)\n\t\t\treturn 0;\n\t\trec = &el->l_recs[1];\n\t}\n\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\tif (cpos >= le32_to_cpu(rec->e_cpos) && cpos < range)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic int ocfs2_leftmost_rec_contains(struct ocfs2_extent_list *el, u32 cpos)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\tunsigned int range;\n\tstruct ocfs2_extent_rec *rec;\n\n\tif (next_free == 0)\n\t\treturn 0;\n\n\trec = &el->l_recs[0];\n\tif (ocfs2_is_empty_extent(rec)) {\n\t\t/* Empty list. */\n\t\tif (next_free == 1)\n\t\t\treturn 0;\n\t\trec = &el->l_recs[1];\n\t}\n\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\tif (cpos >= le32_to_cpu(rec->e_cpos) && cpos < range)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "right_path"
          ],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rotate_subtree_right",
          "args": [
            "handle",
            "et",
            "left_path",
            "right_path",
            "start"
          ],
          "line": 2473
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rotate_subtree_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2101-2197",
          "snippet": "static int ocfs2_rotate_subtree_right(handle_t *handle,\n\t\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t\t      struct ocfs2_path *left_path,\n\t\t\t\t      struct ocfs2_path *right_path,\n\t\t\t\t      int subtree_index)\n{\n\tint ret, i;\n\tstruct buffer_head *right_leaf_bh;\n\tstruct buffer_head *left_leaf_bh = NULL;\n\tstruct buffer_head *root_bh;\n\tstruct ocfs2_extent_list *right_el, *left_el;\n\tstruct ocfs2_extent_rec move_rec;\n\n\tleft_leaf_bh = path_leaf_bh(left_path);\n\tleft_el = path_leaf_el(left_path);\n\n\tif (left_el->l_next_free_rec != left_el->l_count) {\n\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t    \"Inode %llu has non-full interior leaf node %llu\"\n\t\t\t    \"(next free = %u)\",\n\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t    (unsigned long long)left_leaf_bh->b_blocknr,\n\t\t\t    le16_to_cpu(left_el->l_next_free_rec));\n\t\treturn -EROFS;\n\t}\n\n\t/*\n\t * This extent block may already have an empty record, so we\n\t * return early if so.\n\t */\n\tif (ocfs2_is_empty_extent(&left_el->l_recs[0]))\n\t\treturn 0;\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t   subtree_index);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tfor(i = subtree_index + 1; i < path_num_items(right_path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   right_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   left_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tright_leaf_bh = path_leaf_bh(right_path);\n\tright_el = path_leaf_el(right_path);\n\n\t/* This is a code error, not a disk corruption. */\n\tmlog_bug_on_msg(!right_el->l_next_free_rec, \"Inode %llu: Rotate fails \"\n\t\t\t\"because rightmost leaf block %llu is empty\\n\",\n\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t(unsigned long long)right_leaf_bh->b_blocknr);\n\n\tocfs2_create_empty_extent(right_el);\n\n\tocfs2_journal_dirty(handle, right_leaf_bh);\n\n\t/* Do the copy now. */\n\ti = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\tmove_rec = left_el->l_recs[i];\n\tright_el->l_recs[0] = move_rec;\n\n\t/*\n\t * Clear out the record we just copied and shift everything\n\t * over, leaving an empty extent in the left leaf.\n\t *\n\t * We temporarily subtract from next_free_rec so that the\n\t * shift will lose the tail record (which is now defunct).\n\t */\n\tle16_add_cpu(&left_el->l_next_free_rec, -1);\n\tocfs2_shift_records_right(left_el);\n\tmemset(&left_el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\tle16_add_cpu(&left_el->l_next_free_rec, 1);\n\n\tocfs2_journal_dirty(handle, left_leaf_bh);\n\n\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t   subtree_index);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_rotate_subtree_right(handle_t *handle,\n\t\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t\t      struct ocfs2_path *left_path,\n\t\t\t\t      struct ocfs2_path *right_path,\n\t\t\t\t      int subtree_index)\n{\n\tint ret, i;\n\tstruct buffer_head *right_leaf_bh;\n\tstruct buffer_head *left_leaf_bh = NULL;\n\tstruct buffer_head *root_bh;\n\tstruct ocfs2_extent_list *right_el, *left_el;\n\tstruct ocfs2_extent_rec move_rec;\n\n\tleft_leaf_bh = path_leaf_bh(left_path);\n\tleft_el = path_leaf_el(left_path);\n\n\tif (left_el->l_next_free_rec != left_el->l_count) {\n\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t    \"Inode %llu has non-full interior leaf node %llu\"\n\t\t\t    \"(next free = %u)\",\n\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t    (unsigned long long)left_leaf_bh->b_blocknr,\n\t\t\t    le16_to_cpu(left_el->l_next_free_rec));\n\t\treturn -EROFS;\n\t}\n\n\t/*\n\t * This extent block may already have an empty record, so we\n\t * return early if so.\n\t */\n\tif (ocfs2_is_empty_extent(&left_el->l_recs[0]))\n\t\treturn 0;\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t   subtree_index);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tfor(i = subtree_index + 1; i < path_num_items(right_path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   right_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   left_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tright_leaf_bh = path_leaf_bh(right_path);\n\tright_el = path_leaf_el(right_path);\n\n\t/* This is a code error, not a disk corruption. */\n\tmlog_bug_on_msg(!right_el->l_next_free_rec, \"Inode %llu: Rotate fails \"\n\t\t\t\"because rightmost leaf block %llu is empty\\n\",\n\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t(unsigned long long)right_leaf_bh->b_blocknr);\n\n\tocfs2_create_empty_extent(right_el);\n\n\tocfs2_journal_dirty(handle, right_leaf_bh);\n\n\t/* Do the copy now. */\n\ti = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\tmove_rec = left_el->l_recs[i];\n\tright_el->l_recs[0] = move_rec;\n\n\t/*\n\t * Clear out the record we just copied and shift everything\n\t * over, leaving an empty extent in the left leaf.\n\t *\n\t * We temporarily subtract from next_free_rec so that the\n\t * shift will lose the tail record (which is now defunct).\n\t */\n\tle16_add_cpu(&left_el->l_next_free_rec, -1);\n\tocfs2_shift_records_right(left_el);\n\tmemset(&left_el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\tle16_add_cpu(&left_el->l_next_free_rec, 1);\n\n\tocfs2_journal_dirty(handle, left_leaf_bh);\n\n\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t   subtree_index);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_rotate_transaction",
          "args": [
            "handle",
            "start",
            "orig_credits",
            "right_path"
          ],
          "line": 2466
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_rotate_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2279-2291",
          "snippet": "static int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,\n\t\t\t\t\t   int op_credits,\n\t\t\t\t\t   struct ocfs2_path *path)\n{\n\tint ret = 0;\n\tint credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;\n\n\tif (handle->h_buffer_credits < credits)\n\t\tret = ocfs2_extend_trans(handle,\n\t\t\t\t\t credits - handle->h_buffer_credits);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,\n\t\t\t\t\t   int op_credits,\n\t\t\t\t\t   struct ocfs2_path *path)\n{\n\tint ret = 0;\n\tint credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;\n\n\tif (handle->h_buffer_credits < credits)\n\t\tret = ocfs2_extend_trans(handle,\n\t\t\t\t\t credits - handle->h_buffer_credits);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_rotate_subtree",
          "args": [
            "start",
            "(unsigned long long)\n\t\t\tright_path->p_node[start].bh->b_blocknr",
            "right_path->p_tree_depth"
          ],
          "line": 2461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_subtree_root",
          "args": [
            "et",
            "left_path",
            "right_path"
          ],
          "line": 2459
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_subtree_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1737-1765",
          "snippet": "int ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_rotate_requires_path_adjustment",
          "args": [
            "left_path",
            "insert_cpos"
          ],
          "line": 2438
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rotate_requires_path_adjustment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2303-2317",
          "snippet": "static int ocfs2_rotate_requires_path_adjustment(struct ocfs2_path *left_path,\n\t\t\t\t\t\t u32 insert_cpos)\n{\n\tstruct ocfs2_extent_list *left_el;\n\tstruct ocfs2_extent_rec *rec;\n\tint next_free;\n\n\tleft_el = path_leaf_el(left_path);\n\tnext_free = le16_to_cpu(left_el->l_next_free_rec);\n\trec = &left_el->l_recs[next_free - 1];\n\n\tif (insert_cpos > le32_to_cpu(rec->e_cpos))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic int ocfs2_rotate_requires_path_adjustment(struct ocfs2_path *left_path,\n\t\t\t\t\t\t u32 insert_cpos)\n{\n\tstruct ocfs2_extent_list *left_el;\n\tstruct ocfs2_extent_rec *rec;\n\tint next_free;\n\n\tleft_el = path_leaf_el(left_path);\n\tnext_free = le16_to_cpu(left_el->l_next_free_rec);\n\trec = &left_el->l_recs[next_free - 1];\n\n\tif (insert_cpos > le32_to_cpu(rec->e_cpos))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "path_leaf_bh(left_path) ==\n\t\t\t\tpath_leaf_bh(right_path)",
            "\"Owner %llu: error during insert of %u \"\n\t\t\t\t\"(left path cpos %u) results in two identical \"\n\t\t\t\t\"paths ending at %llu\\n\"",
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "insert_cpos",
            "cpos",
            "(unsigned long long)\n\t\t\t\tpath_leaf_bh(left_path)->b_blocknr"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "left_path"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "right_path"
          ],
          "line": 2428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "left_path"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "et->et_ci",
            "left_path",
            "cpos"
          ],
          "line": 2421
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1885-1894",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_rotate_tree_right",
          "args": [
            "(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci)",
            "insert_cpos",
            "cpos"
          ],
          "line": 2416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_rotate_tree_right",
          "args": [
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "insert_cpos",
            "cpos"
          ],
          "line": 2385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_path",
          "args": [
            "right_path"
          ],
          "line": 2372
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "707-711",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 2368
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_rotate_tree_right(handle_t *handle,\n\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t   enum ocfs2_split_type split,\n\t\t\t\t   u32 insert_cpos,\n\t\t\t\t   struct ocfs2_path *right_path,\n\t\t\t\t   struct ocfs2_path **ret_left_path)\n{\n\tint ret, start, orig_credits = handle->h_buffer_credits;\n\tu32 cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\n\t*ret_left_path = NULL;\n\n\tleft_path = ocfs2_new_path_from_path(right_path);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_cpos_for_left_leaf(sb, right_path, &cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_rotate_tree_right(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tinsert_cpos, cpos);\n\n\t/*\n\t * What we want to do here is:\n\t *\n\t * 1) Start with the rightmost path.\n\t *\n\t * 2) Determine a path to the leaf block directly to the left\n\t *    of that leaf.\n\t *\n\t * 3) Determine the 'subtree root' - the lowest level tree node\n\t *    which contains a path to both leaves.\n\t *\n\t * 4) Rotate the subtree.\n\t *\n\t * 5) Find the next subtree by considering the left path to be\n\t *    the new right path.\n\t *\n\t * The check at the top of this while loop also accepts\n\t * insert_cpos == cpos because cpos is only a _theoretical_\n\t * value to get us the left path - insert_cpos might very well\n\t * be filling that hole.\n\t *\n\t * Stop at a cpos of '0' because we either started at the\n\t * leftmost branch (i.e., a tree with one branch and a\n\t * rotation inside of it), or we've gone as far as we can in\n\t * rotating subtrees.\n\t */\n\twhile (cpos && insert_cpos <= cpos) {\n\t\ttrace_ocfs2_rotate_tree_right(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tinsert_cpos, cpos);\n\n\t\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tmlog_bug_on_msg(path_leaf_bh(left_path) ==\n\t\t\t\tpath_leaf_bh(right_path),\n\t\t\t\t\"Owner %llu: error during insert of %u \"\n\t\t\t\t\"(left path cpos %u) results in two identical \"\n\t\t\t\t\"paths ending at %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tinsert_cpos, cpos,\n\t\t\t\t(unsigned long long)\n\t\t\t\tpath_leaf_bh(left_path)->b_blocknr);\n\n\t\tif (split == SPLIT_NONE &&\n\t\t    ocfs2_rotate_requires_path_adjustment(left_path,\n\t\t\t\t\t\t\t  insert_cpos)) {\n\n\t\t\t/*\n\t\t\t * We've rotated the tree as much as we\n\t\t\t * should. The rest is up to\n\t\t\t * ocfs2_insert_path() to complete, after the\n\t\t\t * record insertion. We indicate this\n\t\t\t * situation by returning the left path.\n\t\t\t *\n\t\t\t * The reason we don't adjust the records here\n\t\t\t * before the record insert is that an error\n\t\t\t * later might break the rule where a parent\n\t\t\t * record e_cpos will reflect the actual\n\t\t\t * e_cpos of the 1st nonempty record of the\n\t\t\t * child list.\n\t\t\t */\n\t\t\t*ret_left_path = left_path;\n\t\t\tgoto out_ret_path;\n\t\t}\n\n\t\tstart = ocfs2_find_subtree_root(et, left_path, right_path);\n\n\t\ttrace_ocfs2_rotate_subtree(start,\n\t\t\t(unsigned long long)\n\t\t\tright_path->p_node[start].bh->b_blocknr,\n\t\t\tright_path->p_tree_depth);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, start,\n\t\t\t\t\t\t      orig_credits, right_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_subtree_right(handle, et, left_path,\n\t\t\t\t\t\t right_path, start);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (split != SPLIT_NONE &&\n\t\t    ocfs2_leftmost_rec_contains(path_leaf_el(right_path),\n\t\t\t\t\t\tinsert_cpos)) {\n\t\t\t/*\n\t\t\t * A rotate moves the rightmost left leaf\n\t\t\t * record over to the leftmost right leaf\n\t\t\t * slot. If we're doing an extent split\n\t\t\t * instead of a real insert, then we have to\n\t\t\t * check that the extent to be split wasn't\n\t\t\t * just moved over. If it was, then we can\n\t\t\t * exit here, passing left_path back -\n\t\t\t * ocfs2_split_extent() is smart enough to\n\t\t\t * search both leaves.\n\t\t\t */\n\t\t\t*ret_left_path = left_path;\n\t\t\tgoto out_ret_path;\n\t\t}\n\n\t\t/*\n\t\t * There is no need to re-read the next right path\n\t\t * as we know that it'll be our current left\n\t\t * path. Optimize by copying values instead.\n\t\t */\n\t\tocfs2_mv_path(right_path, left_path);\n\n\t\tret = ocfs2_find_cpos_for_left_leaf(sb, right_path, &cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tocfs2_free_path(left_path);\n\nout_ret_path:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_leftmost_rec_contains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "2319-2340",
    "snippet": "static int ocfs2_leftmost_rec_contains(struct ocfs2_extent_list *el, u32 cpos)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\tunsigned int range;\n\tstruct ocfs2_extent_rec *rec;\n\n\tif (next_free == 0)\n\t\treturn 0;\n\n\trec = &el->l_recs[0];\n\tif (ocfs2_is_empty_extent(rec)) {\n\t\t/* Empty list. */\n\t\tif (next_free == 1)\n\t\t\treturn 0;\n\t\trec = &el->l_recs[1];\n\t}\n\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\tif (cpos >= le32_to_cpu(rec->e_cpos) && cpos < range)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 2337
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_rec_clusters",
          "args": [
            "el",
            "rec"
          ],
          "line": 2336
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rec_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "246-260",
          "snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "rec"
          ],
          "line": 2329
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "266-269",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 2321
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic int ocfs2_leftmost_rec_contains(struct ocfs2_extent_list *el, u32 cpos)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\tunsigned int range;\n\tstruct ocfs2_extent_rec *rec;\n\n\tif (next_free == 0)\n\t\treturn 0;\n\n\trec = &el->l_recs[0];\n\tif (ocfs2_is_empty_extent(rec)) {\n\t\t/* Empty list. */\n\t\tif (next_free == 1)\n\t\t\treturn 0;\n\t\trec = &el->l_recs[1];\n\t}\n\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\tif (cpos >= le32_to_cpu(rec->e_cpos) && cpos < range)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_rotate_requires_path_adjustment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "2303-2317",
    "snippet": "static int ocfs2_rotate_requires_path_adjustment(struct ocfs2_path *left_path,\n\t\t\t\t\t\t u32 insert_cpos)\n{\n\tstruct ocfs2_extent_list *left_el;\n\tstruct ocfs2_extent_rec *rec;\n\tint next_free;\n\n\tleft_el = path_leaf_el(left_path);\n\tnext_free = le16_to_cpu(left_el->l_next_free_rec);\n\trec = &left_el->l_recs[next_free - 1];\n\n\tif (insert_cpos > le32_to_cpu(rec->e_cpos))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 2314
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "left_el->l_next_free_rec"
          ],
          "line": 2311
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "left_path"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic int ocfs2_rotate_requires_path_adjustment(struct ocfs2_path *left_path,\n\t\t\t\t\t\t u32 insert_cpos)\n{\n\tstruct ocfs2_extent_list *left_el;\n\tstruct ocfs2_extent_rec *rec;\n\tint next_free;\n\n\tleft_el = path_leaf_el(left_path);\n\tnext_free = le16_to_cpu(left_el->l_next_free_rec);\n\trec = &left_el->l_recs[next_free - 1];\n\n\tif (insert_cpos > le32_to_cpu(rec->e_cpos))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_extend_rotate_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "2279-2291",
    "snippet": "static int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,\n\t\t\t\t\t   int op_credits,\n\t\t\t\t\t   struct ocfs2_path *path)\n{\n\tint ret = 0;\n\tint credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;\n\n\tif (handle->h_buffer_credits < credits)\n\t\tret = ocfs2_extend_trans(handle,\n\t\t\t\t\t credits - handle->h_buffer_credits);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_extend_trans",
          "args": [
            "handle",
            "credits - handle->h_buffer_credits"
          ],
          "line": 2287
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "426-463",
          "snippet": "int ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,\n\t\t\t\t\t   int op_credits,\n\t\t\t\t\t   struct ocfs2_path *path)\n{\n\tint ret = 0;\n\tint credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;\n\n\tif (handle->h_buffer_credits < credits)\n\t\tret = ocfs2_extend_trans(handle,\n\t\t\t\t\t credits - handle->h_buffer_credits);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_find_cpos_for_left_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "2205-2272",
    "snippet": "int ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "sb",
            "\"Invalid extent tree at extent block %llu\\n\"",
            "(unsigned long long)blkno"
          ],
          "line": 2259
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_rec_clusters",
          "args": [
            "el",
            "&el->l_recs[j - 1]"
          ],
          "line": 2248
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rec_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "246-260",
          "snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "el->l_recs[j - 1].e_cpos"
          ],
          "line": 2247
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "el->l_recs[j].e_blkno"
          ],
          "line": 2228
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 2227
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "path"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "path->p_tree_depth == 0"
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_rotate_subtree_right",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "2101-2197",
    "snippet": "static int ocfs2_rotate_subtree_right(handle_t *handle,\n\t\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t\t      struct ocfs2_path *left_path,\n\t\t\t\t      struct ocfs2_path *right_path,\n\t\t\t\t      int subtree_index)\n{\n\tint ret, i;\n\tstruct buffer_head *right_leaf_bh;\n\tstruct buffer_head *left_leaf_bh = NULL;\n\tstruct buffer_head *root_bh;\n\tstruct ocfs2_extent_list *right_el, *left_el;\n\tstruct ocfs2_extent_rec move_rec;\n\n\tleft_leaf_bh = path_leaf_bh(left_path);\n\tleft_el = path_leaf_el(left_path);\n\n\tif (left_el->l_next_free_rec != left_el->l_count) {\n\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t    \"Inode %llu has non-full interior leaf node %llu\"\n\t\t\t    \"(next free = %u)\",\n\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t    (unsigned long long)left_leaf_bh->b_blocknr,\n\t\t\t    le16_to_cpu(left_el->l_next_free_rec));\n\t\treturn -EROFS;\n\t}\n\n\t/*\n\t * This extent block may already have an empty record, so we\n\t * return early if so.\n\t */\n\tif (ocfs2_is_empty_extent(&left_el->l_recs[0]))\n\t\treturn 0;\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t   subtree_index);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tfor(i = subtree_index + 1; i < path_num_items(right_path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   right_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   left_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tright_leaf_bh = path_leaf_bh(right_path);\n\tright_el = path_leaf_el(right_path);\n\n\t/* This is a code error, not a disk corruption. */\n\tmlog_bug_on_msg(!right_el->l_next_free_rec, \"Inode %llu: Rotate fails \"\n\t\t\t\"because rightmost leaf block %llu is empty\\n\",\n\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t(unsigned long long)right_leaf_bh->b_blocknr);\n\n\tocfs2_create_empty_extent(right_el);\n\n\tocfs2_journal_dirty(handle, right_leaf_bh);\n\n\t/* Do the copy now. */\n\ti = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\tmove_rec = left_el->l_recs[i];\n\tright_el->l_recs[0] = move_rec;\n\n\t/*\n\t * Clear out the record we just copied and shift everything\n\t * over, leaving an empty extent in the left leaf.\n\t *\n\t * We temporarily subtract from next_free_rec so that the\n\t * shift will lose the tail record (which is now defunct).\n\t */\n\tle16_add_cpu(&left_el->l_next_free_rec, -1);\n\tocfs2_shift_records_right(left_el);\n\tmemset(&left_el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\tle16_add_cpu(&left_el->l_next_free_rec, 1);\n\n\tocfs2_journal_dirty(handle, left_leaf_bh);\n\n\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t   subtree_index);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_complete_edge_insert",
          "args": [
            "handle",
            "left_path",
            "right_path",
            "subtree_index"
          ],
          "line": 2192
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_complete_edge_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2030-2099",
          "snippet": "static void ocfs2_complete_edge_insert(handle_t *handle,\n\t\t\t\t       struct ocfs2_path *left_path,\n\t\t\t\t       struct ocfs2_path *right_path,\n\t\t\t\t       int subtree_index)\n{\n\tint i, idx;\n\tstruct ocfs2_extent_list *el, *left_el, *right_el;\n\tstruct ocfs2_extent_rec *left_rec, *right_rec;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\n\t/*\n\t * Update the counts and position values within all the\n\t * interior nodes to reflect the leaf rotation we just did.\n\t *\n\t * The root node is handled below the loop.\n\t *\n\t * We begin the loop with right_el and left_el pointing to the\n\t * leaf lists and work our way up.\n\t *\n\t * NOTE: within this loop, left_el and right_el always refer\n\t * to the *child* lists.\n\t */\n\tleft_el = path_leaf_el(left_path);\n\tright_el = path_leaf_el(right_path);\n\tfor(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {\n\t\ttrace_ocfs2_complete_edge_insert(i);\n\n\t\t/*\n\t\t * One nice property of knowing that all of these\n\t\t * nodes are below the root is that we only deal with\n\t\t * the leftmost right node record and the rightmost\n\t\t * left node record.\n\t\t */\n\t\tel = left_path->p_node[i].el;\n\t\tidx = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\t\tleft_rec = &el->l_recs[idx];\n\n\t\tel = right_path->p_node[i].el;\n\t\tright_rec = &el->l_recs[0];\n\n\t\tocfs2_adjust_adjacent_records(left_rec, left_el, right_rec,\n\t\t\t\t\t      right_el);\n\n\t\tocfs2_journal_dirty(handle, left_path->p_node[i].bh);\n\t\tocfs2_journal_dirty(handle, right_path->p_node[i].bh);\n\n\t\t/*\n\t\t * Setup our list pointers now so that the current\n\t\t * parents become children in the next iteration.\n\t\t */\n\t\tleft_el = left_path->p_node[i].el;\n\t\tright_el = right_path->p_node[i].el;\n\t}\n\n\t/*\n\t * At the root node, adjust the two adjacent records which\n\t * begin our path to the leaves.\n\t */\n\n\tel = left_path->p_node[subtree_index].el;\n\tleft_el = left_path->p_node[subtree_index + 1].el;\n\tright_el = right_path->p_node[subtree_index + 1].el;\n\n\tocfs2_adjust_root_records(el, left_el, right_el,\n\t\t\t\t  left_path->p_node[subtree_index + 1].bh->b_blocknr);\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\n\tocfs2_journal_dirty(handle, root_bh);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_complete_edge_insert(handle_t *handle,\n\t\t\t\t       struct ocfs2_path *left_path,\n\t\t\t\t       struct ocfs2_path *right_path,\n\t\t\t\t       int subtree_index)\n{\n\tint i, idx;\n\tstruct ocfs2_extent_list *el, *left_el, *right_el;\n\tstruct ocfs2_extent_rec *left_rec, *right_rec;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\n\t/*\n\t * Update the counts and position values within all the\n\t * interior nodes to reflect the leaf rotation we just did.\n\t *\n\t * The root node is handled below the loop.\n\t *\n\t * We begin the loop with right_el and left_el pointing to the\n\t * leaf lists and work our way up.\n\t *\n\t * NOTE: within this loop, left_el and right_el always refer\n\t * to the *child* lists.\n\t */\n\tleft_el = path_leaf_el(left_path);\n\tright_el = path_leaf_el(right_path);\n\tfor(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {\n\t\ttrace_ocfs2_complete_edge_insert(i);\n\n\t\t/*\n\t\t * One nice property of knowing that all of these\n\t\t * nodes are below the root is that we only deal with\n\t\t * the leftmost right node record and the rightmost\n\t\t * left node record.\n\t\t */\n\t\tel = left_path->p_node[i].el;\n\t\tidx = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\t\tleft_rec = &el->l_recs[idx];\n\n\t\tel = right_path->p_node[i].el;\n\t\tright_rec = &el->l_recs[0];\n\n\t\tocfs2_adjust_adjacent_records(left_rec, left_el, right_rec,\n\t\t\t\t\t      right_el);\n\n\t\tocfs2_journal_dirty(handle, left_path->p_node[i].bh);\n\t\tocfs2_journal_dirty(handle, right_path->p_node[i].bh);\n\n\t\t/*\n\t\t * Setup our list pointers now so that the current\n\t\t * parents become children in the next iteration.\n\t\t */\n\t\tleft_el = left_path->p_node[i].el;\n\t\tright_el = right_path->p_node[i].el;\n\t}\n\n\t/*\n\t * At the root node, adjust the two adjacent records which\n\t * begin our path to the leaves.\n\t */\n\n\tel = left_path->p_node[subtree_index].el;\n\tleft_el = left_path->p_node[subtree_index + 1].el;\n\tright_el = right_path->p_node[subtree_index + 1].el;\n\n\tocfs2_adjust_root_records(el, left_el, right_el,\n\t\t\t\t  left_path->p_node[subtree_index + 1].bh->b_blocknr);\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\n\tocfs2_journal_dirty(handle, root_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "left_leaf_bh"
          ],
          "line": 2190
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&left_el->l_next_free_rec",
            "1"
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&left_el->l_recs[0]",
            "0",
            "sizeof(struct ocfs2_extent_rec)"
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_shift_records_right",
          "args": [
            "left_el"
          ],
          "line": 2186
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_shift_records_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1583-1596",
          "snippet": "static void ocfs2_shift_records_right(struct ocfs2_extent_list *el)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\tint count = le16_to_cpu(el->l_count);\n\tunsigned int num_bytes;\n\n\tBUG_ON(!next_free);\n\t/* This will cause us to go off the end of our extent list. */\n\tBUG_ON(next_free >= count);\n\n\tnum_bytes = sizeof(struct ocfs2_extent_rec) * next_free;\n\n\tmemmove(&el->l_recs[1], &el->l_recs[0], num_bytes);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_shift_records_right(struct ocfs2_extent_list *el)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\tint count = le16_to_cpu(el->l_count);\n\tunsigned int num_bytes;\n\n\tBUG_ON(!next_free);\n\t/* This will cause us to go off the end of our extent list. */\n\tBUG_ON(next_free >= count);\n\n\tnum_bytes = sizeof(struct ocfs2_extent_rec) * next_free;\n\n\tmemmove(&el->l_recs[1], &el->l_recs[0], num_bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&left_el->l_next_free_rec",
            "-1"
          ],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "left_el->l_next_free_rec"
          ],
          "line": 2174
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_create_empty_extent",
          "args": [
            "right_el"
          ],
          "line": 2169
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_create_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1700-1723",
          "snippet": "static void ocfs2_create_empty_extent(struct ocfs2_extent_list *el)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (next_free == 0)\n\t\tgoto set_and_inc;\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn;\n\n\tmlog_bug_on_msg(el->l_count == el->l_next_free_rec,\n\t\t\t\"Asked to create an empty extent in a full list:\\n\"\n\t\t\t\"count = %u, tree depth = %u\",\n\t\t\tle16_to_cpu(el->l_count),\n\t\t\tle16_to_cpu(el->l_tree_depth));\n\n\tocfs2_shift_records_right(el);\n\nset_and_inc:\n\tle16_add_cpu(&el->l_next_free_rec, 1);\n\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_create_empty_extent(struct ocfs2_extent_list *el)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (next_free == 0)\n\t\tgoto set_and_inc;\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn;\n\n\tmlog_bug_on_msg(el->l_count == el->l_next_free_rec,\n\t\t\t\"Asked to create an empty extent in a full list:\\n\"\n\t\t\t\"count = %u, tree depth = %u\",\n\t\t\tle16_to_cpu(el->l_count),\n\t\t\tle16_to_cpu(el->l_tree_depth));\n\n\tocfs2_shift_records_right(el);\n\nset_and_inc:\n\tle16_add_cpu(&el->l_next_free_rec, 1);\n\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "!right_el->l_next_free_rec",
            "\"Inode %llu: Rotate fails \"\n\t\t\t\"because rightmost leaf block %llu is empty\\n\"",
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "(unsigned long long)right_leaf_bh->b_blocknr"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 2166
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "right_path"
          ],
          "line": 2161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "right_path"
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_path_bh_journal_access",
          "args": [
            "handle",
            "et->et_ci",
            "left_path",
            "i"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_path_bh_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "726-741",
          "snippet": "int ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_num_items",
          "args": [
            "right_path"
          ],
          "line": 2144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "root_bh != right_path->p_node[subtree_index].bh"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&left_el->l_recs[0]"
          ],
          "line": 2131
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "266-269",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "\"Inode %llu has non-full interior leaf node %llu\"\n\t\t\t    \"(next free = %u)\"",
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "(unsigned long long)left_leaf_bh->b_blocknr",
            "le16_to_cpu(left_el->l_next_free_rec)"
          ],
          "line": 2118
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 2118
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "left_path"
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "left_path"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_rotate_subtree_right(handle_t *handle,\n\t\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t\t      struct ocfs2_path *left_path,\n\t\t\t\t      struct ocfs2_path *right_path,\n\t\t\t\t      int subtree_index)\n{\n\tint ret, i;\n\tstruct buffer_head *right_leaf_bh;\n\tstruct buffer_head *left_leaf_bh = NULL;\n\tstruct buffer_head *root_bh;\n\tstruct ocfs2_extent_list *right_el, *left_el;\n\tstruct ocfs2_extent_rec move_rec;\n\n\tleft_leaf_bh = path_leaf_bh(left_path);\n\tleft_el = path_leaf_el(left_path);\n\n\tif (left_el->l_next_free_rec != left_el->l_count) {\n\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t    \"Inode %llu has non-full interior leaf node %llu\"\n\t\t\t    \"(next free = %u)\",\n\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t    (unsigned long long)left_leaf_bh->b_blocknr,\n\t\t\t    le16_to_cpu(left_el->l_next_free_rec));\n\t\treturn -EROFS;\n\t}\n\n\t/*\n\t * This extent block may already have an empty record, so we\n\t * return early if so.\n\t */\n\tif (ocfs2_is_empty_extent(&left_el->l_recs[0]))\n\t\treturn 0;\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t   subtree_index);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tfor(i = subtree_index + 1; i < path_num_items(right_path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   right_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   left_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tright_leaf_bh = path_leaf_bh(right_path);\n\tright_el = path_leaf_el(right_path);\n\n\t/* This is a code error, not a disk corruption. */\n\tmlog_bug_on_msg(!right_el->l_next_free_rec, \"Inode %llu: Rotate fails \"\n\t\t\t\"because rightmost leaf block %llu is empty\\n\",\n\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t(unsigned long long)right_leaf_bh->b_blocknr);\n\n\tocfs2_create_empty_extent(right_el);\n\n\tocfs2_journal_dirty(handle, right_leaf_bh);\n\n\t/* Do the copy now. */\n\ti = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\tmove_rec = left_el->l_recs[i];\n\tright_el->l_recs[0] = move_rec;\n\n\t/*\n\t * Clear out the record we just copied and shift everything\n\t * over, leaving an empty extent in the left leaf.\n\t *\n\t * We temporarily subtract from next_free_rec so that the\n\t * shift will lose the tail record (which is now defunct).\n\t */\n\tle16_add_cpu(&left_el->l_next_free_rec, -1);\n\tocfs2_shift_records_right(left_el);\n\tmemset(&left_el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\tle16_add_cpu(&left_el->l_next_free_rec, 1);\n\n\tocfs2_journal_dirty(handle, left_leaf_bh);\n\n\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t   subtree_index);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_complete_edge_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "2030-2099",
    "snippet": "static void ocfs2_complete_edge_insert(handle_t *handle,\n\t\t\t\t       struct ocfs2_path *left_path,\n\t\t\t\t       struct ocfs2_path *right_path,\n\t\t\t\t       int subtree_index)\n{\n\tint i, idx;\n\tstruct ocfs2_extent_list *el, *left_el, *right_el;\n\tstruct ocfs2_extent_rec *left_rec, *right_rec;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\n\t/*\n\t * Update the counts and position values within all the\n\t * interior nodes to reflect the leaf rotation we just did.\n\t *\n\t * The root node is handled below the loop.\n\t *\n\t * We begin the loop with right_el and left_el pointing to the\n\t * leaf lists and work our way up.\n\t *\n\t * NOTE: within this loop, left_el and right_el always refer\n\t * to the *child* lists.\n\t */\n\tleft_el = path_leaf_el(left_path);\n\tright_el = path_leaf_el(right_path);\n\tfor(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {\n\t\ttrace_ocfs2_complete_edge_insert(i);\n\n\t\t/*\n\t\t * One nice property of knowing that all of these\n\t\t * nodes are below the root is that we only deal with\n\t\t * the leftmost right node record and the rightmost\n\t\t * left node record.\n\t\t */\n\t\tel = left_path->p_node[i].el;\n\t\tidx = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\t\tleft_rec = &el->l_recs[idx];\n\n\t\tel = right_path->p_node[i].el;\n\t\tright_rec = &el->l_recs[0];\n\n\t\tocfs2_adjust_adjacent_records(left_rec, left_el, right_rec,\n\t\t\t\t\t      right_el);\n\n\t\tocfs2_journal_dirty(handle, left_path->p_node[i].bh);\n\t\tocfs2_journal_dirty(handle, right_path->p_node[i].bh);\n\n\t\t/*\n\t\t * Setup our list pointers now so that the current\n\t\t * parents become children in the next iteration.\n\t\t */\n\t\tleft_el = left_path->p_node[i].el;\n\t\tright_el = right_path->p_node[i].el;\n\t}\n\n\t/*\n\t * At the root node, adjust the two adjacent records which\n\t * begin our path to the leaves.\n\t */\n\n\tel = left_path->p_node[subtree_index].el;\n\tleft_el = left_path->p_node[subtree_index + 1].el;\n\tright_el = right_path->p_node[subtree_index + 1].el;\n\n\tocfs2_adjust_root_records(el, left_el, right_el,\n\t\t\t\t  left_path->p_node[subtree_index + 1].bh->b_blocknr);\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\n\tocfs2_journal_dirty(handle, root_bh);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "root_bh"
          ],
          "line": 2098
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_adjust_root_records",
          "args": [
            "el",
            "left_el",
            "right_el",
            "left_path->p_node[subtree_index + 1].bh->b_blocknr"
          ],
          "line": 2093
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_adjust_root_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1992-2015",
          "snippet": "static void ocfs2_adjust_root_records(struct ocfs2_extent_list *root_el,\n\t\t\t\t      struct ocfs2_extent_list *left_el,\n\t\t\t\t      struct ocfs2_extent_list *right_el,\n\t\t\t\t      u64 left_el_blkno)\n{\n\tint i;\n\n\tBUG_ON(le16_to_cpu(root_el->l_tree_depth) <=\n\t       le16_to_cpu(left_el->l_tree_depth));\n\n\tfor(i = 0; i < le16_to_cpu(root_el->l_next_free_rec) - 1; i++) {\n\t\tif (le64_to_cpu(root_el->l_recs[i].e_blkno) == left_el_blkno)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * The path walking code should have never returned a root and\n\t * two paths which are not adjacent.\n\t */\n\tBUG_ON(i >= (le16_to_cpu(root_el->l_next_free_rec) - 1));\n\n\tocfs2_adjust_adjacent_records(&root_el->l_recs[i], left_el,\n\t\t\t\t      &root_el->l_recs[i + 1], right_el);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_adjust_root_records(struct ocfs2_extent_list *root_el,\n\t\t\t\t      struct ocfs2_extent_list *left_el,\n\t\t\t\t      struct ocfs2_extent_list *right_el,\n\t\t\t\t      u64 left_el_blkno)\n{\n\tint i;\n\n\tBUG_ON(le16_to_cpu(root_el->l_tree_depth) <=\n\t       le16_to_cpu(left_el->l_tree_depth));\n\n\tfor(i = 0; i < le16_to_cpu(root_el->l_next_free_rec) - 1; i++) {\n\t\tif (le64_to_cpu(root_el->l_recs[i].e_blkno) == left_el_blkno)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * The path walking code should have never returned a root and\n\t * two paths which are not adjacent.\n\t */\n\tBUG_ON(i >= (le16_to_cpu(root_el->l_next_free_rec) - 1));\n\n\tocfs2_adjust_adjacent_records(&root_el->l_recs[i], left_el,\n\t\t\t\t      &root_el->l_recs[i + 1], right_el);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_adjust_adjacent_records",
          "args": [
            "left_rec",
            "left_el",
            "right_rec",
            "right_el"
          ],
          "line": 2070
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_adjust_adjacent_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1949-1985",
          "snippet": "static void ocfs2_adjust_adjacent_records(struct ocfs2_extent_rec *left_rec,\n\t\t\t\t  struct ocfs2_extent_list *left_child_el,\n\t\t\t\t  struct ocfs2_extent_rec *right_rec,\n\t\t\t\t  struct ocfs2_extent_list *right_child_el)\n{\n\tu32 left_clusters, right_end;\n\n\t/*\n\t * Interior nodes never have holes. Their cpos is the cpos of\n\t * the leftmost record in their child list. Their cluster\n\t * count covers the full theoretical range of their child list\n\t * - the range between their cpos and the cpos of the record\n\t * immediately to their right.\n\t */\n\tleft_clusters = le32_to_cpu(right_child_el->l_recs[0].e_cpos);\n\tif (!ocfs2_rec_clusters(right_child_el, &right_child_el->l_recs[0])) {\n\t\tBUG_ON(right_child_el->l_tree_depth);\n\t\tBUG_ON(le16_to_cpu(right_child_el->l_next_free_rec) <= 1);\n\t\tleft_clusters = le32_to_cpu(right_child_el->l_recs[1].e_cpos);\n\t}\n\tleft_clusters -= le32_to_cpu(left_rec->e_cpos);\n\tleft_rec->e_int_clusters = cpu_to_le32(left_clusters);\n\n\t/*\n\t * Calculate the rightmost cluster count boundary before\n\t * moving cpos - we will need to adjust clusters after\n\t * updating e_cpos to keep the same highest cluster count.\n\t */\n\tright_end = le32_to_cpu(right_rec->e_cpos);\n\tright_end += le32_to_cpu(right_rec->e_int_clusters);\n\n\tright_rec->e_cpos = left_rec->e_cpos;\n\tle32_add_cpu(&right_rec->e_cpos, left_clusters);\n\n\tright_end -= le32_to_cpu(right_rec->e_cpos);\n\tright_rec->e_int_clusters = cpu_to_le32(right_end);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\n\nstatic void ocfs2_adjust_adjacent_records(struct ocfs2_extent_rec *left_rec,\n\t\t\t\t  struct ocfs2_extent_list *left_child_el,\n\t\t\t\t  struct ocfs2_extent_rec *right_rec,\n\t\t\t\t  struct ocfs2_extent_list *right_child_el)\n{\n\tu32 left_clusters, right_end;\n\n\t/*\n\t * Interior nodes never have holes. Their cpos is the cpos of\n\t * the leftmost record in their child list. Their cluster\n\t * count covers the full theoretical range of their child list\n\t * - the range between their cpos and the cpos of the record\n\t * immediately to their right.\n\t */\n\tleft_clusters = le32_to_cpu(right_child_el->l_recs[0].e_cpos);\n\tif (!ocfs2_rec_clusters(right_child_el, &right_child_el->l_recs[0])) {\n\t\tBUG_ON(right_child_el->l_tree_depth);\n\t\tBUG_ON(le16_to_cpu(right_child_el->l_next_free_rec) <= 1);\n\t\tleft_clusters = le32_to_cpu(right_child_el->l_recs[1].e_cpos);\n\t}\n\tleft_clusters -= le32_to_cpu(left_rec->e_cpos);\n\tleft_rec->e_int_clusters = cpu_to_le32(left_clusters);\n\n\t/*\n\t * Calculate the rightmost cluster count boundary before\n\t * moving cpos - we will need to adjust clusters after\n\t * updating e_cpos to keep the same highest cluster count.\n\t */\n\tright_end = le32_to_cpu(right_rec->e_cpos);\n\tright_end += le32_to_cpu(right_rec->e_int_clusters);\n\n\tright_rec->e_cpos = left_rec->e_cpos;\n\tle32_add_cpu(&right_rec->e_cpos, left_clusters);\n\n\tright_end -= le32_to_cpu(right_rec->e_cpos);\n\tright_rec->e_int_clusters = cpu_to_le32(right_end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "left_el->l_next_free_rec"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_complete_edge_insert",
          "args": [
            "i"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "right_path"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "left_path"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_complete_edge_insert(handle_t *handle,\n\t\t\t\t       struct ocfs2_path *left_path,\n\t\t\t\t       struct ocfs2_path *right_path,\n\t\t\t\t       int subtree_index)\n{\n\tint i, idx;\n\tstruct ocfs2_extent_list *el, *left_el, *right_el;\n\tstruct ocfs2_extent_rec *left_rec, *right_rec;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\n\t/*\n\t * Update the counts and position values within all the\n\t * interior nodes to reflect the leaf rotation we just did.\n\t *\n\t * The root node is handled below the loop.\n\t *\n\t * We begin the loop with right_el and left_el pointing to the\n\t * leaf lists and work our way up.\n\t *\n\t * NOTE: within this loop, left_el and right_el always refer\n\t * to the *child* lists.\n\t */\n\tleft_el = path_leaf_el(left_path);\n\tright_el = path_leaf_el(right_path);\n\tfor(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {\n\t\ttrace_ocfs2_complete_edge_insert(i);\n\n\t\t/*\n\t\t * One nice property of knowing that all of these\n\t\t * nodes are below the root is that we only deal with\n\t\t * the leftmost right node record and the rightmost\n\t\t * left node record.\n\t\t */\n\t\tel = left_path->p_node[i].el;\n\t\tidx = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\t\tleft_rec = &el->l_recs[idx];\n\n\t\tel = right_path->p_node[i].el;\n\t\tright_rec = &el->l_recs[0];\n\n\t\tocfs2_adjust_adjacent_records(left_rec, left_el, right_rec,\n\t\t\t\t\t      right_el);\n\n\t\tocfs2_journal_dirty(handle, left_path->p_node[i].bh);\n\t\tocfs2_journal_dirty(handle, right_path->p_node[i].bh);\n\n\t\t/*\n\t\t * Setup our list pointers now so that the current\n\t\t * parents become children in the next iteration.\n\t\t */\n\t\tleft_el = left_path->p_node[i].el;\n\t\tright_el = right_path->p_node[i].el;\n\t}\n\n\t/*\n\t * At the root node, adjust the two adjacent records which\n\t * begin our path to the leaves.\n\t */\n\n\tel = left_path->p_node[subtree_index].el;\n\tleft_el = left_path->p_node[subtree_index + 1].el;\n\tright_el = right_path->p_node[subtree_index + 1].el;\n\n\tocfs2_adjust_root_records(el, left_el, right_el,\n\t\t\t\t  left_path->p_node[subtree_index + 1].bh->b_blocknr);\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\n\tocfs2_journal_dirty(handle, root_bh);\n}"
  },
  {
    "function_name": "ocfs2_adjust_root_records",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "1992-2015",
    "snippet": "static void ocfs2_adjust_root_records(struct ocfs2_extent_list *root_el,\n\t\t\t\t      struct ocfs2_extent_list *left_el,\n\t\t\t\t      struct ocfs2_extent_list *right_el,\n\t\t\t\t      u64 left_el_blkno)\n{\n\tint i;\n\n\tBUG_ON(le16_to_cpu(root_el->l_tree_depth) <=\n\t       le16_to_cpu(left_el->l_tree_depth));\n\n\tfor(i = 0; i < le16_to_cpu(root_el->l_next_free_rec) - 1; i++) {\n\t\tif (le64_to_cpu(root_el->l_recs[i].e_blkno) == left_el_blkno)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * The path walking code should have never returned a root and\n\t * two paths which are not adjacent.\n\t */\n\tBUG_ON(i >= (le16_to_cpu(root_el->l_next_free_rec) - 1));\n\n\tocfs2_adjust_adjacent_records(&root_el->l_recs[i], left_el,\n\t\t\t\t      &root_el->l_recs[i + 1], right_el);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_adjust_adjacent_records",
          "args": [
            "&root_el->l_recs[i]",
            "left_el",
            "&root_el->l_recs[i + 1]",
            "right_el"
          ],
          "line": 2013
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_adjust_adjacent_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1949-1985",
          "snippet": "static void ocfs2_adjust_adjacent_records(struct ocfs2_extent_rec *left_rec,\n\t\t\t\t  struct ocfs2_extent_list *left_child_el,\n\t\t\t\t  struct ocfs2_extent_rec *right_rec,\n\t\t\t\t  struct ocfs2_extent_list *right_child_el)\n{\n\tu32 left_clusters, right_end;\n\n\t/*\n\t * Interior nodes never have holes. Their cpos is the cpos of\n\t * the leftmost record in their child list. Their cluster\n\t * count covers the full theoretical range of their child list\n\t * - the range between their cpos and the cpos of the record\n\t * immediately to their right.\n\t */\n\tleft_clusters = le32_to_cpu(right_child_el->l_recs[0].e_cpos);\n\tif (!ocfs2_rec_clusters(right_child_el, &right_child_el->l_recs[0])) {\n\t\tBUG_ON(right_child_el->l_tree_depth);\n\t\tBUG_ON(le16_to_cpu(right_child_el->l_next_free_rec) <= 1);\n\t\tleft_clusters = le32_to_cpu(right_child_el->l_recs[1].e_cpos);\n\t}\n\tleft_clusters -= le32_to_cpu(left_rec->e_cpos);\n\tleft_rec->e_int_clusters = cpu_to_le32(left_clusters);\n\n\t/*\n\t * Calculate the rightmost cluster count boundary before\n\t * moving cpos - we will need to adjust clusters after\n\t * updating e_cpos to keep the same highest cluster count.\n\t */\n\tright_end = le32_to_cpu(right_rec->e_cpos);\n\tright_end += le32_to_cpu(right_rec->e_int_clusters);\n\n\tright_rec->e_cpos = left_rec->e_cpos;\n\tle32_add_cpu(&right_rec->e_cpos, left_clusters);\n\n\tright_end -= le32_to_cpu(right_rec->e_cpos);\n\tright_rec->e_int_clusters = cpu_to_le32(right_end);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\n\nstatic void ocfs2_adjust_adjacent_records(struct ocfs2_extent_rec *left_rec,\n\t\t\t\t  struct ocfs2_extent_list *left_child_el,\n\t\t\t\t  struct ocfs2_extent_rec *right_rec,\n\t\t\t\t  struct ocfs2_extent_list *right_child_el)\n{\n\tu32 left_clusters, right_end;\n\n\t/*\n\t * Interior nodes never have holes. Their cpos is the cpos of\n\t * the leftmost record in their child list. Their cluster\n\t * count covers the full theoretical range of their child list\n\t * - the range between their cpos and the cpos of the record\n\t * immediately to their right.\n\t */\n\tleft_clusters = le32_to_cpu(right_child_el->l_recs[0].e_cpos);\n\tif (!ocfs2_rec_clusters(right_child_el, &right_child_el->l_recs[0])) {\n\t\tBUG_ON(right_child_el->l_tree_depth);\n\t\tBUG_ON(le16_to_cpu(right_child_el->l_next_free_rec) <= 1);\n\t\tleft_clusters = le32_to_cpu(right_child_el->l_recs[1].e_cpos);\n\t}\n\tleft_clusters -= le32_to_cpu(left_rec->e_cpos);\n\tleft_rec->e_int_clusters = cpu_to_le32(left_clusters);\n\n\t/*\n\t * Calculate the rightmost cluster count boundary before\n\t * moving cpos - we will need to adjust clusters after\n\t * updating e_cpos to keep the same highest cluster count.\n\t */\n\tright_end = le32_to_cpu(right_rec->e_cpos);\n\tright_end += le32_to_cpu(right_rec->e_int_clusters);\n\n\tright_rec->e_cpos = left_rec->e_cpos;\n\tle32_add_cpu(&right_rec->e_cpos, left_clusters);\n\n\tright_end -= le32_to_cpu(right_rec->e_cpos);\n\tright_rec->e_int_clusters = cpu_to_le32(right_end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "i >= (le16_to_cpu(root_el->l_next_free_rec) - 1)"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "root_el->l_next_free_rec"
          ],
          "line": 2011
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "root_el->l_recs[i].e_blkno"
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le16_to_cpu(root_el->l_tree_depth) <=\n\t       le16_to_cpu(left_el->l_tree_depth)"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_adjust_root_records(struct ocfs2_extent_list *root_el,\n\t\t\t\t      struct ocfs2_extent_list *left_el,\n\t\t\t\t      struct ocfs2_extent_list *right_el,\n\t\t\t\t      u64 left_el_blkno)\n{\n\tint i;\n\n\tBUG_ON(le16_to_cpu(root_el->l_tree_depth) <=\n\t       le16_to_cpu(left_el->l_tree_depth));\n\n\tfor(i = 0; i < le16_to_cpu(root_el->l_next_free_rec) - 1; i++) {\n\t\tif (le64_to_cpu(root_el->l_recs[i].e_blkno) == left_el_blkno)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * The path walking code should have never returned a root and\n\t * two paths which are not adjacent.\n\t */\n\tBUG_ON(i >= (le16_to_cpu(root_el->l_next_free_rec) - 1));\n\n\tocfs2_adjust_adjacent_records(&root_el->l_recs[i], left_el,\n\t\t\t\t      &root_el->l_recs[i + 1], right_el);\n}"
  },
  {
    "function_name": "ocfs2_adjust_adjacent_records",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "1949-1985",
    "snippet": "static void ocfs2_adjust_adjacent_records(struct ocfs2_extent_rec *left_rec,\n\t\t\t\t  struct ocfs2_extent_list *left_child_el,\n\t\t\t\t  struct ocfs2_extent_rec *right_rec,\n\t\t\t\t  struct ocfs2_extent_list *right_child_el)\n{\n\tu32 left_clusters, right_end;\n\n\t/*\n\t * Interior nodes never have holes. Their cpos is the cpos of\n\t * the leftmost record in their child list. Their cluster\n\t * count covers the full theoretical range of their child list\n\t * - the range between their cpos and the cpos of the record\n\t * immediately to their right.\n\t */\n\tleft_clusters = le32_to_cpu(right_child_el->l_recs[0].e_cpos);\n\tif (!ocfs2_rec_clusters(right_child_el, &right_child_el->l_recs[0])) {\n\t\tBUG_ON(right_child_el->l_tree_depth);\n\t\tBUG_ON(le16_to_cpu(right_child_el->l_next_free_rec) <= 1);\n\t\tleft_clusters = le32_to_cpu(right_child_el->l_recs[1].e_cpos);\n\t}\n\tleft_clusters -= le32_to_cpu(left_rec->e_cpos);\n\tleft_rec->e_int_clusters = cpu_to_le32(left_clusters);\n\n\t/*\n\t * Calculate the rightmost cluster count boundary before\n\t * moving cpos - we will need to adjust clusters after\n\t * updating e_cpos to keep the same highest cluster count.\n\t */\n\tright_end = le32_to_cpu(right_rec->e_cpos);\n\tright_end += le32_to_cpu(right_rec->e_int_clusters);\n\n\tright_rec->e_cpos = left_rec->e_cpos;\n\tle32_add_cpu(&right_rec->e_cpos, left_clusters);\n\n\tright_end -= le32_to_cpu(right_rec->e_cpos);\n\tright_rec->e_int_clusters = cpu_to_le32(right_end);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
      "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "right_end"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "right_rec->e_cpos"
          ],
          "line": 1983
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&right_rec->e_cpos",
            "left_clusters"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "left_clusters"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le16_to_cpu(right_child_el->l_next_free_rec) <= 1"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "right_child_el->l_next_free_rec"
          ],
          "line": 1966
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "right_child_el->l_tree_depth"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rec_clusters",
          "args": [
            "right_child_el",
            "&right_child_el->l_recs[0]"
          ],
          "line": 1964
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rec_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "246-260",
          "snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\n\nstatic void ocfs2_adjust_adjacent_records(struct ocfs2_extent_rec *left_rec,\n\t\t\t\t  struct ocfs2_extent_list *left_child_el,\n\t\t\t\t  struct ocfs2_extent_rec *right_rec,\n\t\t\t\t  struct ocfs2_extent_list *right_child_el)\n{\n\tu32 left_clusters, right_end;\n\n\t/*\n\t * Interior nodes never have holes. Their cpos is the cpos of\n\t * the leftmost record in their child list. Their cluster\n\t * count covers the full theoretical range of their child list\n\t * - the range between their cpos and the cpos of the record\n\t * immediately to their right.\n\t */\n\tleft_clusters = le32_to_cpu(right_child_el->l_recs[0].e_cpos);\n\tif (!ocfs2_rec_clusters(right_child_el, &right_child_el->l_recs[0])) {\n\t\tBUG_ON(right_child_el->l_tree_depth);\n\t\tBUG_ON(le16_to_cpu(right_child_el->l_next_free_rec) <= 1);\n\t\tleft_clusters = le32_to_cpu(right_child_el->l_recs[1].e_cpos);\n\t}\n\tleft_clusters -= le32_to_cpu(left_rec->e_cpos);\n\tleft_rec->e_int_clusters = cpu_to_le32(left_clusters);\n\n\t/*\n\t * Calculate the rightmost cluster count boundary before\n\t * moving cpos - we will need to adjust clusters after\n\t * updating e_cpos to keep the same highest cluster count.\n\t */\n\tright_end = le32_to_cpu(right_rec->e_cpos);\n\tright_end += le32_to_cpu(right_rec->e_int_clusters);\n\n\tright_rec->e_cpos = left_rec->e_cpos;\n\tle32_add_cpu(&right_rec->e_cpos, left_clusters);\n\n\tright_end -= le32_to_cpu(right_rec->e_cpos);\n\tright_rec->e_int_clusters = cpu_to_le32(right_end);\n}"
  },
  {
    "function_name": "ocfs2_find_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "1917-1933",
    "snippet": "int ocfs2_find_leaf(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t    struct buffer_head **leaf_bh)\n{\n\tint ret;\n\tstruct buffer_head *bh = NULL;\n\n\tret = __ocfs2_find_path(ci, root_el, cpos, find_leaf_ins, &bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*leaf_bh = bh;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_find_path",
          "args": [
            "ci",
            "root_el",
            "cpos",
            "find_leaf_ins",
            "&bh"
          ],
          "line": 1924
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1775-1860",
          "snippet": "static int __ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t\t     struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t\t     path_insert_t *func, void *data)\n{\n\tint i, ret = 0;\n\tu32 range;\n\tu64 blkno;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tel = root_el;\n\twhile (el->l_tree_depth) {\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has empty extent list at \"\n\t\t\t\t    \"depth %u\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    le16_to_cpu(el->l_tree_depth));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\n\t\t}\n\n\t\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec) - 1; i++) {\n\t\t\trec = &el->l_recs[i];\n\n\t\t\t/*\n\t\t\t * In the case that cpos is off the allocation\n\t\t\t * tree, this should just wind up returning the\n\t\t\t * rightmost record.\n\t\t\t */\n\t\t\trange = le32_to_cpu(rec->e_cpos) +\n\t\t\t\tocfs2_rec_clusters(el, rec);\n\t\t\tif (cpos >= le32_to_cpu(rec->e_cpos) && cpos < range)\n\t\t\t    break;\n\t\t}\n\n\t\tblkno = le64_to_cpu(el->l_recs[i].e_blkno);\n\t\tif (blkno == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has bad blkno in extent list \"\n\t\t\t\t    \"at depth %u (index %d)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    le16_to_cpu(el->l_tree_depth), i);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t\tret = ocfs2_read_extent_block(ci, blkno, &bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) >\n\t\t    le16_to_cpu(el->l_count)) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has bad count in extent list \"\n\t\t\t\t    \"at block %llu (next free=%u, count=%u)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t\t    le16_to_cpu(el->l_next_free_rec),\n\t\t\t\t    le16_to_cpu(el->l_count));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (func)\n\t\t\tfunc(data, bh);\n\t}\n\nout:\n\t/*\n\t * Catch any trailing bh that the loop didn't handle.\n\t */\n\tbrelse(bh);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int __ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t\t     struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t\t     path_insert_t *func, void *data)\n{\n\tint i, ret = 0;\n\tu32 range;\n\tu64 blkno;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tel = root_el;\n\twhile (el->l_tree_depth) {\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has empty extent list at \"\n\t\t\t\t    \"depth %u\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    le16_to_cpu(el->l_tree_depth));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\n\t\t}\n\n\t\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec) - 1; i++) {\n\t\t\trec = &el->l_recs[i];\n\n\t\t\t/*\n\t\t\t * In the case that cpos is off the allocation\n\t\t\t * tree, this should just wind up returning the\n\t\t\t * rightmost record.\n\t\t\t */\n\t\t\trange = le32_to_cpu(rec->e_cpos) +\n\t\t\t\tocfs2_rec_clusters(el, rec);\n\t\t\tif (cpos >= le32_to_cpu(rec->e_cpos) && cpos < range)\n\t\t\t    break;\n\t\t}\n\n\t\tblkno = le64_to_cpu(el->l_recs[i].e_blkno);\n\t\tif (blkno == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has bad blkno in extent list \"\n\t\t\t\t    \"at depth %u (index %d)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    le16_to_cpu(el->l_tree_depth), i);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t\tret = ocfs2_read_extent_block(ci, blkno, &bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) >\n\t\t    le16_to_cpu(el->l_count)) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has bad count in extent list \"\n\t\t\t\t    \"at block %llu (next free=%u, count=%u)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t\t    le16_to_cpu(el->l_next_free_rec),\n\t\t\t\t    le16_to_cpu(el->l_count));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (func)\n\t\t\tfunc(data, bh);\n\t}\n\nout:\n\t/*\n\t * Catch any trailing bh that the loop didn't handle.\n\t */\n\tbrelse(bh);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_leaf(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t    struct buffer_head **leaf_bh)\n{\n\tint ret;\n\tstruct buffer_head *bh = NULL;\n\n\tret = __ocfs2_find_path(ci, root_el, cpos, find_leaf_ins, &bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*leaf_bh = bh;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "find_leaf_ins",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "1896-1907",
    "snippet": "static void find_leaf_ins(void *data, struct buffer_head *bh)\n{\n\tstruct ocfs2_extent_block *eb =(struct ocfs2_extent_block *)bh->b_data;\n\tstruct ocfs2_extent_list *el = &eb->h_list;\n\tstruct buffer_head **ret = data;\n\n\t/* We want to retain only the leaf block. */\n\tif (le16_to_cpu(el->l_tree_depth) == 0) {\n\t\tget_bh(bh);\n\t\t*ret = bh;\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_tree_depth"
          ],
          "line": 1903
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic void find_leaf_ins(void *data, struct buffer_head *bh)\n{\n\tstruct ocfs2_extent_block *eb =(struct ocfs2_extent_block *)bh->b_data;\n\tstruct ocfs2_extent_list *el = &eb->h_list;\n\tstruct buffer_head **ret = data;\n\n\t/* We want to retain only the leaf block. */\n\tif (le16_to_cpu(el->l_tree_depth) == 0) {\n\t\tget_bh(bh);\n\t\t*ret = bh;\n\t}\n}"
  },
  {
    "function_name": "ocfs2_find_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "1885-1894",
    "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_find_path",
          "args": [
            "ci",
            "path_root_el(path)",
            "cpos",
            "find_path_ins",
            "&data"
          ],
          "line": 1892
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1775-1860",
          "snippet": "static int __ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t\t     struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t\t     path_insert_t *func, void *data)\n{\n\tint i, ret = 0;\n\tu32 range;\n\tu64 blkno;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tel = root_el;\n\twhile (el->l_tree_depth) {\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has empty extent list at \"\n\t\t\t\t    \"depth %u\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    le16_to_cpu(el->l_tree_depth));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\n\t\t}\n\n\t\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec) - 1; i++) {\n\t\t\trec = &el->l_recs[i];\n\n\t\t\t/*\n\t\t\t * In the case that cpos is off the allocation\n\t\t\t * tree, this should just wind up returning the\n\t\t\t * rightmost record.\n\t\t\t */\n\t\t\trange = le32_to_cpu(rec->e_cpos) +\n\t\t\t\tocfs2_rec_clusters(el, rec);\n\t\t\tif (cpos >= le32_to_cpu(rec->e_cpos) && cpos < range)\n\t\t\t    break;\n\t\t}\n\n\t\tblkno = le64_to_cpu(el->l_recs[i].e_blkno);\n\t\tif (blkno == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has bad blkno in extent list \"\n\t\t\t\t    \"at depth %u (index %d)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    le16_to_cpu(el->l_tree_depth), i);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t\tret = ocfs2_read_extent_block(ci, blkno, &bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) >\n\t\t    le16_to_cpu(el->l_count)) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has bad count in extent list \"\n\t\t\t\t    \"at block %llu (next free=%u, count=%u)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t\t    le16_to_cpu(el->l_next_free_rec),\n\t\t\t\t    le16_to_cpu(el->l_count));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (func)\n\t\t\tfunc(data, bh);\n\t}\n\nout:\n\t/*\n\t * Catch any trailing bh that the loop didn't handle.\n\t */\n\tbrelse(bh);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int __ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t\t     struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t\t     path_insert_t *func, void *data)\n{\n\tint i, ret = 0;\n\tu32 range;\n\tu64 blkno;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tel = root_el;\n\twhile (el->l_tree_depth) {\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has empty extent list at \"\n\t\t\t\t    \"depth %u\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    le16_to_cpu(el->l_tree_depth));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\n\t\t}\n\n\t\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec) - 1; i++) {\n\t\t\trec = &el->l_recs[i];\n\n\t\t\t/*\n\t\t\t * In the case that cpos is off the allocation\n\t\t\t * tree, this should just wind up returning the\n\t\t\t * rightmost record.\n\t\t\t */\n\t\t\trange = le32_to_cpu(rec->e_cpos) +\n\t\t\t\tocfs2_rec_clusters(el, rec);\n\t\t\tif (cpos >= le32_to_cpu(rec->e_cpos) && cpos < range)\n\t\t\t    break;\n\t\t}\n\n\t\tblkno = le64_to_cpu(el->l_recs[i].e_blkno);\n\t\tif (blkno == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has bad blkno in extent list \"\n\t\t\t\t    \"at depth %u (index %d)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    le16_to_cpu(el->l_tree_depth), i);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t\tret = ocfs2_read_extent_block(ci, blkno, &bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) >\n\t\t    le16_to_cpu(el->l_count)) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has bad count in extent list \"\n\t\t\t\t    \"at block %llu (next free=%u, count=%u)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t\t    le16_to_cpu(el->l_next_free_rec),\n\t\t\t\t    le16_to_cpu(el->l_count));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (func)\n\t\t\tfunc(data, bh);\n\t}\n\nout:\n\t/*\n\t * Catch any trailing bh that the loop didn't handle.\n\t */\n\tbrelse(bh);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_root_el",
          "args": [
            "path"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
  },
  {
    "function_name": "find_path_ins",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "1877-1884",
    "snippet": "static void find_path_ins(void *data, struct buffer_head *bh)\n{\n\tstruct find_path_data *fp = data;\n\n\tget_bh(bh);\n\tocfs2_path_insert_eb(fp->path, fp->index, bh);\n\tfp->index++;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_path_insert_eb",
          "args": [
            "fp->path",
            "fp->index",
            "bh"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_path_insert_eb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "670-685",
          "snippet": "static inline void ocfs2_path_insert_eb(struct ocfs2_path *path, int index,\n\t\t\t\t\tstruct buffer_head *eb_bh)\n{\n\tstruct ocfs2_extent_block *eb = (struct ocfs2_extent_block *)eb_bh->b_data;\n\n\t/*\n\t * Right now, no root bh is an extent block, so this helps\n\t * catch code errors with dinode trees. The assertion can be\n\t * safely removed if we ever need to insert extent block\n\t * structures at the root.\n\t */\n\tBUG_ON(index == 0);\n\n\tpath->p_node[index].bh = eb_bh;\n\tpath->p_node[index].el = &eb->h_list;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic inline void ocfs2_path_insert_eb(struct ocfs2_path *path, int index,\n\t\t\t\t\tstruct buffer_head *eb_bh)\n{\n\tstruct ocfs2_extent_block *eb = (struct ocfs2_extent_block *)eb_bh->b_data;\n\n\t/*\n\t * Right now, no root bh is an extent block, so this helps\n\t * catch code errors with dinode trees. The assertion can be\n\t * safely removed if we ever need to insert extent block\n\t * structures at the root.\n\t */\n\tBUG_ON(index == 0);\n\n\tpath->p_node[index].bh = eb_bh;\n\tpath->p_node[index].el = &eb->h_list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void find_path_ins(void *data, struct buffer_head *bh)\n{\n\tstruct find_path_data *fp = data;\n\n\tget_bh(bh);\n\tocfs2_path_insert_eb(fp->path, fp->index, bh);\n\tfp->index++;\n}"
  },
  {
    "function_name": "__ocfs2_find_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "1775-1860",
    "snippet": "static int __ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t\t     struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t\t     path_insert_t *func, void *data)\n{\n\tint i, ret = 0;\n\tu32 range;\n\tu64 blkno;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tel = root_el;\n\twhile (el->l_tree_depth) {\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has empty extent list at \"\n\t\t\t\t    \"depth %u\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    le16_to_cpu(el->l_tree_depth));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\n\t\t}\n\n\t\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec) - 1; i++) {\n\t\t\trec = &el->l_recs[i];\n\n\t\t\t/*\n\t\t\t * In the case that cpos is off the allocation\n\t\t\t * tree, this should just wind up returning the\n\t\t\t * rightmost record.\n\t\t\t */\n\t\t\trange = le32_to_cpu(rec->e_cpos) +\n\t\t\t\tocfs2_rec_clusters(el, rec);\n\t\t\tif (cpos >= le32_to_cpu(rec->e_cpos) && cpos < range)\n\t\t\t    break;\n\t\t}\n\n\t\tblkno = le64_to_cpu(el->l_recs[i].e_blkno);\n\t\tif (blkno == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has bad blkno in extent list \"\n\t\t\t\t    \"at depth %u (index %d)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    le16_to_cpu(el->l_tree_depth), i);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t\tret = ocfs2_read_extent_block(ci, blkno, &bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) >\n\t\t    le16_to_cpu(el->l_count)) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has bad count in extent list \"\n\t\t\t\t    \"at block %llu (next free=%u, count=%u)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t\t    le16_to_cpu(el->l_next_free_rec),\n\t\t\t\t    le16_to_cpu(el->l_count));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (func)\n\t\t\tfunc(data, bh);\n\t}\n\nout:\n\t/*\n\t * Catch any trailing bh that the loop didn't handle.\n\t */\n\tbrelse(bh);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "data",
            "bh"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_zero_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6589-6594",
          "snippet": "static int ocfs2_zero_func(handle_t *handle, struct buffer_head *bh)\n{\n\tset_buffer_uptodate(bh);\n\tmark_buffer_dirty(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_zero_func(handle_t *handle, struct buffer_head *bh)\n{\n\tset_buffer_uptodate(bh);\n\tmark_buffer_dirty(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "ocfs2_metadata_cache_get_super(ci)",
            "\"Owner %llu has bad count in extent list \"\n\t\t\t\t    \"at block %llu (next free=%u, count=%u)\\n\"",
            "(unsigned long long)ocfs2_metadata_cache_owner(ci)",
            "(unsigned long long)bh->b_blocknr",
            "le16_to_cpu(el->l_next_free_rec)",
            "le16_to_cpu(el->l_count)"
          ],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_count"
          ],
          "line": 1844
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "ci"
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "ci"
          ],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_extent_block",
          "args": [
            "ci",
            "blkno",
            "&bh"
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_extent_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "939-953",
          "snippet": "int ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "el->l_recs[i].e_blkno"
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 1810
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_rec_clusters",
          "args": [
            "el",
            "rec"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rec_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "246-260",
          "snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int __ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t\t     struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t\t     path_insert_t *func, void *data)\n{\n\tint i, ret = 0;\n\tu32 range;\n\tu64 blkno;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tel = root_el;\n\twhile (el->l_tree_depth) {\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has empty extent list at \"\n\t\t\t\t    \"depth %u\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    le16_to_cpu(el->l_tree_depth));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\n\t\t}\n\n\t\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec) - 1; i++) {\n\t\t\trec = &el->l_recs[i];\n\n\t\t\t/*\n\t\t\t * In the case that cpos is off the allocation\n\t\t\t * tree, this should just wind up returning the\n\t\t\t * rightmost record.\n\t\t\t */\n\t\t\trange = le32_to_cpu(rec->e_cpos) +\n\t\t\t\tocfs2_rec_clusters(el, rec);\n\t\t\tif (cpos >= le32_to_cpu(rec->e_cpos) && cpos < range)\n\t\t\t    break;\n\t\t}\n\n\t\tblkno = le64_to_cpu(el->l_recs[i].e_blkno);\n\t\tif (blkno == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has bad blkno in extent list \"\n\t\t\t\t    \"at depth %u (index %d)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    le16_to_cpu(el->l_tree_depth), i);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t\tret = ocfs2_read_extent_block(ci, blkno, &bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) >\n\t\t    le16_to_cpu(el->l_count)) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has bad count in extent list \"\n\t\t\t\t    \"at block %llu (next free=%u, count=%u)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t\t    le16_to_cpu(el->l_next_free_rec),\n\t\t\t\t    le16_to_cpu(el->l_count));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (func)\n\t\t\tfunc(data, bh);\n\t}\n\nout:\n\t/*\n\t * Catch any trailing bh that the loop didn't handle.\n\t */\n\tbrelse(bh);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_find_subtree_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "1737-1765",
    "snippet": "int ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "i > left->p_tree_depth",
            "\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\"",
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "left->p_tree_depth",
            "right->p_tree_depth",
            "(unsigned long long)path_leaf_bh(left)->b_blocknr",
            "(unsigned long long)path_leaf_bh(right)->b_blocknr"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "right"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "left"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "path_root_bh(left) != path_root_bh(right)"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_bh",
          "args": [
            "right"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_bh",
          "args": [
            "left"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}"
  },
  {
    "function_name": "ocfs2_create_empty_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "1700-1723",
    "snippet": "static void ocfs2_create_empty_extent(struct ocfs2_extent_list *el)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (next_free == 0)\n\t\tgoto set_and_inc;\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn;\n\n\tmlog_bug_on_msg(el->l_count == el->l_next_free_rec,\n\t\t\t\"Asked to create an empty extent in a full list:\\n\"\n\t\t\t\"count = %u, tree depth = %u\",\n\t\t\tle16_to_cpu(el->l_count),\n\t\t\tle16_to_cpu(el->l_tree_depth));\n\n\tocfs2_shift_records_right(el);\n\nset_and_inc:\n\tle16_add_cpu(&el->l_next_free_rec, 1);\n\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&el->l_recs[0]",
            "0",
            "sizeof(struct ocfs2_extent_rec)"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&el->l_next_free_rec",
            "1"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_shift_records_right",
          "args": [
            "el"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_shift_records_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1583-1596",
          "snippet": "static void ocfs2_shift_records_right(struct ocfs2_extent_list *el)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\tint count = le16_to_cpu(el->l_count);\n\tunsigned int num_bytes;\n\n\tBUG_ON(!next_free);\n\t/* This will cause us to go off the end of our extent list. */\n\tBUG_ON(next_free >= count);\n\n\tnum_bytes = sizeof(struct ocfs2_extent_rec) * next_free;\n\n\tmemmove(&el->l_recs[1], &el->l_recs[0], num_bytes);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_shift_records_right(struct ocfs2_extent_list *el)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\tint count = le16_to_cpu(el->l_count);\n\tunsigned int num_bytes;\n\n\tBUG_ON(!next_free);\n\t/* This will cause us to go off the end of our extent list. */\n\tBUG_ON(next_free >= count);\n\n\tnum_bytes = sizeof(struct ocfs2_extent_rec) * next_free;\n\n\tmemmove(&el->l_recs[1], &el->l_recs[0], num_bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "el->l_count == el->l_next_free_rec",
            "\"Asked to create an empty extent in a full list:\\n\"\n\t\t\t\"count = %u, tree depth = %u\"",
            "le16_to_cpu(el->l_count)",
            "le16_to_cpu(el->l_tree_depth)"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_tree_depth"
          ],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&el->l_recs[0]"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "266-269",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le16_to_cpu(el->l_tree_depth) != 0"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_create_empty_extent(struct ocfs2_extent_list *el)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (next_free == 0)\n\t\tgoto set_and_inc;\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn;\n\n\tmlog_bug_on_msg(el->l_count == el->l_next_free_rec,\n\t\t\t\"Asked to create an empty extent in a full list:\\n\"\n\t\t\t\"count = %u, tree depth = %u\",\n\t\t\tle16_to_cpu(el->l_count),\n\t\t\tle16_to_cpu(el->l_tree_depth));\n\n\tocfs2_shift_records_right(el);\n\nset_and_inc:\n\tle16_add_cpu(&el->l_next_free_rec, 1);\n\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n}"
  },
  {
    "function_name": "ocfs2_remove_empty_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "1677-1691",
    "snippet": "static void ocfs2_remove_empty_extent(struct ocfs2_extent_list *el)\n{\n\tint size, num_recs = le16_to_cpu(el->l_next_free_rec);\n\n\tBUG_ON(num_recs == 0);\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0])) {\n\t\tnum_recs--;\n\t\tsize = num_recs * sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[0], &el->l_recs[1], size);\n\t\tmemset(&el->l_recs[num_recs], 0,\n\t\t       sizeof(struct ocfs2_extent_rec));\n\t\tel->l_next_free_rec = cpu_to_le16(num_recs);\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "num_recs"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&el->l_recs[num_recs]",
            "0",
            "sizeof(struct ocfs2_extent_rec)"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&el->l_recs[0]",
            "&el->l_recs[1]",
            "size"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&el->l_recs[0]"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "266-269",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "num_recs == 0"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_remove_empty_extent(struct ocfs2_extent_list *el)\n{\n\tint size, num_recs = le16_to_cpu(el->l_next_free_rec);\n\n\tBUG_ON(num_recs == 0);\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0])) {\n\t\tnum_recs--;\n\t\tsize = num_recs * sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[0], &el->l_recs[1], size);\n\t\tmemset(&el->l_recs[num_recs], 0,\n\t\t       sizeof(struct ocfs2_extent_rec));\n\t\tel->l_next_free_rec = cpu_to_le16(num_recs);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_rotate_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "1598-1675",
    "snippet": "static void ocfs2_rotate_leaf(struct ocfs2_extent_list *el,\n\t\t\t      struct ocfs2_extent_rec *insert_rec)\n{\n\tint i, insert_index, next_free, has_empty, num_bytes;\n\tu32 insert_cpos = le32_to_cpu(insert_rec->e_cpos);\n\tstruct ocfs2_extent_rec *rec;\n\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\thas_empty = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\tBUG_ON(!next_free);\n\n\t/* The tree code before us didn't allow enough room in the leaf. */\n\tBUG_ON(el->l_next_free_rec == el->l_count && !has_empty);\n\n\t/*\n\t * The easiest way to approach this is to just remove the\n\t * empty extent and temporarily decrement next_free.\n\t */\n\tif (has_empty) {\n\t\t/*\n\t\t * If next_free was 1 (only an empty extent), this\n\t\t * loop won't execute, which is fine. We still want\n\t\t * the decrement above to happen.\n\t\t */\n\t\tfor(i = 0; i < (next_free - 1); i++)\n\t\t\tel->l_recs[i] = el->l_recs[i+1];\n\n\t\tnext_free--;\n\t}\n\n\t/*\n\t * Figure out what the new record index should be.\n\t */\n\tfor(i = 0; i < next_free; i++) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (insert_cpos < le32_to_cpu(rec->e_cpos))\n\t\t\tbreak;\n\t}\n\tinsert_index = i;\n\n\ttrace_ocfs2_rotate_leaf(insert_cpos, insert_index,\n\t\t\t\thas_empty, next_free,\n\t\t\t\tle16_to_cpu(el->l_count));\n\n\tBUG_ON(insert_index < 0);\n\tBUG_ON(insert_index >= le16_to_cpu(el->l_count));\n\tBUG_ON(insert_index > next_free);\n\n\t/*\n\t * No need to memmove if we're just adding to the tail.\n\t */\n\tif (insert_index != next_free) {\n\t\tBUG_ON(next_free >= le16_to_cpu(el->l_count));\n\n\t\tnum_bytes = next_free - insert_index;\n\t\tnum_bytes *= sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[insert_index + 1],\n\t\t\t&el->l_recs[insert_index],\n\t\t\tnum_bytes);\n\t}\n\n\t/*\n\t * Either we had an empty extent, and need to re-increment or\n\t * there was no empty extent on a non full rightmost leaf node,\n\t * in which case we still need to increment.\n\t */\n\tnext_free++;\n\tel->l_next_free_rec = cpu_to_le16(next_free);\n\t/*\n\t * Make sure none of the math above just messed up our tree.\n\t */\n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) > le16_to_cpu(el->l_count));\n\n\tel->l_recs[insert_index] = *insert_rec;\n\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le16_to_cpu(el->l_next_free_rec) > le16_to_cpu(el->l_count)"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_count"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "next_free"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&el->l_recs[insert_index + 1]",
            "&el->l_recs[insert_index]",
            "num_bytes"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "next_free >= le16_to_cpu(el->l_count)"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "insert_index > next_free"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "insert_index >= le16_to_cpu(el->l_count)"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "insert_index < 0"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_rotate_leaf",
          "args": [
            "insert_cpos",
            "insert_index",
            "has_empty",
            "next_free",
            "le16_to_cpu(el->l_count)"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "el->l_next_free_rec == el->l_count && !has_empty"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!next_free"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&el->l_recs[0]"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "266-269",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_rotate_leaf(struct ocfs2_extent_list *el,\n\t\t\t      struct ocfs2_extent_rec *insert_rec)\n{\n\tint i, insert_index, next_free, has_empty, num_bytes;\n\tu32 insert_cpos = le32_to_cpu(insert_rec->e_cpos);\n\tstruct ocfs2_extent_rec *rec;\n\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\thas_empty = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\tBUG_ON(!next_free);\n\n\t/* The tree code before us didn't allow enough room in the leaf. */\n\tBUG_ON(el->l_next_free_rec == el->l_count && !has_empty);\n\n\t/*\n\t * The easiest way to approach this is to just remove the\n\t * empty extent and temporarily decrement next_free.\n\t */\n\tif (has_empty) {\n\t\t/*\n\t\t * If next_free was 1 (only an empty extent), this\n\t\t * loop won't execute, which is fine. We still want\n\t\t * the decrement above to happen.\n\t\t */\n\t\tfor(i = 0; i < (next_free - 1); i++)\n\t\t\tel->l_recs[i] = el->l_recs[i+1];\n\n\t\tnext_free--;\n\t}\n\n\t/*\n\t * Figure out what the new record index should be.\n\t */\n\tfor(i = 0; i < next_free; i++) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (insert_cpos < le32_to_cpu(rec->e_cpos))\n\t\t\tbreak;\n\t}\n\tinsert_index = i;\n\n\ttrace_ocfs2_rotate_leaf(insert_cpos, insert_index,\n\t\t\t\thas_empty, next_free,\n\t\t\t\tle16_to_cpu(el->l_count));\n\n\tBUG_ON(insert_index < 0);\n\tBUG_ON(insert_index >= le16_to_cpu(el->l_count));\n\tBUG_ON(insert_index > next_free);\n\n\t/*\n\t * No need to memmove if we're just adding to the tail.\n\t */\n\tif (insert_index != next_free) {\n\t\tBUG_ON(next_free >= le16_to_cpu(el->l_count));\n\n\t\tnum_bytes = next_free - insert_index;\n\t\tnum_bytes *= sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[insert_index + 1],\n\t\t\t&el->l_recs[insert_index],\n\t\t\tnum_bytes);\n\t}\n\n\t/*\n\t * Either we had an empty extent, and need to re-increment or\n\t * there was no empty extent on a non full rightmost leaf node,\n\t * in which case we still need to increment.\n\t */\n\tnext_free++;\n\tel->l_next_free_rec = cpu_to_le16(next_free);\n\t/*\n\t * Make sure none of the math above just messed up our tree.\n\t */\n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) > le16_to_cpu(el->l_count));\n\n\tel->l_recs[insert_index] = *insert_rec;\n\n}"
  },
  {
    "function_name": "ocfs2_shift_records_right",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "1583-1596",
    "snippet": "static void ocfs2_shift_records_right(struct ocfs2_extent_list *el)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\tint count = le16_to_cpu(el->l_count);\n\tunsigned int num_bytes;\n\n\tBUG_ON(!next_free);\n\t/* This will cause us to go off the end of our extent list. */\n\tBUG_ON(next_free >= count);\n\n\tnum_bytes = sizeof(struct ocfs2_extent_rec) * next_free;\n\n\tmemmove(&el->l_recs[1], &el->l_recs[0], num_bytes);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&el->l_recs[1]",
            "&el->l_recs[0]",
            "num_bytes"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "next_free >= count"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!next_free"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_count"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_shift_records_right(struct ocfs2_extent_list *el)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\tint count = le16_to_cpu(el->l_count);\n\tunsigned int num_bytes;\n\n\tBUG_ON(!next_free);\n\t/* This will cause us to go off the end of our extent list. */\n\tBUG_ON(next_free >= count);\n\n\tnum_bytes = sizeof(struct ocfs2_extent_rec) * next_free;\n\n\tmemmove(&el->l_recs[1], &el->l_recs[0], num_bytes);\n}"
  },
  {
    "function_name": "ocfs2_grow_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "1510-1578",
    "snippet": "static int ocfs2_grow_tree(handle_t *handle, struct ocfs2_extent_tree *et,\n\t\t\t   int *final_depth, struct buffer_head **last_eb_bh,\n\t\t\t   struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret, shift;\n\tstruct ocfs2_extent_list *el = et->et_root_el;\n\tint depth = le16_to_cpu(el->l_tree_depth);\n\tstruct buffer_head *bh = NULL;\n\n\tBUG_ON(meta_ac == NULL);\n\n\tshift = ocfs2_find_branch_target(et, &bh);\n\tif (shift < 0) {\n\t\tret = shift;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* We traveled all the way to the bottom of the allocation tree\n\t * and didn't find room for any more extents - we need to add\n\t * another tree level */\n\tif (shift) {\n\t\tBUG_ON(bh);\n\t\ttrace_ocfs2_grow_tree(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tdepth);\n\n\t\t/* ocfs2_shift_tree_depth will return us a buffer with\n\t\t * the new extent block (so we can pass that to\n\t\t * ocfs2_add_branch). */\n\t\tret = ocfs2_shift_tree_depth(handle, et, meta_ac, &bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tdepth++;\n\t\tif (depth == 1) {\n\t\t\t/*\n\t\t\t * Special case: we have room now if we shifted from\n\t\t\t * tree_depth 0, so no more work needs to be done.\n\t\t\t *\n\t\t\t * We won't be calling add_branch, so pass\n\t\t\t * back *last_eb_bh as the new leaf. At depth\n\t\t\t * zero, it should always be null so there's\n\t\t\t * no reason to brelse.\n\t\t\t */\n\t\t\tBUG_ON(*last_eb_bh);\n\t\t\tget_bh(bh);\n\t\t\t*last_eb_bh = bh;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* call ocfs2_add_branch to add the final part of the tree with\n\t * the new data. */\n\tret = ocfs2_add_branch(handle, et, bh, last_eb_bh,\n\t\t\t       meta_ac);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout:\n\tif (final_depth)\n\t\t*final_depth = depth;\n\tbrelse(bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_add_branch",
          "args": [
            "handle",
            "et",
            "bh",
            "last_eb_bh",
            "meta_ac"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_add_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1157-1333",
          "snippet": "static int ocfs2_add_branch(handle_t *handle,\n\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t    struct buffer_head *eb_bh,\n\t\t\t    struct buffer_head **last_eb_bh,\n\t\t\t    struct ocfs2_alloc_context *meta_ac)\n{\n\tint status, new_blocks, i;\n\tu64 next_blkno, new_last_eb_blk;\n\tstruct buffer_head *bh;\n\tstruct buffer_head **new_eb_bhs = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list  *eb_el;\n\tstruct ocfs2_extent_list  *el;\n\tu32 new_cpos, root_end;\n\n\tBUG_ON(!last_eb_bh || !*last_eb_bh);\n\n\tif (eb_bh) {\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t} else\n\t\tel = et->et_root_el;\n\n\t/* we never add a branch to a leaf. */\n\tBUG_ON(!el->l_tree_depth);\n\n\tnew_blocks = le16_to_cpu(el->l_tree_depth);\n\n\teb = (struct ocfs2_extent_block *)(*last_eb_bh)->b_data;\n\tnew_cpos = ocfs2_sum_rightmost_rec(&eb->h_list);\n\troot_end = ocfs2_sum_rightmost_rec(et->et_root_el);\n\n\t/*\n\t * If there is a gap before the root end and the real end\n\t * of the righmost leaf block, we need to remove the gap\n\t * between new_cpos and root_end first so that the tree\n\t * is consistent after we add a new branch(it will start\n\t * from new_cpos).\n\t */\n\tif (root_end > new_cpos) {\n\t\ttrace_ocfs2_adjust_rightmost_branch(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\troot_end, new_cpos);\n\n\t\tstatus = ocfs2_adjust_rightmost_branch(handle, et);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* allocate the number of new eb blocks we need */\n\tnew_eb_bhs = kcalloc(new_blocks, sizeof(struct buffer_head *),\n\t\t\t     GFP_KERNEL);\n\tif (!new_eb_bhs) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_create_new_meta_bhs(handle, et, new_blocks,\n\t\t\t\t\t   meta_ac, new_eb_bhs);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* Note: new_eb_bhs[new_blocks - 1] is the guy which will be\n\t * linked with the rest of the tree.\n\t * conversly, new_eb_bhs[0] is the new bottommost leaf.\n\t *\n\t * when we leave the loop, new_last_eb_blk will point to the\n\t * newest leaf, and next_blkno will point to the topmost extent\n\t * block. */\n\tnext_blkno = new_last_eb_blk = 0;\n\tfor(i = 0; i < new_blocks; i++) {\n\t\tbh = new_eb_bhs[i];\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\t/* ocfs2_create_new_meta_bhs() should create it right! */\n\t\tBUG_ON(!OCFS2_IS_VALID_EXTENT_BLOCK(eb));\n\t\teb_el = &eb->h_list;\n\n\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\teb->h_next_leaf_blk = 0;\n\t\teb_el->l_tree_depth = cpu_to_le16(i);\n\t\teb_el->l_next_free_rec = cpu_to_le16(1);\n\t\t/*\n\t\t * This actually counts as an empty extent as\n\t\t * c_clusters == 0\n\t\t */\n\t\teb_el->l_recs[0].e_cpos = cpu_to_le32(new_cpos);\n\t\teb_el->l_recs[0].e_blkno = cpu_to_le64(next_blkno);\n\t\t/*\n\t\t * eb_el isn't always an interior node, but even leaf\n\t\t * nodes want a zero'd flags and reserved field so\n\t\t * this gets the whole 32 bits regardless of use.\n\t\t */\n\t\teb_el->l_recs[0].e_int_clusters = cpu_to_le32(0);\n\t\tif (!eb_el->l_tree_depth)\n\t\t\tnew_last_eb_blk = le64_to_cpu(eb->h_blkno);\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t\tnext_blkno = le64_to_cpu(eb->h_blkno);\n\t}\n\n\t/* This is a bit hairy. We want to update up to three blocks\n\t * here without leaving any of them in an inconsistent state\n\t * in case of error. We don't have to worry about\n\t * journal_dirty erroring as it won't unless we've aborted the\n\t * handle (in which case we would never be here) so reserving\n\t * the write with journal_access is all we need to do. */\n\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, *last_eb_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tstatus = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (eb_bh) {\n\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, eb_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Link the new branch into the rest of the tree (el will\n\t * either be on the root_bh, or the extent block passed in. */\n\ti = le16_to_cpu(el->l_next_free_rec);\n\tel->l_recs[i].e_blkno = cpu_to_le64(next_blkno);\n\tel->l_recs[i].e_cpos = cpu_to_le32(new_cpos);\n\tel->l_recs[i].e_int_clusters = 0;\n\tle16_add_cpu(&el->l_next_free_rec, 1);\n\n\t/* fe needs a new last extent block pointer, as does the\n\t * next_leaf on the previously last-extent-block. */\n\tocfs2_et_set_last_eb_blk(et, new_last_eb_blk);\n\n\teb = (struct ocfs2_extent_block *) (*last_eb_bh)->b_data;\n\teb->h_next_leaf_blk = cpu_to_le64(new_last_eb_blk);\n\n\tocfs2_journal_dirty(handle, *last_eb_bh);\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\tif (eb_bh)\n\t\tocfs2_journal_dirty(handle, eb_bh);\n\n\t/*\n\t * Some callers want to track the rightmost leaf so pass it\n\t * back here.\n\t */\n\tbrelse(*last_eb_bh);\n\tget_bh(new_eb_bhs[0]);\n\t*last_eb_bh = new_eb_bhs[0];\n\n\tstatus = 0;\nbail:\n\tif (new_eb_bhs) {\n\t\tfor (i = 0; i < new_blocks; i++)\n\t\t\tbrelse(new_eb_bhs[i]);\n\t\tkfree(new_eb_bhs);\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_add_branch(handle_t *handle,\n\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t    struct buffer_head *eb_bh,\n\t\t\t    struct buffer_head **last_eb_bh,\n\t\t\t    struct ocfs2_alloc_context *meta_ac)\n{\n\tint status, new_blocks, i;\n\tu64 next_blkno, new_last_eb_blk;\n\tstruct buffer_head *bh;\n\tstruct buffer_head **new_eb_bhs = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list  *eb_el;\n\tstruct ocfs2_extent_list  *el;\n\tu32 new_cpos, root_end;\n\n\tBUG_ON(!last_eb_bh || !*last_eb_bh);\n\n\tif (eb_bh) {\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t} else\n\t\tel = et->et_root_el;\n\n\t/* we never add a branch to a leaf. */\n\tBUG_ON(!el->l_tree_depth);\n\n\tnew_blocks = le16_to_cpu(el->l_tree_depth);\n\n\teb = (struct ocfs2_extent_block *)(*last_eb_bh)->b_data;\n\tnew_cpos = ocfs2_sum_rightmost_rec(&eb->h_list);\n\troot_end = ocfs2_sum_rightmost_rec(et->et_root_el);\n\n\t/*\n\t * If there is a gap before the root end and the real end\n\t * of the righmost leaf block, we need to remove the gap\n\t * between new_cpos and root_end first so that the tree\n\t * is consistent after we add a new branch(it will start\n\t * from new_cpos).\n\t */\n\tif (root_end > new_cpos) {\n\t\ttrace_ocfs2_adjust_rightmost_branch(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\troot_end, new_cpos);\n\n\t\tstatus = ocfs2_adjust_rightmost_branch(handle, et);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* allocate the number of new eb blocks we need */\n\tnew_eb_bhs = kcalloc(new_blocks, sizeof(struct buffer_head *),\n\t\t\t     GFP_KERNEL);\n\tif (!new_eb_bhs) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_create_new_meta_bhs(handle, et, new_blocks,\n\t\t\t\t\t   meta_ac, new_eb_bhs);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* Note: new_eb_bhs[new_blocks - 1] is the guy which will be\n\t * linked with the rest of the tree.\n\t * conversly, new_eb_bhs[0] is the new bottommost leaf.\n\t *\n\t * when we leave the loop, new_last_eb_blk will point to the\n\t * newest leaf, and next_blkno will point to the topmost extent\n\t * block. */\n\tnext_blkno = new_last_eb_blk = 0;\n\tfor(i = 0; i < new_blocks; i++) {\n\t\tbh = new_eb_bhs[i];\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\t/* ocfs2_create_new_meta_bhs() should create it right! */\n\t\tBUG_ON(!OCFS2_IS_VALID_EXTENT_BLOCK(eb));\n\t\teb_el = &eb->h_list;\n\n\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\teb->h_next_leaf_blk = 0;\n\t\teb_el->l_tree_depth = cpu_to_le16(i);\n\t\teb_el->l_next_free_rec = cpu_to_le16(1);\n\t\t/*\n\t\t * This actually counts as an empty extent as\n\t\t * c_clusters == 0\n\t\t */\n\t\teb_el->l_recs[0].e_cpos = cpu_to_le32(new_cpos);\n\t\teb_el->l_recs[0].e_blkno = cpu_to_le64(next_blkno);\n\t\t/*\n\t\t * eb_el isn't always an interior node, but even leaf\n\t\t * nodes want a zero'd flags and reserved field so\n\t\t * this gets the whole 32 bits regardless of use.\n\t\t */\n\t\teb_el->l_recs[0].e_int_clusters = cpu_to_le32(0);\n\t\tif (!eb_el->l_tree_depth)\n\t\t\tnew_last_eb_blk = le64_to_cpu(eb->h_blkno);\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t\tnext_blkno = le64_to_cpu(eb->h_blkno);\n\t}\n\n\t/* This is a bit hairy. We want to update up to three blocks\n\t * here without leaving any of them in an inconsistent state\n\t * in case of error. We don't have to worry about\n\t * journal_dirty erroring as it won't unless we've aborted the\n\t * handle (in which case we would never be here) so reserving\n\t * the write with journal_access is all we need to do. */\n\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, *last_eb_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tstatus = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (eb_bh) {\n\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, eb_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Link the new branch into the rest of the tree (el will\n\t * either be on the root_bh, or the extent block passed in. */\n\ti = le16_to_cpu(el->l_next_free_rec);\n\tel->l_recs[i].e_blkno = cpu_to_le64(next_blkno);\n\tel->l_recs[i].e_cpos = cpu_to_le32(new_cpos);\n\tel->l_recs[i].e_int_clusters = 0;\n\tle16_add_cpu(&el->l_next_free_rec, 1);\n\n\t/* fe needs a new last extent block pointer, as does the\n\t * next_leaf on the previously last-extent-block. */\n\tocfs2_et_set_last_eb_blk(et, new_last_eb_blk);\n\n\teb = (struct ocfs2_extent_block *) (*last_eb_bh)->b_data;\n\teb->h_next_leaf_blk = cpu_to_le64(new_last_eb_blk);\n\n\tocfs2_journal_dirty(handle, *last_eb_bh);\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\tif (eb_bh)\n\t\tocfs2_journal_dirty(handle, eb_bh);\n\n\t/*\n\t * Some callers want to track the rightmost leaf so pass it\n\t * back here.\n\t */\n\tbrelse(*last_eb_bh);\n\tget_bh(new_eb_bhs[0]);\n\t*last_eb_bh = new_eb_bhs[0];\n\n\tstatus = 0;\nbail:\n\tif (new_eb_bhs) {\n\t\tfor (i = 0; i < new_blocks; i++)\n\t\t\tbrelse(new_eb_bhs[i]);\n\t\tkfree(new_eb_bhs);\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "*last_eb_bh"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_shift_tree_depth",
          "args": [
            "handle",
            "et",
            "meta_ac",
            "&bh"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_shift_tree_depth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1340-1413",
          "snippet": "static int ocfs2_shift_tree_depth(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t  struct buffer_head **ret_new_eb_bh)\n{\n\tint status, i;\n\tu32 new_clusters;\n\tstruct buffer_head *new_eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list  *root_el;\n\tstruct ocfs2_extent_list  *eb_el;\n\n\tstatus = ocfs2_create_new_meta_bhs(handle, et, 1, meta_ac,\n\t\t\t\t\t   &new_eb_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\teb = (struct ocfs2_extent_block *) new_eb_bh->b_data;\n\t/* ocfs2_create_new_meta_bhs() should create it right! */\n\tBUG_ON(!OCFS2_IS_VALID_EXTENT_BLOCK(eb));\n\n\teb_el = &eb->h_list;\n\troot_el = et->et_root_el;\n\n\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, new_eb_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* copy the root extent list data into the new extent block */\n\teb_el->l_tree_depth = root_el->l_tree_depth;\n\teb_el->l_next_free_rec = root_el->l_next_free_rec;\n\tfor (i = 0; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\teb_el->l_recs[i] = root_el->l_recs[i];\n\n\tocfs2_journal_dirty(handle, new_eb_bh);\n\n\tstatus = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tnew_clusters = ocfs2_sum_rightmost_rec(eb_el);\n\n\t/* update root_bh now */\n\tle16_add_cpu(&root_el->l_tree_depth, 1);\n\troot_el->l_recs[0].e_cpos = 0;\n\troot_el->l_recs[0].e_blkno = eb->h_blkno;\n\troot_el->l_recs[0].e_int_clusters = cpu_to_le32(new_clusters);\n\tfor (i = 1; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\tmemset(&root_el->l_recs[i], 0, sizeof(struct ocfs2_extent_rec));\n\troot_el->l_next_free_rec = cpu_to_le16(1);\n\n\t/* If this is our 1st tree depth shift, then last_eb_blk\n\t * becomes the allocated extent block */\n\tif (root_el->l_tree_depth == cpu_to_le16(1))\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\t*ret_new_eb_bh = new_eb_bh;\n\tnew_eb_bh = NULL;\n\tstatus = 0;\nbail:\n\tbrelse(new_eb_bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_shift_tree_depth(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t  struct buffer_head **ret_new_eb_bh)\n{\n\tint status, i;\n\tu32 new_clusters;\n\tstruct buffer_head *new_eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list  *root_el;\n\tstruct ocfs2_extent_list  *eb_el;\n\n\tstatus = ocfs2_create_new_meta_bhs(handle, et, 1, meta_ac,\n\t\t\t\t\t   &new_eb_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\teb = (struct ocfs2_extent_block *) new_eb_bh->b_data;\n\t/* ocfs2_create_new_meta_bhs() should create it right! */\n\tBUG_ON(!OCFS2_IS_VALID_EXTENT_BLOCK(eb));\n\n\teb_el = &eb->h_list;\n\troot_el = et->et_root_el;\n\n\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, new_eb_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* copy the root extent list data into the new extent block */\n\teb_el->l_tree_depth = root_el->l_tree_depth;\n\teb_el->l_next_free_rec = root_el->l_next_free_rec;\n\tfor (i = 0; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\teb_el->l_recs[i] = root_el->l_recs[i];\n\n\tocfs2_journal_dirty(handle, new_eb_bh);\n\n\tstatus = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tnew_clusters = ocfs2_sum_rightmost_rec(eb_el);\n\n\t/* update root_bh now */\n\tle16_add_cpu(&root_el->l_tree_depth, 1);\n\troot_el->l_recs[0].e_cpos = 0;\n\troot_el->l_recs[0].e_blkno = eb->h_blkno;\n\troot_el->l_recs[0].e_int_clusters = cpu_to_le32(new_clusters);\n\tfor (i = 1; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\tmemset(&root_el->l_recs[i], 0, sizeof(struct ocfs2_extent_rec));\n\troot_el->l_next_free_rec = cpu_to_le16(1);\n\n\t/* If this is our 1st tree depth shift, then last_eb_blk\n\t * becomes the allocated extent block */\n\tif (root_el->l_tree_depth == cpu_to_le16(1))\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\t*ret_new_eb_bh = new_eb_bh;\n\tnew_eb_bh = NULL;\n\tstatus = 0;\nbail:\n\tbrelse(new_eb_bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_grow_tree",
          "args": [
            "(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci)",
            "depth"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bh"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_branch_target",
          "args": [
            "et",
            "&bh"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_branch_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1432-1498",
          "snippet": "static int ocfs2_find_branch_target(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct buffer_head **target_bh)\n{\n\tint status = 0, i;\n\tu64 blkno;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list  *el;\n\tstruct buffer_head *bh = NULL;\n\tstruct buffer_head *lowest_bh = NULL;\n\n\t*target_bh = NULL;\n\n\tel = et->et_root_el;\n\n\twhile(le16_to_cpu(el->l_tree_depth) > 1) {\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has empty \"\n\t\t\t\t    \"extent list (next_free_rec == 0)\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci));\n\t\t\tstatus = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\t\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\tblkno = le64_to_cpu(el->l_recs[i].e_blkno);\n\t\tif (!blkno) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has extent \"\n\t\t\t\t    \"list where extent # %d has no physical \"\n\t\t\t\t    \"block start\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci), i);\n\t\t\tstatus = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\n\t\tstatus = ocfs2_read_extent_block(et->et_ci, blkno, &bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) <\n\t\t    le16_to_cpu(el->l_count)) {\n\t\t\tbrelse(lowest_bh);\n\t\t\tlowest_bh = bh;\n\t\t\tget_bh(lowest_bh);\n\t\t}\n\t}\n\n\t/* If we didn't find one and the fe doesn't have any room,\n\t * then return '1' */\n\tel = et->et_root_el;\n\tif (!lowest_bh && (el->l_next_free_rec == el->l_count))\n\t\tstatus = 1;\n\n\t*target_bh = lowest_bh;\nbail:\n\tbrelse(bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_find_branch_target(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct buffer_head **target_bh)\n{\n\tint status = 0, i;\n\tu64 blkno;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list  *el;\n\tstruct buffer_head *bh = NULL;\n\tstruct buffer_head *lowest_bh = NULL;\n\n\t*target_bh = NULL;\n\n\tel = et->et_root_el;\n\n\twhile(le16_to_cpu(el->l_tree_depth) > 1) {\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has empty \"\n\t\t\t\t    \"extent list (next_free_rec == 0)\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci));\n\t\t\tstatus = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\t\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\tblkno = le64_to_cpu(el->l_recs[i].e_blkno);\n\t\tif (!blkno) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has extent \"\n\t\t\t\t    \"list where extent # %d has no physical \"\n\t\t\t\t    \"block start\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci), i);\n\t\t\tstatus = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\n\t\tstatus = ocfs2_read_extent_block(et->et_ci, blkno, &bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) <\n\t\t    le16_to_cpu(el->l_count)) {\n\t\t\tbrelse(lowest_bh);\n\t\t\tlowest_bh = bh;\n\t\t\tget_bh(lowest_bh);\n\t\t}\n\t}\n\n\t/* If we didn't find one and the fe doesn't have any room,\n\t * then return '1' */\n\tel = et->et_root_el;\n\tif (!lowest_bh && (el->l_next_free_rec == el->l_count))\n\t\tstatus = 1;\n\n\t*target_bh = lowest_bh;\nbail:\n\tbrelse(bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "meta_ac == NULL"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_tree_depth"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_grow_tree(handle_t *handle, struct ocfs2_extent_tree *et,\n\t\t\t   int *final_depth, struct buffer_head **last_eb_bh,\n\t\t\t   struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret, shift;\n\tstruct ocfs2_extent_list *el = et->et_root_el;\n\tint depth = le16_to_cpu(el->l_tree_depth);\n\tstruct buffer_head *bh = NULL;\n\n\tBUG_ON(meta_ac == NULL);\n\n\tshift = ocfs2_find_branch_target(et, &bh);\n\tif (shift < 0) {\n\t\tret = shift;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* We traveled all the way to the bottom of the allocation tree\n\t * and didn't find room for any more extents - we need to add\n\t * another tree level */\n\tif (shift) {\n\t\tBUG_ON(bh);\n\t\ttrace_ocfs2_grow_tree(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tdepth);\n\n\t\t/* ocfs2_shift_tree_depth will return us a buffer with\n\t\t * the new extent block (so we can pass that to\n\t\t * ocfs2_add_branch). */\n\t\tret = ocfs2_shift_tree_depth(handle, et, meta_ac, &bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tdepth++;\n\t\tif (depth == 1) {\n\t\t\t/*\n\t\t\t * Special case: we have room now if we shifted from\n\t\t\t * tree_depth 0, so no more work needs to be done.\n\t\t\t *\n\t\t\t * We won't be calling add_branch, so pass\n\t\t\t * back *last_eb_bh as the new leaf. At depth\n\t\t\t * zero, it should always be null so there's\n\t\t\t * no reason to brelse.\n\t\t\t */\n\t\t\tBUG_ON(*last_eb_bh);\n\t\t\tget_bh(bh);\n\t\t\t*last_eb_bh = bh;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* call ocfs2_add_branch to add the final part of the tree with\n\t * the new data. */\n\tret = ocfs2_add_branch(handle, et, bh, last_eb_bh,\n\t\t\t       meta_ac);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout:\n\tif (final_depth)\n\t\t*final_depth = depth;\n\tbrelse(bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_find_branch_target",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "1432-1498",
    "snippet": "static int ocfs2_find_branch_target(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct buffer_head **target_bh)\n{\n\tint status = 0, i;\n\tu64 blkno;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list  *el;\n\tstruct buffer_head *bh = NULL;\n\tstruct buffer_head *lowest_bh = NULL;\n\n\t*target_bh = NULL;\n\n\tel = et->et_root_el;\n\n\twhile(le16_to_cpu(el->l_tree_depth) > 1) {\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has empty \"\n\t\t\t\t    \"extent list (next_free_rec == 0)\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci));\n\t\t\tstatus = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\t\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\tblkno = le64_to_cpu(el->l_recs[i].e_blkno);\n\t\tif (!blkno) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has extent \"\n\t\t\t\t    \"list where extent # %d has no physical \"\n\t\t\t\t    \"block start\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci), i);\n\t\t\tstatus = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\n\t\tstatus = ocfs2_read_extent_block(et->et_ci, blkno, &bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) <\n\t\t    le16_to_cpu(el->l_count)) {\n\t\t\tbrelse(lowest_bh);\n\t\t\tlowest_bh = bh;\n\t\t\tget_bh(lowest_bh);\n\t\t}\n\t}\n\n\t/* If we didn't find one and the fe doesn't have any room,\n\t * then return '1' */\n\tel = et->et_root_el;\n\tif (!lowest_bh && (el->l_next_free_rec == el->l_count))\n\t\tstatus = 1;\n\n\t*target_bh = lowest_bh;\nbail:\n\tbrelse(bh);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "lowest_bh"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_count"
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_extent_block",
          "args": [
            "et->et_ci",
            "blkno",
            "&bh"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_extent_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "939-953",
          "snippet": "int ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "\"Owner %llu has extent \"\n\t\t\t\t    \"list where extent # %d has no physical \"\n\t\t\t\t    \"block start\"",
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "i"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "el->l_recs[i].e_blkno"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_find_branch_target(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct buffer_head **target_bh)\n{\n\tint status = 0, i;\n\tu64 blkno;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list  *el;\n\tstruct buffer_head *bh = NULL;\n\tstruct buffer_head *lowest_bh = NULL;\n\n\t*target_bh = NULL;\n\n\tel = et->et_root_el;\n\n\twhile(le16_to_cpu(el->l_tree_depth) > 1) {\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has empty \"\n\t\t\t\t    \"extent list (next_free_rec == 0)\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci));\n\t\t\tstatus = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\t\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\tblkno = le64_to_cpu(el->l_recs[i].e_blkno);\n\t\tif (!blkno) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has extent \"\n\t\t\t\t    \"list where extent # %d has no physical \"\n\t\t\t\t    \"block start\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci), i);\n\t\t\tstatus = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\n\t\tstatus = ocfs2_read_extent_block(et->et_ci, blkno, &bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) <\n\t\t    le16_to_cpu(el->l_count)) {\n\t\t\tbrelse(lowest_bh);\n\t\t\tlowest_bh = bh;\n\t\t\tget_bh(lowest_bh);\n\t\t}\n\t}\n\n\t/* If we didn't find one and the fe doesn't have any room,\n\t * then return '1' */\n\tel = et->et_root_el;\n\tif (!lowest_bh && (el->l_next_free_rec == el->l_count))\n\t\tstatus = 1;\n\n\t*target_bh = lowest_bh;\nbail:\n\tbrelse(bh);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_shift_tree_depth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "1340-1413",
    "snippet": "static int ocfs2_shift_tree_depth(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t  struct buffer_head **ret_new_eb_bh)\n{\n\tint status, i;\n\tu32 new_clusters;\n\tstruct buffer_head *new_eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list  *root_el;\n\tstruct ocfs2_extent_list  *eb_el;\n\n\tstatus = ocfs2_create_new_meta_bhs(handle, et, 1, meta_ac,\n\t\t\t\t\t   &new_eb_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\teb = (struct ocfs2_extent_block *) new_eb_bh->b_data;\n\t/* ocfs2_create_new_meta_bhs() should create it right! */\n\tBUG_ON(!OCFS2_IS_VALID_EXTENT_BLOCK(eb));\n\n\teb_el = &eb->h_list;\n\troot_el = et->et_root_el;\n\n\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, new_eb_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* copy the root extent list data into the new extent block */\n\teb_el->l_tree_depth = root_el->l_tree_depth;\n\teb_el->l_next_free_rec = root_el->l_next_free_rec;\n\tfor (i = 0; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\teb_el->l_recs[i] = root_el->l_recs[i];\n\n\tocfs2_journal_dirty(handle, new_eb_bh);\n\n\tstatus = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tnew_clusters = ocfs2_sum_rightmost_rec(eb_el);\n\n\t/* update root_bh now */\n\tle16_add_cpu(&root_el->l_tree_depth, 1);\n\troot_el->l_recs[0].e_cpos = 0;\n\troot_el->l_recs[0].e_blkno = eb->h_blkno;\n\troot_el->l_recs[0].e_int_clusters = cpu_to_le32(new_clusters);\n\tfor (i = 1; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\tmemset(&root_el->l_recs[i], 0, sizeof(struct ocfs2_extent_rec));\n\troot_el->l_next_free_rec = cpu_to_le16(1);\n\n\t/* If this is our 1st tree depth shift, then last_eb_blk\n\t * becomes the allocated extent block */\n\tif (root_el->l_tree_depth == cpu_to_le16(1))\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\t*ret_new_eb_bh = new_eb_bh;\n\tnew_eb_bh = NULL;\n\tstatus = 0;\nbail:\n\tbrelse(new_eb_bh);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "new_eb_bh"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "et->et_root_bh"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_et_set_last_eb_blk",
          "args": [
            "et",
            "le64_to_cpu(eb->h_blkno)"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_set_last_eb_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "498-502",
          "snippet": "static inline void ocfs2_et_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u64 new_last_eb_blk)\n{\n\tet->et_ops->eo_set_last_eb_blk(et, new_last_eb_blk);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic inline void ocfs2_et_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u64 new_last_eb_blk)\n{\n\tet->et_ops->eo_set_last_eb_blk(et, new_last_eb_blk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "eb->h_blkno"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&root_el->l_recs[i]",
            "0",
            "sizeof(struct ocfs2_extent_rec)"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "root_el->l_next_free_rec"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_clusters"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&root_el->l_tree_depth",
            "1"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_sum_rightmost_rec",
          "args": [
            "eb_el"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sum_rightmost_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1090-1098",
          "snippet": "static inline u32 ocfs2_sum_rightmost_rec(struct ocfs2_extent_list  *el)\n{\n\tint i;\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\n\treturn le32_to_cpu(el->l_recs[i].e_cpos) +\n\t\tocfs2_rec_clusters(el, &el->l_recs[i]);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u32 ocfs2_sum_rightmost_rec(struct ocfs2_extent_list  *el)\n{\n\tint i;\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\n\treturn le32_to_cpu(el->l_recs[i].e_cpos) +\n\t\tocfs2_rec_clusters(el, &el->l_recs[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_et_root_journal_access",
          "args": [
            "handle",
            "et",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_root_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "529-535",
          "snippet": "static inline int ocfs2_et_root_journal_access(handle_t *handle,\n\t\t\t\t\t       struct ocfs2_extent_tree *et,\n\t\t\t\t\t       int type)\n{\n\treturn et->et_root_journal_access(handle, et->et_ci, et->et_root_bh,\n\t\t\t\t\t  type);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic inline int ocfs2_et_root_journal_access(handle_t *handle,\n\t\t\t\t\t       struct ocfs2_extent_tree *et,\n\t\t\t\t\t       int type)\n{\n\treturn et->et_root_journal_access(handle, et->et_ci, et->et_root_bh,\n\t\t\t\t\t  type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_eb",
          "args": [
            "handle",
            "et->et_ci",
            "new_eb_bh",
            "OCFS2_JOURNAL_ACCESS_CREATE"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_eb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "716-720",
          "snippet": "int ocfs2_journal_access_eb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &eb_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers eb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_extent_block, h_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers eb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_extent_block, h_check),\n};\n\nint ocfs2_journal_access_eb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &eb_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!OCFS2_IS_VALID_EXTENT_BLOCK(eb)"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_EXTENT_BLOCK",
          "args": [
            "eb"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_create_new_meta_bhs",
          "args": [
            "handle",
            "et",
            "1",
            "meta_ac",
            "&new_eb_bh"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_create_new_meta_bhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "997-1076",
          "snippet": "static int ocfs2_create_new_meta_bhs(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     int wanted,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     struct buffer_head *bhs[])\n{\n\tint count, status, i;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, first_blkno;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(et->et_ci));\n\tstruct ocfs2_extent_block *eb;\n\n\tcount = 0;\n\twhile (count < wanted) {\n\t\tstatus = ocfs2_claim_metadata(handle,\n\t\t\t\t\t      meta_ac,\n\t\t\t\t\t      wanted - count,\n\t\t\t\t\t      &suballoc_loc,\n\t\t\t\t\t      &suballoc_bit_start,\n\t\t\t\t\t      &num_got,\n\t\t\t\t\t      &first_blkno);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tfor(i = count;  i < (num_got + count); i++) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, first_blkno);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tocfs2_set_new_buffer_uptodate(et->et_ci, bhs[i]);\n\n\t\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci,\n\t\t\t\t\t\t\t bhs[i],\n\t\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tmemset(bhs[i]->b_data, 0, osb->sb->s_blocksize);\n\t\t\teb = (struct ocfs2_extent_block *) bhs[i]->b_data;\n\t\t\t/* Ok, setup the minimal stuff here. */\n\t\t\tstrcpy(eb->h_signature, OCFS2_EXTENT_BLOCK_SIGNATURE);\n\t\t\teb->h_blkno = cpu_to_le64(first_blkno);\n\t\t\teb->h_fs_generation = cpu_to_le32(osb->fs_generation);\n\t\t\teb->h_suballoc_slot =\n\t\t\t\tcpu_to_le16(meta_ac->ac_alloc_slot);\n\t\t\teb->h_suballoc_loc = cpu_to_le64(suballoc_loc);\n\t\t\teb->h_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\t\t\teb->h_list.l_count =\n\t\t\t\tcpu_to_le16(ocfs2_extent_recs_per_eb(osb->sb));\n\n\t\t\tsuballoc_bit_start++;\n\t\t\tfirst_blkno++;\n\n\t\t\t/* We'll also be dirtied by the caller, so\n\t\t\t * this isn't absolutely necessary. */\n\t\t\tocfs2_journal_dirty(handle, bhs[i]);\n\t\t}\n\n\t\tcount += num_got;\n\t}\n\n\tstatus = 0;\nbail:\n\tif (status < 0) {\n\t\tfor(i = 0; i < wanted; i++) {\n\t\t\tbrelse(bhs[i]);\n\t\t\tbhs[i] = NULL;\n\t\t}\n\t\tmlog_errno(status);\n\t}\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_create_new_meta_bhs(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     int wanted,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     struct buffer_head *bhs[])\n{\n\tint count, status, i;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, first_blkno;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(et->et_ci));\n\tstruct ocfs2_extent_block *eb;\n\n\tcount = 0;\n\twhile (count < wanted) {\n\t\tstatus = ocfs2_claim_metadata(handle,\n\t\t\t\t\t      meta_ac,\n\t\t\t\t\t      wanted - count,\n\t\t\t\t\t      &suballoc_loc,\n\t\t\t\t\t      &suballoc_bit_start,\n\t\t\t\t\t      &num_got,\n\t\t\t\t\t      &first_blkno);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tfor(i = count;  i < (num_got + count); i++) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, first_blkno);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tocfs2_set_new_buffer_uptodate(et->et_ci, bhs[i]);\n\n\t\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci,\n\t\t\t\t\t\t\t bhs[i],\n\t\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tmemset(bhs[i]->b_data, 0, osb->sb->s_blocksize);\n\t\t\teb = (struct ocfs2_extent_block *) bhs[i]->b_data;\n\t\t\t/* Ok, setup the minimal stuff here. */\n\t\t\tstrcpy(eb->h_signature, OCFS2_EXTENT_BLOCK_SIGNATURE);\n\t\t\teb->h_blkno = cpu_to_le64(first_blkno);\n\t\t\teb->h_fs_generation = cpu_to_le32(osb->fs_generation);\n\t\t\teb->h_suballoc_slot =\n\t\t\t\tcpu_to_le16(meta_ac->ac_alloc_slot);\n\t\t\teb->h_suballoc_loc = cpu_to_le64(suballoc_loc);\n\t\t\teb->h_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\t\t\teb->h_list.l_count =\n\t\t\t\tcpu_to_le16(ocfs2_extent_recs_per_eb(osb->sb));\n\n\t\t\tsuballoc_bit_start++;\n\t\t\tfirst_blkno++;\n\n\t\t\t/* We'll also be dirtied by the caller, so\n\t\t\t * this isn't absolutely necessary. */\n\t\t\tocfs2_journal_dirty(handle, bhs[i]);\n\t\t}\n\n\t\tcount += num_got;\n\t}\n\n\tstatus = 0;\nbail:\n\tif (status < 0) {\n\t\tfor(i = 0; i < wanted; i++) {\n\t\t\tbrelse(bhs[i]);\n\t\t\tbhs[i] = NULL;\n\t\t}\n\t\tmlog_errno(status);\n\t}\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_shift_tree_depth(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t  struct buffer_head **ret_new_eb_bh)\n{\n\tint status, i;\n\tu32 new_clusters;\n\tstruct buffer_head *new_eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list  *root_el;\n\tstruct ocfs2_extent_list  *eb_el;\n\n\tstatus = ocfs2_create_new_meta_bhs(handle, et, 1, meta_ac,\n\t\t\t\t\t   &new_eb_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\teb = (struct ocfs2_extent_block *) new_eb_bh->b_data;\n\t/* ocfs2_create_new_meta_bhs() should create it right! */\n\tBUG_ON(!OCFS2_IS_VALID_EXTENT_BLOCK(eb));\n\n\teb_el = &eb->h_list;\n\troot_el = et->et_root_el;\n\n\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, new_eb_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* copy the root extent list data into the new extent block */\n\teb_el->l_tree_depth = root_el->l_tree_depth;\n\teb_el->l_next_free_rec = root_el->l_next_free_rec;\n\tfor (i = 0; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\teb_el->l_recs[i] = root_el->l_recs[i];\n\n\tocfs2_journal_dirty(handle, new_eb_bh);\n\n\tstatus = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tnew_clusters = ocfs2_sum_rightmost_rec(eb_el);\n\n\t/* update root_bh now */\n\tle16_add_cpu(&root_el->l_tree_depth, 1);\n\troot_el->l_recs[0].e_cpos = 0;\n\troot_el->l_recs[0].e_blkno = eb->h_blkno;\n\troot_el->l_recs[0].e_int_clusters = cpu_to_le32(new_clusters);\n\tfor (i = 1; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\tmemset(&root_el->l_recs[i], 0, sizeof(struct ocfs2_extent_rec));\n\troot_el->l_next_free_rec = cpu_to_le16(1);\n\n\t/* If this is our 1st tree depth shift, then last_eb_blk\n\t * becomes the allocated extent block */\n\tif (root_el->l_tree_depth == cpu_to_le16(1))\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\t*ret_new_eb_bh = new_eb_bh;\n\tnew_eb_bh = NULL;\n\tstatus = 0;\nbail:\n\tbrelse(new_eb_bh);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_add_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "1157-1333",
    "snippet": "static int ocfs2_add_branch(handle_t *handle,\n\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t    struct buffer_head *eb_bh,\n\t\t\t    struct buffer_head **last_eb_bh,\n\t\t\t    struct ocfs2_alloc_context *meta_ac)\n{\n\tint status, new_blocks, i;\n\tu64 next_blkno, new_last_eb_blk;\n\tstruct buffer_head *bh;\n\tstruct buffer_head **new_eb_bhs = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list  *eb_el;\n\tstruct ocfs2_extent_list  *el;\n\tu32 new_cpos, root_end;\n\n\tBUG_ON(!last_eb_bh || !*last_eb_bh);\n\n\tif (eb_bh) {\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t} else\n\t\tel = et->et_root_el;\n\n\t/* we never add a branch to a leaf. */\n\tBUG_ON(!el->l_tree_depth);\n\n\tnew_blocks = le16_to_cpu(el->l_tree_depth);\n\n\teb = (struct ocfs2_extent_block *)(*last_eb_bh)->b_data;\n\tnew_cpos = ocfs2_sum_rightmost_rec(&eb->h_list);\n\troot_end = ocfs2_sum_rightmost_rec(et->et_root_el);\n\n\t/*\n\t * If there is a gap before the root end and the real end\n\t * of the righmost leaf block, we need to remove the gap\n\t * between new_cpos and root_end first so that the tree\n\t * is consistent after we add a new branch(it will start\n\t * from new_cpos).\n\t */\n\tif (root_end > new_cpos) {\n\t\ttrace_ocfs2_adjust_rightmost_branch(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\troot_end, new_cpos);\n\n\t\tstatus = ocfs2_adjust_rightmost_branch(handle, et);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* allocate the number of new eb blocks we need */\n\tnew_eb_bhs = kcalloc(new_blocks, sizeof(struct buffer_head *),\n\t\t\t     GFP_KERNEL);\n\tif (!new_eb_bhs) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_create_new_meta_bhs(handle, et, new_blocks,\n\t\t\t\t\t   meta_ac, new_eb_bhs);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* Note: new_eb_bhs[new_blocks - 1] is the guy which will be\n\t * linked with the rest of the tree.\n\t * conversly, new_eb_bhs[0] is the new bottommost leaf.\n\t *\n\t * when we leave the loop, new_last_eb_blk will point to the\n\t * newest leaf, and next_blkno will point to the topmost extent\n\t * block. */\n\tnext_blkno = new_last_eb_blk = 0;\n\tfor(i = 0; i < new_blocks; i++) {\n\t\tbh = new_eb_bhs[i];\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\t/* ocfs2_create_new_meta_bhs() should create it right! */\n\t\tBUG_ON(!OCFS2_IS_VALID_EXTENT_BLOCK(eb));\n\t\teb_el = &eb->h_list;\n\n\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\teb->h_next_leaf_blk = 0;\n\t\teb_el->l_tree_depth = cpu_to_le16(i);\n\t\teb_el->l_next_free_rec = cpu_to_le16(1);\n\t\t/*\n\t\t * This actually counts as an empty extent as\n\t\t * c_clusters == 0\n\t\t */\n\t\teb_el->l_recs[0].e_cpos = cpu_to_le32(new_cpos);\n\t\teb_el->l_recs[0].e_blkno = cpu_to_le64(next_blkno);\n\t\t/*\n\t\t * eb_el isn't always an interior node, but even leaf\n\t\t * nodes want a zero'd flags and reserved field so\n\t\t * this gets the whole 32 bits regardless of use.\n\t\t */\n\t\teb_el->l_recs[0].e_int_clusters = cpu_to_le32(0);\n\t\tif (!eb_el->l_tree_depth)\n\t\t\tnew_last_eb_blk = le64_to_cpu(eb->h_blkno);\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t\tnext_blkno = le64_to_cpu(eb->h_blkno);\n\t}\n\n\t/* This is a bit hairy. We want to update up to three blocks\n\t * here without leaving any of them in an inconsistent state\n\t * in case of error. We don't have to worry about\n\t * journal_dirty erroring as it won't unless we've aborted the\n\t * handle (in which case we would never be here) so reserving\n\t * the write with journal_access is all we need to do. */\n\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, *last_eb_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tstatus = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (eb_bh) {\n\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, eb_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Link the new branch into the rest of the tree (el will\n\t * either be on the root_bh, or the extent block passed in. */\n\ti = le16_to_cpu(el->l_next_free_rec);\n\tel->l_recs[i].e_blkno = cpu_to_le64(next_blkno);\n\tel->l_recs[i].e_cpos = cpu_to_le32(new_cpos);\n\tel->l_recs[i].e_int_clusters = 0;\n\tle16_add_cpu(&el->l_next_free_rec, 1);\n\n\t/* fe needs a new last extent block pointer, as does the\n\t * next_leaf on the previously last-extent-block. */\n\tocfs2_et_set_last_eb_blk(et, new_last_eb_blk);\n\n\teb = (struct ocfs2_extent_block *) (*last_eb_bh)->b_data;\n\teb->h_next_leaf_blk = cpu_to_le64(new_last_eb_blk);\n\n\tocfs2_journal_dirty(handle, *last_eb_bh);\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\tif (eb_bh)\n\t\tocfs2_journal_dirty(handle, eb_bh);\n\n\t/*\n\t * Some callers want to track the rightmost leaf so pass it\n\t * back here.\n\t */\n\tbrelse(*last_eb_bh);\n\tget_bh(new_eb_bhs[0]);\n\t*last_eb_bh = new_eb_bhs[0];\n\n\tstatus = 0;\nbail:\n\tif (new_eb_bhs) {\n\t\tfor (i = 0; i < new_blocks; i++)\n\t\t\tbrelse(new_eb_bhs[i]);\n\t\tkfree(new_eb_bhs);\n\t}\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_eb_bhs"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "new_eb_bhs[i]"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "new_eb_bhs[0]"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "eb_bh"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "new_last_eb_blk"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_et_set_last_eb_blk",
          "args": [
            "et",
            "new_last_eb_blk"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_set_last_eb_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "498-502",
          "snippet": "static inline void ocfs2_et_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u64 new_last_eb_blk)\n{\n\tet->et_ops->eo_set_last_eb_blk(et, new_last_eb_blk);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic inline void ocfs2_et_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u64 new_last_eb_blk)\n{\n\tet->et_ops->eo_set_last_eb_blk(et, new_last_eb_blk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&el->l_next_free_rec",
            "1"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_cpos"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "next_blkno"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_eb",
          "args": [
            "handle",
            "et->et_ci",
            "eb_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_eb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "716-720",
          "snippet": "int ocfs2_journal_access_eb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &eb_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers eb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_extent_block, h_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers eb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_extent_block, h_check),\n};\n\nint ocfs2_journal_access_eb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &eb_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_et_root_journal_access",
          "args": [
            "handle",
            "et",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_root_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "529-535",
          "snippet": "static inline int ocfs2_et_root_journal_access(handle_t *handle,\n\t\t\t\t\t       struct ocfs2_extent_tree *et,\n\t\t\t\t\t       int type)\n{\n\treturn et->et_root_journal_access(handle, et->et_ci, et->et_root_bh,\n\t\t\t\t\t  type);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic inline int ocfs2_et_root_journal_access(handle_t *handle,\n\t\t\t\t\t       struct ocfs2_extent_tree *et,\n\t\t\t\t\t       int type)\n{\n\treturn et->et_root_journal_access(handle, et->et_ci, et->et_root_bh,\n\t\t\t\t\t  type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "eb->h_blkno"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "0"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "next_blkno"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_cpos"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "i"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!OCFS2_IS_VALID_EXTENT_BLOCK(eb)"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_EXTENT_BLOCK",
          "args": [
            "eb"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_create_new_meta_bhs",
          "args": [
            "handle",
            "et",
            "new_blocks",
            "meta_ac",
            "new_eb_bhs"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_create_new_meta_bhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "997-1076",
          "snippet": "static int ocfs2_create_new_meta_bhs(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     int wanted,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     struct buffer_head *bhs[])\n{\n\tint count, status, i;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, first_blkno;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(et->et_ci));\n\tstruct ocfs2_extent_block *eb;\n\n\tcount = 0;\n\twhile (count < wanted) {\n\t\tstatus = ocfs2_claim_metadata(handle,\n\t\t\t\t\t      meta_ac,\n\t\t\t\t\t      wanted - count,\n\t\t\t\t\t      &suballoc_loc,\n\t\t\t\t\t      &suballoc_bit_start,\n\t\t\t\t\t      &num_got,\n\t\t\t\t\t      &first_blkno);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tfor(i = count;  i < (num_got + count); i++) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, first_blkno);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tocfs2_set_new_buffer_uptodate(et->et_ci, bhs[i]);\n\n\t\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci,\n\t\t\t\t\t\t\t bhs[i],\n\t\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tmemset(bhs[i]->b_data, 0, osb->sb->s_blocksize);\n\t\t\teb = (struct ocfs2_extent_block *) bhs[i]->b_data;\n\t\t\t/* Ok, setup the minimal stuff here. */\n\t\t\tstrcpy(eb->h_signature, OCFS2_EXTENT_BLOCK_SIGNATURE);\n\t\t\teb->h_blkno = cpu_to_le64(first_blkno);\n\t\t\teb->h_fs_generation = cpu_to_le32(osb->fs_generation);\n\t\t\teb->h_suballoc_slot =\n\t\t\t\tcpu_to_le16(meta_ac->ac_alloc_slot);\n\t\t\teb->h_suballoc_loc = cpu_to_le64(suballoc_loc);\n\t\t\teb->h_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\t\t\teb->h_list.l_count =\n\t\t\t\tcpu_to_le16(ocfs2_extent_recs_per_eb(osb->sb));\n\n\t\t\tsuballoc_bit_start++;\n\t\t\tfirst_blkno++;\n\n\t\t\t/* We'll also be dirtied by the caller, so\n\t\t\t * this isn't absolutely necessary. */\n\t\t\tocfs2_journal_dirty(handle, bhs[i]);\n\t\t}\n\n\t\tcount += num_got;\n\t}\n\n\tstatus = 0;\nbail:\n\tif (status < 0) {\n\t\tfor(i = 0; i < wanted; i++) {\n\t\t\tbrelse(bhs[i]);\n\t\t\tbhs[i] = NULL;\n\t\t}\n\t\tmlog_errno(status);\n\t}\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_create_new_meta_bhs(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     int wanted,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     struct buffer_head *bhs[])\n{\n\tint count, status, i;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, first_blkno;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(et->et_ci));\n\tstruct ocfs2_extent_block *eb;\n\n\tcount = 0;\n\twhile (count < wanted) {\n\t\tstatus = ocfs2_claim_metadata(handle,\n\t\t\t\t\t      meta_ac,\n\t\t\t\t\t      wanted - count,\n\t\t\t\t\t      &suballoc_loc,\n\t\t\t\t\t      &suballoc_bit_start,\n\t\t\t\t\t      &num_got,\n\t\t\t\t\t      &first_blkno);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tfor(i = count;  i < (num_got + count); i++) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, first_blkno);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tocfs2_set_new_buffer_uptodate(et->et_ci, bhs[i]);\n\n\t\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci,\n\t\t\t\t\t\t\t bhs[i],\n\t\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tmemset(bhs[i]->b_data, 0, osb->sb->s_blocksize);\n\t\t\teb = (struct ocfs2_extent_block *) bhs[i]->b_data;\n\t\t\t/* Ok, setup the minimal stuff here. */\n\t\t\tstrcpy(eb->h_signature, OCFS2_EXTENT_BLOCK_SIGNATURE);\n\t\t\teb->h_blkno = cpu_to_le64(first_blkno);\n\t\t\teb->h_fs_generation = cpu_to_le32(osb->fs_generation);\n\t\t\teb->h_suballoc_slot =\n\t\t\t\tcpu_to_le16(meta_ac->ac_alloc_slot);\n\t\t\teb->h_suballoc_loc = cpu_to_le64(suballoc_loc);\n\t\t\teb->h_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\t\t\teb->h_list.l_count =\n\t\t\t\tcpu_to_le16(ocfs2_extent_recs_per_eb(osb->sb));\n\n\t\t\tsuballoc_bit_start++;\n\t\t\tfirst_blkno++;\n\n\t\t\t/* We'll also be dirtied by the caller, so\n\t\t\t * this isn't absolutely necessary. */\n\t\t\tocfs2_journal_dirty(handle, bhs[i]);\n\t\t}\n\n\t\tcount += num_got;\n\t}\n\n\tstatus = 0;\nbail:\n\tif (status < 0) {\n\t\tfor(i = 0; i < wanted; i++) {\n\t\t\tbrelse(bhs[i]);\n\t\t\tbhs[i] = NULL;\n\t\t}\n\t\tmlog_errno(status);\n\t}\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "new_blocks",
            "sizeof(struct buffer_head *)",
            "GFP_KERNEL"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_adjust_rightmost_branch",
          "args": [
            "handle",
            "et"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_adjust_rightmost_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1104-1144",
          "snippet": "static int ocfs2_adjust_rightmost_branch(handle_t *handle,\n\t\t\t\t\t struct ocfs2_extent_tree *et)\n{\n\tint status;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tstatus = -ENOMEM;\n\t\treturn status;\n\t}\n\n\tstatus = ocfs2_find_path(et->et_ci, path, UINT_MAX);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_extend_trans(handle, path_num_items(path));\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\trec = &el->l_recs[le16_to_cpu(el->l_next_free_rec) - 1];\n\n\tocfs2_adjust_rightmost_records(handle, et, path, rec);\n\nout:\n\tocfs2_free_path(path);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_adjust_rightmost_branch(handle_t *handle,\n\t\t\t\t\t struct ocfs2_extent_tree *et)\n{\n\tint status;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tstatus = -ENOMEM;\n\t\treturn status;\n\t}\n\n\tstatus = ocfs2_find_path(et->et_ci, path, UINT_MAX);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_extend_trans(handle, path_num_items(path));\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\trec = &el->l_recs[le16_to_cpu(el->l_next_free_rec) - 1];\n\n\tocfs2_adjust_rightmost_records(handle, et, path, rec);\n\nout:\n\tocfs2_free_path(path);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_adjust_rightmost_branch",
          "args": [
            "(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci)",
            "root_end",
            "new_cpos"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_sum_rightmost_rec",
          "args": [
            "et->et_root_el"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sum_rightmost_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1090-1098",
          "snippet": "static inline u32 ocfs2_sum_rightmost_rec(struct ocfs2_extent_list  *el)\n{\n\tint i;\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\n\treturn le32_to_cpu(el->l_recs[i].e_cpos) +\n\t\tocfs2_rec_clusters(el, &el->l_recs[i]);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u32 ocfs2_sum_rightmost_rec(struct ocfs2_extent_list  *el)\n{\n\tint i;\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\n\treturn le32_to_cpu(el->l_recs[i].e_cpos) +\n\t\tocfs2_rec_clusters(el, &el->l_recs[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!el->l_tree_depth"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!last_eb_bh || !*last_eb_bh"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_add_branch(handle_t *handle,\n\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t    struct buffer_head *eb_bh,\n\t\t\t    struct buffer_head **last_eb_bh,\n\t\t\t    struct ocfs2_alloc_context *meta_ac)\n{\n\tint status, new_blocks, i;\n\tu64 next_blkno, new_last_eb_blk;\n\tstruct buffer_head *bh;\n\tstruct buffer_head **new_eb_bhs = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list  *eb_el;\n\tstruct ocfs2_extent_list  *el;\n\tu32 new_cpos, root_end;\n\n\tBUG_ON(!last_eb_bh || !*last_eb_bh);\n\n\tif (eb_bh) {\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t} else\n\t\tel = et->et_root_el;\n\n\t/* we never add a branch to a leaf. */\n\tBUG_ON(!el->l_tree_depth);\n\n\tnew_blocks = le16_to_cpu(el->l_tree_depth);\n\n\teb = (struct ocfs2_extent_block *)(*last_eb_bh)->b_data;\n\tnew_cpos = ocfs2_sum_rightmost_rec(&eb->h_list);\n\troot_end = ocfs2_sum_rightmost_rec(et->et_root_el);\n\n\t/*\n\t * If there is a gap before the root end and the real end\n\t * of the righmost leaf block, we need to remove the gap\n\t * between new_cpos and root_end first so that the tree\n\t * is consistent after we add a new branch(it will start\n\t * from new_cpos).\n\t */\n\tif (root_end > new_cpos) {\n\t\ttrace_ocfs2_adjust_rightmost_branch(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\troot_end, new_cpos);\n\n\t\tstatus = ocfs2_adjust_rightmost_branch(handle, et);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* allocate the number of new eb blocks we need */\n\tnew_eb_bhs = kcalloc(new_blocks, sizeof(struct buffer_head *),\n\t\t\t     GFP_KERNEL);\n\tif (!new_eb_bhs) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_create_new_meta_bhs(handle, et, new_blocks,\n\t\t\t\t\t   meta_ac, new_eb_bhs);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* Note: new_eb_bhs[new_blocks - 1] is the guy which will be\n\t * linked with the rest of the tree.\n\t * conversly, new_eb_bhs[0] is the new bottommost leaf.\n\t *\n\t * when we leave the loop, new_last_eb_blk will point to the\n\t * newest leaf, and next_blkno will point to the topmost extent\n\t * block. */\n\tnext_blkno = new_last_eb_blk = 0;\n\tfor(i = 0; i < new_blocks; i++) {\n\t\tbh = new_eb_bhs[i];\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\t/* ocfs2_create_new_meta_bhs() should create it right! */\n\t\tBUG_ON(!OCFS2_IS_VALID_EXTENT_BLOCK(eb));\n\t\teb_el = &eb->h_list;\n\n\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\teb->h_next_leaf_blk = 0;\n\t\teb_el->l_tree_depth = cpu_to_le16(i);\n\t\teb_el->l_next_free_rec = cpu_to_le16(1);\n\t\t/*\n\t\t * This actually counts as an empty extent as\n\t\t * c_clusters == 0\n\t\t */\n\t\teb_el->l_recs[0].e_cpos = cpu_to_le32(new_cpos);\n\t\teb_el->l_recs[0].e_blkno = cpu_to_le64(next_blkno);\n\t\t/*\n\t\t * eb_el isn't always an interior node, but even leaf\n\t\t * nodes want a zero'd flags and reserved field so\n\t\t * this gets the whole 32 bits regardless of use.\n\t\t */\n\t\teb_el->l_recs[0].e_int_clusters = cpu_to_le32(0);\n\t\tif (!eb_el->l_tree_depth)\n\t\t\tnew_last_eb_blk = le64_to_cpu(eb->h_blkno);\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t\tnext_blkno = le64_to_cpu(eb->h_blkno);\n\t}\n\n\t/* This is a bit hairy. We want to update up to three blocks\n\t * here without leaving any of them in an inconsistent state\n\t * in case of error. We don't have to worry about\n\t * journal_dirty erroring as it won't unless we've aborted the\n\t * handle (in which case we would never be here) so reserving\n\t * the write with journal_access is all we need to do. */\n\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, *last_eb_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tstatus = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (eb_bh) {\n\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, eb_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Link the new branch into the rest of the tree (el will\n\t * either be on the root_bh, or the extent block passed in. */\n\ti = le16_to_cpu(el->l_next_free_rec);\n\tel->l_recs[i].e_blkno = cpu_to_le64(next_blkno);\n\tel->l_recs[i].e_cpos = cpu_to_le32(new_cpos);\n\tel->l_recs[i].e_int_clusters = 0;\n\tle16_add_cpu(&el->l_next_free_rec, 1);\n\n\t/* fe needs a new last extent block pointer, as does the\n\t * next_leaf on the previously last-extent-block. */\n\tocfs2_et_set_last_eb_blk(et, new_last_eb_blk);\n\n\teb = (struct ocfs2_extent_block *) (*last_eb_bh)->b_data;\n\teb->h_next_leaf_blk = cpu_to_le64(new_last_eb_blk);\n\n\tocfs2_journal_dirty(handle, *last_eb_bh);\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\tif (eb_bh)\n\t\tocfs2_journal_dirty(handle, eb_bh);\n\n\t/*\n\t * Some callers want to track the rightmost leaf so pass it\n\t * back here.\n\t */\n\tbrelse(*last_eb_bh);\n\tget_bh(new_eb_bhs[0]);\n\t*last_eb_bh = new_eb_bhs[0];\n\n\tstatus = 0;\nbail:\n\tif (new_eb_bhs) {\n\t\tfor (i = 0; i < new_blocks; i++)\n\t\t\tbrelse(new_eb_bhs[i]);\n\t\tkfree(new_eb_bhs);\n\t}\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_adjust_rightmost_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "1104-1144",
    "snippet": "static int ocfs2_adjust_rightmost_branch(handle_t *handle,\n\t\t\t\t\t struct ocfs2_extent_tree *et)\n{\n\tint status;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tstatus = -ENOMEM;\n\t\treturn status;\n\t}\n\n\tstatus = ocfs2_find_path(et->et_ci, path, UINT_MAX);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_extend_trans(handle, path_num_items(path));\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\trec = &el->l_recs[le16_to_cpu(el->l_next_free_rec) - 1];\n\n\tocfs2_adjust_rightmost_records(handle, et, path, rec);\n\nout:\n\tocfs2_free_path(path);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "path"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "609-615",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_adjust_rightmost_records",
          "args": [
            "handle",
            "et",
            "path",
            "rec"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_adjust_rightmost_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "3914-3950",
          "snippet": "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec)\n{\n\tint ret, i, next_free;\n\tstruct buffer_head *bh;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\t/*\n\t * Update everything except the leaf block.\n\t */\n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tbh = path->p_node[i].bh;\n\t\tel = path->p_node[i].el;\n\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tif (next_free == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has a bad extent list\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci));\n\t\t\tret = -EIO;\n\t\t\treturn;\n\t\t}\n\n\t\trec = &el->l_recs[next_free - 1];\n\n\t\trec->e_int_clusters = insert_rec->e_cpos;\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec)\n{\n\tint ret, i, next_free;\n\tstruct buffer_head *bh;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\t/*\n\t * Update everything except the leaf block.\n\t */\n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tbh = path->p_node[i].bh;\n\t\tel = path->p_node[i].el;\n\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tif (next_free == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has a bad extent list\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci));\n\t\t\tret = -EIO;\n\t\t\treturn;\n\t\t}\n\n\t\trec = &el->l_recs[next_free - 1];\n\n\t\trec->e_int_clusters = insert_rec->e_cpos;\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_path",
          "args": [
            "et->et_ci",
            "handle",
            "path"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "746-765",
          "snippet": "int ocfs2_journal_access_path(struct ocfs2_caching_info *ci,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_path *path)\n{\n\tint i, ret = 0;\n\n\tif (!path)\n\t\tgoto out;\n\n\tfor(i = 0; i < path_num_items(path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, ci, path, i);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_journal_access_path(struct ocfs2_caching_info *ci,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_path *path)\n{\n\tint i, ret = 0;\n\n\tif (!path)\n\t\tgoto out;\n\n\tfor(i = 0; i < path_num_items(path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, ci, path, i);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_trans",
          "args": [
            "handle",
            "path_num_items(path)"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "426-463",
          "snippet": "int ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_num_items",
          "args": [
            "path"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "et->et_ci",
            "path",
            "UINT_MAX"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1885-1894",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_et",
          "args": [
            "et"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_et",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "713-717",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstruct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_adjust_rightmost_branch(handle_t *handle,\n\t\t\t\t\t struct ocfs2_extent_tree *et)\n{\n\tint status;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tstatus = -ENOMEM;\n\t\treturn status;\n\t}\n\n\tstatus = ocfs2_find_path(et->et_ci, path, UINT_MAX);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_extend_trans(handle, path_num_items(path));\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\trec = &el->l_recs[le16_to_cpu(el->l_next_free_rec) - 1];\n\n\tocfs2_adjust_rightmost_records(handle, et, path, rec);\n\nout:\n\tocfs2_free_path(path);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_sum_rightmost_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "1090-1098",
    "snippet": "static inline u32 ocfs2_sum_rightmost_rec(struct ocfs2_extent_list  *el)\n{\n\tint i;\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\n\treturn le32_to_cpu(el->l_recs[i].e_cpos) +\n\t\tocfs2_rec_clusters(el, &el->l_recs[i]);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_rec_clusters",
          "args": [
            "el",
            "&el->l_recs[i]"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rec_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "246-260",
          "snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "el->l_recs[i].e_cpos"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u32 ocfs2_sum_rightmost_rec(struct ocfs2_extent_list  *el)\n{\n\tint i;\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\n\treturn le32_to_cpu(el->l_recs[i].e_cpos) +\n\t\tocfs2_rec_clusters(el, &el->l_recs[i]);\n}"
  },
  {
    "function_name": "ocfs2_create_new_meta_bhs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "997-1076",
    "snippet": "static int ocfs2_create_new_meta_bhs(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     int wanted,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     struct buffer_head *bhs[])\n{\n\tint count, status, i;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, first_blkno;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(et->et_ci));\n\tstruct ocfs2_extent_block *eb;\n\n\tcount = 0;\n\twhile (count < wanted) {\n\t\tstatus = ocfs2_claim_metadata(handle,\n\t\t\t\t\t      meta_ac,\n\t\t\t\t\t      wanted - count,\n\t\t\t\t\t      &suballoc_loc,\n\t\t\t\t\t      &suballoc_bit_start,\n\t\t\t\t\t      &num_got,\n\t\t\t\t\t      &first_blkno);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tfor(i = count;  i < (num_got + count); i++) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, first_blkno);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tocfs2_set_new_buffer_uptodate(et->et_ci, bhs[i]);\n\n\t\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci,\n\t\t\t\t\t\t\t bhs[i],\n\t\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tmemset(bhs[i]->b_data, 0, osb->sb->s_blocksize);\n\t\t\teb = (struct ocfs2_extent_block *) bhs[i]->b_data;\n\t\t\t/* Ok, setup the minimal stuff here. */\n\t\t\tstrcpy(eb->h_signature, OCFS2_EXTENT_BLOCK_SIGNATURE);\n\t\t\teb->h_blkno = cpu_to_le64(first_blkno);\n\t\t\teb->h_fs_generation = cpu_to_le32(osb->fs_generation);\n\t\t\teb->h_suballoc_slot =\n\t\t\t\tcpu_to_le16(meta_ac->ac_alloc_slot);\n\t\t\teb->h_suballoc_loc = cpu_to_le64(suballoc_loc);\n\t\t\teb->h_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\t\t\teb->h_list.l_count =\n\t\t\t\tcpu_to_le16(ocfs2_extent_recs_per_eb(osb->sb));\n\n\t\t\tsuballoc_bit_start++;\n\t\t\tfirst_blkno++;\n\n\t\t\t/* We'll also be dirtied by the caller, so\n\t\t\t * this isn't absolutely necessary. */\n\t\t\tocfs2_journal_dirty(handle, bhs[i]);\n\t\t}\n\n\t\tcount += num_got;\n\t}\n\n\tstatus = 0;\nbail:\n\tif (status < 0) {\n\t\tfor(i = 0; i < wanted; i++) {\n\t\t\tbrelse(bhs[i]);\n\t\t\tbhs[i] = NULL;\n\t\t}\n\t\tmlog_errno(status);\n\t}\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bhs[i]"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "bhs[i]"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ocfs2_extent_recs_per_eb(osb->sb)"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_recs_per_eb",
          "args": [
            "osb->sb"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_recs_per_eb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1517-1525",
          "snippet": "static inline int ocfs2_extent_recs_per_eb(int blocksize)\n{\n\tint size;\n\n\tsize = blocksize -\n\t\toffsetof(struct ocfs2_extent_block, h_list.l_recs);\n\n\treturn size / sizeof(struct ocfs2_extent_rec);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_extent_recs_per_eb(int blocksize)\n{\n\tint size;\n\n\tsize = blocksize -\n\t\toffsetof(struct ocfs2_extent_block, h_list.l_recs);\n\n\treturn size / sizeof(struct ocfs2_extent_rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "suballoc_bit_start"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "suballoc_loc"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "meta_ac->ac_alloc_slot"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "osb->fs_generation"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "first_blkno"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "eb->h_signature",
            "OCFS2_EXTENT_BLOCK_SIGNATURE"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bhs[i]->b_data",
            "0",
            "osb->sb->s_blocksize"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_eb",
          "args": [
            "handle",
            "et->et_ci",
            "bhs[i]",
            "OCFS2_JOURNAL_ACCESS_CREATE"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_eb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "716-720",
          "snippet": "int ocfs2_journal_access_eb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &eb_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers eb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_extent_block, h_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers eb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_extent_block, h_check),\n};\n\nint ocfs2_journal_access_eb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &eb_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_new_buffer_uptodate",
          "args": [
            "et->et_ci",
            "bhs[i]"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_new_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "521-532",
          "snippet": "void ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "osb->sb",
            "first_blkno"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_claim_metadata",
          "args": [
            "handle",
            "meta_ac",
            "wanted - count",
            "&suballoc_loc",
            "&suballoc_bit_start",
            "&num_got",
            "&first_blkno"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_claim_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1993-2029",
          "snippet": "int ocfs2_claim_metadata(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 bits_wanted,\n\t\t\t u64 *suballoc_loc,\n\t\t\t u16 *suballoc_bit_start,\n\t\t\t unsigned int *num_bits,\n\t\t\t u64 *blkno_start)\n{\n\tint status;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\n\tBUG_ON(!ac);\n\tBUG_ON(ac->ac_bits_wanted < (ac->ac_bits_given + bits_wanted));\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_META);\n\n\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t   handle,\n\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t   1,\n\t\t\t\t\t   &res);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tatomic_inc(&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs);\n\n\t*suballoc_loc = res.sr_bg_blkno;\n\t*suballoc_bit_start = res.sr_bit_offset;\n\t*blkno_start = res.sr_blkno;\n\tac->ac_bits_given += res.sr_bits;\n\t*num_bits = res.sr_bits;\n\tstatus = 0;\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_claim_metadata(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 bits_wanted,\n\t\t\t u64 *suballoc_loc,\n\t\t\t u16 *suballoc_bit_start,\n\t\t\t unsigned int *num_bits,\n\t\t\t u64 *blkno_start)\n{\n\tint status;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\n\tBUG_ON(!ac);\n\tBUG_ON(ac->ac_bits_wanted < (ac->ac_bits_given + bits_wanted));\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_META);\n\n\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t   handle,\n\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t   1,\n\t\t\t\t\t   &res);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tatomic_inc(&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs);\n\n\t*suballoc_loc = res.sr_bg_blkno;\n\t*suballoc_bit_start = res.sr_bit_offset;\n\t*blkno_start = res.sr_blkno;\n\tac->ac_bits_given += res.sr_bits;\n\t*num_bits = res.sr_bits;\n\tstatus = 0;\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_create_new_meta_bhs(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     int wanted,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     struct buffer_head *bhs[])\n{\n\tint count, status, i;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, first_blkno;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(et->et_ci));\n\tstruct ocfs2_extent_block *eb;\n\n\tcount = 0;\n\twhile (count < wanted) {\n\t\tstatus = ocfs2_claim_metadata(handle,\n\t\t\t\t\t      meta_ac,\n\t\t\t\t\t      wanted - count,\n\t\t\t\t\t      &suballoc_loc,\n\t\t\t\t\t      &suballoc_bit_start,\n\t\t\t\t\t      &num_got,\n\t\t\t\t\t      &first_blkno);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tfor(i = count;  i < (num_got + count); i++) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, first_blkno);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tocfs2_set_new_buffer_uptodate(et->et_ci, bhs[i]);\n\n\t\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci,\n\t\t\t\t\t\t\t bhs[i],\n\t\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tmemset(bhs[i]->b_data, 0, osb->sb->s_blocksize);\n\t\t\teb = (struct ocfs2_extent_block *) bhs[i]->b_data;\n\t\t\t/* Ok, setup the minimal stuff here. */\n\t\t\tstrcpy(eb->h_signature, OCFS2_EXTENT_BLOCK_SIGNATURE);\n\t\t\teb->h_blkno = cpu_to_le64(first_blkno);\n\t\t\teb->h_fs_generation = cpu_to_le32(osb->fs_generation);\n\t\t\teb->h_suballoc_slot =\n\t\t\t\tcpu_to_le16(meta_ac->ac_alloc_slot);\n\t\t\teb->h_suballoc_loc = cpu_to_le64(suballoc_loc);\n\t\t\teb->h_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\t\t\teb->h_list.l_count =\n\t\t\t\tcpu_to_le16(ocfs2_extent_recs_per_eb(osb->sb));\n\n\t\t\tsuballoc_bit_start++;\n\t\t\tfirst_blkno++;\n\n\t\t\t/* We'll also be dirtied by the caller, so\n\t\t\t * this isn't absolutely necessary. */\n\t\t\tocfs2_journal_dirty(handle, bhs[i]);\n\t\t}\n\n\t\tcount += num_got;\n\t}\n\n\tstatus = 0;\nbail:\n\tif (status < 0) {\n\t\tfor(i = 0; i < wanted; i++) {\n\t\t\tbrelse(bhs[i]);\n\t\t\tbhs[i] = NULL;\n\t\t}\n\t\tmlog_errno(status);\n\t}\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_num_free_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "959-990",
    "snippet": "int ocfs2_num_free_extents(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_extent_tree *et)\n{\n\tint retval;\n\tstruct ocfs2_extent_list *el = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct buffer_head *eb_bh = NULL;\n\tu64 last_eb_blk = 0;\n\n\tel = et->et_root_el;\n\tlast_eb_blk = ocfs2_et_get_last_eb_blk(et);\n\n\tif (last_eb_blk) {\n\t\tretval = ocfs2_read_extent_block(et->et_ci, last_eb_blk,\n\t\t\t\t\t\t &eb_bh);\n\t\tif (retval < 0) {\n\t\t\tmlog_errno(retval);\n\t\t\tgoto bail;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\tBUG_ON(el->l_tree_depth != 0);\n\n\tretval = le16_to_cpu(el->l_count) - le16_to_cpu(el->l_next_free_rec);\nbail:\n\tbrelse(eb_bh);\n\n\ttrace_ocfs2_num_free_extents(retval);\n\treturn retval;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ocfs2_num_free_extents",
          "args": [
            "retval"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "eb_bh"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "el->l_tree_depth != 0"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "retval"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_extent_block",
          "args": [
            "et->et_ci",
            "last_eb_blk",
            "&eb_bh"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_extent_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "939-953",
          "snippet": "int ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_et_get_last_eb_blk",
          "args": [
            "et"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_get_last_eb_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "504-507",
          "snippet": "static inline u64 ocfs2_et_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\treturn et->et_ops->eo_get_last_eb_blk(et);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic inline u64 ocfs2_et_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\treturn et->et_ops->eo_get_last_eb_blk(et);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nint ocfs2_num_free_extents(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_extent_tree *et)\n{\n\tint retval;\n\tstruct ocfs2_extent_list *el = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct buffer_head *eb_bh = NULL;\n\tu64 last_eb_blk = 0;\n\n\tel = et->et_root_el;\n\tlast_eb_blk = ocfs2_et_get_last_eb_blk(et);\n\n\tif (last_eb_blk) {\n\t\tretval = ocfs2_read_extent_block(et->et_ci, last_eb_blk,\n\t\t\t\t\t\t &eb_bh);\n\t\tif (retval < 0) {\n\t\t\tmlog_errno(retval);\n\t\t\tgoto bail;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\tBUG_ON(el->l_tree_depth != 0);\n\n\tretval = le16_to_cpu(el->l_count) - le16_to_cpu(el->l_next_free_rec);\nbail:\n\tbrelse(eb_bh);\n\n\ttrace_ocfs2_num_free_extents(retval);\n\treturn retval;\n}"
  },
  {
    "function_name": "ocfs2_read_extent_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "939-953",
    "snippet": "int ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_read_block",
          "args": [
            "ci",
            "eb_blkno",
            "&tmp",
            "ocfs2_validate_extent_block"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_blocks_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "101-174",
          "snippet": "int ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_validate_extent_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "883-937",
    "snippet": "static int ocfs2_validate_extent_block(struct super_block *sb,\n\t\t\t\t       struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_extent_block *eb =\n\t\t(struct ocfs2_extent_block *)bh->b_data;\n\n\ttrace_ocfs2_validate_extent_block((unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t/*\n\t * If the ecc fails, we return the error but otherwise\n\t * leave the filesystem running.  We know any error is\n\t * local to this block.\n\t */\n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &eb->h_check);\n\tif (rc) {\n\t\tmlog(ML_ERROR, \"Checksum failed for extent block %llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Errors after here are fatal.\n\t */\n\n\tif (!OCFS2_IS_VALID_EXTENT_BLOCK(eb)) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extent block #%llu has bad signature %.*s\",\n\t\t\t    (unsigned long long)bh->b_blocknr, 7,\n\t\t\t    eb->h_signature);\n\t\treturn -EINVAL;\n\t}\n\n\tif (le64_to_cpu(eb->h_blkno) != bh->b_blocknr) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extent block #%llu has an invalid h_blkno \"\n\t\t\t    \"of %llu\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    (unsigned long long)le64_to_cpu(eb->h_blkno));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(eb->h_fs_generation) != OCFS2_SB(sb)->fs_generation) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extent block #%llu has an invalid \"\n\t\t\t    \"h_fs_generation of #%u\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    le32_to_cpu(eb->h_fs_generation));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "sb",
            "\"Extent block #%llu has an invalid \"\n\t\t\t    \"h_fs_generation of #%u\"",
            "(unsigned long long)bh->b_blocknr",
            "le32_to_cpu(eb->h_fs_generation)"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "eb->h_fs_generation"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "eb->h_blkno"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_EXTENT_BLOCK",
          "args": [
            "eb"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Checksum failed for extent block %llu\\n\"",
            "(unsigned long long)bh->b_blocknr"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_validate_meta_ecc",
          "args": [
            "sb",
            "bh->b_data",
            "&eb->h_check"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_validate_meta_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "613-624",
          "snippet": "int ocfs2_validate_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate(data, sb->s_blocksize, bc,\n\t\t\t\t\t\t&osb->osb_ecc_stats);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nint ocfs2_validate_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate(data, sb->s_blocksize, bc,\n\t\t\t\t\t\t&osb->osb_ecc_stats);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_uptodate(bh)"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_validate_extent_block",
          "args": [
            "(unsigned long long)bh->b_blocknr"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_validate_extent_block(struct super_block *sb,\n\t\t\t\t       struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_extent_block *eb =\n\t\t(struct ocfs2_extent_block *)bh->b_data;\n\n\ttrace_ocfs2_validate_extent_block((unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t/*\n\t * If the ecc fails, we return the error but otherwise\n\t * leave the filesystem running.  We know any error is\n\t * local to this block.\n\t */\n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &eb->h_check);\n\tif (rc) {\n\t\tmlog(ML_ERROR, \"Checksum failed for extent block %llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Errors after here are fatal.\n\t */\n\n\tif (!OCFS2_IS_VALID_EXTENT_BLOCK(eb)) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extent block #%llu has bad signature %.*s\",\n\t\t\t    (unsigned long long)bh->b_blocknr, 7,\n\t\t\t    eb->h_signature);\n\t\treturn -EINVAL;\n\t}\n\n\tif (le64_to_cpu(eb->h_blkno) != bh->b_blocknr) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extent block #%llu has an invalid h_blkno \"\n\t\t\t    \"of %llu\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    (unsigned long long)le64_to_cpu(eb->h_blkno));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(eb->h_fs_generation) != OCFS2_SB(sb)->fs_generation) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extent block #%llu has an invalid \"\n\t\t\t    \"h_fs_generation of #%u\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    le32_to_cpu(eb->h_fs_generation));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_extent_rec_contig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "824-849",
    "snippet": "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec)\n{\n\tu64 blkno = le64_to_cpu(insert_rec->e_blkno);\n\n\t/*\n\t * Refuse to coalesce extent records with different flag\n\t * fields - we don't want to mix unwritten extents with user\n\t * data.\n\t */\n\tif (ext->e_flags != insert_rec->e_flags)\n\t\treturn CONTIG_NONE;\n\n\tif (ocfs2_extents_adjacent(ext, insert_rec) &&\n\t    ocfs2_block_extent_contig(sb, ext, blkno))\n\t\t\treturn CONTIG_RIGHT;\n\n\tblkno = le64_to_cpu(ext->e_blkno);\n\tif (ocfs2_extents_adjacent(insert_rec, ext) &&\n\t    ocfs2_block_extent_contig(sb, insert_rec, blkno))\n\t\treturn CONTIG_LEFT;\n\n\treturn CONTIG_NONE;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
      "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);",
      "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_block_extent_contig",
          "args": [
            "sb",
            "insert_rec",
            "blkno"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_extent_contig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "801-811",
          "snippet": "static int ocfs2_block_extent_contig(struct super_block *sb,\n\t\t\t\t     struct ocfs2_extent_rec *ext,\n\t\t\t\t     u64 blkno)\n{\n\tu64 blk_end = le64_to_cpu(ext->e_blkno);\n\n\tblk_end += ocfs2_clusters_to_blocks(sb,\n\t\t\t\t    le16_to_cpu(ext->e_leaf_clusters));\n\n\treturn blkno == blk_end;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nstatic int ocfs2_block_extent_contig(struct super_block *sb,\n\t\t\t\t     struct ocfs2_extent_rec *ext,\n\t\t\t\t     u64 blkno)\n{\n\tu64 blk_end = le64_to_cpu(ext->e_blkno);\n\n\tblk_end += ocfs2_clusters_to_blocks(sb,\n\t\t\t\t    le16_to_cpu(ext->e_leaf_clusters));\n\n\treturn blkno == blk_end;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_extents_adjacent",
          "args": [
            "insert_rec",
            "ext"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extents_adjacent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "813-822",
          "snippet": "static int ocfs2_extents_adjacent(struct ocfs2_extent_rec *left,\n\t\t\t\t  struct ocfs2_extent_rec *right)\n{\n\tu32 left_range;\n\n\tleft_range = le32_to_cpu(left->e_cpos) +\n\t\tle16_to_cpu(left->e_leaf_clusters);\n\n\treturn (left_range == le32_to_cpu(right->e_cpos));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_extents_adjacent(struct ocfs2_extent_rec *left,\n\t\t\t\t  struct ocfs2_extent_rec *right)\n{\n\tu32 left_range;\n\n\tleft_range = le32_to_cpu(left->e_cpos) +\n\t\tle16_to_cpu(left->e_leaf_clusters);\n\n\treturn (left_range == le32_to_cpu(right->e_cpos));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "ext->e_blkno"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec)\n{\n\tu64 blkno = le64_to_cpu(insert_rec->e_blkno);\n\n\t/*\n\t * Refuse to coalesce extent records with different flag\n\t * fields - we don't want to mix unwritten extents with user\n\t * data.\n\t */\n\tif (ext->e_flags != insert_rec->e_flags)\n\t\treturn CONTIG_NONE;\n\n\tif (ocfs2_extents_adjacent(ext, insert_rec) &&\n\t    ocfs2_block_extent_contig(sb, ext, blkno))\n\t\t\treturn CONTIG_RIGHT;\n\n\tblkno = le64_to_cpu(ext->e_blkno);\n\tif (ocfs2_extents_adjacent(insert_rec, ext) &&\n\t    ocfs2_block_extent_contig(sb, insert_rec, blkno))\n\t\treturn CONTIG_LEFT;\n\n\treturn CONTIG_NONE;\n}"
  },
  {
    "function_name": "ocfs2_extents_adjacent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "813-822",
    "snippet": "static int ocfs2_extents_adjacent(struct ocfs2_extent_rec *left,\n\t\t\t\t  struct ocfs2_extent_rec *right)\n{\n\tu32 left_range;\n\n\tleft_range = le32_to_cpu(left->e_cpos) +\n\t\tle16_to_cpu(left->e_leaf_clusters);\n\n\treturn (left_range == le32_to_cpu(right->e_cpos));\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "right->e_cpos"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "left->e_leaf_clusters"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_extents_adjacent(struct ocfs2_extent_rec *left,\n\t\t\t\t  struct ocfs2_extent_rec *right)\n{\n\tu32 left_range;\n\n\tleft_range = le32_to_cpu(left->e_cpos) +\n\t\tle16_to_cpu(left->e_leaf_clusters);\n\n\treturn (left_range == le32_to_cpu(right->e_cpos));\n}"
  },
  {
    "function_name": "ocfs2_block_extent_contig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "801-811",
    "snippet": "static int ocfs2_block_extent_contig(struct super_block *sb,\n\t\t\t\t     struct ocfs2_extent_rec *ext,\n\t\t\t\t     u64 blkno)\n{\n\tu64 blk_end = le64_to_cpu(ext->e_blkno);\n\n\tblk_end += ocfs2_clusters_to_blocks(sb,\n\t\t\t\t    le16_to_cpu(ext->e_leaf_clusters));\n\n\treturn blkno == blk_end;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "sb",
            "le16_to_cpu(ext->e_leaf_clusters)"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "ext->e_leaf_clusters"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "ext->e_blkno"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nstatic int ocfs2_block_extent_contig(struct super_block *sb,\n\t\t\t\t     struct ocfs2_extent_rec *ext,\n\t\t\t\t     u64 blkno)\n{\n\tu64 blk_end = le64_to_cpu(ext->e_blkno);\n\n\tblk_end += ocfs2_clusters_to_blocks(sb,\n\t\t\t\t    le16_to_cpu(ext->e_leaf_clusters));\n\n\treturn blkno == blk_end;\n}"
  },
  {
    "function_name": "ocfs2_search_extent_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "773-795",
    "snippet": "int ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_rec_clusters",
          "args": [
            "el",
            "rec"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rec_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "246-260",
          "snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nint ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_journal_access_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "746-765",
    "snippet": "int ocfs2_journal_access_path(struct ocfs2_caching_info *ci,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_path *path)\n{\n\tint i, ret = 0;\n\n\tif (!path)\n\t\tgoto out;\n\n\tfor(i = 0; i < path_num_items(path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, ci, path, i);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_path_bh_journal_access",
          "args": [
            "handle",
            "ci",
            "path",
            "i"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_path_bh_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "726-741",
          "snippet": "int ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_num_items",
          "args": [
            "path"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_journal_access_path(struct ocfs2_caching_info *ci,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_path *path)\n{\n\tint i, ret = 0;\n\n\tif (!path)\n\t\tgoto out;\n\n\tfor(i = 0; i < path_num_items(path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, ci, path, i);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_path_bh_journal_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "726-741",
    "snippet": "int ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "access",
          "args": [
            "handle",
            "ci",
            "path->p_node[idx].bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_path_bh_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "726-741",
          "snippet": "int ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "path_root_access",
          "args": [
            "path"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}"
  },
  {
    "function_name": "ocfs2_new_path_from_et",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "713-717",
    "snippet": "struct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_new_path",
          "args": [
            "et->et_root_bh",
            "et->et_root_el",
            "et->et_root_journal_access"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "687-705",
          "snippet": "static struct ocfs2_path *ocfs2_new_path(struct buffer_head *root_bh,\n\t\t\t\t\t struct ocfs2_extent_list *root_el,\n\t\t\t\t\t ocfs2_journal_access_func access)\n{\n\tstruct ocfs2_path *path;\n\n\tBUG_ON(le16_to_cpu(root_el->l_tree_depth) >= OCFS2_MAX_PATH_DEPTH);\n\n\tpath = kzalloc(sizeof(*path), GFP_NOFS);\n\tif (path) {\n\t\tpath->p_tree_depth = le16_to_cpu(root_el->l_tree_depth);\n\t\tget_bh(root_bh);\n\t\tpath_root_bh(path) = root_bh;\n\t\tpath_root_el(path) = root_el;\n\t\tpath_root_access(path) = access;\n\t}\n\n\treturn path;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_path *ocfs2_new_path(struct buffer_head *root_bh,\n\t\t\t\t\t struct ocfs2_extent_list *root_el,\n\t\t\t\t\t ocfs2_journal_access_func access)\n{\n\tstruct ocfs2_path *path;\n\n\tBUG_ON(le16_to_cpu(root_el->l_tree_depth) >= OCFS2_MAX_PATH_DEPTH);\n\n\tpath = kzalloc(sizeof(*path), GFP_NOFS);\n\tif (path) {\n\t\tpath->p_tree_depth = le16_to_cpu(root_el->l_tree_depth);\n\t\tget_bh(root_bh);\n\t\tpath_root_bh(path) = root_bh;\n\t\tpath_root_el(path) = root_el;\n\t\tpath_root_access(path) = access;\n\t}\n\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstruct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}"
  },
  {
    "function_name": "ocfs2_new_path_from_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "707-711",
    "snippet": "struct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_new_path",
          "args": [
            "path_root_bh(path)",
            "path_root_el(path)",
            "path_root_access(path)"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "687-705",
          "snippet": "static struct ocfs2_path *ocfs2_new_path(struct buffer_head *root_bh,\n\t\t\t\t\t struct ocfs2_extent_list *root_el,\n\t\t\t\t\t ocfs2_journal_access_func access)\n{\n\tstruct ocfs2_path *path;\n\n\tBUG_ON(le16_to_cpu(root_el->l_tree_depth) >= OCFS2_MAX_PATH_DEPTH);\n\n\tpath = kzalloc(sizeof(*path), GFP_NOFS);\n\tif (path) {\n\t\tpath->p_tree_depth = le16_to_cpu(root_el->l_tree_depth);\n\t\tget_bh(root_bh);\n\t\tpath_root_bh(path) = root_bh;\n\t\tpath_root_el(path) = root_el;\n\t\tpath_root_access(path) = access;\n\t}\n\n\treturn path;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_path *ocfs2_new_path(struct buffer_head *root_bh,\n\t\t\t\t\t struct ocfs2_extent_list *root_el,\n\t\t\t\t\t ocfs2_journal_access_func access)\n{\n\tstruct ocfs2_path *path;\n\n\tBUG_ON(le16_to_cpu(root_el->l_tree_depth) >= OCFS2_MAX_PATH_DEPTH);\n\n\tpath = kzalloc(sizeof(*path), GFP_NOFS);\n\tif (path) {\n\t\tpath->p_tree_depth = le16_to_cpu(root_el->l_tree_depth);\n\t\tget_bh(root_bh);\n\t\tpath_root_bh(path) = root_bh;\n\t\tpath_root_el(path) = root_el;\n\t\tpath_root_access(path) = access;\n\t}\n\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_root_access",
          "args": [
            "path"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_el",
          "args": [
            "path"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_bh",
          "args": [
            "path"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}"
  },
  {
    "function_name": "ocfs2_new_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "687-705",
    "snippet": "static struct ocfs2_path *ocfs2_new_path(struct buffer_head *root_bh,\n\t\t\t\t\t struct ocfs2_extent_list *root_el,\n\t\t\t\t\t ocfs2_journal_access_func access)\n{\n\tstruct ocfs2_path *path;\n\n\tBUG_ON(le16_to_cpu(root_el->l_tree_depth) >= OCFS2_MAX_PATH_DEPTH);\n\n\tpath = kzalloc(sizeof(*path), GFP_NOFS);\n\tif (path) {\n\t\tpath->p_tree_depth = le16_to_cpu(root_el->l_tree_depth);\n\t\tget_bh(root_bh);\n\t\tpath_root_bh(path) = root_bh;\n\t\tpath_root_el(path) = root_el;\n\t\tpath_root_access(path) = access;\n\t}\n\n\treturn path;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_root_access",
          "args": [
            "path"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_el",
          "args": [
            "path"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_bh",
          "args": [
            "path"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "root_bh"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "root_el->l_tree_depth"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*path)",
            "GFP_NOFS"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le16_to_cpu(root_el->l_tree_depth) >= OCFS2_MAX_PATH_DEPTH"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_path *ocfs2_new_path(struct buffer_head *root_bh,\n\t\t\t\t\t struct ocfs2_extent_list *root_el,\n\t\t\t\t\t ocfs2_journal_access_func access)\n{\n\tstruct ocfs2_path *path;\n\n\tBUG_ON(le16_to_cpu(root_el->l_tree_depth) >= OCFS2_MAX_PATH_DEPTH);\n\n\tpath = kzalloc(sizeof(*path), GFP_NOFS);\n\tif (path) {\n\t\tpath->p_tree_depth = le16_to_cpu(root_el->l_tree_depth);\n\t\tget_bh(root_bh);\n\t\tpath_root_bh(path) = root_bh;\n\t\tpath_root_el(path) = root_el;\n\t\tpath_root_access(path) = access;\n\t}\n\n\treturn path;\n}"
  },
  {
    "function_name": "ocfs2_path_insert_eb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "670-685",
    "snippet": "static inline void ocfs2_path_insert_eb(struct ocfs2_path *path, int index,\n\t\t\t\t\tstruct buffer_head *eb_bh)\n{\n\tstruct ocfs2_extent_block *eb = (struct ocfs2_extent_block *)eb_bh->b_data;\n\n\t/*\n\t * Right now, no root bh is an extent block, so this helps\n\t * catch code errors with dinode trees. The assertion can be\n\t * safely removed if we ever need to insert extent block\n\t * structures at the root.\n\t */\n\tBUG_ON(index == 0);\n\n\tpath->p_node[index].bh = eb_bh;\n\tpath->p_node[index].el = &eb->h_list;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "index == 0"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic inline void ocfs2_path_insert_eb(struct ocfs2_path *path, int index,\n\t\t\t\t\tstruct buffer_head *eb_bh)\n{\n\tstruct ocfs2_extent_block *eb = (struct ocfs2_extent_block *)eb_bh->b_data;\n\n\t/*\n\t * Right now, no root bh is an extent block, so this helps\n\t * catch code errors with dinode trees. The assertion can be\n\t * safely removed if we ever need to insert extent block\n\t * structures at the root.\n\t */\n\tBUG_ON(index == 0);\n\n\tpath->p_node[index].bh = eb_bh;\n\tpath->p_node[index].el = &eb->h_list;\n}"
  },
  {
    "function_name": "ocfs2_mv_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "647-663",
    "snippet": "static void ocfs2_mv_path(struct ocfs2_path *dest, struct ocfs2_path *src)\n{\n\tint i;\n\n\tBUG_ON(path_root_bh(dest) != path_root_bh(src));\n\tBUG_ON(path_root_access(dest) != path_root_access(src));\n\n\tfor(i = 1; i < OCFS2_MAX_PATH_DEPTH; i++) {\n\t\tbrelse(dest->p_node[i].bh);\n\n\t\tdest->p_node[i].bh = src->p_node[i].bh;\n\t\tdest->p_node[i].el = src->p_node[i].el;\n\n\t\tsrc->p_node[i].bh = NULL;\n\t\tsrc->p_node[i].el = NULL;\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dest->p_node[i].bh"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "path_root_access(dest) != path_root_access(src)"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_access",
          "args": [
            "src"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_access",
          "args": [
            "dest"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "path_root_bh(dest) != path_root_bh(src)"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_bh",
          "args": [
            "src"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_bh",
          "args": [
            "dest"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_mv_path(struct ocfs2_path *dest, struct ocfs2_path *src)\n{\n\tint i;\n\n\tBUG_ON(path_root_bh(dest) != path_root_bh(src));\n\tBUG_ON(path_root_access(dest) != path_root_access(src));\n\n\tfor(i = 1; i < OCFS2_MAX_PATH_DEPTH; i++) {\n\t\tbrelse(dest->p_node[i].bh);\n\n\t\tdest->p_node[i].bh = src->p_node[i].bh;\n\t\tdest->p_node[i].el = src->p_node[i].el;\n\n\t\tsrc->p_node[i].bh = NULL;\n\t\tsrc->p_node[i].el = NULL;\n\t}\n}"
  },
  {
    "function_name": "ocfs2_cp_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "624-641",
    "snippet": "static void ocfs2_cp_path(struct ocfs2_path *dest, struct ocfs2_path *src)\n{\n\tint i;\n\n\tBUG_ON(path_root_bh(dest) != path_root_bh(src));\n\tBUG_ON(path_root_el(dest) != path_root_el(src));\n\tBUG_ON(path_root_access(dest) != path_root_access(src));\n\n\tocfs2_reinit_path(dest, 1);\n\n\tfor(i = 1; i < OCFS2_MAX_PATH_DEPTH; i++) {\n\t\tdest->p_node[i].bh = src->p_node[i].bh;\n\t\tdest->p_node[i].el = src->p_node[i].el;\n\n\t\tif (dest->p_node[i].bh)\n\t\t\tget_bh(dest->p_node[i].bh);\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "dest->p_node[i].bh"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reinit_path",
          "args": [
            "dest",
            "1"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reinit_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "580-607",
          "snippet": "void ocfs2_reinit_path(struct ocfs2_path *path, int keep_root)\n{\n\tint i, start = 0, depth = 0;\n\tstruct ocfs2_path_item *node;\n\n\tif (keep_root)\n\t\tstart = 1;\n\n\tfor(i = start; i < path_num_items(path); i++) {\n\t\tnode = &path->p_node[i];\n\n\t\tbrelse(node->bh);\n\t\tnode->bh = NULL;\n\t\tnode->el = NULL;\n\t}\n\n\t/*\n\t * Tree depth may change during truncate, or insert. If we're\n\t * keeping the root extent list, then make sure that our path\n\t * structure reflects the proper depth.\n\t */\n\tif (keep_root)\n\t\tdepth = le16_to_cpu(path_root_el(path)->l_tree_depth);\n\telse\n\t\tpath_root_access(path) = NULL;\n\n\tpath->p_tree_depth = depth;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_reinit_path(struct ocfs2_path *path, int keep_root)\n{\n\tint i, start = 0, depth = 0;\n\tstruct ocfs2_path_item *node;\n\n\tif (keep_root)\n\t\tstart = 1;\n\n\tfor(i = start; i < path_num_items(path); i++) {\n\t\tnode = &path->p_node[i];\n\n\t\tbrelse(node->bh);\n\t\tnode->bh = NULL;\n\t\tnode->el = NULL;\n\t}\n\n\t/*\n\t * Tree depth may change during truncate, or insert. If we're\n\t * keeping the root extent list, then make sure that our path\n\t * structure reflects the proper depth.\n\t */\n\tif (keep_root)\n\t\tdepth = le16_to_cpu(path_root_el(path)->l_tree_depth);\n\telse\n\t\tpath_root_access(path) = NULL;\n\n\tpath->p_tree_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "path_root_access(dest) != path_root_access(src)"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_access",
          "args": [
            "src"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_access",
          "args": [
            "dest"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "path_root_el(dest) != path_root_el(src)"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_el",
          "args": [
            "src"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_el",
          "args": [
            "dest"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "path_root_bh(dest) != path_root_bh(src)"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_bh",
          "args": [
            "src"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_bh",
          "args": [
            "dest"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_cp_path(struct ocfs2_path *dest, struct ocfs2_path *src)\n{\n\tint i;\n\n\tBUG_ON(path_root_bh(dest) != path_root_bh(src));\n\tBUG_ON(path_root_el(dest) != path_root_el(src));\n\tBUG_ON(path_root_access(dest) != path_root_access(src));\n\n\tocfs2_reinit_path(dest, 1);\n\n\tfor(i = 1; i < OCFS2_MAX_PATH_DEPTH; i++) {\n\t\tdest->p_node[i].bh = src->p_node[i].bh;\n\t\tdest->p_node[i].el = src->p_node[i].el;\n\n\t\tif (dest->p_node[i].bh)\n\t\t\tget_bh(dest->p_node[i].bh);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_free_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "609-615",
    "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "path"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reinit_path",
          "args": [
            "path",
            "0"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reinit_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "580-607",
          "snippet": "void ocfs2_reinit_path(struct ocfs2_path *path, int keep_root)\n{\n\tint i, start = 0, depth = 0;\n\tstruct ocfs2_path_item *node;\n\n\tif (keep_root)\n\t\tstart = 1;\n\n\tfor(i = start; i < path_num_items(path); i++) {\n\t\tnode = &path->p_node[i];\n\n\t\tbrelse(node->bh);\n\t\tnode->bh = NULL;\n\t\tnode->el = NULL;\n\t}\n\n\t/*\n\t * Tree depth may change during truncate, or insert. If we're\n\t * keeping the root extent list, then make sure that our path\n\t * structure reflects the proper depth.\n\t */\n\tif (keep_root)\n\t\tdepth = le16_to_cpu(path_root_el(path)->l_tree_depth);\n\telse\n\t\tpath_root_access(path) = NULL;\n\n\tpath->p_tree_depth = depth;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_reinit_path(struct ocfs2_path *path, int keep_root)\n{\n\tint i, start = 0, depth = 0;\n\tstruct ocfs2_path_item *node;\n\n\tif (keep_root)\n\t\tstart = 1;\n\n\tfor(i = start; i < path_num_items(path); i++) {\n\t\tnode = &path->p_node[i];\n\n\t\tbrelse(node->bh);\n\t\tnode->bh = NULL;\n\t\tnode->el = NULL;\n\t}\n\n\t/*\n\t * Tree depth may change during truncate, or insert. If we're\n\t * keeping the root extent list, then make sure that our path\n\t * structure reflects the proper depth.\n\t */\n\tif (keep_root)\n\t\tdepth = le16_to_cpu(path_root_el(path)->l_tree_depth);\n\telse\n\t\tpath_root_access(path) = NULL;\n\n\tpath->p_tree_depth = depth;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_reinit_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "580-607",
    "snippet": "void ocfs2_reinit_path(struct ocfs2_path *path, int keep_root)\n{\n\tint i, start = 0, depth = 0;\n\tstruct ocfs2_path_item *node;\n\n\tif (keep_root)\n\t\tstart = 1;\n\n\tfor(i = start; i < path_num_items(path); i++) {\n\t\tnode = &path->p_node[i];\n\n\t\tbrelse(node->bh);\n\t\tnode->bh = NULL;\n\t\tnode->el = NULL;\n\t}\n\n\t/*\n\t * Tree depth may change during truncate, or insert. If we're\n\t * keeping the root extent list, then make sure that our path\n\t * structure reflects the proper depth.\n\t */\n\tif (keep_root)\n\t\tdepth = le16_to_cpu(path_root_el(path)->l_tree_depth);\n\telse\n\t\tpath_root_access(path) = NULL;\n\n\tpath->p_tree_depth = depth;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_root_access",
          "args": [
            "path"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "path_root_el(path)->l_tree_depth"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_root_el",
          "args": [
            "path"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "node->bh"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_num_items",
          "args": [
            "path"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_reinit_path(struct ocfs2_path *path, int keep_root)\n{\n\tint i, start = 0, depth = 0;\n\tstruct ocfs2_path_item *node;\n\n\tif (keep_root)\n\t\tstart = 1;\n\n\tfor(i = start; i < path_num_items(path); i++) {\n\t\tnode = &path->p_node[i];\n\n\t\tbrelse(node->bh);\n\t\tnode->bh = NULL;\n\t\tnode->el = NULL;\n\t}\n\n\t/*\n\t * Tree depth may change during truncate, or insert. If we're\n\t * keeping the root extent list, then make sure that our path\n\t * structure reflects the proper depth.\n\t */\n\tif (keep_root)\n\t\tdepth = le16_to_cpu(path_root_el(path)->l_tree_depth);\n\telse\n\t\tpath_root_access(path) = NULL;\n\n\tpath->p_tree_depth = depth;\n}"
  },
  {
    "function_name": "ocfs2_et_sanity_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "560-567",
    "snippet": "static inline int ocfs2_et_sanity_check(struct ocfs2_extent_tree *et)\n{\n\tint ret = 0;\n\n\tif (et->et_ops->eo_sanity_check)\n\t\tret = et->et_ops->eo_sanity_check(et);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "et->et_ops->eo_sanity_check",
          "args": [
            "et"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic inline int ocfs2_et_sanity_check(struct ocfs2_extent_tree *et)\n{\n\tint ret = 0;\n\n\tif (et->et_ops->eo_sanity_check)\n\t\tret = et->et_ops->eo_sanity_check(et);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_et_insert_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "550-558",
    "snippet": "static inline int ocfs2_et_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_extent_rec *rec)\n{\n\tint ret = 0;\n\n\tif (et->et_ops->eo_insert_check)\n\t\tret = et->et_ops->eo_insert_check(et, rec);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "et->et_ops->eo_insert_check",
          "args": [
            "et",
            "rec"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic inline int ocfs2_et_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_extent_rec *rec)\n{\n\tint ret = 0;\n\n\tif (et->et_ops->eo_insert_check)\n\t\tret = et->et_ops->eo_insert_check(et, rec);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_et_extent_contig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "537-548",
    "snippet": "static inline enum ocfs2_contig_type\n\tocfs2_et_extent_contig(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_extent_rec *rec,\n\t\t\t       struct ocfs2_extent_rec *insert_rec)\n{\n\tif (et->et_ops->eo_extent_contig)\n\t\treturn et->et_ops->eo_extent_contig(et, rec, insert_rec);\n\n\treturn ocfs2_extent_rec_contig(\n\t\t\t\tocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\trec, insert_rec);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_extent_rec_contig",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "rec",
            "insert_rec"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_rec_contig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "824-849",
          "snippet": "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec)\n{\n\tu64 blkno = le64_to_cpu(insert_rec->e_blkno);\n\n\t/*\n\t * Refuse to coalesce extent records with different flag\n\t * fields - we don't want to mix unwritten extents with user\n\t * data.\n\t */\n\tif (ext->e_flags != insert_rec->e_flags)\n\t\treturn CONTIG_NONE;\n\n\tif (ocfs2_extents_adjacent(ext, insert_rec) &&\n\t    ocfs2_block_extent_contig(sb, ext, blkno))\n\t\t\treturn CONTIG_RIGHT;\n\n\tblkno = le64_to_cpu(ext->e_blkno);\n\tif (ocfs2_extents_adjacent(insert_rec, ext) &&\n\t    ocfs2_block_extent_contig(sb, insert_rec, blkno))\n\t\treturn CONTIG_LEFT;\n\n\treturn CONTIG_NONE;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec)\n{\n\tu64 blkno = le64_to_cpu(insert_rec->e_blkno);\n\n\t/*\n\t * Refuse to coalesce extent records with different flag\n\t * fields - we don't want to mix unwritten extents with user\n\t * data.\n\t */\n\tif (ext->e_flags != insert_rec->e_flags)\n\t\treturn CONTIG_NONE;\n\n\tif (ocfs2_extents_adjacent(ext, insert_rec) &&\n\t    ocfs2_block_extent_contig(sb, ext, blkno))\n\t\t\treturn CONTIG_RIGHT;\n\n\tblkno = le64_to_cpu(ext->e_blkno);\n\tif (ocfs2_extents_adjacent(insert_rec, ext) &&\n\t    ocfs2_block_extent_contig(sb, insert_rec, blkno))\n\t\treturn CONTIG_LEFT;\n\n\treturn CONTIG_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "et->et_ops->eo_extent_contig",
          "args": [
            "et",
            "rec",
            "insert_rec"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic inline enum ocfs2_contig_type\n\tocfs2_et_extent_contig(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_extent_rec *rec,\n\t\t\t       struct ocfs2_extent_rec *insert_rec)\n{\n\tif (et->et_ops->eo_extent_contig)\n\t\treturn et->et_ops->eo_extent_contig(et, rec, insert_rec);\n\n\treturn ocfs2_extent_rec_contig(\n\t\t\t\tocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\trec, insert_rec);\n}"
  },
  {
    "function_name": "ocfs2_et_root_journal_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "529-535",
    "snippet": "static inline int ocfs2_et_root_journal_access(handle_t *handle,\n\t\t\t\t\t       struct ocfs2_extent_tree *et,\n\t\t\t\t\t       int type)\n{\n\treturn et->et_root_journal_access(handle, et->et_ci, et->et_root_bh,\n\t\t\t\t\t  type);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "et->et_root_journal_access",
          "args": [
            "handle",
            "et->et_ci",
            "et->et_root_bh",
            "type"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic inline int ocfs2_et_root_journal_access(handle_t *handle,\n\t\t\t\t\t       struct ocfs2_extent_tree *et,\n\t\t\t\t\t       int type)\n{\n\treturn et->et_root_journal_access(handle, et->et_ci, et->et_root_bh,\n\t\t\t\t\t  type);\n}"
  },
  {
    "function_name": "ocfs2_et_extent_map_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "522-527",
    "snippet": "static inline void ocfs2_et_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t\tu32 clusters)\n{\n\tif (et->et_ops->eo_extent_map_truncate)\n\t\tet->et_ops->eo_extent_map_truncate(et, clusters);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
      "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "et->et_ops->eo_extent_map_truncate",
          "args": [
            "et",
            "clusters"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic inline void ocfs2_et_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t\tu32 clusters)\n{\n\tif (et->et_ops->eo_extent_map_truncate)\n\t\tet->et_ops->eo_extent_map_truncate(et, clusters);\n}"
  },
  {
    "function_name": "ocfs2_et_extent_map_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "515-520",
    "snippet": "static inline void ocfs2_et_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\tif (et->et_ops->eo_extent_map_insert)\n\t\tet->et_ops->eo_extent_map_insert(et, rec);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "et->et_ops->eo_extent_map_insert",
          "args": [
            "et",
            "rec"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic inline void ocfs2_et_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\tif (et->et_ops->eo_extent_map_insert)\n\t\tet->et_ops->eo_extent_map_insert(et, rec);\n}"
  },
  {
    "function_name": "ocfs2_et_update_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "509-513",
    "snippet": "static inline void ocfs2_et_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u32 clusters)\n{\n\tet->et_ops->eo_update_clusters(et, clusters);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
      "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "et->et_ops->eo_update_clusters",
          "args": [
            "et",
            "clusters"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic inline void ocfs2_et_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u32 clusters)\n{\n\tet->et_ops->eo_update_clusters(et, clusters);\n}"
  },
  {
    "function_name": "ocfs2_et_get_last_eb_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "504-507",
    "snippet": "static inline u64 ocfs2_et_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\treturn et->et_ops->eo_get_last_eb_blk(et);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "et->et_ops->eo_get_last_eb_blk",
          "args": [
            "et"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic inline u64 ocfs2_et_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\treturn et->et_ops->eo_get_last_eb_blk(et);\n}"
  },
  {
    "function_name": "ocfs2_et_set_last_eb_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "498-502",
    "snippet": "static inline void ocfs2_et_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u64 new_last_eb_blk)\n{\n\tet->et_ops->eo_set_last_eb_blk(et, new_last_eb_blk);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "et->et_ops->eo_set_last_eb_blk",
          "args": [
            "et",
            "new_last_eb_blk"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic inline void ocfs2_et_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u64 new_last_eb_blk)\n{\n\tet->et_ops->eo_set_last_eb_blk(et, new_last_eb_blk);\n}"
  },
  {
    "function_name": "ocfs2_init_refcount_extent_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "490-496",
    "snippet": "void ocfs2_init_refcount_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_rb,\n\t\t\t\t NULL, &ocfs2_refcount_tree_et_ops);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static struct ocfs2_extent_tree_operations ocfs2_refcount_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_refcount_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_refcount_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_refcount_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_refcount_tree_fill_root_el,\n\t.eo_extent_contig\t= ocfs2_refcount_tree_extent_contig,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_init_extent_tree",
          "args": [
            "et",
            "ci",
            "bh",
            "ocfs2_journal_access_rb",
            "NULL",
            "&ocfs2_refcount_tree_et_ops"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_init_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "436-456",
          "snippet": "static void __ocfs2_init_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     ocfs2_journal_access_func access,\n\t\t\t\t     void *obj,\n\t\t\t\t     struct ocfs2_extent_tree_operations *ops)\n{\n\tet->et_ops = ops;\n\tet->et_root_bh = bh;\n\tet->et_ci = ci;\n\tet->et_root_journal_access = access;\n\tif (!obj)\n\t\tobj = (void *)bh->b_data;\n\tet->et_object = obj;\n\n\tet->et_ops->eo_fill_root_el(et);\n\tif (!et->et_ops->eo_fill_max_leaf_clusters)\n\t\tet->et_max_leaf_clusters = 0;\n\telse\n\t\tet->et_ops->eo_fill_max_leaf_clusters(et);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic void __ocfs2_init_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     ocfs2_journal_access_func access,\n\t\t\t\t     void *obj,\n\t\t\t\t     struct ocfs2_extent_tree_operations *ops)\n{\n\tet->et_ops = ops;\n\tet->et_root_bh = bh;\n\tet->et_ci = ci;\n\tet->et_root_journal_access = access;\n\tif (!obj)\n\t\tobj = (void *)bh->b_data;\n\tet->et_object = obj;\n\n\tet->et_ops->eo_fill_root_el(et);\n\tif (!et->et_ops->eo_fill_max_leaf_clusters)\n\t\tet->et_max_leaf_clusters = 0;\n\telse\n\t\tet->et_ops->eo_fill_max_leaf_clusters(et);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_refcount_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_refcount_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_refcount_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_refcount_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_refcount_tree_fill_root_el,\n\t.eo_extent_contig\t= ocfs2_refcount_tree_extent_contig,\n};\n\nvoid ocfs2_init_refcount_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_rb,\n\t\t\t\t NULL, &ocfs2_refcount_tree_et_ops);\n}"
  },
  {
    "function_name": "ocfs2_init_dx_root_extent_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "482-488",
    "snippet": "void ocfs2_init_dx_root_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t\t    struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_dr,\n\t\t\t\t NULL, &ocfs2_dx_root_et_ops);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static struct ocfs2_extent_tree_operations ocfs2_dx_root_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dx_root_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dx_root_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dx_root_update_clusters,\n\t.eo_sanity_check\t= ocfs2_dx_root_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dx_root_fill_root_el,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_init_extent_tree",
          "args": [
            "et",
            "ci",
            "bh",
            "ocfs2_journal_access_dr",
            "NULL",
            "&ocfs2_dx_root_et_ops"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_init_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "436-456",
          "snippet": "static void __ocfs2_init_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     ocfs2_journal_access_func access,\n\t\t\t\t     void *obj,\n\t\t\t\t     struct ocfs2_extent_tree_operations *ops)\n{\n\tet->et_ops = ops;\n\tet->et_root_bh = bh;\n\tet->et_ci = ci;\n\tet->et_root_journal_access = access;\n\tif (!obj)\n\t\tobj = (void *)bh->b_data;\n\tet->et_object = obj;\n\n\tet->et_ops->eo_fill_root_el(et);\n\tif (!et->et_ops->eo_fill_max_leaf_clusters)\n\t\tet->et_max_leaf_clusters = 0;\n\telse\n\t\tet->et_ops->eo_fill_max_leaf_clusters(et);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic void __ocfs2_init_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     ocfs2_journal_access_func access,\n\t\t\t\t     void *obj,\n\t\t\t\t     struct ocfs2_extent_tree_operations *ops)\n{\n\tet->et_ops = ops;\n\tet->et_root_bh = bh;\n\tet->et_ci = ci;\n\tet->et_root_journal_access = access;\n\tif (!obj)\n\t\tobj = (void *)bh->b_data;\n\tet->et_object = obj;\n\n\tet->et_ops->eo_fill_root_el(et);\n\tif (!et->et_ops->eo_fill_max_leaf_clusters)\n\t\tet->et_max_leaf_clusters = 0;\n\telse\n\t\tet->et_ops->eo_fill_max_leaf_clusters(et);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_dx_root_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dx_root_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dx_root_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dx_root_update_clusters,\n\t.eo_sanity_check\t= ocfs2_dx_root_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dx_root_fill_root_el,\n};\n\nvoid ocfs2_init_dx_root_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t\t    struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_dr,\n\t\t\t\t NULL, &ocfs2_dx_root_et_ops);\n}"
  },
  {
    "function_name": "ocfs2_init_xattr_value_extent_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "474-480",
    "snippet": "void ocfs2_init_xattr_value_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\t\tstruct ocfs2_xattr_value_buf *vb)\n{\n\t__ocfs2_init_extent_tree(et, ci, vb->vb_bh, vb->vb_access, vb,\n\t\t\t\t &ocfs2_xattr_value_et_ops);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static struct ocfs2_extent_tree_operations ocfs2_xattr_value_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_xattr_value_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_xattr_value_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_xattr_value_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_xattr_value_fill_root_el,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_init_extent_tree",
          "args": [
            "et",
            "ci",
            "vb->vb_bh",
            "vb->vb_access",
            "vb",
            "&ocfs2_xattr_value_et_ops"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_init_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "436-456",
          "snippet": "static void __ocfs2_init_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     ocfs2_journal_access_func access,\n\t\t\t\t     void *obj,\n\t\t\t\t     struct ocfs2_extent_tree_operations *ops)\n{\n\tet->et_ops = ops;\n\tet->et_root_bh = bh;\n\tet->et_ci = ci;\n\tet->et_root_journal_access = access;\n\tif (!obj)\n\t\tobj = (void *)bh->b_data;\n\tet->et_object = obj;\n\n\tet->et_ops->eo_fill_root_el(et);\n\tif (!et->et_ops->eo_fill_max_leaf_clusters)\n\t\tet->et_max_leaf_clusters = 0;\n\telse\n\t\tet->et_ops->eo_fill_max_leaf_clusters(et);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic void __ocfs2_init_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     ocfs2_journal_access_func access,\n\t\t\t\t     void *obj,\n\t\t\t\t     struct ocfs2_extent_tree_operations *ops)\n{\n\tet->et_ops = ops;\n\tet->et_root_bh = bh;\n\tet->et_ci = ci;\n\tet->et_root_journal_access = access;\n\tif (!obj)\n\t\tobj = (void *)bh->b_data;\n\tet->et_object = obj;\n\n\tet->et_ops->eo_fill_root_el(et);\n\tif (!et->et_ops->eo_fill_max_leaf_clusters)\n\t\tet->et_max_leaf_clusters = 0;\n\telse\n\t\tet->et_ops->eo_fill_max_leaf_clusters(et);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_xattr_value_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_xattr_value_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_xattr_value_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_xattr_value_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_xattr_value_fill_root_el,\n};\n\nvoid ocfs2_init_xattr_value_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\t\tstruct ocfs2_xattr_value_buf *vb)\n{\n\t__ocfs2_init_extent_tree(et, ci, vb->vb_bh, vb->vb_access, vb,\n\t\t\t\t &ocfs2_xattr_value_et_ops);\n}"
  },
  {
    "function_name": "ocfs2_init_xattr_tree_extent_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "466-472",
    "snippet": "void ocfs2_init_xattr_tree_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t       struct ocfs2_caching_info *ci,\n\t\t\t\t       struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_xb,\n\t\t\t\t NULL, &ocfs2_xattr_tree_et_ops);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static struct ocfs2_extent_tree_operations ocfs2_xattr_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_xattr_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_xattr_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_xattr_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_xattr_tree_fill_root_el,\n\t.eo_fill_max_leaf_clusters = ocfs2_xattr_tree_fill_max_leaf_clusters,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_init_extent_tree",
          "args": [
            "et",
            "ci",
            "bh",
            "ocfs2_journal_access_xb",
            "NULL",
            "&ocfs2_xattr_tree_et_ops"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_init_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "436-456",
          "snippet": "static void __ocfs2_init_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     ocfs2_journal_access_func access,\n\t\t\t\t     void *obj,\n\t\t\t\t     struct ocfs2_extent_tree_operations *ops)\n{\n\tet->et_ops = ops;\n\tet->et_root_bh = bh;\n\tet->et_ci = ci;\n\tet->et_root_journal_access = access;\n\tif (!obj)\n\t\tobj = (void *)bh->b_data;\n\tet->et_object = obj;\n\n\tet->et_ops->eo_fill_root_el(et);\n\tif (!et->et_ops->eo_fill_max_leaf_clusters)\n\t\tet->et_max_leaf_clusters = 0;\n\telse\n\t\tet->et_ops->eo_fill_max_leaf_clusters(et);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic void __ocfs2_init_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     ocfs2_journal_access_func access,\n\t\t\t\t     void *obj,\n\t\t\t\t     struct ocfs2_extent_tree_operations *ops)\n{\n\tet->et_ops = ops;\n\tet->et_root_bh = bh;\n\tet->et_ci = ci;\n\tet->et_root_journal_access = access;\n\tif (!obj)\n\t\tobj = (void *)bh->b_data;\n\tet->et_object = obj;\n\n\tet->et_ops->eo_fill_root_el(et);\n\tif (!et->et_ops->eo_fill_max_leaf_clusters)\n\t\tet->et_max_leaf_clusters = 0;\n\telse\n\t\tet->et_ops->eo_fill_max_leaf_clusters(et);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_xattr_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_xattr_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_xattr_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_xattr_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_xattr_tree_fill_root_el,\n\t.eo_fill_max_leaf_clusters = ocfs2_xattr_tree_fill_max_leaf_clusters,\n};\n\nvoid ocfs2_init_xattr_tree_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t       struct ocfs2_caching_info *ci,\n\t\t\t\t       struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_xb,\n\t\t\t\t NULL, &ocfs2_xattr_tree_et_ops);\n}"
  },
  {
    "function_name": "ocfs2_init_dinode_extent_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "458-464",
    "snippet": "void ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_init_extent_tree",
          "args": [
            "et",
            "ci",
            "bh",
            "ocfs2_journal_access_di",
            "NULL",
            "&ocfs2_dinode_et_ops"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_init_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "436-456",
          "snippet": "static void __ocfs2_init_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     ocfs2_journal_access_func access,\n\t\t\t\t     void *obj,\n\t\t\t\t     struct ocfs2_extent_tree_operations *ops)\n{\n\tet->et_ops = ops;\n\tet->et_root_bh = bh;\n\tet->et_ci = ci;\n\tet->et_root_journal_access = access;\n\tif (!obj)\n\t\tobj = (void *)bh->b_data;\n\tet->et_object = obj;\n\n\tet->et_ops->eo_fill_root_el(et);\n\tif (!et->et_ops->eo_fill_max_leaf_clusters)\n\t\tet->et_max_leaf_clusters = 0;\n\telse\n\t\tet->et_ops->eo_fill_max_leaf_clusters(et);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic void __ocfs2_init_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     ocfs2_journal_access_func access,\n\t\t\t\t     void *obj,\n\t\t\t\t     struct ocfs2_extent_tree_operations *ops)\n{\n\tet->et_ops = ops;\n\tet->et_root_bh = bh;\n\tet->et_ci = ci;\n\tet->et_root_journal_access = access;\n\tif (!obj)\n\t\tobj = (void *)bh->b_data;\n\tet->et_object = obj;\n\n\tet->et_ops->eo_fill_root_el(et);\n\tif (!et->et_ops->eo_fill_max_leaf_clusters)\n\t\tet->et_max_leaf_clusters = 0;\n\telse\n\t\tet->et_ops->eo_fill_max_leaf_clusters(et);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};\n\nvoid ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}"
  },
  {
    "function_name": "__ocfs2_init_extent_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "436-456",
    "snippet": "static void __ocfs2_init_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     ocfs2_journal_access_func access,\n\t\t\t\t     void *obj,\n\t\t\t\t     struct ocfs2_extent_tree_operations *ops)\n{\n\tet->et_ops = ops;\n\tet->et_root_bh = bh;\n\tet->et_ci = ci;\n\tet->et_root_journal_access = access;\n\tif (!obj)\n\t\tobj = (void *)bh->b_data;\n\tet->et_object = obj;\n\n\tet->et_ops->eo_fill_root_el(et);\n\tif (!et->et_ops->eo_fill_max_leaf_clusters)\n\t\tet->et_max_leaf_clusters = 0;\n\telse\n\t\tet->et_ops->eo_fill_max_leaf_clusters(et);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "et->et_ops->eo_fill_max_leaf_clusters",
          "args": [
            "et"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "et->et_ops->eo_fill_root_el",
          "args": [
            "et"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic void __ocfs2_init_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     ocfs2_journal_access_func access,\n\t\t\t\t     void *obj,\n\t\t\t\t     struct ocfs2_extent_tree_operations *ops)\n{\n\tet->et_ops = ops;\n\tet->et_root_bh = bh;\n\tet->et_ci = ci;\n\tet->et_root_journal_access = access;\n\tif (!obj)\n\t\tobj = (void *)bh->b_data;\n\tet->et_object = obj;\n\n\tet->et_ops->eo_fill_root_el(et);\n\tif (!et->et_ops->eo_fill_max_leaf_clusters)\n\t\tet->et_max_leaf_clusters = 0;\n\telse\n\t\tet->et_ops->eo_fill_max_leaf_clusters(et);\n}"
  },
  {
    "function_name": "ocfs2_refcount_tree_extent_contig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "420-426",
    "snippet": "static enum ocfs2_contig_type\nocfs2_refcount_tree_extent_contig(struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_extent_rec *ext,\n\t\t\t\t  struct ocfs2_extent_rec *insert_rec)\n{\n\treturn CONTIG_NONE;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic enum ocfs2_contig_type\nocfs2_refcount_tree_extent_contig(struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_extent_rec *ext,\n\t\t\t\t  struct ocfs2_extent_rec *insert_rec)\n{\n\treturn CONTIG_NONE;\n}"
  },
  {
    "function_name": "ocfs2_refcount_tree_update_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "412-418",
    "snippet": "static void ocfs2_refcount_tree_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t\tu32 clusters)\n{\n\tstruct ocfs2_refcount_block *rb = et->et_object;\n\n\tle32_add_cpu(&rb->rf_clusters, clusters);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
      "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&rb->rf_clusters",
            "clusters"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_refcount_tree_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t\tu32 clusters)\n{\n\tstruct ocfs2_refcount_block *rb = et->et_object;\n\n\tle32_add_cpu(&rb->rf_clusters, clusters);\n}"
  },
  {
    "function_name": "ocfs2_refcount_tree_get_last_eb_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "405-410",
    "snippet": "static u64 ocfs2_refcount_tree_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_refcount_block *rb = et->et_object;\n\n\treturn le64_to_cpu(rb->rf_last_eb_blk);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "rb->rf_last_eb_blk"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic u64 ocfs2_refcount_tree_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_refcount_block *rb = et->et_object;\n\n\treturn le64_to_cpu(rb->rf_last_eb_blk);\n}"
  },
  {
    "function_name": "ocfs2_refcount_tree_set_last_eb_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "397-403",
    "snippet": "static void ocfs2_refcount_tree_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t\tu64 blkno)\n{\n\tstruct ocfs2_refcount_block *rb = et->et_object;\n\n\trb->rf_last_eb_blk = cpu_to_le64(blkno);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "blkno"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_refcount_tree_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t\tu64 blkno)\n{\n\tstruct ocfs2_refcount_block *rb = et->et_object;\n\n\trb->rf_last_eb_blk = cpu_to_le64(blkno);\n}"
  },
  {
    "function_name": "ocfs2_refcount_tree_fill_root_el",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "390-395",
    "snippet": "static void ocfs2_refcount_tree_fill_root_el(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_refcount_block *rb = et->et_object;\n\n\tet->et_root_el = &rb->rf_list;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_refcount_tree_fill_root_el(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_refcount_block *rb = et->et_object;\n\n\tet->et_root_el = &rb->rf_list;\n}"
  },
  {
    "function_name": "ocfs2_dx_root_fill_root_el",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "375-380",
    "snippet": "static void ocfs2_dx_root_fill_root_el(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dx_root_block *dx_root = et->et_object;\n\n\tet->et_root_el = &dx_root->dr_list;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_dx_root_fill_root_el(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dx_root_block *dx_root = et->et_object;\n\n\tet->et_root_el = &dx_root->dr_list;\n}"
  },
  {
    "function_name": "ocfs2_dx_root_sanity_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "366-373",
    "snippet": "static int ocfs2_dx_root_sanity_check(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dx_root_block *dx_root = et->et_object;\n\n\tBUG_ON(!OCFS2_IS_VALID_DX_ROOT(dx_root));\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!OCFS2_IS_VALID_DX_ROOT(dx_root)"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_DX_ROOT",
          "args": [
            "dx_root"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_dx_root_sanity_check(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dx_root_block *dx_root = et->et_object;\n\n\tBUG_ON(!OCFS2_IS_VALID_DX_ROOT(dx_root));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_dx_root_update_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "358-364",
    "snippet": "static void ocfs2_dx_root_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t  u32 clusters)\n{\n\tstruct ocfs2_dx_root_block *dx_root = et->et_object;\n\n\tle32_add_cpu(&dx_root->dr_clusters, clusters);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
      "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&dx_root->dr_clusters",
            "clusters"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_dx_root_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t  u32 clusters)\n{\n\tstruct ocfs2_dx_root_block *dx_root = et->et_object;\n\n\tle32_add_cpu(&dx_root->dr_clusters, clusters);\n}"
  },
  {
    "function_name": "ocfs2_dx_root_get_last_eb_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "351-356",
    "snippet": "static u64 ocfs2_dx_root_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dx_root_block *dx_root = et->et_object;\n\n\treturn le64_to_cpu(dx_root->dr_last_eb_blk);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "dx_root->dr_last_eb_blk"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic u64 ocfs2_dx_root_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dx_root_block *dx_root = et->et_object;\n\n\treturn le64_to_cpu(dx_root->dr_last_eb_blk);\n}"
  },
  {
    "function_name": "ocfs2_dx_root_set_last_eb_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "343-349",
    "snippet": "static void ocfs2_dx_root_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t  u64 blkno)\n{\n\tstruct ocfs2_dx_root_block *dx_root = et->et_object;\n\n\tdx_root->dr_last_eb_blk = cpu_to_le64(blkno);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "blkno"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_dx_root_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t  u64 blkno)\n{\n\tstruct ocfs2_dx_root_block *dx_root = et->et_object;\n\n\tdx_root->dr_last_eb_blk = cpu_to_le64(blkno);\n}"
  },
  {
    "function_name": "ocfs2_xattr_tree_update_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "327-333",
    "snippet": "static void ocfs2_xattr_tree_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters)\n{\n\tstruct ocfs2_xattr_block *xb = et->et_object;\n\n\tle32_add_cpu(&xb->xb_attrs.xb_root.xt_clusters, clusters);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
      "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&xb->xb_attrs.xb_root.xt_clusters",
            "clusters"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_xattr_tree_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters)\n{\n\tstruct ocfs2_xattr_block *xb = et->et_object;\n\n\tle32_add_cpu(&xb->xb_attrs.xb_root.xt_clusters, clusters);\n}"
  },
  {
    "function_name": "ocfs2_xattr_tree_get_last_eb_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "319-325",
    "snippet": "static u64 ocfs2_xattr_tree_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_xattr_block *xb = et->et_object;\n\tstruct ocfs2_xattr_tree_root *xt = &xb->xb_attrs.xb_root;\n\n\treturn le64_to_cpu(xt->xt_last_eb_blk);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "xt->xt_last_eb_blk"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic u64 ocfs2_xattr_tree_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_xattr_block *xb = et->et_object;\n\tstruct ocfs2_xattr_tree_root *xt = &xb->xb_attrs.xb_root;\n\n\treturn le64_to_cpu(xt->xt_last_eb_blk);\n}"
  },
  {
    "function_name": "ocfs2_xattr_tree_set_last_eb_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "310-317",
    "snippet": "static void ocfs2_xattr_tree_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u64 blkno)\n{\n\tstruct ocfs2_xattr_block *xb = et->et_object;\n\tstruct ocfs2_xattr_tree_root *xt = &xb->xb_attrs.xb_root;\n\n\txt->xt_last_eb_blk = cpu_to_le64(blkno);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "blkno"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_xattr_tree_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u64 blkno)\n{\n\tstruct ocfs2_xattr_block *xb = et->et_object;\n\tstruct ocfs2_xattr_tree_root *xt = &xb->xb_attrs.xb_root;\n\n\txt->xt_last_eb_blk = cpu_to_le64(blkno);\n}"
  },
  {
    "function_name": "ocfs2_xattr_tree_fill_max_leaf_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "303-308",
    "snippet": "static void ocfs2_xattr_tree_fill_max_leaf_clusters(struct ocfs2_extent_tree *et)\n{\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tet->et_max_leaf_clusters =\n\t\tocfs2_clusters_for_bytes(sb, OCFS2_MAX_XATTR_TREE_LEAF_SIZE);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_clusters_for_bytes",
          "args": [
            "sb",
            "OCFS2_MAX_XATTR_TREE_LEAF_SIZE"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_for_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-740",
          "snippet": "static inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_xattr_tree_fill_max_leaf_clusters(struct ocfs2_extent_tree *et)\n{\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tet->et_max_leaf_clusters =\n\t\tocfs2_clusters_for_bytes(sb, OCFS2_MAX_XATTR_TREE_LEAF_SIZE);\n}"
  },
  {
    "function_name": "ocfs2_xattr_tree_fill_root_el",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "296-301",
    "snippet": "static void ocfs2_xattr_tree_fill_root_el(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_xattr_block *xb = et->et_object;\n\n\tet->et_root_el = &xb->xb_attrs.xb_root.xt_list;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_xattr_tree_fill_root_el(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_xattr_block *xb = et->et_object;\n\n\tet->et_root_el = &xb->xb_attrs.xb_root.xt_list;\n}"
  },
  {
    "function_name": "ocfs2_xattr_value_update_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "281-287",
    "snippet": "static void ocfs2_xattr_value_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t      u32 clusters)\n{\n\tstruct ocfs2_xattr_value_buf *vb = et->et_object;\n\n\tle32_add_cpu(&vb->vb_xv->xr_clusters, clusters);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
      "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&vb->vb_xv->xr_clusters",
            "clusters"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_xattr_value_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t      u32 clusters)\n{\n\tstruct ocfs2_xattr_value_buf *vb = et->et_object;\n\n\tle32_add_cpu(&vb->vb_xv->xr_clusters, clusters);\n}"
  },
  {
    "function_name": "ocfs2_xattr_value_get_last_eb_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "274-279",
    "snippet": "static u64 ocfs2_xattr_value_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_xattr_value_buf *vb = et->et_object;\n\n\treturn le64_to_cpu(vb->vb_xv->xr_last_eb_blk);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "vb->vb_xv->xr_last_eb_blk"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic u64 ocfs2_xattr_value_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_xattr_value_buf *vb = et->et_object;\n\n\treturn le64_to_cpu(vb->vb_xv->xr_last_eb_blk);\n}"
  },
  {
    "function_name": "ocfs2_xattr_value_set_last_eb_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "266-272",
    "snippet": "static void ocfs2_xattr_value_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t      u64 blkno)\n{\n\tstruct ocfs2_xattr_value_buf *vb = et->et_object;\n\n\tvb->vb_xv->xr_last_eb_blk = cpu_to_le64(blkno);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "blkno"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_xattr_value_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t      u64 blkno)\n{\n\tstruct ocfs2_xattr_value_buf *vb = et->et_object;\n\n\tvb->vb_xv->xr_last_eb_blk = cpu_to_le64(blkno);\n}"
  },
  {
    "function_name": "ocfs2_xattr_value_fill_root_el",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "259-264",
    "snippet": "static void ocfs2_xattr_value_fill_root_el(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_xattr_value_buf *vb = et->et_object;\n\n\tet->et_root_el = &vb->vb_xv->xr_list;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_xattr_value_fill_root_el(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_xattr_value_buf *vb = et->et_object;\n\n\tet->et_root_el = &vb->vb_xv->xr_list;\n}"
  },
  {
    "function_name": "ocfs2_dinode_fill_root_el",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "251-256",
    "snippet": "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dinode *di = et->et_object;\n\n\tet->et_root_el = &di->id2.i_list;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dinode *di = et->et_object;\n\n\tet->et_root_el = &di->id2.i_list;\n}"
  },
  {
    "function_name": "ocfs2_dinode_sanity_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "241-249",
    "snippet": "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dinode *di = et->et_object;\n\n\tBUG_ON(et->et_ops != &ocfs2_dinode_et_ops);\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!OCFS2_IS_VALID_DINODE(di)"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_DINODE",
          "args": [
            "di"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "et->et_ops != &ocfs2_dinode_et_ops"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};\n\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dinode *di = et->et_object;\n\n\tBUG_ON(et->et_ops != &ocfs2_dinode_et_ops);\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_dinode_insert_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "223-239",
    "snippet": "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec)\n{\n\tstruct ocfs2_inode_info *oi = cache_info_to_inode(et->et_ci);\n\tstruct ocfs2_super *osb = OCFS2_SB(oi->vfs_inode.i_sb);\n\n\tBUG_ON(oi->ip_dyn_features & OCFS2_INLINE_DATA_FL);\n\tmlog_bug_on_msg(!ocfs2_sparse_alloc(osb) &&\n\t\t\t(oi->ip_clusters != le32_to_cpu(rec->e_cpos)),\n\t\t\t\"Device %s, asking for sparse allocation: inode %llu, \"\n\t\t\t\"cpos %u, clusters %u\\n\",\n\t\t\tosb->dev_str,\n\t\t\t(unsigned long long)oi->ip_blkno,\n\t\t\trec->e_cpos, oi->ip_clusters);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "!ocfs2_sparse_alloc(osb) &&\n\t\t\t(oi->ip_clusters != le32_to_cpu(rec->e_cpos))",
            "\"Device %s, asking for sparse allocation: inode %llu, \"\n\t\t\t\"cpos %u, clusters %u\\n\"",
            "osb->dev_str",
            "(unsigned long long)oi->ip_blkno",
            "rec->e_cpos",
            "oi->ip_clusters"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_sparse_alloc",
          "args": [
            "osb"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sparse_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "483-488",
          "snippet": "static inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "oi->ip_dyn_features & OCFS2_INLINE_DATA_FL"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "oi->vfs_inode.i_sb"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_info_to_inode",
          "args": [
            "et->et_ci"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "cache_info_to_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "185-188",
          "snippet": "static inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec)\n{\n\tstruct ocfs2_inode_info *oi = cache_info_to_inode(et->et_ci);\n\tstruct ocfs2_super *osb = OCFS2_SB(oi->vfs_inode.i_sb);\n\n\tBUG_ON(oi->ip_dyn_features & OCFS2_INLINE_DATA_FL);\n\tmlog_bug_on_msg(!ocfs2_sparse_alloc(osb) &&\n\t\t\t(oi->ip_clusters != le32_to_cpu(rec->e_cpos)),\n\t\t\t\"Device %s, asking for sparse allocation: inode %llu, \"\n\t\t\t\"cpos %u, clusters %u\\n\",\n\t\t\tosb->dev_str,\n\t\t\t(unsigned long long)oi->ip_blkno,\n\t\t\trec->e_cpos, oi->ip_clusters);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_dinode_extent_map_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "215-221",
    "snippet": "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters)\n{\n\tstruct inode *inode = &cache_info_to_inode(et->et_ci)->vfs_inode;\n\n\tocfs2_extent_map_trunc(inode, clusters);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
      "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_extent_map_trunc",
          "args": [
            "inode",
            "clusters"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_map_trunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "114-144",
          "snippet": "void ocfs2_extent_map_trunc(struct inode *inode, unsigned int cpos)\n{\n\tstruct ocfs2_extent_map_item *emi, *n;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map *em = &oi->ip_extent_map;\n\tLIST_HEAD(tmp_list);\n\tunsigned int range;\n\n\tspin_lock(&oi->ip_lock);\n\tlist_for_each_entry_safe(emi, n, &em->em_list, ei_list) {\n\t\tif (emi->ei_cpos >= cpos) {\n\t\t\t/* Full truncate of this record. */\n\t\t\tlist_move(&emi->ei_list, &tmp_list);\n\t\t\tBUG_ON(em->em_num_items == 0);\n\t\t\tem->em_num_items--;\n\t\t\tcontinue;\n\t\t}\n\n\t\trange = emi->ei_cpos + emi->ei_clusters;\n\t\tif (range > cpos) {\n\t\t\t/* Partial truncate */\n\t\t\temi->ei_clusters = cpos - emi->ei_cpos;\n\t\t}\n\t}\n\tspin_unlock(&oi->ip_lock);\n\n\tlist_for_each_entry_safe(emi, n, &tmp_list, ei_list) {\n\t\tlist_del(&emi->ei_list);\n\t\tkfree(emi);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid ocfs2_extent_map_trunc(struct inode *inode, unsigned int cpos)\n{\n\tstruct ocfs2_extent_map_item *emi, *n;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map *em = &oi->ip_extent_map;\n\tLIST_HEAD(tmp_list);\n\tunsigned int range;\n\n\tspin_lock(&oi->ip_lock);\n\tlist_for_each_entry_safe(emi, n, &em->em_list, ei_list) {\n\t\tif (emi->ei_cpos >= cpos) {\n\t\t\t/* Full truncate of this record. */\n\t\t\tlist_move(&emi->ei_list, &tmp_list);\n\t\t\tBUG_ON(em->em_num_items == 0);\n\t\t\tem->em_num_items--;\n\t\t\tcontinue;\n\t\t}\n\n\t\trange = emi->ei_cpos + emi->ei_clusters;\n\t\tif (range > cpos) {\n\t\t\t/* Partial truncate */\n\t\t\temi->ei_clusters = cpos - emi->ei_cpos;\n\t\t}\n\t}\n\tspin_unlock(&oi->ip_lock);\n\n\tlist_for_each_entry_safe(emi, n, &tmp_list, ei_list) {\n\t\tlist_del(&emi->ei_list);\n\t\tkfree(emi);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_info_to_inode",
          "args": [
            "et->et_ci"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "cache_info_to_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "185-188",
          "snippet": "static inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters)\n{\n\tstruct inode *inode = &cache_info_to_inode(et->et_ci)->vfs_inode;\n\n\tocfs2_extent_map_trunc(inode, clusters);\n}"
  },
  {
    "function_name": "ocfs2_dinode_extent_map_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "207-213",
    "snippet": "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec)\n{\n\tstruct inode *inode = &cache_info_to_inode(et->et_ci)->vfs_inode;\n\n\tocfs2_extent_map_insert_rec(inode, rec);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_extent_map_insert_rec",
          "args": [
            "inode",
            "rec"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_map_insert_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "227-286",
          "snippet": "void ocfs2_extent_map_insert_rec(struct inode *inode,\n\t\t\t\t struct ocfs2_extent_rec *rec)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map *em = &oi->ip_extent_map;\n\tstruct ocfs2_extent_map_item *emi, *new_emi = NULL;\n\tstruct ocfs2_extent_map_item ins;\n\n\tins.ei_cpos = le32_to_cpu(rec->e_cpos);\n\tins.ei_phys = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t       le64_to_cpu(rec->e_blkno));\n\tins.ei_clusters = le16_to_cpu(rec->e_leaf_clusters);\n\tins.ei_flags = rec->e_flags;\n\nsearch:\n\tspin_lock(&oi->ip_lock);\n\n\tlist_for_each_entry(emi, &em->em_list, ei_list) {\n\t\tif (ocfs2_try_to_merge_extent_map(emi, &ins)) {\n\t\t\tlist_move(&emi->ei_list, &em->em_list);\n\t\t\tspin_unlock(&oi->ip_lock);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * No item could be merged.\n\t *\n\t * Either allocate and add a new item, or overwrite the last recently\n\t * inserted.\n\t */\n\n\tif (em->em_num_items < OCFS2_MAX_EXTENT_MAP_ITEMS) {\n\t\tif (new_emi == NULL) {\n\t\t\tspin_unlock(&oi->ip_lock);\n\n\t\t\tnew_emi = kmalloc(sizeof(*new_emi), GFP_NOFS);\n\t\t\tif (new_emi == NULL)\n\t\t\t\tgoto out;\n\n\t\t\tgoto search;\n\t\t}\n\n\t\tocfs2_copy_emi_fields(new_emi, &ins);\n\t\tlist_add(&new_emi->ei_list, &em->em_list);\n\t\tem->em_num_items++;\n\t\tnew_emi = NULL;\n\t} else {\n\t\tBUG_ON(list_empty(&em->em_list) || em->em_num_items == 0);\n\t\temi = list_entry(em->em_list.prev,\n\t\t\t\t struct ocfs2_extent_map_item, ei_list);\n\t\tlist_move(&emi->ei_list, &em->em_list);\n\t\tocfs2_copy_emi_fields(emi, &ins);\n\t}\n\n\tspin_unlock(&oi->ip_lock);\n\nout:\n\tkfree(new_emi);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid ocfs2_extent_map_insert_rec(struct inode *inode,\n\t\t\t\t struct ocfs2_extent_rec *rec)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map *em = &oi->ip_extent_map;\n\tstruct ocfs2_extent_map_item *emi, *new_emi = NULL;\n\tstruct ocfs2_extent_map_item ins;\n\n\tins.ei_cpos = le32_to_cpu(rec->e_cpos);\n\tins.ei_phys = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t       le64_to_cpu(rec->e_blkno));\n\tins.ei_clusters = le16_to_cpu(rec->e_leaf_clusters);\n\tins.ei_flags = rec->e_flags;\n\nsearch:\n\tspin_lock(&oi->ip_lock);\n\n\tlist_for_each_entry(emi, &em->em_list, ei_list) {\n\t\tif (ocfs2_try_to_merge_extent_map(emi, &ins)) {\n\t\t\tlist_move(&emi->ei_list, &em->em_list);\n\t\t\tspin_unlock(&oi->ip_lock);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * No item could be merged.\n\t *\n\t * Either allocate and add a new item, or overwrite the last recently\n\t * inserted.\n\t */\n\n\tif (em->em_num_items < OCFS2_MAX_EXTENT_MAP_ITEMS) {\n\t\tif (new_emi == NULL) {\n\t\t\tspin_unlock(&oi->ip_lock);\n\n\t\t\tnew_emi = kmalloc(sizeof(*new_emi), GFP_NOFS);\n\t\t\tif (new_emi == NULL)\n\t\t\t\tgoto out;\n\n\t\t\tgoto search;\n\t\t}\n\n\t\tocfs2_copy_emi_fields(new_emi, &ins);\n\t\tlist_add(&new_emi->ei_list, &em->em_list);\n\t\tem->em_num_items++;\n\t\tnew_emi = NULL;\n\t} else {\n\t\tBUG_ON(list_empty(&em->em_list) || em->em_num_items == 0);\n\t\temi = list_entry(em->em_list.prev,\n\t\t\t\t struct ocfs2_extent_map_item, ei_list);\n\t\tlist_move(&emi->ei_list, &em->em_list);\n\t\tocfs2_copy_emi_fields(emi, &ins);\n\t}\n\n\tspin_unlock(&oi->ip_lock);\n\nout:\n\tkfree(new_emi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_info_to_inode",
          "args": [
            "et->et_ci"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "cache_info_to_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "185-188",
          "snippet": "static inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec)\n{\n\tstruct inode *inode = &cache_info_to_inode(et->et_ci)->vfs_inode;\n\n\tocfs2_extent_map_insert_rec(inode, rec);\n}"
  },
  {
    "function_name": "ocfs2_dinode_update_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "195-205",
    "snippet": "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters)\n{\n\tstruct ocfs2_inode_info *oi = cache_info_to_inode(et->et_ci);\n\tstruct ocfs2_dinode *di = et->et_object;\n\n\tle32_add_cpu(&di->i_clusters, clusters);\n\tspin_lock(&oi->ip_lock);\n\toi->ip_clusters = le32_to_cpu(di->i_clusters);\n\tspin_unlock(&oi->ip_lock);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
      "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "di->i_clusters"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&di->i_clusters",
            "clusters"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_info_to_inode",
          "args": [
            "et->et_ci"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "cache_info_to_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "185-188",
          "snippet": "static inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters)\n{\n\tstruct ocfs2_inode_info *oi = cache_info_to_inode(et->et_ci);\n\tstruct ocfs2_dinode *di = et->et_object;\n\n\tle32_add_cpu(&di->i_clusters, clusters);\n\tspin_lock(&oi->ip_lock);\n\toi->ip_clusters = le32_to_cpu(di->i_clusters);\n\tspin_unlock(&oi->ip_lock);\n}"
  },
  {
    "function_name": "ocfs2_dinode_get_last_eb_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "187-193",
    "snippet": "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dinode *di = et->et_object;\n\n\tBUG_ON(et->et_ops != &ocfs2_dinode_et_ops);\n\treturn le64_to_cpu(di->i_last_eb_blk);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "di->i_last_eb_blk"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "et->et_ops != &ocfs2_dinode_et_ops"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dinode *di = et->et_object;\n\n\tBUG_ON(et->et_ops != &ocfs2_dinode_et_ops);\n\treturn le64_to_cpu(di->i_last_eb_blk);\n}"
  },
  {
    "function_name": "ocfs2_dinode_set_last_eb_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
    "lines": "178-185",
    "snippet": "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno)\n{\n\tstruct ocfs2_dinode *di = et->et_object;\n\n\tBUG_ON(et->et_ops != &ocfs2_dinode_et_ops);\n\tdi->i_last_eb_blk = cpu_to_le64(blkno);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "blkno"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "et->et_ops != &ocfs2_dinode_et_ops"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno)\n{\n\tstruct ocfs2_dinode *di = et->et_object;\n\n\tBUG_ON(et->et_ops != &ocfs2_dinode_et_ops);\n\tdi->i_last_eb_blk = cpu_to_le64(blkno);\n}"
  }
]