[
  {
    "function_name": "nlm_stat_to_errno",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "819-849",
    "snippet": "static int\nnlm_stat_to_errno(__be32 status)\n{\n\tswitch(ntohl(status)) {\n\tcase NLM_LCK_GRANTED:\n\t\treturn 0;\n\tcase NLM_LCK_DENIED:\n\t\treturn -EAGAIN;\n\tcase NLM_LCK_DENIED_NOLOCKS:\n\tcase NLM_LCK_DENIED_GRACE_PERIOD:\n\t\treturn -ENOLCK;\n\tcase NLM_LCK_BLOCKED:\n\t\tprintk(KERN_NOTICE \"lockd: unexpected status NLM_BLOCKED\\n\");\n\t\treturn -ENOLCK;\n#ifdef CONFIG_LOCKD_V4\n\tcase NLM_DEADLCK:\n\t\treturn -EDEADLK;\n\tcase NLM_ROFS:\n\t\treturn -EROFS;\n\tcase NLM_STALE_FH:\n\t\treturn -ESTALE;\n\tcase NLM_FBIG:\n\t\treturn -EOVERFLOW;\n\tcase NLM_FAILED:\n\t\treturn -ENOLCK;\n#endif\n\t}\n\tprintk(KERN_NOTICE \"lockd: unexpected server status %d\\n\",\n\t\t ntohl(status));\n\treturn -ENOLCK;\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"lockd: unexpected server status %d\\n\"",
            "ntohl(status)"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "status"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "status"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int\nnlm_stat_to_errno(__be32 status)\n{\n\tswitch(ntohl(status)) {\n\tcase NLM_LCK_GRANTED:\n\t\treturn 0;\n\tcase NLM_LCK_DENIED:\n\t\treturn -EAGAIN;\n\tcase NLM_LCK_DENIED_NOLOCKS:\n\tcase NLM_LCK_DENIED_GRACE_PERIOD:\n\t\treturn -ENOLCK;\n\tcase NLM_LCK_BLOCKED:\n\t\tprintk(KERN_NOTICE \"lockd: unexpected status NLM_BLOCKED\\n\");\n\t\treturn -ENOLCK;\n#ifdef CONFIG_LOCKD_V4\n\tcase NLM_DEADLCK:\n\t\treturn -EDEADLK;\n\tcase NLM_ROFS:\n\t\treturn -EROFS;\n\tcase NLM_STALE_FH:\n\t\treturn -ESTALE;\n\tcase NLM_FBIG:\n\t\treturn -EOVERFLOW;\n\tcase NLM_FAILED:\n\t\treturn -ENOLCK;\n#endif\n\t}\n\tprintk(KERN_NOTICE \"lockd: unexpected server status %d\\n\",\n\t\t ntohl(status));\n\treturn -ENOLCK;\n}"
  },
  {
    "function_name": "nlmclnt_cancel_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "768-809",
    "snippet": "static void nlmclnt_cancel_callback(struct rpc_task *task, void *data)\n{\n\tstruct nlm_rqst\t*req = data;\n\tu32 status = ntohl(req->a_res.status);\n\n\tif (RPC_ASSASSINATED(task))\n\t\tgoto die;\n\n\tif (task->tk_status < 0) {\n\t\tdprintk(\"lockd: CANCEL call error %d, retrying.\\n\",\n\t\t\t\t\ttask->tk_status);\n\t\tgoto retry_cancel;\n\t}\n\n\tdprintk(\"lockd: cancel status %u (task %u)\\n\",\n\t\t\tstatus, task->tk_pid);\n\n\tswitch (status) {\n\tcase NLM_LCK_GRANTED:\n\tcase NLM_LCK_DENIED_GRACE_PERIOD:\n\tcase NLM_LCK_DENIED:\n\t\t/* Everything's good */\n\t\tbreak;\n\tcase NLM_LCK_DENIED_NOLOCKS:\n\t\tdprintk(\"lockd: CANCEL failed (server has no locks)\\n\");\n\t\tgoto retry_cancel;\n\tdefault:\n\t\tprintk(KERN_NOTICE \"lockd: weird return %d for CANCEL call\\n\",\n\t\t\tstatus);\n\t}\n\ndie:\n\treturn;\n\nretry_cancel:\n\t/* Don't ever retry more than 3 times */\n\tif (req->a_retries++ >= NLMCLNT_MAX_RETRIES)\n\t\tgoto die;\n\tnlm_rebind_host(req->a_host);\n\trpc_restart_call(task);\n\trpc_delay(task, 30 * HZ);\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define NLMCLNT_MAX_RETRIES\t3"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_delay",
          "args": [
            "task",
            "30 * HZ"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_restart_call",
          "args": [
            "task"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_rebind_host",
          "args": [
            "req->a_host"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_rebind_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "488-496",
          "snippet": "void\nnlm_rebind_host(struct nlm_host *host)\n{\n\tdprintk(\"lockd: rebind host %s\\n\", host->h_name);\n\tif (host->h_rpcclnt && time_after_eq(jiffies, host->h_nextrebind)) {\n\t\trpc_force_rebind(host->h_rpcclnt);\n\t\thost->h_nextrebind = jiffies + NLM_HOST_REBIND;\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NLM_HOST_REBIND\t\t(60 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NLM_HOST_REBIND\t\t(60 * HZ)\n\nvoid\nnlm_rebind_host(struct nlm_host *host)\n{\n\tdprintk(\"lockd: rebind host %s\\n\", host->h_name);\n\tif (host->h_rpcclnt && time_after_eq(jiffies, host->h_nextrebind)) {\n\t\trpc_force_rebind(host->h_rpcclnt);\n\t\thost->h_nextrebind = jiffies + NLM_HOST_REBIND;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"lockd: weird return %d for CANCEL call\\n\"",
            "status"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: CANCEL failed (server has no locks)\\n\""
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: cancel status %u (task %u)\\n\"",
            "status",
            "task->tk_pid"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: CANCEL call error %d, retrying.\\n\"",
            "task->tk_status"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RPC_ASSASSINATED",
          "args": [
            "task"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "req->a_res.status"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define NLMCLNT_MAX_RETRIES\t3\n\nstatic void nlmclnt_cancel_callback(struct rpc_task *task, void *data)\n{\n\tstruct nlm_rqst\t*req = data;\n\tu32 status = ntohl(req->a_res.status);\n\n\tif (RPC_ASSASSINATED(task))\n\t\tgoto die;\n\n\tif (task->tk_status < 0) {\n\t\tdprintk(\"lockd: CANCEL call error %d, retrying.\\n\",\n\t\t\t\t\ttask->tk_status);\n\t\tgoto retry_cancel;\n\t}\n\n\tdprintk(\"lockd: cancel status %u (task %u)\\n\",\n\t\t\tstatus, task->tk_pid);\n\n\tswitch (status) {\n\tcase NLM_LCK_GRANTED:\n\tcase NLM_LCK_DENIED_GRACE_PERIOD:\n\tcase NLM_LCK_DENIED:\n\t\t/* Everything's good */\n\t\tbreak;\n\tcase NLM_LCK_DENIED_NOLOCKS:\n\t\tdprintk(\"lockd: CANCEL failed (server has no locks)\\n\");\n\t\tgoto retry_cancel;\n\tdefault:\n\t\tprintk(KERN_NOTICE \"lockd: weird return %d for CANCEL call\\n\",\n\t\t\tstatus);\n\t}\n\ndie:\n\treturn;\n\nretry_cancel:\n\t/* Don't ever retry more than 3 times */\n\tif (req->a_retries++ >= NLMCLNT_MAX_RETRIES)\n\t\tgoto die;\n\tnlm_rebind_host(req->a_host);\n\trpc_restart_call(task);\n\trpc_delay(task, 30 * HZ);\n}"
  },
  {
    "function_name": "nlmclnt_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "743-766",
    "snippet": "static int nlmclnt_cancel(struct nlm_host *host, int block, struct file_lock *fl)\n{\n\tstruct nlm_rqst\t*req;\n\tint status;\n\n\tdprintk(\"lockd: blocking lock attempt was interrupted by a signal.\\n\"\n\t\t\"       Attempting to cancel lock.\\n\");\n\n\treq = nlm_alloc_call(host);\n\tif (!req)\n\t\treturn -ENOMEM;\n\treq->a_flags = RPC_TASK_ASYNC;\n\n\tnlmclnt_setlockargs(req, fl);\n\treq->a_args.block = block;\n\n\tatomic_inc(&req->a_count);\n\tstatus = nlmclnt_async_call(nfs_file_cred(fl->fl_file), req,\n\t\t\tNLMPROC_CANCEL, &nlmclnt_cancel_ops);\n\tif (status == 0 && req->a_res.status == nlm_lck_denied)\n\t\tstatus = -ENOLCK;\n\tnlmclnt_release_call(req);\n\treturn status;\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);",
      "static int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);",
      "static int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);",
      "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);",
      "static int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);",
      "static const struct rpc_call_ops nlmclnt_cancel_ops;",
      "static const struct rpc_call_ops nlmclnt_cancel_ops = {\n\t.rpc_call_done = nlmclnt_cancel_callback,\n\t.rpc_release = nlmclnt_rpc_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmclnt_release_call",
          "args": [
            "req"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_release_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "215-222",
          "snippet": "void nlmclnt_release_call(struct nlm_rqst *call)\n{\n\tif (!atomic_dec_and_test(&call->a_count))\n\t\treturn;\n\tnlmclnt_release_host(call->a_host);\n\tnlmclnt_release_lockargs(call);\n\tkfree(call);\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid nlmclnt_release_call(struct nlm_rqst *call)\n{\n\tif (!atomic_dec_and_test(&call->a_count))\n\t\treturn;\n\tnlmclnt_release_host(call->a_host);\n\tnlmclnt_release_lockargs(call);\n\tkfree(call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmclnt_async_call",
          "args": [
            "nfs_file_cred(fl->fl_file)",
            "req",
            "NLMPROC_CANCEL",
            "&nlmclnt_cancel_ops"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_async_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "394-410",
          "snippet": "static int nlmclnt_async_call(struct rpc_cred *cred, struct nlm_rqst *req, u32 proc, const struct rpc_call_ops *tk_ops)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &req->a_args,\n\t\t.rpc_resp\t= &req->a_res,\n\t\t.rpc_cred\t= cred,\n\t};\n\tstruct rpc_task *task;\n\tint err;\n\n\ttask = __nlm_async_call(req, proc, &msg, tk_ops);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\terr = rpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn err;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int nlmclnt_async_call(struct rpc_cred *cred, struct nlm_rqst *req, u32 proc, const struct rpc_call_ops *tk_ops)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &req->a_args,\n\t\t.rpc_resp\t= &req->a_res,\n\t\t.rpc_cred\t= cred,\n\t};\n\tstruct rpc_task *task;\n\tint err;\n\n\ttask = __nlm_async_call(req, proc, &msg, tk_ops);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\terr = rpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_file_cred",
          "args": [
            "fl->fl_file"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&req->a_count"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmclnt_setlockargs",
          "args": [
            "req",
            "fl"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_setlockargs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "124-141",
          "snippet": "static void nlmclnt_setlockargs(struct nlm_rqst *req, struct file_lock *fl)\n{\n\tstruct nlm_args\t*argp = &req->a_args;\n\tstruct nlm_lock\t*lock = &argp->lock;\n\tchar *nodename = req->a_host->h_rpcclnt->cl_nodename;\n\n\tnlmclnt_next_cookie(&argp->cookie);\n\tmemcpy(&lock->fh, NFS_FH(file_inode(fl->fl_file)), sizeof(struct nfs_fh));\n\tlock->caller  = nodename;\n\tlock->oh.data = req->a_owner;\n\tlock->oh.len  = snprintf(req->a_owner, sizeof(req->a_owner), \"%u@%s\",\n\t\t\t\t(unsigned int)fl->fl_u.nfs_fl.owner->pid,\n\t\t\t\tnodename);\n\tlock->svid = fl->fl_u.nfs_fl.owner->pid;\n\tlock->fl.fl_start = fl->fl_start;\n\tlock->fl.fl_end = fl->fl_end;\n\tlock->fl.fl_type = fl->fl_type;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);\n\nstatic void nlmclnt_setlockargs(struct nlm_rqst *req, struct file_lock *fl)\n{\n\tstruct nlm_args\t*argp = &req->a_args;\n\tstruct nlm_lock\t*lock = &argp->lock;\n\tchar *nodename = req->a_host->h_rpcclnt->cl_nodename;\n\n\tnlmclnt_next_cookie(&argp->cookie);\n\tmemcpy(&lock->fh, NFS_FH(file_inode(fl->fl_file)), sizeof(struct nfs_fh));\n\tlock->caller  = nodename;\n\tlock->oh.data = req->a_owner;\n\tlock->oh.len  = snprintf(req->a_owner, sizeof(req->a_owner), \"%u@%s\",\n\t\t\t\t(unsigned int)fl->fl_u.nfs_fl.owner->pid,\n\t\t\t\tnodename);\n\tlock->svid = fl->fl_u.nfs_fl.owner->pid;\n\tlock->fl.fl_start = fl->fl_start;\n\tlock->fl.fl_end = fl->fl_end;\n\tlock->fl.fl_type = fl->fl_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlm_alloc_call",
          "args": [
            "host"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_alloc_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "194-213",
          "snippet": "struct nlm_rqst *nlm_alloc_call(struct nlm_host *host)\n{\n\tstruct nlm_rqst\t*call;\n\n\tfor(;;) {\n\t\tcall = kzalloc(sizeof(*call), GFP_KERNEL);\n\t\tif (call != NULL) {\n\t\t\tatomic_set(&call->a_count, 1);\n\t\t\tlocks_init_lock(&call->a_args.lock.fl);\n\t\t\tlocks_init_lock(&call->a_res.lock.fl);\n\t\t\tcall->a_host = nlm_get_host(host);\n\t\t\treturn call;\n\t\t}\n\t\tif (signalled())\n\t\t\tbreak;\n\t\tprintk(\"nlm_alloc_call: failed, waiting for memory\\n\");\n\t\tschedule_timeout_interruptible(5*HZ);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\n\nstruct nlm_rqst *nlm_alloc_call(struct nlm_host *host)\n{\n\tstruct nlm_rqst\t*call;\n\n\tfor(;;) {\n\t\tcall = kzalloc(sizeof(*call), GFP_KERNEL);\n\t\tif (call != NULL) {\n\t\t\tatomic_set(&call->a_count, 1);\n\t\t\tlocks_init_lock(&call->a_args.lock.fl);\n\t\t\tlocks_init_lock(&call->a_res.lock.fl);\n\t\t\tcall->a_host = nlm_get_host(host);\n\t\t\treturn call;\n\t\t}\n\t\tif (signalled())\n\t\t\tbreak;\n\t\tprintk(\"nlm_alloc_call: failed, waiting for memory\\n\");\n\t\tschedule_timeout_interruptible(5*HZ);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: blocking lock attempt was interrupted by a signal.\\n\"\n\t\t\"       Attempting to cancel lock.\\n\""
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\nstatic int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);\nstatic const struct rpc_call_ops nlmclnt_cancel_ops;\nstatic const struct rpc_call_ops nlmclnt_cancel_ops = {\n\t.rpc_call_done = nlmclnt_cancel_callback,\n\t.rpc_release = nlmclnt_rpc_release,\n};\n\nstatic int nlmclnt_cancel(struct nlm_host *host, int block, struct file_lock *fl)\n{\n\tstruct nlm_rqst\t*req;\n\tint status;\n\n\tdprintk(\"lockd: blocking lock attempt was interrupted by a signal.\\n\"\n\t\t\"       Attempting to cancel lock.\\n\");\n\n\treq = nlm_alloc_call(host);\n\tif (!req)\n\t\treturn -ENOMEM;\n\treq->a_flags = RPC_TASK_ASYNC;\n\n\tnlmclnt_setlockargs(req, fl);\n\treq->a_args.block = block;\n\n\tatomic_inc(&req->a_count);\n\tstatus = nlmclnt_async_call(nfs_file_cred(fl->fl_file), req,\n\t\t\tNLMPROC_CANCEL, &nlmclnt_cancel_ops);\n\tif (status == 0 && req->a_res.status == nlm_lck_denied)\n\t\tstatus = -ENOLCK;\n\tnlmclnt_release_call(req);\n\treturn status;\n}"
  },
  {
    "function_name": "nlmclnt_unlock_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "701-731",
    "snippet": "static void nlmclnt_unlock_callback(struct rpc_task *task, void *data)\n{\n\tstruct nlm_rqst\t*req = data;\n\tu32 status = ntohl(req->a_res.status);\n\n\tif (RPC_ASSASSINATED(task))\n\t\tgoto die;\n\n\tif (task->tk_status < 0) {\n\t\tdprintk(\"lockd: unlock failed (err = %d)\\n\", -task->tk_status);\n\t\tswitch (task->tk_status) {\n\t\tcase -EACCES:\n\t\tcase -EIO:\n\t\t\tgoto die;\n\t\tdefault:\n\t\t\tgoto retry_rebind;\n\t\t}\n\t}\n\tif (status == NLM_LCK_DENIED_GRACE_PERIOD) {\n\t\trpc_delay(task, NLMCLNT_GRACE_WAIT);\n\t\tgoto retry_unlock;\n\t}\n\tif (status != NLM_LCK_GRANTED)\n\t\tprintk(KERN_WARNING \"lockd: unexpected unlock status: %d\\n\", status);\ndie:\n\treturn;\n retry_rebind:\n\tnlm_rebind_host(req->a_host);\n retry_unlock:\n\trpc_restart_call(task);\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define NLMCLNT_GRACE_WAIT\t(5*HZ)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_restart_call",
          "args": [
            "task"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_rebind_host",
          "args": [
            "req->a_host"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_rebind_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "488-496",
          "snippet": "void\nnlm_rebind_host(struct nlm_host *host)\n{\n\tdprintk(\"lockd: rebind host %s\\n\", host->h_name);\n\tif (host->h_rpcclnt && time_after_eq(jiffies, host->h_nextrebind)) {\n\t\trpc_force_rebind(host->h_rpcclnt);\n\t\thost->h_nextrebind = jiffies + NLM_HOST_REBIND;\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NLM_HOST_REBIND\t\t(60 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NLM_HOST_REBIND\t\t(60 * HZ)\n\nvoid\nnlm_rebind_host(struct nlm_host *host)\n{\n\tdprintk(\"lockd: rebind host %s\\n\", host->h_name);\n\tif (host->h_rpcclnt && time_after_eq(jiffies, host->h_nextrebind)) {\n\t\trpc_force_rebind(host->h_rpcclnt);\n\t\thost->h_nextrebind = jiffies + NLM_HOST_REBIND;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"lockd: unexpected unlock status: %d\\n\"",
            "status"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_delay",
          "args": [
            "task",
            "NLMCLNT_GRACE_WAIT"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: unlock failed (err = %d)\\n\"",
            "-task->tk_status"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RPC_ASSASSINATED",
          "args": [
            "task"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "req->a_res.status"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define NLMCLNT_GRACE_WAIT\t(5*HZ)\n\nstatic void nlmclnt_unlock_callback(struct rpc_task *task, void *data)\n{\n\tstruct nlm_rqst\t*req = data;\n\tu32 status = ntohl(req->a_res.status);\n\n\tif (RPC_ASSASSINATED(task))\n\t\tgoto die;\n\n\tif (task->tk_status < 0) {\n\t\tdprintk(\"lockd: unlock failed (err = %d)\\n\", -task->tk_status);\n\t\tswitch (task->tk_status) {\n\t\tcase -EACCES:\n\t\tcase -EIO:\n\t\t\tgoto die;\n\t\tdefault:\n\t\t\tgoto retry_rebind;\n\t\t}\n\t}\n\tif (status == NLM_LCK_DENIED_GRACE_PERIOD) {\n\t\trpc_delay(task, NLMCLNT_GRACE_WAIT);\n\t\tgoto retry_unlock;\n\t}\n\tif (status != NLM_LCK_GRANTED)\n\t\tprintk(KERN_WARNING \"lockd: unexpected unlock status: %d\\n\", status);\ndie:\n\treturn;\n retry_rebind:\n\tnlm_rebind_host(req->a_host);\n retry_unlock:\n\trpc_restart_call(task);\n}"
  },
  {
    "function_name": "nlmclnt_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "659-699",
    "snippet": "static int\nnlmclnt_unlock(struct nlm_rqst *req, struct file_lock *fl)\n{\n\tstruct nlm_host\t*host = req->a_host;\n\tstruct nlm_res\t*resp = &req->a_res;\n\tint status;\n\tunsigned char fl_flags = fl->fl_flags;\n\n\t/*\n\t * Note: the server is supposed to either grant us the unlock\n\t * request, or to deny it with NLM_LCK_DENIED_GRACE_PERIOD. In either\n\t * case, we want to unlock.\n\t */\n\tfl->fl_flags |= FL_EXISTS;\n\tdown_read(&host->h_rwsem);\n\tstatus = do_vfs_lock(fl);\n\tup_read(&host->h_rwsem);\n\tfl->fl_flags = fl_flags;\n\tif (status == -ENOENT) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\tatomic_inc(&req->a_count);\n\tstatus = nlmclnt_async_call(nfs_file_cred(fl->fl_file), req,\n\t\t\tNLMPROC_UNLOCK, &nlmclnt_unlock_ops);\n\tif (status < 0)\n\t\tgoto out;\n\n\tif (resp->status == nlm_granted)\n\t\tgoto out;\n\n\tif (resp->status != nlm_lck_denied_nolocks)\n\t\tprintk(\"lockd: unexpected unlock status: %d\\n\",\n\t\t\tntohl(resp->status));\n\t/* What to do now? I'm out of my depth... */\n\tstatus = -ENOLCK;\nout:\n\tnlmclnt_release_call(req);\n\treturn status;\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);",
      "static int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);",
      "static int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);",
      "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);",
      "static int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);",
      "static const struct rpc_call_ops nlmclnt_unlock_ops;",
      "static const struct rpc_call_ops nlmclnt_unlock_ops = {\n\t.rpc_call_done = nlmclnt_unlock_callback,\n\t.rpc_release = nlmclnt_rpc_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmclnt_release_call",
          "args": [
            "req"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_release_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "215-222",
          "snippet": "void nlmclnt_release_call(struct nlm_rqst *call)\n{\n\tif (!atomic_dec_and_test(&call->a_count))\n\t\treturn;\n\tnlmclnt_release_host(call->a_host);\n\tnlmclnt_release_lockargs(call);\n\tkfree(call);\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid nlmclnt_release_call(struct nlm_rqst *call)\n{\n\tif (!atomic_dec_and_test(&call->a_count))\n\t\treturn;\n\tnlmclnt_release_host(call->a_host);\n\tnlmclnt_release_lockargs(call);\n\tkfree(call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"lockd: unexpected unlock status: %d\\n\"",
            "ntohl(resp->status)"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "resp->status"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmclnt_async_call",
          "args": [
            "nfs_file_cred(fl->fl_file)",
            "req",
            "NLMPROC_UNLOCK",
            "&nlmclnt_unlock_ops"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_async_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "394-410",
          "snippet": "static int nlmclnt_async_call(struct rpc_cred *cred, struct nlm_rqst *req, u32 proc, const struct rpc_call_ops *tk_ops)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &req->a_args,\n\t\t.rpc_resp\t= &req->a_res,\n\t\t.rpc_cred\t= cred,\n\t};\n\tstruct rpc_task *task;\n\tint err;\n\n\ttask = __nlm_async_call(req, proc, &msg, tk_ops);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\terr = rpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn err;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int nlmclnt_async_call(struct rpc_cred *cred, struct nlm_rqst *req, u32 proc, const struct rpc_call_ops *tk_ops)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &req->a_args,\n\t\t.rpc_resp\t= &req->a_res,\n\t\t.rpc_cred\t= cred,\n\t};\n\tstruct rpc_task *task;\n\tint err;\n\n\ttask = __nlm_async_call(req, proc, &msg, tk_ops);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\terr = rpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_file_cred",
          "args": [
            "fl->fl_file"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&req->a_count"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&host->h_rwsem"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_vfs_lock",
          "args": [
            "fl"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "do_vfs_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "475-489",
          "snippet": "static int do_vfs_lock(struct file_lock *fl)\n{\n\tint res = 0;\n\tswitch (fl->fl_flags & (FL_POSIX|FL_FLOCK)) {\n\t\tcase FL_POSIX:\n\t\t\tres = posix_lock_file_wait(fl->fl_file, fl);\n\t\t\tbreak;\n\t\tcase FL_FLOCK:\n\t\t\tres = flock_lock_file_wait(fl->fl_file, fl);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);\n\nstatic int do_vfs_lock(struct file_lock *fl)\n{\n\tint res = 0;\n\tswitch (fl->fl_flags & (FL_POSIX|FL_FLOCK)) {\n\t\tcase FL_POSIX:\n\t\t\tres = posix_lock_file_wait(fl->fl_file, fl);\n\t\t\tbreak;\n\t\tcase FL_FLOCK:\n\t\t\tres = flock_lock_file_wait(fl->fl_file, fl);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&host->h_rwsem"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\nstatic int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);\nstatic const struct rpc_call_ops nlmclnt_unlock_ops;\nstatic const struct rpc_call_ops nlmclnt_unlock_ops = {\n\t.rpc_call_done = nlmclnt_unlock_callback,\n\t.rpc_release = nlmclnt_rpc_release,\n};\n\nstatic int\nnlmclnt_unlock(struct nlm_rqst *req, struct file_lock *fl)\n{\n\tstruct nlm_host\t*host = req->a_host;\n\tstruct nlm_res\t*resp = &req->a_res;\n\tint status;\n\tunsigned char fl_flags = fl->fl_flags;\n\n\t/*\n\t * Note: the server is supposed to either grant us the unlock\n\t * request, or to deny it with NLM_LCK_DENIED_GRACE_PERIOD. In either\n\t * case, we want to unlock.\n\t */\n\tfl->fl_flags |= FL_EXISTS;\n\tdown_read(&host->h_rwsem);\n\tstatus = do_vfs_lock(fl);\n\tup_read(&host->h_rwsem);\n\tfl->fl_flags = fl_flags;\n\tif (status == -ENOENT) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\tatomic_inc(&req->a_count);\n\tstatus = nlmclnt_async_call(nfs_file_cred(fl->fl_file), req,\n\t\t\tNLMPROC_UNLOCK, &nlmclnt_unlock_ops);\n\tif (status < 0)\n\t\tgoto out;\n\n\tif (resp->status == nlm_granted)\n\t\tgoto out;\n\n\tif (resp->status != nlm_lck_denied_nolocks)\n\t\tprintk(\"lockd: unexpected unlock status: %d\\n\",\n\t\t\tntohl(resp->status));\n\t/* What to do now? I'm out of my depth... */\n\tstatus = -ENOLCK;\nout:\n\tnlmclnt_release_call(req);\n\treturn status;\n}"
  },
  {
    "function_name": "nlmclnt_reclaim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "618-654",
    "snippet": "int\nnlmclnt_reclaim(struct nlm_host *host, struct file_lock *fl,\n\t\tstruct nlm_rqst *req)\n{\n\tint\t\tstatus;\n\n\tmemset(req, 0, sizeof(*req));\n\tlocks_init_lock(&req->a_args.lock.fl);\n\tlocks_init_lock(&req->a_res.lock.fl);\n\treq->a_host  = host;\n\n\t/* Set up the argument struct */\n\tnlmclnt_setlockargs(req, fl);\n\treq->a_args.reclaim = 1;\n\n\tstatus = nlmclnt_call(nfs_file_cred(fl->fl_file), req, NLMPROC_LOCK);\n\tif (status >= 0 && req->a_res.status == nlm_granted)\n\t\treturn 0;\n\n\tprintk(KERN_WARNING \"lockd: failed to reclaim lock for pid %d \"\n\t\t\t\t\"(errno %d, status %d)\\n\", fl->fl_pid,\n\t\t\t\tstatus, ntohl(req->a_res.status));\n\n\t/*\n\t * FIXME: This is a serious failure. We can\n\t *\n\t *  a.\tIgnore the problem\n\t *  b.\tSend the owning process some signal (Linux doesn't have\n\t *\tSIGLOST, though...)\n\t *  c.\tRetry the operation\n\t *\n\t * Until someone comes up with a simple implementation\n\t * for b or c, I'll choose option a.\n\t */\n\n\treturn -ENOLCK;\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);",
      "static int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);",
      "static int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);",
      "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);",
      "static int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"lockd: failed to reclaim lock for pid %d \"\n\t\t\t\t\"(errno %d, status %d)\\n\"",
            "fl->fl_pid",
            "status",
            "ntohl(req->a_res.status)"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "req->a_res.status"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmclnt_call",
          "args": [
            "nfs_file_cred(fl->fl_file)",
            "req",
            "NLMPROC_LOCK"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "248-322",
          "snippet": "static int\nnlmclnt_call(struct rpc_cred *cred, struct nlm_rqst *req, u32 proc)\n{\n\tstruct nlm_host\t*host = req->a_host;\n\tstruct rpc_clnt\t*clnt;\n\tstruct nlm_args\t*argp = &req->a_args;\n\tstruct nlm_res\t*resp = &req->a_res;\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= argp,\n\t\t.rpc_resp\t= resp,\n\t\t.rpc_cred\t= cred,\n\t};\n\tint\t\tstatus;\n\n\tdprintk(\"lockd: call procedure %d on %s\\n\",\n\t\t\t(int)proc, host->h_name);\n\n\tdo {\n\t\tif (host->h_reclaiming && !argp->reclaim)\n\t\t\tgoto in_grace_period;\n\n\t\t/* If we have no RPC client yet, create one. */\n\t\tif ((clnt = nlm_bind_host(host)) == NULL)\n\t\t\treturn -ENOLCK;\n\t\tmsg.rpc_proc = &clnt->cl_procinfo[proc];\n\n\t\t/* Perform the RPC call. If an error occurs, try again */\n\t\tif ((status = rpc_call_sync(clnt, &msg, 0)) < 0) {\n\t\t\tdprintk(\"lockd: rpc_call returned error %d\\n\", -status);\n\t\t\tswitch (status) {\n\t\t\tcase -EPROTONOSUPPORT:\n\t\t\t\tstatus = -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase -ECONNREFUSED:\n\t\t\tcase -ETIMEDOUT:\n\t\t\tcase -ENOTCONN:\n\t\t\t\tnlm_rebind_host(host);\n\t\t\t\tstatus = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\tcase -ERESTARTSYS:\n\t\t\t\treturn signalled () ? -EINTR : status;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else\n\t\tif (resp->status == nlm_lck_denied_grace_period) {\n\t\t\tdprintk(\"lockd: server in grace period\\n\");\n\t\t\tif (argp->reclaim) {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t     \"lockd: spurious grace period reject?!\\n\");\n\t\t\t\treturn -ENOLCK;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!argp->reclaim) {\n\t\t\t\t/* We appear to be out of the grace period */\n\t\t\t\twake_up_all(&host->h_gracewait);\n\t\t\t}\n\t\t\tdprintk(\"lockd: server returns status %d\\n\",\n\t\t\t\tntohl(resp->status));\n\t\t\treturn 0;\t/* Okay, call complete */\n\t\t}\n\nin_grace_period:\n\t\t/*\n\t\t * The server has rebooted and appears to be in the grace\n\t\t * period during which locks are only allowed to be\n\t\t * reclaimed.\n\t\t * We can only back off and try again later.\n\t\t */\n\t\tstatus = nlm_wait_on_grace(&host->h_gracewait);\n\t} while (status == 0);\n\n\treturn status;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\n\nstatic int\nnlmclnt_call(struct rpc_cred *cred, struct nlm_rqst *req, u32 proc)\n{\n\tstruct nlm_host\t*host = req->a_host;\n\tstruct rpc_clnt\t*clnt;\n\tstruct nlm_args\t*argp = &req->a_args;\n\tstruct nlm_res\t*resp = &req->a_res;\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= argp,\n\t\t.rpc_resp\t= resp,\n\t\t.rpc_cred\t= cred,\n\t};\n\tint\t\tstatus;\n\n\tdprintk(\"lockd: call procedure %d on %s\\n\",\n\t\t\t(int)proc, host->h_name);\n\n\tdo {\n\t\tif (host->h_reclaiming && !argp->reclaim)\n\t\t\tgoto in_grace_period;\n\n\t\t/* If we have no RPC client yet, create one. */\n\t\tif ((clnt = nlm_bind_host(host)) == NULL)\n\t\t\treturn -ENOLCK;\n\t\tmsg.rpc_proc = &clnt->cl_procinfo[proc];\n\n\t\t/* Perform the RPC call. If an error occurs, try again */\n\t\tif ((status = rpc_call_sync(clnt, &msg, 0)) < 0) {\n\t\t\tdprintk(\"lockd: rpc_call returned error %d\\n\", -status);\n\t\t\tswitch (status) {\n\t\t\tcase -EPROTONOSUPPORT:\n\t\t\t\tstatus = -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase -ECONNREFUSED:\n\t\t\tcase -ETIMEDOUT:\n\t\t\tcase -ENOTCONN:\n\t\t\t\tnlm_rebind_host(host);\n\t\t\t\tstatus = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\tcase -ERESTARTSYS:\n\t\t\t\treturn signalled () ? -EINTR : status;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else\n\t\tif (resp->status == nlm_lck_denied_grace_period) {\n\t\t\tdprintk(\"lockd: server in grace period\\n\");\n\t\t\tif (argp->reclaim) {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t     \"lockd: spurious grace period reject?!\\n\");\n\t\t\t\treturn -ENOLCK;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!argp->reclaim) {\n\t\t\t\t/* We appear to be out of the grace period */\n\t\t\t\twake_up_all(&host->h_gracewait);\n\t\t\t}\n\t\t\tdprintk(\"lockd: server returns status %d\\n\",\n\t\t\t\tntohl(resp->status));\n\t\t\treturn 0;\t/* Okay, call complete */\n\t\t}\n\nin_grace_period:\n\t\t/*\n\t\t * The server has rebooted and appears to be in the grace\n\t\t * period during which locks are only allowed to be\n\t\t * reclaimed.\n\t\t * We can only back off and try again later.\n\t\t */\n\t\tstatus = nlm_wait_on_grace(&host->h_gracewait);\n\t} while (status == 0);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_file_cred",
          "args": [
            "fl->fl_file"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmclnt_setlockargs",
          "args": [
            "req",
            "fl"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_setlockargs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "124-141",
          "snippet": "static void nlmclnt_setlockargs(struct nlm_rqst *req, struct file_lock *fl)\n{\n\tstruct nlm_args\t*argp = &req->a_args;\n\tstruct nlm_lock\t*lock = &argp->lock;\n\tchar *nodename = req->a_host->h_rpcclnt->cl_nodename;\n\n\tnlmclnt_next_cookie(&argp->cookie);\n\tmemcpy(&lock->fh, NFS_FH(file_inode(fl->fl_file)), sizeof(struct nfs_fh));\n\tlock->caller  = nodename;\n\tlock->oh.data = req->a_owner;\n\tlock->oh.len  = snprintf(req->a_owner, sizeof(req->a_owner), \"%u@%s\",\n\t\t\t\t(unsigned int)fl->fl_u.nfs_fl.owner->pid,\n\t\t\t\tnodename);\n\tlock->svid = fl->fl_u.nfs_fl.owner->pid;\n\tlock->fl.fl_start = fl->fl_start;\n\tlock->fl.fl_end = fl->fl_end;\n\tlock->fl.fl_type = fl->fl_type;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);\n\nstatic void nlmclnt_setlockargs(struct nlm_rqst *req, struct file_lock *fl)\n{\n\tstruct nlm_args\t*argp = &req->a_args;\n\tstruct nlm_lock\t*lock = &argp->lock;\n\tchar *nodename = req->a_host->h_rpcclnt->cl_nodename;\n\n\tnlmclnt_next_cookie(&argp->cookie);\n\tmemcpy(&lock->fh, NFS_FH(file_inode(fl->fl_file)), sizeof(struct nfs_fh));\n\tlock->caller  = nodename;\n\tlock->oh.data = req->a_owner;\n\tlock->oh.len  = snprintf(req->a_owner, sizeof(req->a_owner), \"%u@%s\",\n\t\t\t\t(unsigned int)fl->fl_u.nfs_fl.owner->pid,\n\t\t\t\tnodename);\n\tlock->svid = fl->fl_u.nfs_fl.owner->pid;\n\tlock->fl.fl_start = fl->fl_start;\n\tlock->fl.fl_end = fl->fl_end;\n\tlock->fl.fl_type = fl->fl_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_init_lock",
          "args": [
            "&req->a_res.lock.fl"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "locks_init_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "311-315",
          "snippet": "void locks_init_lock(struct file_lock *fl)\n{\n\tmemset(fl, 0, sizeof(struct file_lock));\n\tlocks_init_lock_heads(fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_init_lock(struct file_lock *fl)\n{\n\tmemset(fl, 0, sizeof(struct file_lock));\n\tlocks_init_lock_heads(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "req",
            "0",
            "sizeof(*req)"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\nstatic int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);\n\nint\nnlmclnt_reclaim(struct nlm_host *host, struct file_lock *fl,\n\t\tstruct nlm_rqst *req)\n{\n\tint\t\tstatus;\n\n\tmemset(req, 0, sizeof(*req));\n\tlocks_init_lock(&req->a_args.lock.fl);\n\tlocks_init_lock(&req->a_res.lock.fl);\n\treq->a_host  = host;\n\n\t/* Set up the argument struct */\n\tnlmclnt_setlockargs(req, fl);\n\treq->a_args.reclaim = 1;\n\n\tstatus = nlmclnt_call(nfs_file_cred(fl->fl_file), req, NLMPROC_LOCK);\n\tif (status >= 0 && req->a_res.status == nlm_granted)\n\t\treturn 0;\n\n\tprintk(KERN_WARNING \"lockd: failed to reclaim lock for pid %d \"\n\t\t\t\t\"(errno %d, status %d)\\n\", fl->fl_pid,\n\t\t\t\tstatus, ntohl(req->a_res.status));\n\n\t/*\n\t * FIXME: This is a serious failure. We can\n\t *\n\t *  a.\tIgnore the problem\n\t *  b.\tSend the owning process some signal (Linux doesn't have\n\t *\tSIGLOST, though...)\n\t *  c.\tRetry the operation\n\t *\n\t * Until someone comes up with a simple implementation\n\t * for b or c, I'll choose option a.\n\t */\n\n\treturn -ENOLCK;\n}"
  },
  {
    "function_name": "nlmclnt_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "511-613",
    "snippet": "static int\nnlmclnt_lock(struct nlm_rqst *req, struct file_lock *fl)\n{\n\tstruct rpc_cred *cred = nfs_file_cred(fl->fl_file);\n\tstruct nlm_host\t*host = req->a_host;\n\tstruct nlm_res\t*resp = &req->a_res;\n\tstruct nlm_wait *block = NULL;\n\tunsigned char fl_flags = fl->fl_flags;\n\tunsigned char fl_type;\n\tint status = -ENOLCK;\n\n\tif (nsm_monitor(host) < 0)\n\t\tgoto out;\n\treq->a_args.state = nsm_local_state;\n\n\tfl->fl_flags |= FL_ACCESS;\n\tstatus = do_vfs_lock(fl);\n\tfl->fl_flags = fl_flags;\n\tif (status < 0)\n\t\tgoto out;\n\n\tblock = nlmclnt_prepare_block(host, fl);\nagain:\n\t/*\n\t * Initialise resp->status to a valid non-zero value,\n\t * since 0 == nlm_lck_granted\n\t */\n\tresp->status = nlm_lck_blocked;\n\tfor(;;) {\n\t\t/* Reboot protection */\n\t\tfl->fl_u.nfs_fl.state = host->h_state;\n\t\tstatus = nlmclnt_call(cred, req, NLMPROC_LOCK);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\t/* Did a reclaimer thread notify us of a server reboot? */\n\t\tif (resp->status ==  nlm_lck_denied_grace_period)\n\t\t\tcontinue;\n\t\tif (resp->status != nlm_lck_blocked)\n\t\t\tbreak;\n\t\t/* Wait on an NLM blocking lock */\n\t\tstatus = nlmclnt_block(block, req, NLMCLNT_POLL_TIMEOUT);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tif (resp->status != nlm_lck_blocked)\n\t\t\tbreak;\n\t}\n\n\t/* if we were interrupted while blocking, then cancel the lock request\n\t * and exit\n\t */\n\tif (resp->status == nlm_lck_blocked) {\n\t\tif (!req->a_args.block)\n\t\t\tgoto out_unlock;\n\t\tif (nlmclnt_cancel(host, req->a_args.block, fl) == 0)\n\t\t\tgoto out_unblock;\n\t}\n\n\tif (resp->status == nlm_granted) {\n\t\tdown_read(&host->h_rwsem);\n\t\t/* Check whether or not the server has rebooted */\n\t\tif (fl->fl_u.nfs_fl.state != host->h_state) {\n\t\t\tup_read(&host->h_rwsem);\n\t\t\tgoto again;\n\t\t}\n\t\t/* Ensure the resulting lock will get added to granted list */\n\t\tfl->fl_flags |= FL_SLEEP;\n\t\tif (do_vfs_lock(fl) < 0)\n\t\t\tprintk(KERN_WARNING \"%s: VFS is out of sync with lock manager!\\n\", __func__);\n\t\tup_read(&host->h_rwsem);\n\t\tfl->fl_flags = fl_flags;\n\t\tstatus = 0;\n\t}\n\tif (status < 0)\n\t\tgoto out_unlock;\n\t/*\n\t * EAGAIN doesn't make sense for sleeping locks, and in some\n\t * cases NLM_LCK_DENIED is returned for a permanent error.  So\n\t * turn it into an ENOLCK.\n\t */\n\tif (resp->status == nlm_lck_denied && (fl_flags & FL_SLEEP))\n\t\tstatus = -ENOLCK;\n\telse\n\t\tstatus = nlm_stat_to_errno(resp->status);\nout_unblock:\n\tnlmclnt_finish_block(block);\nout:\n\tnlmclnt_release_call(req);\n\treturn status;\nout_unlock:\n\t/* Fatal error: ensure that we remove the lock altogether */\n\tdprintk(\"lockd: lock attempt ended in fatal error.\\n\"\n\t\t\"       Attempting to unlock.\\n\");\n\tnlmclnt_finish_block(block);\n\tfl_type = fl->fl_type;\n\tfl->fl_type = F_UNLCK;\n\tdown_read(&host->h_rwsem);\n\tdo_vfs_lock(fl);\n\tup_read(&host->h_rwsem);\n\tfl->fl_type = fl_type;\n\tfl->fl_flags = fl_flags;\n\tnlmclnt_async_call(cred, req, NLMPROC_UNLOCK, &nlmclnt_unlock_ops);\n\treturn status;\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define NLMCLNT_POLL_TIMEOUT\t(30*HZ)"
    ],
    "globals_used": [
      "static int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);",
      "static int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);",
      "static int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);",
      "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);",
      "static int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);",
      "static const struct rpc_call_ops nlmclnt_unlock_ops;",
      "static const struct rpc_call_ops nlmclnt_unlock_ops = {\n\t.rpc_call_done = nlmclnt_unlock_callback,\n\t.rpc_release = nlmclnt_rpc_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmclnt_async_call",
          "args": [
            "cred",
            "req",
            "NLMPROC_UNLOCK",
            "&nlmclnt_unlock_ops"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_async_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "394-410",
          "snippet": "static int nlmclnt_async_call(struct rpc_cred *cred, struct nlm_rqst *req, u32 proc, const struct rpc_call_ops *tk_ops)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &req->a_args,\n\t\t.rpc_resp\t= &req->a_res,\n\t\t.rpc_cred\t= cred,\n\t};\n\tstruct rpc_task *task;\n\tint err;\n\n\ttask = __nlm_async_call(req, proc, &msg, tk_ops);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\terr = rpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn err;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int nlmclnt_async_call(struct rpc_cred *cred, struct nlm_rqst *req, u32 proc, const struct rpc_call_ops *tk_ops)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &req->a_args,\n\t\t.rpc_resp\t= &req->a_res,\n\t\t.rpc_cred\t= cred,\n\t};\n\tstruct rpc_task *task;\n\tint err;\n\n\ttask = __nlm_async_call(req, proc, &msg, tk_ops);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\terr = rpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&host->h_rwsem"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_vfs_lock",
          "args": [
            "fl"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "do_vfs_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "475-489",
          "snippet": "static int do_vfs_lock(struct file_lock *fl)\n{\n\tint res = 0;\n\tswitch (fl->fl_flags & (FL_POSIX|FL_FLOCK)) {\n\t\tcase FL_POSIX:\n\t\t\tres = posix_lock_file_wait(fl->fl_file, fl);\n\t\t\tbreak;\n\t\tcase FL_FLOCK:\n\t\t\tres = flock_lock_file_wait(fl->fl_file, fl);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);\n\nstatic int do_vfs_lock(struct file_lock *fl)\n{\n\tint res = 0;\n\tswitch (fl->fl_flags & (FL_POSIX|FL_FLOCK)) {\n\t\tcase FL_POSIX:\n\t\t\tres = posix_lock_file_wait(fl->fl_file, fl);\n\t\t\tbreak;\n\t\tcase FL_FLOCK:\n\t\t\tres = flock_lock_file_wait(fl->fl_file, fl);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&host->h_rwsem"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmclnt_finish_block",
          "args": [
            "block"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_finish_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntlock.c",
          "lines": "116-124",
          "snippet": "void nlmclnt_finish_block(struct nlm_wait *block)\n{\n\tif (block == NULL)\n\t\treturn;\n\tspin_lock(&nlm_blocked_lock);\n\tlist_del(&block->b_list);\n\tspin_unlock(&nlm_blocked_lock);\n\tkfree(block);\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(nlm_blocked_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_fs.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic DEFINE_SPINLOCK(nlm_blocked_lock);\n\nvoid nlmclnt_finish_block(struct nlm_wait *block)\n{\n\tif (block == NULL)\n\t\treturn;\n\tspin_lock(&nlm_blocked_lock);\n\tlist_del(&block->b_list);\n\tspin_unlock(&nlm_blocked_lock);\n\tkfree(block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: lock attempt ended in fatal error.\\n\"\n\t\t\"       Attempting to unlock.\\n\""
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmclnt_release_call",
          "args": [
            "req"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_release_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "215-222",
          "snippet": "void nlmclnt_release_call(struct nlm_rqst *call)\n{\n\tif (!atomic_dec_and_test(&call->a_count))\n\t\treturn;\n\tnlmclnt_release_host(call->a_host);\n\tnlmclnt_release_lockargs(call);\n\tkfree(call);\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid nlmclnt_release_call(struct nlm_rqst *call)\n{\n\tif (!atomic_dec_and_test(&call->a_count))\n\t\treturn;\n\tnlmclnt_release_host(call->a_host);\n\tnlmclnt_release_lockargs(call);\n\tkfree(call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlm_stat_to_errno",
          "args": [
            "resp->status"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_stat_to_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "819-849",
          "snippet": "static int\nnlm_stat_to_errno(__be32 status)\n{\n\tswitch(ntohl(status)) {\n\tcase NLM_LCK_GRANTED:\n\t\treturn 0;\n\tcase NLM_LCK_DENIED:\n\t\treturn -EAGAIN;\n\tcase NLM_LCK_DENIED_NOLOCKS:\n\tcase NLM_LCK_DENIED_GRACE_PERIOD:\n\t\treturn -ENOLCK;\n\tcase NLM_LCK_BLOCKED:\n\t\tprintk(KERN_NOTICE \"lockd: unexpected status NLM_BLOCKED\\n\");\n\t\treturn -ENOLCK;\n#ifdef CONFIG_LOCKD_V4\n\tcase NLM_DEADLCK:\n\t\treturn -EDEADLK;\n\tcase NLM_ROFS:\n\t\treturn -EROFS;\n\tcase NLM_STALE_FH:\n\t\treturn -ESTALE;\n\tcase NLM_FBIG:\n\t\treturn -EOVERFLOW;\n\tcase NLM_FAILED:\n\t\treturn -ENOLCK;\n#endif\n\t}\n\tprintk(KERN_NOTICE \"lockd: unexpected server status %d\\n\",\n\t\t ntohl(status));\n\treturn -ENOLCK;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int\nnlm_stat_to_errno(__be32 status)\n{\n\tswitch(ntohl(status)) {\n\tcase NLM_LCK_GRANTED:\n\t\treturn 0;\n\tcase NLM_LCK_DENIED:\n\t\treturn -EAGAIN;\n\tcase NLM_LCK_DENIED_NOLOCKS:\n\tcase NLM_LCK_DENIED_GRACE_PERIOD:\n\t\treturn -ENOLCK;\n\tcase NLM_LCK_BLOCKED:\n\t\tprintk(KERN_NOTICE \"lockd: unexpected status NLM_BLOCKED\\n\");\n\t\treturn -ENOLCK;\n#ifdef CONFIG_LOCKD_V4\n\tcase NLM_DEADLCK:\n\t\treturn -EDEADLK;\n\tcase NLM_ROFS:\n\t\treturn -EROFS;\n\tcase NLM_STALE_FH:\n\t\treturn -ESTALE;\n\tcase NLM_FBIG:\n\t\treturn -EOVERFLOW;\n\tcase NLM_FAILED:\n\t\treturn -ENOLCK;\n#endif\n\t}\n\tprintk(KERN_NOTICE \"lockd: unexpected server status %d\\n\",\n\t\t ntohl(status));\n\treturn -ENOLCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&host->h_rwsem"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"%s: VFS is out of sync with lock manager!\\n\"",
            "__func__"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&host->h_rwsem"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&host->h_rwsem"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmclnt_cancel",
          "args": [
            "host",
            "req->a_args.block",
            "fl"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "743-766",
          "snippet": "static int nlmclnt_cancel(struct nlm_host *host, int block, struct file_lock *fl)\n{\n\tstruct nlm_rqst\t*req;\n\tint status;\n\n\tdprintk(\"lockd: blocking lock attempt was interrupted by a signal.\\n\"\n\t\t\"       Attempting to cancel lock.\\n\");\n\n\treq = nlm_alloc_call(host);\n\tif (!req)\n\t\treturn -ENOMEM;\n\treq->a_flags = RPC_TASK_ASYNC;\n\n\tnlmclnt_setlockargs(req, fl);\n\treq->a_args.block = block;\n\n\tatomic_inc(&req->a_count);\n\tstatus = nlmclnt_async_call(nfs_file_cred(fl->fl_file), req,\n\t\t\tNLMPROC_CANCEL, &nlmclnt_cancel_ops);\n\tif (status == 0 && req->a_res.status == nlm_lck_denied)\n\t\tstatus = -ENOLCK;\n\tnlmclnt_release_call(req);\n\treturn status;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);",
            "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);",
            "static int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);",
            "static const struct rpc_call_ops nlmclnt_cancel_ops;",
            "static const struct rpc_call_ops nlmclnt_cancel_ops = {\n\t.rpc_call_done = nlmclnt_cancel_callback,\n\t.rpc_release = nlmclnt_rpc_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\nstatic int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);\nstatic const struct rpc_call_ops nlmclnt_cancel_ops;\nstatic const struct rpc_call_ops nlmclnt_cancel_ops = {\n\t.rpc_call_done = nlmclnt_cancel_callback,\n\t.rpc_release = nlmclnt_rpc_release,\n};\n\nstatic int nlmclnt_cancel(struct nlm_host *host, int block, struct file_lock *fl)\n{\n\tstruct nlm_rqst\t*req;\n\tint status;\n\n\tdprintk(\"lockd: blocking lock attempt was interrupted by a signal.\\n\"\n\t\t\"       Attempting to cancel lock.\\n\");\n\n\treq = nlm_alloc_call(host);\n\tif (!req)\n\t\treturn -ENOMEM;\n\treq->a_flags = RPC_TASK_ASYNC;\n\n\tnlmclnt_setlockargs(req, fl);\n\treq->a_args.block = block;\n\n\tatomic_inc(&req->a_count);\n\tstatus = nlmclnt_async_call(nfs_file_cred(fl->fl_file), req,\n\t\t\tNLMPROC_CANCEL, &nlmclnt_cancel_ops);\n\tif (status == 0 && req->a_res.status == nlm_lck_denied)\n\t\tstatus = -ENOLCK;\n\tnlmclnt_release_call(req);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmclnt_block",
          "args": [
            "block",
            "req",
            "NLMCLNT_POLL_TIMEOUT"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntlock.c",
          "lines": "129-157",
          "snippet": "int nlmclnt_block(struct nlm_wait *block, struct nlm_rqst *req, long timeout)\n{\n\tlong ret;\n\n\t/* A borken server might ask us to block even if we didn't\n\t * request it. Just say no!\n\t */\n\tif (block == NULL)\n\t\treturn -EAGAIN;\n\n\t/* Go to sleep waiting for GRANT callback. Some servers seem\n\t * to lose callbacks, however, so we're going to poll from\n\t * time to time just to make sure.\n\t *\n\t * For now, the retry frequency is pretty high; normally \n\t * a 1 minute timeout would do. See the comment before\n\t * nlmclnt_lock for an explanation.\n\t */\n\tret = wait_event_interruptible_timeout(block->b_wait,\n\t\t\tblock->b_status != nlm_lck_blocked,\n\t\t\ttimeout);\n\tif (ret < 0)\n\t\treturn -ERESTARTSYS;\n\t/* Reset the lock status after a server reboot so we resend */\n\tif (block->b_status == nlm_lck_denied_grace_period)\n\t\tblock->b_status = nlm_lck_blocked;\n\treq->a_res.status = block->b_status;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_fs.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint nlmclnt_block(struct nlm_wait *block, struct nlm_rqst *req, long timeout)\n{\n\tlong ret;\n\n\t/* A borken server might ask us to block even if we didn't\n\t * request it. Just say no!\n\t */\n\tif (block == NULL)\n\t\treturn -EAGAIN;\n\n\t/* Go to sleep waiting for GRANT callback. Some servers seem\n\t * to lose callbacks, however, so we're going to poll from\n\t * time to time just to make sure.\n\t *\n\t * For now, the retry frequency is pretty high; normally \n\t * a 1 minute timeout would do. See the comment before\n\t * nlmclnt_lock for an explanation.\n\t */\n\tret = wait_event_interruptible_timeout(block->b_wait,\n\t\t\tblock->b_status != nlm_lck_blocked,\n\t\t\ttimeout);\n\tif (ret < 0)\n\t\treturn -ERESTARTSYS;\n\t/* Reset the lock status after a server reboot so we resend */\n\tif (block->b_status == nlm_lck_denied_grace_period)\n\t\tblock->b_status = nlm_lck_blocked;\n\treq->a_res.status = block->b_status;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmclnt_call",
          "args": [
            "cred",
            "req",
            "NLMPROC_LOCK"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "248-322",
          "snippet": "static int\nnlmclnt_call(struct rpc_cred *cred, struct nlm_rqst *req, u32 proc)\n{\n\tstruct nlm_host\t*host = req->a_host;\n\tstruct rpc_clnt\t*clnt;\n\tstruct nlm_args\t*argp = &req->a_args;\n\tstruct nlm_res\t*resp = &req->a_res;\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= argp,\n\t\t.rpc_resp\t= resp,\n\t\t.rpc_cred\t= cred,\n\t};\n\tint\t\tstatus;\n\n\tdprintk(\"lockd: call procedure %d on %s\\n\",\n\t\t\t(int)proc, host->h_name);\n\n\tdo {\n\t\tif (host->h_reclaiming && !argp->reclaim)\n\t\t\tgoto in_grace_period;\n\n\t\t/* If we have no RPC client yet, create one. */\n\t\tif ((clnt = nlm_bind_host(host)) == NULL)\n\t\t\treturn -ENOLCK;\n\t\tmsg.rpc_proc = &clnt->cl_procinfo[proc];\n\n\t\t/* Perform the RPC call. If an error occurs, try again */\n\t\tif ((status = rpc_call_sync(clnt, &msg, 0)) < 0) {\n\t\t\tdprintk(\"lockd: rpc_call returned error %d\\n\", -status);\n\t\t\tswitch (status) {\n\t\t\tcase -EPROTONOSUPPORT:\n\t\t\t\tstatus = -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase -ECONNREFUSED:\n\t\t\tcase -ETIMEDOUT:\n\t\t\tcase -ENOTCONN:\n\t\t\t\tnlm_rebind_host(host);\n\t\t\t\tstatus = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\tcase -ERESTARTSYS:\n\t\t\t\treturn signalled () ? -EINTR : status;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else\n\t\tif (resp->status == nlm_lck_denied_grace_period) {\n\t\t\tdprintk(\"lockd: server in grace period\\n\");\n\t\t\tif (argp->reclaim) {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t     \"lockd: spurious grace period reject?!\\n\");\n\t\t\t\treturn -ENOLCK;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!argp->reclaim) {\n\t\t\t\t/* We appear to be out of the grace period */\n\t\t\t\twake_up_all(&host->h_gracewait);\n\t\t\t}\n\t\t\tdprintk(\"lockd: server returns status %d\\n\",\n\t\t\t\tntohl(resp->status));\n\t\t\treturn 0;\t/* Okay, call complete */\n\t\t}\n\nin_grace_period:\n\t\t/*\n\t\t * The server has rebooted and appears to be in the grace\n\t\t * period during which locks are only allowed to be\n\t\t * reclaimed.\n\t\t * We can only back off and try again later.\n\t\t */\n\t\tstatus = nlm_wait_on_grace(&host->h_gracewait);\n\t} while (status == 0);\n\n\treturn status;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\n\nstatic int\nnlmclnt_call(struct rpc_cred *cred, struct nlm_rqst *req, u32 proc)\n{\n\tstruct nlm_host\t*host = req->a_host;\n\tstruct rpc_clnt\t*clnt;\n\tstruct nlm_args\t*argp = &req->a_args;\n\tstruct nlm_res\t*resp = &req->a_res;\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= argp,\n\t\t.rpc_resp\t= resp,\n\t\t.rpc_cred\t= cred,\n\t};\n\tint\t\tstatus;\n\n\tdprintk(\"lockd: call procedure %d on %s\\n\",\n\t\t\t(int)proc, host->h_name);\n\n\tdo {\n\t\tif (host->h_reclaiming && !argp->reclaim)\n\t\t\tgoto in_grace_period;\n\n\t\t/* If we have no RPC client yet, create one. */\n\t\tif ((clnt = nlm_bind_host(host)) == NULL)\n\t\t\treturn -ENOLCK;\n\t\tmsg.rpc_proc = &clnt->cl_procinfo[proc];\n\n\t\t/* Perform the RPC call. If an error occurs, try again */\n\t\tif ((status = rpc_call_sync(clnt, &msg, 0)) < 0) {\n\t\t\tdprintk(\"lockd: rpc_call returned error %d\\n\", -status);\n\t\t\tswitch (status) {\n\t\t\tcase -EPROTONOSUPPORT:\n\t\t\t\tstatus = -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase -ECONNREFUSED:\n\t\t\tcase -ETIMEDOUT:\n\t\t\tcase -ENOTCONN:\n\t\t\t\tnlm_rebind_host(host);\n\t\t\t\tstatus = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\tcase -ERESTARTSYS:\n\t\t\t\treturn signalled () ? -EINTR : status;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else\n\t\tif (resp->status == nlm_lck_denied_grace_period) {\n\t\t\tdprintk(\"lockd: server in grace period\\n\");\n\t\t\tif (argp->reclaim) {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t     \"lockd: spurious grace period reject?!\\n\");\n\t\t\t\treturn -ENOLCK;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!argp->reclaim) {\n\t\t\t\t/* We appear to be out of the grace period */\n\t\t\t\twake_up_all(&host->h_gracewait);\n\t\t\t}\n\t\t\tdprintk(\"lockd: server returns status %d\\n\",\n\t\t\t\tntohl(resp->status));\n\t\t\treturn 0;\t/* Okay, call complete */\n\t\t}\n\nin_grace_period:\n\t\t/*\n\t\t * The server has rebooted and appears to be in the grace\n\t\t * period during which locks are only allowed to be\n\t\t * reclaimed.\n\t\t * We can only back off and try again later.\n\t\t */\n\t\tstatus = nlm_wait_on_grace(&host->h_gracewait);\n\t} while (status == 0);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmclnt_prepare_block",
          "args": [
            "host",
            "fl"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_prepare_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntlock.c",
          "lines": "98-114",
          "snippet": "struct nlm_wait *nlmclnt_prepare_block(struct nlm_host *host, struct file_lock *fl)\n{\n\tstruct nlm_wait *block;\n\n\tblock = kmalloc(sizeof(*block), GFP_KERNEL);\n\tif (block != NULL) {\n\t\tblock->b_host = host;\n\t\tblock->b_lock = fl;\n\t\tinit_waitqueue_head(&block->b_wait);\n\t\tblock->b_status = nlm_lck_blocked;\n\n\t\tspin_lock(&nlm_blocked_lock);\n\t\tlist_add(&block->b_list, &nlm_blocked);\n\t\tspin_unlock(&nlm_blocked_lock);\n\t}\n\treturn block;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(nlm_blocked);",
            "static DEFINE_SPINLOCK(nlm_blocked_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_fs.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(nlm_blocked);\nstatic DEFINE_SPINLOCK(nlm_blocked_lock);\n\nstruct nlm_wait *nlmclnt_prepare_block(struct nlm_host *host, struct file_lock *fl)\n{\n\tstruct nlm_wait *block;\n\n\tblock = kmalloc(sizeof(*block), GFP_KERNEL);\n\tif (block != NULL) {\n\t\tblock->b_host = host;\n\t\tblock->b_lock = fl;\n\t\tinit_waitqueue_head(&block->b_wait);\n\t\tblock->b_status = nlm_lck_blocked;\n\n\t\tspin_lock(&nlm_blocked_lock);\n\t\tlist_add(&block->b_list, &nlm_blocked);\n\t\tspin_unlock(&nlm_blocked_lock);\n\t}\n\treturn block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nsm_monitor",
          "args": [
            "host"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "nsm_monitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/mon.c",
          "lines": "188-232",
          "snippet": "int nsm_monitor(const struct nlm_host *host)\n{\n\tstruct nsm_handle *nsm = host->h_nsmhandle;\n\tstruct nsm_res\tres;\n\tint\t\tstatus;\n\tstruct rpc_clnt *clnt;\n\tconst char *nodename = NULL;\n\n\tdprintk(\"lockd: nsm_monitor(%s)\\n\", nsm->sm_name);\n\n\tif (nsm->sm_monitored)\n\t\treturn 0;\n\n\tif (host->h_rpcclnt)\n\t\tnodename = host->h_rpcclnt->cl_nodename;\n\n\t/*\n\t * Choose whether to record the caller_name or IP address of\n\t * this peer in the local rpc.statd's database.\n\t */\n\tnsm->sm_mon_name = nsm_use_hostnames ? nsm->sm_name : nsm->sm_addrbuf;\n\n\tclnt = nsm_client_get(host->net, nodename);\n\tif (IS_ERR(clnt)) {\n\t\tstatus = PTR_ERR(clnt);\n\t\tdprintk(\"lockd: failed to create NSM upcall transport, \"\n\t\t\t\t\"status=%d, net=%p\\n\", status, host->net);\n\t\treturn status;\n\t}\n\n\tstatus = nsm_mon_unmon(nsm, NSMPROC_MON, &res, clnt);\n\tif (unlikely(res.status != 0))\n\t\tstatus = -EIO;\n\tif (unlikely(status < 0)) {\n\t\tpr_notice_ratelimited(\"lockd: cannot monitor %s\\n\", nsm->sm_name);\n\t\treturn status;\n\t}\n\n\tnsm->sm_monitored = 1;\n\tif (unlikely(nsm_local_state != res.state)) {\n\t\tnsm_local_state = res.state;\n\t\tdprintk(\"lockd: NSM state changed to %d\\n\", nsm_local_state);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/xprtsock.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/ktime.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <asm/unaligned.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/ktime.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint nsm_monitor(const struct nlm_host *host)\n{\n\tstruct nsm_handle *nsm = host->h_nsmhandle;\n\tstruct nsm_res\tres;\n\tint\t\tstatus;\n\tstruct rpc_clnt *clnt;\n\tconst char *nodename = NULL;\n\n\tdprintk(\"lockd: nsm_monitor(%s)\\n\", nsm->sm_name);\n\n\tif (nsm->sm_monitored)\n\t\treturn 0;\n\n\tif (host->h_rpcclnt)\n\t\tnodename = host->h_rpcclnt->cl_nodename;\n\n\t/*\n\t * Choose whether to record the caller_name or IP address of\n\t * this peer in the local rpc.statd's database.\n\t */\n\tnsm->sm_mon_name = nsm_use_hostnames ? nsm->sm_name : nsm->sm_addrbuf;\n\n\tclnt = nsm_client_get(host->net, nodename);\n\tif (IS_ERR(clnt)) {\n\t\tstatus = PTR_ERR(clnt);\n\t\tdprintk(\"lockd: failed to create NSM upcall transport, \"\n\t\t\t\t\"status=%d, net=%p\\n\", status, host->net);\n\t\treturn status;\n\t}\n\n\tstatus = nsm_mon_unmon(nsm, NSMPROC_MON, &res, clnt);\n\tif (unlikely(res.status != 0))\n\t\tstatus = -EIO;\n\tif (unlikely(status < 0)) {\n\t\tpr_notice_ratelimited(\"lockd: cannot monitor %s\\n\", nsm->sm_name);\n\t\treturn status;\n\t}\n\n\tnsm->sm_monitored = 1;\n\tif (unlikely(nsm_local_state != res.state)) {\n\t\tnsm_local_state = res.state;\n\t\tdprintk(\"lockd: NSM state changed to %d\\n\", nsm_local_state);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_file_cred",
          "args": [
            "fl->fl_file"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define NLMCLNT_POLL_TIMEOUT\t(30*HZ)\n\nstatic int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\nstatic int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);\nstatic const struct rpc_call_ops nlmclnt_unlock_ops;\nstatic const struct rpc_call_ops nlmclnt_unlock_ops = {\n\t.rpc_call_done = nlmclnt_unlock_callback,\n\t.rpc_release = nlmclnt_rpc_release,\n};\n\nstatic int\nnlmclnt_lock(struct nlm_rqst *req, struct file_lock *fl)\n{\n\tstruct rpc_cred *cred = nfs_file_cred(fl->fl_file);\n\tstruct nlm_host\t*host = req->a_host;\n\tstruct nlm_res\t*resp = &req->a_res;\n\tstruct nlm_wait *block = NULL;\n\tunsigned char fl_flags = fl->fl_flags;\n\tunsigned char fl_type;\n\tint status = -ENOLCK;\n\n\tif (nsm_monitor(host) < 0)\n\t\tgoto out;\n\treq->a_args.state = nsm_local_state;\n\n\tfl->fl_flags |= FL_ACCESS;\n\tstatus = do_vfs_lock(fl);\n\tfl->fl_flags = fl_flags;\n\tif (status < 0)\n\t\tgoto out;\n\n\tblock = nlmclnt_prepare_block(host, fl);\nagain:\n\t/*\n\t * Initialise resp->status to a valid non-zero value,\n\t * since 0 == nlm_lck_granted\n\t */\n\tresp->status = nlm_lck_blocked;\n\tfor(;;) {\n\t\t/* Reboot protection */\n\t\tfl->fl_u.nfs_fl.state = host->h_state;\n\t\tstatus = nlmclnt_call(cred, req, NLMPROC_LOCK);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\t/* Did a reclaimer thread notify us of a server reboot? */\n\t\tif (resp->status ==  nlm_lck_denied_grace_period)\n\t\t\tcontinue;\n\t\tif (resp->status != nlm_lck_blocked)\n\t\t\tbreak;\n\t\t/* Wait on an NLM blocking lock */\n\t\tstatus = nlmclnt_block(block, req, NLMCLNT_POLL_TIMEOUT);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tif (resp->status != nlm_lck_blocked)\n\t\t\tbreak;\n\t}\n\n\t/* if we were interrupted while blocking, then cancel the lock request\n\t * and exit\n\t */\n\tif (resp->status == nlm_lck_blocked) {\n\t\tif (!req->a_args.block)\n\t\t\tgoto out_unlock;\n\t\tif (nlmclnt_cancel(host, req->a_args.block, fl) == 0)\n\t\t\tgoto out_unblock;\n\t}\n\n\tif (resp->status == nlm_granted) {\n\t\tdown_read(&host->h_rwsem);\n\t\t/* Check whether or not the server has rebooted */\n\t\tif (fl->fl_u.nfs_fl.state != host->h_state) {\n\t\t\tup_read(&host->h_rwsem);\n\t\t\tgoto again;\n\t\t}\n\t\t/* Ensure the resulting lock will get added to granted list */\n\t\tfl->fl_flags |= FL_SLEEP;\n\t\tif (do_vfs_lock(fl) < 0)\n\t\t\tprintk(KERN_WARNING \"%s: VFS is out of sync with lock manager!\\n\", __func__);\n\t\tup_read(&host->h_rwsem);\n\t\tfl->fl_flags = fl_flags;\n\t\tstatus = 0;\n\t}\n\tif (status < 0)\n\t\tgoto out_unlock;\n\t/*\n\t * EAGAIN doesn't make sense for sleeping locks, and in some\n\t * cases NLM_LCK_DENIED is returned for a permanent error.  So\n\t * turn it into an ENOLCK.\n\t */\n\tif (resp->status == nlm_lck_denied && (fl_flags & FL_SLEEP))\n\t\tstatus = -ENOLCK;\n\telse\n\t\tstatus = nlm_stat_to_errno(resp->status);\nout_unblock:\n\tnlmclnt_finish_block(block);\nout:\n\tnlmclnt_release_call(req);\n\treturn status;\nout_unlock:\n\t/* Fatal error: ensure that we remove the lock altogether */\n\tdprintk(\"lockd: lock attempt ended in fatal error.\\n\"\n\t\t\"       Attempting to unlock.\\n\");\n\tnlmclnt_finish_block(block);\n\tfl_type = fl->fl_type;\n\tfl->fl_type = F_UNLCK;\n\tdown_read(&host->h_rwsem);\n\tdo_vfs_lock(fl);\n\tup_read(&host->h_rwsem);\n\tfl->fl_type = fl_type;\n\tfl->fl_flags = fl_flags;\n\tnlmclnt_async_call(cred, req, NLMPROC_UNLOCK, &nlmclnt_unlock_ops);\n\treturn status;\n}"
  },
  {
    "function_name": "do_vfs_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "475-489",
    "snippet": "static int do_vfs_lock(struct file_lock *fl)\n{\n\tint res = 0;\n\tswitch (fl->fl_flags & (FL_POSIX|FL_FLOCK)) {\n\t\tcase FL_POSIX:\n\t\t\tres = posix_lock_file_wait(fl->fl_file, fl);\n\t\t\tbreak;\n\t\tcase FL_FLOCK:\n\t\t\tres = flock_lock_file_wait(fl->fl_file, fl);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\treturn res;\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);",
      "static int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);",
      "static int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);",
      "static int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flock_lock_file_wait",
          "args": [
            "fl->fl_file",
            "fl"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "flock_lock_file_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1858-1874",
          "snippet": "int flock_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_file(filp, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint flock_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_file(filp, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_lock_file_wait",
          "args": [
            "fl->fl_file",
            "fl"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "posix_lock_file_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1173-1189",
          "snippet": "int posix_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep ();\n\tfor (;;) {\n\t\terror = posix_lock_file(filp, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint posix_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep ();\n\tfor (;;) {\n\t\terror = posix_lock_file(filp, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);\n\nstatic int do_vfs_lock(struct file_lock *fl)\n{\n\tint res = 0;\n\tswitch (fl->fl_flags & (FL_POSIX|FL_FLOCK)) {\n\t\tcase FL_POSIX:\n\t\t\tres = posix_lock_file_wait(fl->fl_file, fl);\n\t\t\tbreak;\n\t\tcase FL_FLOCK:\n\t\t\tres = flock_lock_file_wait(fl->fl_file, fl);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "nlmclnt_locks_init_private",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "467-473",
    "snippet": "static void nlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host)\n{\n\tfl->fl_u.nfs_fl.state = 0;\n\tfl->fl_u.nfs_fl.owner = nlm_find_lockowner(host, fl->fl_owner);\n\tINIT_LIST_HEAD(&fl->fl_u.nfs_fl.list);\n\tfl->fl_ops = &nlmclnt_lock_ops;\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);",
      "static int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);",
      "static int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);",
      "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);",
      "static int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);",
      "static const struct file_lock_operations nlmclnt_lock_ops = {\n\t.fl_copy_lock = nlmclnt_locks_copy_lock,\n\t.fl_release_private = nlmclnt_locks_release_private,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fl->fl_u.nfs_fl.list"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_find_lockowner",
          "args": [
            "host",
            "fl->fl_owner"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_find_lockowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "95-119",
          "snippet": "static struct nlm_lockowner *nlm_find_lockowner(struct nlm_host *host, fl_owner_t owner)\n{\n\tstruct nlm_lockowner *res, *new = NULL;\n\n\tspin_lock(&host->h_lock);\n\tres = __nlm_find_lockowner(host, owner);\n\tif (res == NULL) {\n\t\tspin_unlock(&host->h_lock);\n\t\tnew = kmalloc(sizeof(*new), GFP_KERNEL);\n\t\tspin_lock(&host->h_lock);\n\t\tres = __nlm_find_lockowner(host, owner);\n\t\tif (res == NULL && new != NULL) {\n\t\t\tres = new;\n\t\t\tatomic_set(&new->count, 1);\n\t\t\tnew->owner = owner;\n\t\t\tnew->pid = __nlm_alloc_pid(host);\n\t\t\tnew->host = nlm_get_host(host);\n\t\t\tlist_add(&new->list, &host->h_lockowners);\n\t\t\tnew = NULL;\n\t\t}\n\t}\n\tspin_unlock(&host->h_lock);\n\tkfree(new);\n\treturn res;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\n\nstatic struct nlm_lockowner *nlm_find_lockowner(struct nlm_host *host, fl_owner_t owner)\n{\n\tstruct nlm_lockowner *res, *new = NULL;\n\n\tspin_lock(&host->h_lock);\n\tres = __nlm_find_lockowner(host, owner);\n\tif (res == NULL) {\n\t\tspin_unlock(&host->h_lock);\n\t\tnew = kmalloc(sizeof(*new), GFP_KERNEL);\n\t\tspin_lock(&host->h_lock);\n\t\tres = __nlm_find_lockowner(host, owner);\n\t\tif (res == NULL && new != NULL) {\n\t\t\tres = new;\n\t\t\tatomic_set(&new->count, 1);\n\t\t\tnew->owner = owner;\n\t\t\tnew->pid = __nlm_alloc_pid(host);\n\t\t\tnew->host = nlm_get_host(host);\n\t\t\tlist_add(&new->list, &host->h_lockowners);\n\t\t\tnew = NULL;\n\t\t}\n\t}\n\tspin_unlock(&host->h_lock);\n\tkfree(new);\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\nstatic int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);\nstatic const struct file_lock_operations nlmclnt_lock_ops = {\n\t.fl_copy_lock = nlmclnt_locks_copy_lock,\n\t.fl_release_private = nlmclnt_locks_release_private,\n};\n\nstatic void nlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host)\n{\n\tfl->fl_u.nfs_fl.state = 0;\n\tfl->fl_u.nfs_fl.owner = nlm_find_lockowner(host, fl->fl_owner);\n\tINIT_LIST_HEAD(&fl->fl_u.nfs_fl.list);\n\tfl->fl_ops = &nlmclnt_lock_ops;\n}"
  },
  {
    "function_name": "nlmclnt_locks_release_private",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "454-460",
    "snippet": "static void nlmclnt_locks_release_private(struct file_lock *fl)\n{\n\tspin_lock(&fl->fl_u.nfs_fl.owner->host->h_lock);\n\tlist_del(&fl->fl_u.nfs_fl.list);\n\tspin_unlock(&fl->fl_u.nfs_fl.owner->host->h_lock);\n\tnlm_put_lockowner(fl->fl_u.nfs_fl.owner);\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);",
      "static int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);",
      "static int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);",
      "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);",
      "static int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlm_put_lockowner",
          "args": [
            "fl->fl_u.nfs_fl.owner"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_put_lockowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "55-63",
          "snippet": "static void nlm_put_lockowner(struct nlm_lockowner *lockowner)\n{\n\tif (!atomic_dec_and_lock(&lockowner->count, &lockowner->host->h_lock))\n\t\treturn;\n\tlist_del(&lockowner->list);\n\tspin_unlock(&lockowner->host->h_lock);\n\tnlmclnt_release_host(lockowner->host);\n\tkfree(lockowner);\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\n\nstatic void nlm_put_lockowner(struct nlm_lockowner *lockowner)\n{\n\tif (!atomic_dec_and_lock(&lockowner->count, &lockowner->host->h_lock))\n\t\treturn;\n\tlist_del(&lockowner->list);\n\tspin_unlock(&lockowner->host->h_lock);\n\tnlmclnt_release_host(lockowner->host);\n\tkfree(lockowner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fl->fl_u.nfs_fl.owner->host->h_lock"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&fl->fl_u.nfs_fl.list"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fl->fl_u.nfs_fl.owner->host->h_lock"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\nstatic int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);\n\nstatic void nlmclnt_locks_release_private(struct file_lock *fl)\n{\n\tspin_lock(&fl->fl_u.nfs_fl.owner->host->h_lock);\n\tlist_del(&fl->fl_u.nfs_fl.list);\n\tspin_unlock(&fl->fl_u.nfs_fl.owner->host->h_lock);\n\tnlm_put_lockowner(fl->fl_u.nfs_fl.owner);\n}"
  },
  {
    "function_name": "nlmclnt_locks_copy_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "445-452",
    "snippet": "static void nlmclnt_locks_copy_lock(struct file_lock *new, struct file_lock *fl)\n{\n\tspin_lock(&fl->fl_u.nfs_fl.owner->host->h_lock);\n\tnew->fl_u.nfs_fl.state = fl->fl_u.nfs_fl.state;\n\tnew->fl_u.nfs_fl.owner = nlm_get_lockowner(fl->fl_u.nfs_fl.owner);\n\tlist_add_tail(&new->fl_u.nfs_fl.list, &fl->fl_u.nfs_fl.owner->host->h_granted);\n\tspin_unlock(&fl->fl_u.nfs_fl.owner->host->h_lock);\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);",
      "static int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);",
      "static int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);",
      "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);",
      "static int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fl->fl_u.nfs_fl.owner->host->h_lock"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&new->fl_u.nfs_fl.list",
            "&fl->fl_u.nfs_fl.owner->host->h_granted"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_get_lockowner",
          "args": [
            "fl->fl_u.nfs_fl.owner"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_get_lockowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "49-53",
          "snippet": "static struct nlm_lockowner *nlm_get_lockowner(struct nlm_lockowner *lockowner)\n{\n\tatomic_inc(&lockowner->count);\n\treturn lockowner;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic struct nlm_lockowner *nlm_get_lockowner(struct nlm_lockowner *lockowner)\n{\n\tatomic_inc(&lockowner->count);\n\treturn lockowner;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fl->fl_u.nfs_fl.owner->host->h_lock"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\nstatic int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);\n\nstatic void nlmclnt_locks_copy_lock(struct file_lock *new, struct file_lock *fl)\n{\n\tspin_lock(&fl->fl_u.nfs_fl.owner->host->h_lock);\n\tnew->fl_u.nfs_fl.state = fl->fl_u.nfs_fl.state;\n\tnew->fl_u.nfs_fl.owner = nlm_get_lockowner(fl->fl_u.nfs_fl.owner);\n\tlist_add_tail(&new->fl_u.nfs_fl.list, &fl->fl_u.nfs_fl.owner->host->h_granted);\n\tspin_unlock(&fl->fl_u.nfs_fl.owner->host->h_lock);\n}"
  },
  {
    "function_name": "nlmclnt_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "415-443",
    "snippet": "static int\nnlmclnt_test(struct nlm_rqst *req, struct file_lock *fl)\n{\n\tint\tstatus;\n\n\tstatus = nlmclnt_call(nfs_file_cred(fl->fl_file), req, NLMPROC_TEST);\n\tif (status < 0)\n\t\tgoto out;\n\n\tswitch (req->a_res.status) {\n\t\tcase nlm_granted:\n\t\t\tfl->fl_type = F_UNLCK;\n\t\t\tbreak;\n\t\tcase nlm_lck_denied:\n\t\t\t/*\n\t\t\t * Report the conflicting lock back to the application.\n\t\t\t */\n\t\t\tfl->fl_start = req->a_res.lock.fl.fl_start;\n\t\t\tfl->fl_end = req->a_res.lock.fl.fl_end;\n\t\t\tfl->fl_type = req->a_res.lock.fl.fl_type;\n\t\t\tfl->fl_pid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = nlm_stat_to_errno(req->a_res.status);\n\t}\nout:\n\tnlmclnt_release_call(req);\n\treturn status;\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);",
      "static int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);",
      "static int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);",
      "static int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmclnt_release_call",
          "args": [
            "req"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_release_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "215-222",
          "snippet": "void nlmclnt_release_call(struct nlm_rqst *call)\n{\n\tif (!atomic_dec_and_test(&call->a_count))\n\t\treturn;\n\tnlmclnt_release_host(call->a_host);\n\tnlmclnt_release_lockargs(call);\n\tkfree(call);\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid nlmclnt_release_call(struct nlm_rqst *call)\n{\n\tif (!atomic_dec_and_test(&call->a_count))\n\t\treturn;\n\tnlmclnt_release_host(call->a_host);\n\tnlmclnt_release_lockargs(call);\n\tkfree(call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlm_stat_to_errno",
          "args": [
            "req->a_res.status"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_stat_to_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "819-849",
          "snippet": "static int\nnlm_stat_to_errno(__be32 status)\n{\n\tswitch(ntohl(status)) {\n\tcase NLM_LCK_GRANTED:\n\t\treturn 0;\n\tcase NLM_LCK_DENIED:\n\t\treturn -EAGAIN;\n\tcase NLM_LCK_DENIED_NOLOCKS:\n\tcase NLM_LCK_DENIED_GRACE_PERIOD:\n\t\treturn -ENOLCK;\n\tcase NLM_LCK_BLOCKED:\n\t\tprintk(KERN_NOTICE \"lockd: unexpected status NLM_BLOCKED\\n\");\n\t\treturn -ENOLCK;\n#ifdef CONFIG_LOCKD_V4\n\tcase NLM_DEADLCK:\n\t\treturn -EDEADLK;\n\tcase NLM_ROFS:\n\t\treturn -EROFS;\n\tcase NLM_STALE_FH:\n\t\treturn -ESTALE;\n\tcase NLM_FBIG:\n\t\treturn -EOVERFLOW;\n\tcase NLM_FAILED:\n\t\treturn -ENOLCK;\n#endif\n\t}\n\tprintk(KERN_NOTICE \"lockd: unexpected server status %d\\n\",\n\t\t ntohl(status));\n\treturn -ENOLCK;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int\nnlm_stat_to_errno(__be32 status)\n{\n\tswitch(ntohl(status)) {\n\tcase NLM_LCK_GRANTED:\n\t\treturn 0;\n\tcase NLM_LCK_DENIED:\n\t\treturn -EAGAIN;\n\tcase NLM_LCK_DENIED_NOLOCKS:\n\tcase NLM_LCK_DENIED_GRACE_PERIOD:\n\t\treturn -ENOLCK;\n\tcase NLM_LCK_BLOCKED:\n\t\tprintk(KERN_NOTICE \"lockd: unexpected status NLM_BLOCKED\\n\");\n\t\treturn -ENOLCK;\n#ifdef CONFIG_LOCKD_V4\n\tcase NLM_DEADLCK:\n\t\treturn -EDEADLK;\n\tcase NLM_ROFS:\n\t\treturn -EROFS;\n\tcase NLM_STALE_FH:\n\t\treturn -ESTALE;\n\tcase NLM_FBIG:\n\t\treturn -EOVERFLOW;\n\tcase NLM_FAILED:\n\t\treturn -ENOLCK;\n#endif\n\t}\n\tprintk(KERN_NOTICE \"lockd: unexpected server status %d\\n\",\n\t\t ntohl(status));\n\treturn -ENOLCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmclnt_call",
          "args": [
            "nfs_file_cred(fl->fl_file)",
            "req",
            "NLMPROC_TEST"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "248-322",
          "snippet": "static int\nnlmclnt_call(struct rpc_cred *cred, struct nlm_rqst *req, u32 proc)\n{\n\tstruct nlm_host\t*host = req->a_host;\n\tstruct rpc_clnt\t*clnt;\n\tstruct nlm_args\t*argp = &req->a_args;\n\tstruct nlm_res\t*resp = &req->a_res;\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= argp,\n\t\t.rpc_resp\t= resp,\n\t\t.rpc_cred\t= cred,\n\t};\n\tint\t\tstatus;\n\n\tdprintk(\"lockd: call procedure %d on %s\\n\",\n\t\t\t(int)proc, host->h_name);\n\n\tdo {\n\t\tif (host->h_reclaiming && !argp->reclaim)\n\t\t\tgoto in_grace_period;\n\n\t\t/* If we have no RPC client yet, create one. */\n\t\tif ((clnt = nlm_bind_host(host)) == NULL)\n\t\t\treturn -ENOLCK;\n\t\tmsg.rpc_proc = &clnt->cl_procinfo[proc];\n\n\t\t/* Perform the RPC call. If an error occurs, try again */\n\t\tif ((status = rpc_call_sync(clnt, &msg, 0)) < 0) {\n\t\t\tdprintk(\"lockd: rpc_call returned error %d\\n\", -status);\n\t\t\tswitch (status) {\n\t\t\tcase -EPROTONOSUPPORT:\n\t\t\t\tstatus = -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase -ECONNREFUSED:\n\t\t\tcase -ETIMEDOUT:\n\t\t\tcase -ENOTCONN:\n\t\t\t\tnlm_rebind_host(host);\n\t\t\t\tstatus = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\tcase -ERESTARTSYS:\n\t\t\t\treturn signalled () ? -EINTR : status;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else\n\t\tif (resp->status == nlm_lck_denied_grace_period) {\n\t\t\tdprintk(\"lockd: server in grace period\\n\");\n\t\t\tif (argp->reclaim) {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t     \"lockd: spurious grace period reject?!\\n\");\n\t\t\t\treturn -ENOLCK;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!argp->reclaim) {\n\t\t\t\t/* We appear to be out of the grace period */\n\t\t\t\twake_up_all(&host->h_gracewait);\n\t\t\t}\n\t\t\tdprintk(\"lockd: server returns status %d\\n\",\n\t\t\t\tntohl(resp->status));\n\t\t\treturn 0;\t/* Okay, call complete */\n\t\t}\n\nin_grace_period:\n\t\t/*\n\t\t * The server has rebooted and appears to be in the grace\n\t\t * period during which locks are only allowed to be\n\t\t * reclaimed.\n\t\t * We can only back off and try again later.\n\t\t */\n\t\tstatus = nlm_wait_on_grace(&host->h_gracewait);\n\t} while (status == 0);\n\n\treturn status;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\n\nstatic int\nnlmclnt_call(struct rpc_cred *cred, struct nlm_rqst *req, u32 proc)\n{\n\tstruct nlm_host\t*host = req->a_host;\n\tstruct rpc_clnt\t*clnt;\n\tstruct nlm_args\t*argp = &req->a_args;\n\tstruct nlm_res\t*resp = &req->a_res;\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= argp,\n\t\t.rpc_resp\t= resp,\n\t\t.rpc_cred\t= cred,\n\t};\n\tint\t\tstatus;\n\n\tdprintk(\"lockd: call procedure %d on %s\\n\",\n\t\t\t(int)proc, host->h_name);\n\n\tdo {\n\t\tif (host->h_reclaiming && !argp->reclaim)\n\t\t\tgoto in_grace_period;\n\n\t\t/* If we have no RPC client yet, create one. */\n\t\tif ((clnt = nlm_bind_host(host)) == NULL)\n\t\t\treturn -ENOLCK;\n\t\tmsg.rpc_proc = &clnt->cl_procinfo[proc];\n\n\t\t/* Perform the RPC call. If an error occurs, try again */\n\t\tif ((status = rpc_call_sync(clnt, &msg, 0)) < 0) {\n\t\t\tdprintk(\"lockd: rpc_call returned error %d\\n\", -status);\n\t\t\tswitch (status) {\n\t\t\tcase -EPROTONOSUPPORT:\n\t\t\t\tstatus = -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase -ECONNREFUSED:\n\t\t\tcase -ETIMEDOUT:\n\t\t\tcase -ENOTCONN:\n\t\t\t\tnlm_rebind_host(host);\n\t\t\t\tstatus = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\tcase -ERESTARTSYS:\n\t\t\t\treturn signalled () ? -EINTR : status;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else\n\t\tif (resp->status == nlm_lck_denied_grace_period) {\n\t\t\tdprintk(\"lockd: server in grace period\\n\");\n\t\t\tif (argp->reclaim) {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t     \"lockd: spurious grace period reject?!\\n\");\n\t\t\t\treturn -ENOLCK;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!argp->reclaim) {\n\t\t\t\t/* We appear to be out of the grace period */\n\t\t\t\twake_up_all(&host->h_gracewait);\n\t\t\t}\n\t\t\tdprintk(\"lockd: server returns status %d\\n\",\n\t\t\t\tntohl(resp->status));\n\t\t\treturn 0;\t/* Okay, call complete */\n\t\t}\n\nin_grace_period:\n\t\t/*\n\t\t * The server has rebooted and appears to be in the grace\n\t\t * period during which locks are only allowed to be\n\t\t * reclaimed.\n\t\t * We can only back off and try again later.\n\t\t */\n\t\tstatus = nlm_wait_on_grace(&host->h_gracewait);\n\t} while (status == 0);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_file_cred",
          "args": [
            "fl->fl_file"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);\n\nstatic int\nnlmclnt_test(struct nlm_rqst *req, struct file_lock *fl)\n{\n\tint\tstatus;\n\n\tstatus = nlmclnt_call(nfs_file_cred(fl->fl_file), req, NLMPROC_TEST);\n\tif (status < 0)\n\t\tgoto out;\n\n\tswitch (req->a_res.status) {\n\t\tcase nlm_granted:\n\t\t\tfl->fl_type = F_UNLCK;\n\t\t\tbreak;\n\t\tcase nlm_lck_denied:\n\t\t\t/*\n\t\t\t * Report the conflicting lock back to the application.\n\t\t\t */\n\t\t\tfl->fl_start = req->a_res.lock.fl.fl_start;\n\t\t\tfl->fl_end = req->a_res.lock.fl.fl_end;\n\t\t\tfl->fl_type = req->a_res.lock.fl.fl_type;\n\t\t\tfl->fl_pid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = nlm_stat_to_errno(req->a_res.status);\n\t}\nout:\n\tnlmclnt_release_call(req);\n\treturn status;\n}"
  },
  {
    "function_name": "nlmclnt_async_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "394-410",
    "snippet": "static int nlmclnt_async_call(struct rpc_cred *cred, struct nlm_rqst *req, u32 proc, const struct rpc_call_ops *tk_ops)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &req->a_args,\n\t\t.rpc_resp\t= &req->a_res,\n\t\t.rpc_cred\t= cred,\n\t};\n\tstruct rpc_task *task;\n\tint err;\n\n\ttask = __nlm_async_call(req, proc, &msg, tk_ops);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\terr = rpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn err;\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_put_task",
          "args": [
            "task"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_wait_for_completion_task",
          "args": [
            "task"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "task"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "task"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__nlm_async_call",
          "args": [
            "req",
            "proc",
            "&msg",
            "tk_ops"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "__nlm_async_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "327-353",
          "snippet": "static struct rpc_task *__nlm_async_call(struct nlm_rqst *req, u32 proc, struct rpc_message *msg, const struct rpc_call_ops *tk_ops)\n{\n\tstruct nlm_host\t*host = req->a_host;\n\tstruct rpc_clnt\t*clnt;\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_message = msg,\n\t\t.callback_ops = tk_ops,\n\t\t.callback_data = req,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\n\tdprintk(\"lockd: call procedure %d on %s (async)\\n\",\n\t\t\t(int)proc, host->h_name);\n\n\t/* If we have no RPC client yet, create one. */\n\tclnt = nlm_bind_host(host);\n\tif (clnt == NULL)\n\t\tgoto out_err;\n\tmsg->rpc_proc = &clnt->cl_procinfo[proc];\n\ttask_setup_data.rpc_client = clnt;\n\n        /* bootstrap and kick off the async RPC call */\n\treturn rpc_run_task(&task_setup_data);\nout_err:\n\ttk_ops->rpc_release(req);\n\treturn ERR_PTR(-ENOLCK);\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\n\nstatic struct rpc_task *__nlm_async_call(struct nlm_rqst *req, u32 proc, struct rpc_message *msg, const struct rpc_call_ops *tk_ops)\n{\n\tstruct nlm_host\t*host = req->a_host;\n\tstruct rpc_clnt\t*clnt;\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_message = msg,\n\t\t.callback_ops = tk_ops,\n\t\t.callback_data = req,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\n\tdprintk(\"lockd: call procedure %d on %s (async)\\n\",\n\t\t\t(int)proc, host->h_name);\n\n\t/* If we have no RPC client yet, create one. */\n\tclnt = nlm_bind_host(host);\n\tif (clnt == NULL)\n\t\tgoto out_err;\n\tmsg->rpc_proc = &clnt->cl_procinfo[proc];\n\ttask_setup_data.rpc_client = clnt;\n\n        /* bootstrap and kick off the async RPC call */\n\treturn rpc_run_task(&task_setup_data);\nout_err:\n\ttk_ops->rpc_release(req);\n\treturn ERR_PTR(-ENOLCK);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int nlmclnt_async_call(struct rpc_cred *cred, struct nlm_rqst *req, u32 proc, const struct rpc_call_ops *tk_ops)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &req->a_args,\n\t\t.rpc_resp\t= &req->a_res,\n\t\t.rpc_cred\t= cred,\n\t};\n\tstruct rpc_task *task;\n\tint err;\n\n\ttask = __nlm_async_call(req, proc, &msg, tk_ops);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\terr = rpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn err;\n}"
  },
  {
    "function_name": "nlm_async_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "378-384",
    "snippet": "int nlm_async_reply(struct nlm_rqst *req, u32 proc, const struct rpc_call_ops *tk_ops)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &req->a_res,\n\t};\n\treturn nlm_do_async_call(req, proc, &msg, tk_ops);\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlm_do_async_call",
          "args": [
            "req",
            "proc",
            "&msg",
            "tk_ops"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_do_async_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "355-364",
          "snippet": "static int nlm_do_async_call(struct nlm_rqst *req, u32 proc, struct rpc_message *msg, const struct rpc_call_ops *tk_ops)\n{\n\tstruct rpc_task *task;\n\n\ttask = __nlm_async_call(req, proc, msg, tk_ops);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\trpc_put_task(task);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int nlm_do_async_call(struct nlm_rqst *req, u32 proc, struct rpc_message *msg, const struct rpc_call_ops *tk_ops)\n{\n\tstruct rpc_task *task;\n\n\ttask = __nlm_async_call(req, proc, msg, tk_ops);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\trpc_put_task(task);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint nlm_async_reply(struct nlm_rqst *req, u32 proc, const struct rpc_call_ops *tk_ops)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &req->a_res,\n\t};\n\treturn nlm_do_async_call(req, proc, &msg, tk_ops);\n}"
  },
  {
    "function_name": "nlm_async_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "369-376",
    "snippet": "int nlm_async_call(struct nlm_rqst *req, u32 proc, const struct rpc_call_ops *tk_ops)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &req->a_args,\n\t\t.rpc_resp\t= &req->a_res,\n\t};\n\treturn nlm_do_async_call(req, proc, &msg, tk_ops);\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlm_do_async_call",
          "args": [
            "req",
            "proc",
            "&msg",
            "tk_ops"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_do_async_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "355-364",
          "snippet": "static int nlm_do_async_call(struct nlm_rqst *req, u32 proc, struct rpc_message *msg, const struct rpc_call_ops *tk_ops)\n{\n\tstruct rpc_task *task;\n\n\ttask = __nlm_async_call(req, proc, msg, tk_ops);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\trpc_put_task(task);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int nlm_do_async_call(struct nlm_rqst *req, u32 proc, struct rpc_message *msg, const struct rpc_call_ops *tk_ops)\n{\n\tstruct rpc_task *task;\n\n\ttask = __nlm_async_call(req, proc, msg, tk_ops);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\trpc_put_task(task);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint nlm_async_call(struct nlm_rqst *req, u32 proc, const struct rpc_call_ops *tk_ops)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &req->a_args,\n\t\t.rpc_resp\t= &req->a_res,\n\t};\n\treturn nlm_do_async_call(req, proc, &msg, tk_ops);\n}"
  },
  {
    "function_name": "nlm_do_async_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "355-364",
    "snippet": "static int nlm_do_async_call(struct nlm_rqst *req, u32 proc, struct rpc_message *msg, const struct rpc_call_ops *tk_ops)\n{\n\tstruct rpc_task *task;\n\n\ttask = __nlm_async_call(req, proc, msg, tk_ops);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\trpc_put_task(task);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_put_task",
          "args": [
            "task"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "task"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "task"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__nlm_async_call",
          "args": [
            "req",
            "proc",
            "msg",
            "tk_ops"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "__nlm_async_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "327-353",
          "snippet": "static struct rpc_task *__nlm_async_call(struct nlm_rqst *req, u32 proc, struct rpc_message *msg, const struct rpc_call_ops *tk_ops)\n{\n\tstruct nlm_host\t*host = req->a_host;\n\tstruct rpc_clnt\t*clnt;\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_message = msg,\n\t\t.callback_ops = tk_ops,\n\t\t.callback_data = req,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\n\tdprintk(\"lockd: call procedure %d on %s (async)\\n\",\n\t\t\t(int)proc, host->h_name);\n\n\t/* If we have no RPC client yet, create one. */\n\tclnt = nlm_bind_host(host);\n\tif (clnt == NULL)\n\t\tgoto out_err;\n\tmsg->rpc_proc = &clnt->cl_procinfo[proc];\n\ttask_setup_data.rpc_client = clnt;\n\n        /* bootstrap and kick off the async RPC call */\n\treturn rpc_run_task(&task_setup_data);\nout_err:\n\ttk_ops->rpc_release(req);\n\treturn ERR_PTR(-ENOLCK);\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\n\nstatic struct rpc_task *__nlm_async_call(struct nlm_rqst *req, u32 proc, struct rpc_message *msg, const struct rpc_call_ops *tk_ops)\n{\n\tstruct nlm_host\t*host = req->a_host;\n\tstruct rpc_clnt\t*clnt;\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_message = msg,\n\t\t.callback_ops = tk_ops,\n\t\t.callback_data = req,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\n\tdprintk(\"lockd: call procedure %d on %s (async)\\n\",\n\t\t\t(int)proc, host->h_name);\n\n\t/* If we have no RPC client yet, create one. */\n\tclnt = nlm_bind_host(host);\n\tif (clnt == NULL)\n\t\tgoto out_err;\n\tmsg->rpc_proc = &clnt->cl_procinfo[proc];\n\ttask_setup_data.rpc_client = clnt;\n\n        /* bootstrap and kick off the async RPC call */\n\treturn rpc_run_task(&task_setup_data);\nout_err:\n\ttk_ops->rpc_release(req);\n\treturn ERR_PTR(-ENOLCK);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int nlm_do_async_call(struct nlm_rqst *req, u32 proc, struct rpc_message *msg, const struct rpc_call_ops *tk_ops)\n{\n\tstruct rpc_task *task;\n\n\ttask = __nlm_async_call(req, proc, msg, tk_ops);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\trpc_put_task(task);\n\treturn 0;\n}"
  },
  {
    "function_name": "__nlm_async_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "327-353",
    "snippet": "static struct rpc_task *__nlm_async_call(struct nlm_rqst *req, u32 proc, struct rpc_message *msg, const struct rpc_call_ops *tk_ops)\n{\n\tstruct nlm_host\t*host = req->a_host;\n\tstruct rpc_clnt\t*clnt;\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_message = msg,\n\t\t.callback_ops = tk_ops,\n\t\t.callback_data = req,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\n\tdprintk(\"lockd: call procedure %d on %s (async)\\n\",\n\t\t\t(int)proc, host->h_name);\n\n\t/* If we have no RPC client yet, create one. */\n\tclnt = nlm_bind_host(host);\n\tif (clnt == NULL)\n\t\tgoto out_err;\n\tmsg->rpc_proc = &clnt->cl_procinfo[proc];\n\ttask_setup_data.rpc_client = clnt;\n\n        /* bootstrap and kick off the async RPC call */\n\treturn rpc_run_task(&task_setup_data);\nout_err:\n\ttk_ops->rpc_release(req);\n\treturn ERR_PTR(-ENOLCK);\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOLCK"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tk_ops->rpc_release",
          "args": [
            "req"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_run_task",
          "args": [
            "&task_setup_data"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_bind_host",
          "args": [
            "host"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_bind_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "417-483",
          "snippet": "struct rpc_clnt *\nnlm_bind_host(struct nlm_host *host)\n{\n\tstruct rpc_clnt\t*clnt;\n\n\tdprintk(\"lockd: nlm_bind_host %s (%s)\\n\",\n\t\t\thost->h_name, host->h_addrbuf);\n\n\t/* Lock host handle */\n\tmutex_lock(&host->h_mutex);\n\n\t/* If we've already created an RPC client, check whether\n\t * RPC rebind is required\n\t */\n\tif ((clnt = host->h_rpcclnt) != NULL) {\n\t\tif (time_after_eq(jiffies, host->h_nextrebind)) {\n\t\t\trpc_force_rebind(clnt);\n\t\t\thost->h_nextrebind = jiffies + NLM_HOST_REBIND;\n\t\t\tdprintk(\"lockd: next rebind in %lu jiffies\\n\",\n\t\t\t\t\thost->h_nextrebind - jiffies);\n\t\t}\n\t} else {\n\t\tunsigned long increment = nlmsvc_timeout;\n\t\tstruct rpc_timeout timeparms = {\n\t\t\t.to_initval\t= increment,\n\t\t\t.to_increment\t= increment,\n\t\t\t.to_maxval\t= increment * 6UL,\n\t\t\t.to_retries\t= 5U,\n\t\t};\n\t\tstruct rpc_create_args args = {\n\t\t\t.net\t\t= host->net,\n\t\t\t.protocol\t= host->h_proto,\n\t\t\t.address\t= nlm_addr(host),\n\t\t\t.addrsize\t= host->h_addrlen,\n\t\t\t.timeout\t= &timeparms,\n\t\t\t.servername\t= host->h_name,\n\t\t\t.program\t= &nlm_program,\n\t\t\t.version\t= host->h_version,\n\t\t\t.authflavor\t= RPC_AUTH_UNIX,\n\t\t\t.flags\t\t= (RPC_CLNT_CREATE_NOPING |\n\t\t\t\t\t   RPC_CLNT_CREATE_AUTOBIND),\n\t\t};\n\n\t\t/*\n\t\t * lockd retries server side blocks automatically so we want\n\t\t * those to be soft RPC calls. Client side calls need to be\n\t\t * hard RPC tasks.\n\t\t */\n\t\tif (!host->h_server)\n\t\t\targs.flags |= RPC_CLNT_CREATE_HARDRTRY;\n\t\tif (host->h_noresvport)\n\t\t\targs.flags |= RPC_CLNT_CREATE_NONPRIVPORT;\n\t\tif (host->h_srcaddrlen)\n\t\t\targs.saddress = nlm_srcaddr(host);\n\n\t\tclnt = rpc_create(&args);\n\t\tif (!IS_ERR(clnt))\n\t\t\thost->h_rpcclnt = clnt;\n\t\telse {\n\t\t\tprintk(\"lockd: couldn't create RPC handle for %s\\n\", host->h_name);\n\t\t\tclnt = NULL;\n\t\t}\n\t}\n\n\tmutex_unlock(&host->h_mutex);\n\treturn clnt;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NLM_HOST_REBIND\t\t(60 * HZ)"
          ],
          "globals_used": [
            "static void\t\t\tnlm_gc_hosts(struct net *net);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NLM_HOST_REBIND\t\t(60 * HZ)\n\nstatic void\t\t\tnlm_gc_hosts(struct net *net);\n\nstruct rpc_clnt *\nnlm_bind_host(struct nlm_host *host)\n{\n\tstruct rpc_clnt\t*clnt;\n\n\tdprintk(\"lockd: nlm_bind_host %s (%s)\\n\",\n\t\t\thost->h_name, host->h_addrbuf);\n\n\t/* Lock host handle */\n\tmutex_lock(&host->h_mutex);\n\n\t/* If we've already created an RPC client, check whether\n\t * RPC rebind is required\n\t */\n\tif ((clnt = host->h_rpcclnt) != NULL) {\n\t\tif (time_after_eq(jiffies, host->h_nextrebind)) {\n\t\t\trpc_force_rebind(clnt);\n\t\t\thost->h_nextrebind = jiffies + NLM_HOST_REBIND;\n\t\t\tdprintk(\"lockd: next rebind in %lu jiffies\\n\",\n\t\t\t\t\thost->h_nextrebind - jiffies);\n\t\t}\n\t} else {\n\t\tunsigned long increment = nlmsvc_timeout;\n\t\tstruct rpc_timeout timeparms = {\n\t\t\t.to_initval\t= increment,\n\t\t\t.to_increment\t= increment,\n\t\t\t.to_maxval\t= increment * 6UL,\n\t\t\t.to_retries\t= 5U,\n\t\t};\n\t\tstruct rpc_create_args args = {\n\t\t\t.net\t\t= host->net,\n\t\t\t.protocol\t= host->h_proto,\n\t\t\t.address\t= nlm_addr(host),\n\t\t\t.addrsize\t= host->h_addrlen,\n\t\t\t.timeout\t= &timeparms,\n\t\t\t.servername\t= host->h_name,\n\t\t\t.program\t= &nlm_program,\n\t\t\t.version\t= host->h_version,\n\t\t\t.authflavor\t= RPC_AUTH_UNIX,\n\t\t\t.flags\t\t= (RPC_CLNT_CREATE_NOPING |\n\t\t\t\t\t   RPC_CLNT_CREATE_AUTOBIND),\n\t\t};\n\n\t\t/*\n\t\t * lockd retries server side blocks automatically so we want\n\t\t * those to be soft RPC calls. Client side calls need to be\n\t\t * hard RPC tasks.\n\t\t */\n\t\tif (!host->h_server)\n\t\t\targs.flags |= RPC_CLNT_CREATE_HARDRTRY;\n\t\tif (host->h_noresvport)\n\t\t\targs.flags |= RPC_CLNT_CREATE_NONPRIVPORT;\n\t\tif (host->h_srcaddrlen)\n\t\t\targs.saddress = nlm_srcaddr(host);\n\n\t\tclnt = rpc_create(&args);\n\t\tif (!IS_ERR(clnt))\n\t\t\thost->h_rpcclnt = clnt;\n\t\telse {\n\t\t\tprintk(\"lockd: couldn't create RPC handle for %s\\n\", host->h_name);\n\t\t\tclnt = NULL;\n\t\t}\n\t}\n\n\tmutex_unlock(&host->h_mutex);\n\treturn clnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: call procedure %d on %s (async)\\n\"",
            "(int)proc",
            "host->h_name"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\n\nstatic struct rpc_task *__nlm_async_call(struct nlm_rqst *req, u32 proc, struct rpc_message *msg, const struct rpc_call_ops *tk_ops)\n{\n\tstruct nlm_host\t*host = req->a_host;\n\tstruct rpc_clnt\t*clnt;\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_message = msg,\n\t\t.callback_ops = tk_ops,\n\t\t.callback_data = req,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\n\tdprintk(\"lockd: call procedure %d on %s (async)\\n\",\n\t\t\t(int)proc, host->h_name);\n\n\t/* If we have no RPC client yet, create one. */\n\tclnt = nlm_bind_host(host);\n\tif (clnt == NULL)\n\t\tgoto out_err;\n\tmsg->rpc_proc = &clnt->cl_procinfo[proc];\n\ttask_setup_data.rpc_client = clnt;\n\n        /* bootstrap and kick off the async RPC call */\n\treturn rpc_run_task(&task_setup_data);\nout_err:\n\ttk_ops->rpc_release(req);\n\treturn ERR_PTR(-ENOLCK);\n}"
  },
  {
    "function_name": "nlmclnt_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "248-322",
    "snippet": "static int\nnlmclnt_call(struct rpc_cred *cred, struct nlm_rqst *req, u32 proc)\n{\n\tstruct nlm_host\t*host = req->a_host;\n\tstruct rpc_clnt\t*clnt;\n\tstruct nlm_args\t*argp = &req->a_args;\n\tstruct nlm_res\t*resp = &req->a_res;\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= argp,\n\t\t.rpc_resp\t= resp,\n\t\t.rpc_cred\t= cred,\n\t};\n\tint\t\tstatus;\n\n\tdprintk(\"lockd: call procedure %d on %s\\n\",\n\t\t\t(int)proc, host->h_name);\n\n\tdo {\n\t\tif (host->h_reclaiming && !argp->reclaim)\n\t\t\tgoto in_grace_period;\n\n\t\t/* If we have no RPC client yet, create one. */\n\t\tif ((clnt = nlm_bind_host(host)) == NULL)\n\t\t\treturn -ENOLCK;\n\t\tmsg.rpc_proc = &clnt->cl_procinfo[proc];\n\n\t\t/* Perform the RPC call. If an error occurs, try again */\n\t\tif ((status = rpc_call_sync(clnt, &msg, 0)) < 0) {\n\t\t\tdprintk(\"lockd: rpc_call returned error %d\\n\", -status);\n\t\t\tswitch (status) {\n\t\t\tcase -EPROTONOSUPPORT:\n\t\t\t\tstatus = -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase -ECONNREFUSED:\n\t\t\tcase -ETIMEDOUT:\n\t\t\tcase -ENOTCONN:\n\t\t\t\tnlm_rebind_host(host);\n\t\t\t\tstatus = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\tcase -ERESTARTSYS:\n\t\t\t\treturn signalled () ? -EINTR : status;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else\n\t\tif (resp->status == nlm_lck_denied_grace_period) {\n\t\t\tdprintk(\"lockd: server in grace period\\n\");\n\t\t\tif (argp->reclaim) {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t     \"lockd: spurious grace period reject?!\\n\");\n\t\t\t\treturn -ENOLCK;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!argp->reclaim) {\n\t\t\t\t/* We appear to be out of the grace period */\n\t\t\t\twake_up_all(&host->h_gracewait);\n\t\t\t}\n\t\t\tdprintk(\"lockd: server returns status %d\\n\",\n\t\t\t\tntohl(resp->status));\n\t\t\treturn 0;\t/* Okay, call complete */\n\t\t}\n\nin_grace_period:\n\t\t/*\n\t\t * The server has rebooted and appears to be in the grace\n\t\t * period during which locks are only allowed to be\n\t\t * reclaimed.\n\t\t * We can only back off and try again later.\n\t\t */\n\t\tstatus = nlm_wait_on_grace(&host->h_gracewait);\n\t} while (status == 0);\n\n\treturn status;\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlm_wait_on_grace",
          "args": [
            "&host->h_gracewait"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_wait_on_grace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "229-243",
          "snippet": "static int nlm_wait_on_grace(wait_queue_head_t *queue)\n{\n\tDEFINE_WAIT(wait);\n\tint status = -EINTR;\n\n\tprepare_to_wait(queue, &wait, TASK_INTERRUPTIBLE);\n\tif (!signalled ()) {\n\t\tschedule_timeout(NLMCLNT_GRACE_WAIT);\n\t\ttry_to_freeze();\n\t\tif (!signalled ())\n\t\t\tstatus = 0;\n\t}\n\tfinish_wait(queue, &wait);\n\treturn status;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define NLMCLNT_GRACE_WAIT\t(5*HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define NLMCLNT_GRACE_WAIT\t(5*HZ)\n\nstatic int nlm_wait_on_grace(wait_queue_head_t *queue)\n{\n\tDEFINE_WAIT(wait);\n\tint status = -EINTR;\n\n\tprepare_to_wait(queue, &wait, TASK_INTERRUPTIBLE);\n\tif (!signalled ()) {\n\t\tschedule_timeout(NLMCLNT_GRACE_WAIT);\n\t\ttry_to_freeze();\n\t\tif (!signalled ())\n\t\t\tstatus = 0;\n\t}\n\tfinish_wait(queue, &wait);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: server returns status %d\\n\"",
            "ntohl(resp->status)"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "resp->status"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&host->h_gracewait"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t\t\t     \"lockd: spurious grace period reject?!\\n\""
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: server in grace period\\n\""
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signalled",
          "args": [],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_rebind_host",
          "args": [
            "host"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_rebind_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "488-496",
          "snippet": "void\nnlm_rebind_host(struct nlm_host *host)\n{\n\tdprintk(\"lockd: rebind host %s\\n\", host->h_name);\n\tif (host->h_rpcclnt && time_after_eq(jiffies, host->h_nextrebind)) {\n\t\trpc_force_rebind(host->h_rpcclnt);\n\t\thost->h_nextrebind = jiffies + NLM_HOST_REBIND;\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NLM_HOST_REBIND\t\t(60 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NLM_HOST_REBIND\t\t(60 * HZ)\n\nvoid\nnlm_rebind_host(struct nlm_host *host)\n{\n\tdprintk(\"lockd: rebind host %s\\n\", host->h_name);\n\tif (host->h_rpcclnt && time_after_eq(jiffies, host->h_nextrebind)) {\n\t\trpc_force_rebind(host->h_rpcclnt);\n\t\thost->h_nextrebind = jiffies + NLM_HOST_REBIND;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: rpc_call returned error %d\\n\"",
            "-status"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_call_sync",
          "args": [
            "clnt",
            "&msg",
            "0"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_bind_host",
          "args": [
            "host"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_bind_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "417-483",
          "snippet": "struct rpc_clnt *\nnlm_bind_host(struct nlm_host *host)\n{\n\tstruct rpc_clnt\t*clnt;\n\n\tdprintk(\"lockd: nlm_bind_host %s (%s)\\n\",\n\t\t\thost->h_name, host->h_addrbuf);\n\n\t/* Lock host handle */\n\tmutex_lock(&host->h_mutex);\n\n\t/* If we've already created an RPC client, check whether\n\t * RPC rebind is required\n\t */\n\tif ((clnt = host->h_rpcclnt) != NULL) {\n\t\tif (time_after_eq(jiffies, host->h_nextrebind)) {\n\t\t\trpc_force_rebind(clnt);\n\t\t\thost->h_nextrebind = jiffies + NLM_HOST_REBIND;\n\t\t\tdprintk(\"lockd: next rebind in %lu jiffies\\n\",\n\t\t\t\t\thost->h_nextrebind - jiffies);\n\t\t}\n\t} else {\n\t\tunsigned long increment = nlmsvc_timeout;\n\t\tstruct rpc_timeout timeparms = {\n\t\t\t.to_initval\t= increment,\n\t\t\t.to_increment\t= increment,\n\t\t\t.to_maxval\t= increment * 6UL,\n\t\t\t.to_retries\t= 5U,\n\t\t};\n\t\tstruct rpc_create_args args = {\n\t\t\t.net\t\t= host->net,\n\t\t\t.protocol\t= host->h_proto,\n\t\t\t.address\t= nlm_addr(host),\n\t\t\t.addrsize\t= host->h_addrlen,\n\t\t\t.timeout\t= &timeparms,\n\t\t\t.servername\t= host->h_name,\n\t\t\t.program\t= &nlm_program,\n\t\t\t.version\t= host->h_version,\n\t\t\t.authflavor\t= RPC_AUTH_UNIX,\n\t\t\t.flags\t\t= (RPC_CLNT_CREATE_NOPING |\n\t\t\t\t\t   RPC_CLNT_CREATE_AUTOBIND),\n\t\t};\n\n\t\t/*\n\t\t * lockd retries server side blocks automatically so we want\n\t\t * those to be soft RPC calls. Client side calls need to be\n\t\t * hard RPC tasks.\n\t\t */\n\t\tif (!host->h_server)\n\t\t\targs.flags |= RPC_CLNT_CREATE_HARDRTRY;\n\t\tif (host->h_noresvport)\n\t\t\targs.flags |= RPC_CLNT_CREATE_NONPRIVPORT;\n\t\tif (host->h_srcaddrlen)\n\t\t\targs.saddress = nlm_srcaddr(host);\n\n\t\tclnt = rpc_create(&args);\n\t\tif (!IS_ERR(clnt))\n\t\t\thost->h_rpcclnt = clnt;\n\t\telse {\n\t\t\tprintk(\"lockd: couldn't create RPC handle for %s\\n\", host->h_name);\n\t\t\tclnt = NULL;\n\t\t}\n\t}\n\n\tmutex_unlock(&host->h_mutex);\n\treturn clnt;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NLM_HOST_REBIND\t\t(60 * HZ)"
          ],
          "globals_used": [
            "static void\t\t\tnlm_gc_hosts(struct net *net);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NLM_HOST_REBIND\t\t(60 * HZ)\n\nstatic void\t\t\tnlm_gc_hosts(struct net *net);\n\nstruct rpc_clnt *\nnlm_bind_host(struct nlm_host *host)\n{\n\tstruct rpc_clnt\t*clnt;\n\n\tdprintk(\"lockd: nlm_bind_host %s (%s)\\n\",\n\t\t\thost->h_name, host->h_addrbuf);\n\n\t/* Lock host handle */\n\tmutex_lock(&host->h_mutex);\n\n\t/* If we've already created an RPC client, check whether\n\t * RPC rebind is required\n\t */\n\tif ((clnt = host->h_rpcclnt) != NULL) {\n\t\tif (time_after_eq(jiffies, host->h_nextrebind)) {\n\t\t\trpc_force_rebind(clnt);\n\t\t\thost->h_nextrebind = jiffies + NLM_HOST_REBIND;\n\t\t\tdprintk(\"lockd: next rebind in %lu jiffies\\n\",\n\t\t\t\t\thost->h_nextrebind - jiffies);\n\t\t}\n\t} else {\n\t\tunsigned long increment = nlmsvc_timeout;\n\t\tstruct rpc_timeout timeparms = {\n\t\t\t.to_initval\t= increment,\n\t\t\t.to_increment\t= increment,\n\t\t\t.to_maxval\t= increment * 6UL,\n\t\t\t.to_retries\t= 5U,\n\t\t};\n\t\tstruct rpc_create_args args = {\n\t\t\t.net\t\t= host->net,\n\t\t\t.protocol\t= host->h_proto,\n\t\t\t.address\t= nlm_addr(host),\n\t\t\t.addrsize\t= host->h_addrlen,\n\t\t\t.timeout\t= &timeparms,\n\t\t\t.servername\t= host->h_name,\n\t\t\t.program\t= &nlm_program,\n\t\t\t.version\t= host->h_version,\n\t\t\t.authflavor\t= RPC_AUTH_UNIX,\n\t\t\t.flags\t\t= (RPC_CLNT_CREATE_NOPING |\n\t\t\t\t\t   RPC_CLNT_CREATE_AUTOBIND),\n\t\t};\n\n\t\t/*\n\t\t * lockd retries server side blocks automatically so we want\n\t\t * those to be soft RPC calls. Client side calls need to be\n\t\t * hard RPC tasks.\n\t\t */\n\t\tif (!host->h_server)\n\t\t\targs.flags |= RPC_CLNT_CREATE_HARDRTRY;\n\t\tif (host->h_noresvport)\n\t\t\targs.flags |= RPC_CLNT_CREATE_NONPRIVPORT;\n\t\tif (host->h_srcaddrlen)\n\t\t\targs.saddress = nlm_srcaddr(host);\n\n\t\tclnt = rpc_create(&args);\n\t\tif (!IS_ERR(clnt))\n\t\t\thost->h_rpcclnt = clnt;\n\t\telse {\n\t\t\tprintk(\"lockd: couldn't create RPC handle for %s\\n\", host->h_name);\n\t\t\tclnt = NULL;\n\t\t}\n\t}\n\n\tmutex_unlock(&host->h_mutex);\n\treturn clnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: call procedure %d on %s\\n\"",
            "(int)proc",
            "host->h_name"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\n\nstatic int\nnlmclnt_call(struct rpc_cred *cred, struct nlm_rqst *req, u32 proc)\n{\n\tstruct nlm_host\t*host = req->a_host;\n\tstruct rpc_clnt\t*clnt;\n\tstruct nlm_args\t*argp = &req->a_args;\n\tstruct nlm_res\t*resp = &req->a_res;\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= argp,\n\t\t.rpc_resp\t= resp,\n\t\t.rpc_cred\t= cred,\n\t};\n\tint\t\tstatus;\n\n\tdprintk(\"lockd: call procedure %d on %s\\n\",\n\t\t\t(int)proc, host->h_name);\n\n\tdo {\n\t\tif (host->h_reclaiming && !argp->reclaim)\n\t\t\tgoto in_grace_period;\n\n\t\t/* If we have no RPC client yet, create one. */\n\t\tif ((clnt = nlm_bind_host(host)) == NULL)\n\t\t\treturn -ENOLCK;\n\t\tmsg.rpc_proc = &clnt->cl_procinfo[proc];\n\n\t\t/* Perform the RPC call. If an error occurs, try again */\n\t\tif ((status = rpc_call_sync(clnt, &msg, 0)) < 0) {\n\t\t\tdprintk(\"lockd: rpc_call returned error %d\\n\", -status);\n\t\t\tswitch (status) {\n\t\t\tcase -EPROTONOSUPPORT:\n\t\t\t\tstatus = -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase -ECONNREFUSED:\n\t\t\tcase -ETIMEDOUT:\n\t\t\tcase -ENOTCONN:\n\t\t\t\tnlm_rebind_host(host);\n\t\t\t\tstatus = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\tcase -ERESTARTSYS:\n\t\t\t\treturn signalled () ? -EINTR : status;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else\n\t\tif (resp->status == nlm_lck_denied_grace_period) {\n\t\t\tdprintk(\"lockd: server in grace period\\n\");\n\t\t\tif (argp->reclaim) {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t     \"lockd: spurious grace period reject?!\\n\");\n\t\t\t\treturn -ENOLCK;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!argp->reclaim) {\n\t\t\t\t/* We appear to be out of the grace period */\n\t\t\t\twake_up_all(&host->h_gracewait);\n\t\t\t}\n\t\t\tdprintk(\"lockd: server returns status %d\\n\",\n\t\t\t\tntohl(resp->status));\n\t\t\treturn 0;\t/* Okay, call complete */\n\t\t}\n\nin_grace_period:\n\t\t/*\n\t\t * The server has rebooted and appears to be in the grace\n\t\t * period during which locks are only allowed to be\n\t\t * reclaimed.\n\t\t * We can only back off and try again later.\n\t\t */\n\t\tstatus = nlm_wait_on_grace(&host->h_gracewait);\n\t} while (status == 0);\n\n\treturn status;\n}"
  },
  {
    "function_name": "nlm_wait_on_grace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "229-243",
    "snippet": "static int nlm_wait_on_grace(wait_queue_head_t *queue)\n{\n\tDEFINE_WAIT(wait);\n\tint status = -EINTR;\n\n\tprepare_to_wait(queue, &wait, TASK_INTERRUPTIBLE);\n\tif (!signalled ()) {\n\t\tschedule_timeout(NLMCLNT_GRACE_WAIT);\n\t\ttry_to_freeze();\n\t\tif (!signalled ())\n\t\t\tstatus = 0;\n\t}\n\tfinish_wait(queue, &wait);\n\treturn status;\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define NLMCLNT_GRACE_WAIT\t(5*HZ)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "queue",
            "&wait"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signalled",
          "args": [],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_freeze",
          "args": [],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout",
          "args": [
            "NLMCLNT_GRACE_WAIT"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signalled",
          "args": [],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "queue",
            "&wait",
            "TASK_INTERRUPTIBLE"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define NLMCLNT_GRACE_WAIT\t(5*HZ)\n\nstatic int nlm_wait_on_grace(wait_queue_head_t *queue)\n{\n\tDEFINE_WAIT(wait);\n\tint status = -EINTR;\n\n\tprepare_to_wait(queue, &wait, TASK_INTERRUPTIBLE);\n\tif (!signalled ()) {\n\t\tschedule_timeout(NLMCLNT_GRACE_WAIT);\n\t\ttry_to_freeze();\n\t\tif (!signalled ())\n\t\t\tstatus = 0;\n\t}\n\tfinish_wait(queue, &wait);\n\treturn status;\n}"
  },
  {
    "function_name": "nlmclnt_rpc_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "224-227",
    "snippet": "static void nlmclnt_rpc_release(void *data)\n{\n\tnlmclnt_release_call(data);\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmclnt_release_call",
          "args": [
            "data"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_release_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "215-222",
          "snippet": "void nlmclnt_release_call(struct nlm_rqst *call)\n{\n\tif (!atomic_dec_and_test(&call->a_count))\n\t\treturn;\n\tnlmclnt_release_host(call->a_host);\n\tnlmclnt_release_lockargs(call);\n\tkfree(call);\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid nlmclnt_release_call(struct nlm_rqst *call)\n{\n\tif (!atomic_dec_and_test(&call->a_count))\n\t\treturn;\n\tnlmclnt_release_host(call->a_host);\n\tnlmclnt_release_lockargs(call);\n\tkfree(call);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void nlmclnt_rpc_release(void *data)\n{\n\tnlmclnt_release_call(data);\n}"
  },
  {
    "function_name": "nlmclnt_release_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "215-222",
    "snippet": "void nlmclnt_release_call(struct nlm_rqst *call)\n{\n\tif (!atomic_dec_and_test(&call->a_count))\n\t\treturn;\n\tnlmclnt_release_host(call->a_host);\n\tnlmclnt_release_lockargs(call);\n\tkfree(call);\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "call"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmclnt_release_lockargs",
          "args": [
            "call"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_release_lockargs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "143-146",
          "snippet": "static void nlmclnt_release_lockargs(struct nlm_rqst *req)\n{\n\tWARN_ON_ONCE(req->a_args.lock.fl.fl_ops != NULL);\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void nlmclnt_release_lockargs(struct nlm_rqst *req)\n{\n\tWARN_ON_ONCE(req->a_args.lock.fl.fl_ops != NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmclnt_release_host",
          "args": [
            "call->a_host"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_release_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "282-300",
          "snippet": "void nlmclnt_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release client host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(host->h_server);\n\n\tif (atomic_dec_and_test(&host->h_count)) {\n\t\tWARN_ON_ONCE(!list_empty(&host->h_lockowners));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_granted));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_reclaim));\n\n\t\tmutex_lock(&nlm_host_mutex);\n\t\tnlm_destroy_host_locked(host);\n\t\tmutex_unlock(&nlm_host_mutex);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nlm_host_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic DEFINE_MUTEX(nlm_host_mutex);\n\nvoid nlmclnt_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release client host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(host->h_server);\n\n\tif (atomic_dec_and_test(&host->h_count)) {\n\t\tWARN_ON_ONCE(!list_empty(&host->h_lockowners));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_granted));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_reclaim));\n\n\t\tmutex_lock(&nlm_host_mutex);\n\t\tnlm_destroy_host_locked(host);\n\t\tmutex_unlock(&nlm_host_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&call->a_count"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid nlmclnt_release_call(struct nlm_rqst *call)\n{\n\tif (!atomic_dec_and_test(&call->a_count))\n\t\treturn;\n\tnlmclnt_release_host(call->a_host);\n\tnlmclnt_release_lockargs(call);\n\tkfree(call);\n}"
  },
  {
    "function_name": "nlm_alloc_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "194-213",
    "snippet": "struct nlm_rqst *nlm_alloc_call(struct nlm_host *host)\n{\n\tstruct nlm_rqst\t*call;\n\n\tfor(;;) {\n\t\tcall = kzalloc(sizeof(*call), GFP_KERNEL);\n\t\tif (call != NULL) {\n\t\t\tatomic_set(&call->a_count, 1);\n\t\t\tlocks_init_lock(&call->a_args.lock.fl);\n\t\t\tlocks_init_lock(&call->a_res.lock.fl);\n\t\t\tcall->a_host = nlm_get_host(host);\n\t\t\treturn call;\n\t\t}\n\t\tif (signalled())\n\t\t\tbreak;\n\t\tprintk(\"nlm_alloc_call: failed, waiting for memory\\n\");\n\t\tschedule_timeout_interruptible(5*HZ);\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "5*HZ"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"nlm_alloc_call: failed, waiting for memory\\n\""
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "signalled",
          "args": [],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_get_host",
          "args": [
            "host"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_get_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "501-509",
          "snippet": "struct nlm_host * nlm_get_host(struct nlm_host *host)\n{\n\tif (host) {\n\t\tdprintk(\"lockd: get host %s\\n\", host->h_name);\n\t\tatomic_inc(&host->h_count);\n\t\thost->h_expires = jiffies + NLM_HOST_EXPIRE;\n\t}\n\treturn host;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NLM_HOST_EXPIRE\t\t(300 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NLM_HOST_EXPIRE\t\t(300 * HZ)\n\nstruct nlm_host * nlm_get_host(struct nlm_host *host)\n{\n\tif (host) {\n\t\tdprintk(\"lockd: get host %s\\n\", host->h_name);\n\t\tatomic_inc(&host->h_count);\n\t\thost->h_expires = jiffies + NLM_HOST_EXPIRE;\n\t}\n\treturn host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_init_lock",
          "args": [
            "&call->a_res.lock.fl"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "locks_init_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "311-315",
          "snippet": "void locks_init_lock(struct file_lock *fl)\n{\n\tmemset(fl, 0, sizeof(struct file_lock));\n\tlocks_init_lock_heads(fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_init_lock(struct file_lock *fl)\n{\n\tmemset(fl, 0, sizeof(struct file_lock));\n\tlocks_init_lock_heads(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&call->a_count",
            "1"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*call)",
            "GFP_KERNEL"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\n\nstruct nlm_rqst *nlm_alloc_call(struct nlm_host *host)\n{\n\tstruct nlm_rqst\t*call;\n\n\tfor(;;) {\n\t\tcall = kzalloc(sizeof(*call), GFP_KERNEL);\n\t\tif (call != NULL) {\n\t\t\tatomic_set(&call->a_count, 1);\n\t\t\tlocks_init_lock(&call->a_args.lock.fl);\n\t\t\tlocks_init_lock(&call->a_res.lock.fl);\n\t\t\tcall->a_host = nlm_get_host(host);\n\t\t\treturn call;\n\t\t}\n\t\tif (signalled())\n\t\t\tbreak;\n\t\tprintk(\"nlm_alloc_call: failed, waiting for memory\\n\");\n\t\tschedule_timeout_interruptible(5*HZ);\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "nlmclnt_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "155-188",
    "snippet": "int nlmclnt_proc(struct nlm_host *host, int cmd, struct file_lock *fl)\n{\n\tstruct nlm_rqst\t\t*call;\n\tint\t\t\tstatus;\n\n\tcall = nlm_alloc_call(host);\n\tif (call == NULL)\n\t\treturn -ENOMEM;\n\n\tnlmclnt_locks_init_private(fl, host);\n\tif (!fl->fl_u.nfs_fl.owner) {\n\t\t/* lockowner allocation has failed */\n\t\tnlmclnt_release_call(call);\n\t\treturn -ENOMEM;\n\t}\n\t/* Set up the argument struct */\n\tnlmclnt_setlockargs(call, fl);\n\n\tif (IS_SETLK(cmd) || IS_SETLKW(cmd)) {\n\t\tif (fl->fl_type != F_UNLCK) {\n\t\t\tcall->a_args.block = IS_SETLKW(cmd) ? 1 : 0;\n\t\t\tstatus = nlmclnt_lock(call, fl);\n\t\t} else\n\t\t\tstatus = nlmclnt_unlock(call, fl);\n\t} else if (IS_GETLK(cmd))\n\t\tstatus = nlmclnt_test(call, fl);\n\telse\n\t\tstatus = -EINVAL;\n\tfl->fl_ops->fl_release_private(fl);\n\tfl->fl_ops = NULL;\n\n\tdprintk(\"lockd: clnt proc returns %d\\n\", status);\n\treturn status;\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);",
      "static int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);",
      "static int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);",
      "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);",
      "static int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: clnt proc returns %d\\n\"",
            "status"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fl->fl_ops->fl_release_private",
          "args": [
            "fl"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmclnt_test",
          "args": [
            "call",
            "fl"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "415-443",
          "snippet": "static int\nnlmclnt_test(struct nlm_rqst *req, struct file_lock *fl)\n{\n\tint\tstatus;\n\n\tstatus = nlmclnt_call(nfs_file_cred(fl->fl_file), req, NLMPROC_TEST);\n\tif (status < 0)\n\t\tgoto out;\n\n\tswitch (req->a_res.status) {\n\t\tcase nlm_granted:\n\t\t\tfl->fl_type = F_UNLCK;\n\t\t\tbreak;\n\t\tcase nlm_lck_denied:\n\t\t\t/*\n\t\t\t * Report the conflicting lock back to the application.\n\t\t\t */\n\t\t\tfl->fl_start = req->a_res.lock.fl.fl_start;\n\t\t\tfl->fl_end = req->a_res.lock.fl.fl_end;\n\t\t\tfl->fl_type = req->a_res.lock.fl.fl_type;\n\t\t\tfl->fl_pid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = nlm_stat_to_errno(req->a_res.status);\n\t}\nout:\n\tnlmclnt_release_call(req);\n\treturn status;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);\n\nstatic int\nnlmclnt_test(struct nlm_rqst *req, struct file_lock *fl)\n{\n\tint\tstatus;\n\n\tstatus = nlmclnt_call(nfs_file_cred(fl->fl_file), req, NLMPROC_TEST);\n\tif (status < 0)\n\t\tgoto out;\n\n\tswitch (req->a_res.status) {\n\t\tcase nlm_granted:\n\t\t\tfl->fl_type = F_UNLCK;\n\t\t\tbreak;\n\t\tcase nlm_lck_denied:\n\t\t\t/*\n\t\t\t * Report the conflicting lock back to the application.\n\t\t\t */\n\t\t\tfl->fl_start = req->a_res.lock.fl.fl_start;\n\t\t\tfl->fl_end = req->a_res.lock.fl.fl_end;\n\t\t\tfl->fl_type = req->a_res.lock.fl.fl_type;\n\t\t\tfl->fl_pid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = nlm_stat_to_errno(req->a_res.status);\n\t}\nout:\n\tnlmclnt_release_call(req);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_GETLK",
          "args": [
            "cmd"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmclnt_unlock",
          "args": [
            "call",
            "fl"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_unlock_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "701-731",
          "snippet": "static void nlmclnt_unlock_callback(struct rpc_task *task, void *data)\n{\n\tstruct nlm_rqst\t*req = data;\n\tu32 status = ntohl(req->a_res.status);\n\n\tif (RPC_ASSASSINATED(task))\n\t\tgoto die;\n\n\tif (task->tk_status < 0) {\n\t\tdprintk(\"lockd: unlock failed (err = %d)\\n\", -task->tk_status);\n\t\tswitch (task->tk_status) {\n\t\tcase -EACCES:\n\t\tcase -EIO:\n\t\t\tgoto die;\n\t\tdefault:\n\t\t\tgoto retry_rebind;\n\t\t}\n\t}\n\tif (status == NLM_LCK_DENIED_GRACE_PERIOD) {\n\t\trpc_delay(task, NLMCLNT_GRACE_WAIT);\n\t\tgoto retry_unlock;\n\t}\n\tif (status != NLM_LCK_GRANTED)\n\t\tprintk(KERN_WARNING \"lockd: unexpected unlock status: %d\\n\", status);\ndie:\n\treturn;\n retry_rebind:\n\tnlm_rebind_host(req->a_host);\n retry_unlock:\n\trpc_restart_call(task);\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define NLMCLNT_GRACE_WAIT\t(5*HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define NLMCLNT_GRACE_WAIT\t(5*HZ)\n\nstatic void nlmclnt_unlock_callback(struct rpc_task *task, void *data)\n{\n\tstruct nlm_rqst\t*req = data;\n\tu32 status = ntohl(req->a_res.status);\n\n\tif (RPC_ASSASSINATED(task))\n\t\tgoto die;\n\n\tif (task->tk_status < 0) {\n\t\tdprintk(\"lockd: unlock failed (err = %d)\\n\", -task->tk_status);\n\t\tswitch (task->tk_status) {\n\t\tcase -EACCES:\n\t\tcase -EIO:\n\t\t\tgoto die;\n\t\tdefault:\n\t\t\tgoto retry_rebind;\n\t\t}\n\t}\n\tif (status == NLM_LCK_DENIED_GRACE_PERIOD) {\n\t\trpc_delay(task, NLMCLNT_GRACE_WAIT);\n\t\tgoto retry_unlock;\n\t}\n\tif (status != NLM_LCK_GRANTED)\n\t\tprintk(KERN_WARNING \"lockd: unexpected unlock status: %d\\n\", status);\ndie:\n\treturn;\n retry_rebind:\n\tnlm_rebind_host(req->a_host);\n retry_unlock:\n\trpc_restart_call(task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmclnt_lock",
          "args": [
            "call",
            "fl"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "511-613",
          "snippet": "static int\nnlmclnt_lock(struct nlm_rqst *req, struct file_lock *fl)\n{\n\tstruct rpc_cred *cred = nfs_file_cred(fl->fl_file);\n\tstruct nlm_host\t*host = req->a_host;\n\tstruct nlm_res\t*resp = &req->a_res;\n\tstruct nlm_wait *block = NULL;\n\tunsigned char fl_flags = fl->fl_flags;\n\tunsigned char fl_type;\n\tint status = -ENOLCK;\n\n\tif (nsm_monitor(host) < 0)\n\t\tgoto out;\n\treq->a_args.state = nsm_local_state;\n\n\tfl->fl_flags |= FL_ACCESS;\n\tstatus = do_vfs_lock(fl);\n\tfl->fl_flags = fl_flags;\n\tif (status < 0)\n\t\tgoto out;\n\n\tblock = nlmclnt_prepare_block(host, fl);\nagain:\n\t/*\n\t * Initialise resp->status to a valid non-zero value,\n\t * since 0 == nlm_lck_granted\n\t */\n\tresp->status = nlm_lck_blocked;\n\tfor(;;) {\n\t\t/* Reboot protection */\n\t\tfl->fl_u.nfs_fl.state = host->h_state;\n\t\tstatus = nlmclnt_call(cred, req, NLMPROC_LOCK);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\t/* Did a reclaimer thread notify us of a server reboot? */\n\t\tif (resp->status ==  nlm_lck_denied_grace_period)\n\t\t\tcontinue;\n\t\tif (resp->status != nlm_lck_blocked)\n\t\t\tbreak;\n\t\t/* Wait on an NLM blocking lock */\n\t\tstatus = nlmclnt_block(block, req, NLMCLNT_POLL_TIMEOUT);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tif (resp->status != nlm_lck_blocked)\n\t\t\tbreak;\n\t}\n\n\t/* if we were interrupted while blocking, then cancel the lock request\n\t * and exit\n\t */\n\tif (resp->status == nlm_lck_blocked) {\n\t\tif (!req->a_args.block)\n\t\t\tgoto out_unlock;\n\t\tif (nlmclnt_cancel(host, req->a_args.block, fl) == 0)\n\t\t\tgoto out_unblock;\n\t}\n\n\tif (resp->status == nlm_granted) {\n\t\tdown_read(&host->h_rwsem);\n\t\t/* Check whether or not the server has rebooted */\n\t\tif (fl->fl_u.nfs_fl.state != host->h_state) {\n\t\t\tup_read(&host->h_rwsem);\n\t\t\tgoto again;\n\t\t}\n\t\t/* Ensure the resulting lock will get added to granted list */\n\t\tfl->fl_flags |= FL_SLEEP;\n\t\tif (do_vfs_lock(fl) < 0)\n\t\t\tprintk(KERN_WARNING \"%s: VFS is out of sync with lock manager!\\n\", __func__);\n\t\tup_read(&host->h_rwsem);\n\t\tfl->fl_flags = fl_flags;\n\t\tstatus = 0;\n\t}\n\tif (status < 0)\n\t\tgoto out_unlock;\n\t/*\n\t * EAGAIN doesn't make sense for sleeping locks, and in some\n\t * cases NLM_LCK_DENIED is returned for a permanent error.  So\n\t * turn it into an ENOLCK.\n\t */\n\tif (resp->status == nlm_lck_denied && (fl_flags & FL_SLEEP))\n\t\tstatus = -ENOLCK;\n\telse\n\t\tstatus = nlm_stat_to_errno(resp->status);\nout_unblock:\n\tnlmclnt_finish_block(block);\nout:\n\tnlmclnt_release_call(req);\n\treturn status;\nout_unlock:\n\t/* Fatal error: ensure that we remove the lock altogether */\n\tdprintk(\"lockd: lock attempt ended in fatal error.\\n\"\n\t\t\"       Attempting to unlock.\\n\");\n\tnlmclnt_finish_block(block);\n\tfl_type = fl->fl_type;\n\tfl->fl_type = F_UNLCK;\n\tdown_read(&host->h_rwsem);\n\tdo_vfs_lock(fl);\n\tup_read(&host->h_rwsem);\n\tfl->fl_type = fl_type;\n\tfl->fl_flags = fl_flags;\n\tnlmclnt_async_call(cred, req, NLMPROC_UNLOCK, &nlmclnt_unlock_ops);\n\treturn status;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define NLMCLNT_POLL_TIMEOUT\t(30*HZ)"
          ],
          "globals_used": [
            "static int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);",
            "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);",
            "static int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);",
            "static const struct rpc_call_ops nlmclnt_unlock_ops;",
            "static const struct rpc_call_ops nlmclnt_unlock_ops = {\n\t.rpc_call_done = nlmclnt_unlock_callback,\n\t.rpc_release = nlmclnt_rpc_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define NLMCLNT_POLL_TIMEOUT\t(30*HZ)\n\nstatic int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\nstatic int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);\nstatic const struct rpc_call_ops nlmclnt_unlock_ops;\nstatic const struct rpc_call_ops nlmclnt_unlock_ops = {\n\t.rpc_call_done = nlmclnt_unlock_callback,\n\t.rpc_release = nlmclnt_rpc_release,\n};\n\nstatic int\nnlmclnt_lock(struct nlm_rqst *req, struct file_lock *fl)\n{\n\tstruct rpc_cred *cred = nfs_file_cred(fl->fl_file);\n\tstruct nlm_host\t*host = req->a_host;\n\tstruct nlm_res\t*resp = &req->a_res;\n\tstruct nlm_wait *block = NULL;\n\tunsigned char fl_flags = fl->fl_flags;\n\tunsigned char fl_type;\n\tint status = -ENOLCK;\n\n\tif (nsm_monitor(host) < 0)\n\t\tgoto out;\n\treq->a_args.state = nsm_local_state;\n\n\tfl->fl_flags |= FL_ACCESS;\n\tstatus = do_vfs_lock(fl);\n\tfl->fl_flags = fl_flags;\n\tif (status < 0)\n\t\tgoto out;\n\n\tblock = nlmclnt_prepare_block(host, fl);\nagain:\n\t/*\n\t * Initialise resp->status to a valid non-zero value,\n\t * since 0 == nlm_lck_granted\n\t */\n\tresp->status = nlm_lck_blocked;\n\tfor(;;) {\n\t\t/* Reboot protection */\n\t\tfl->fl_u.nfs_fl.state = host->h_state;\n\t\tstatus = nlmclnt_call(cred, req, NLMPROC_LOCK);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\t/* Did a reclaimer thread notify us of a server reboot? */\n\t\tif (resp->status ==  nlm_lck_denied_grace_period)\n\t\t\tcontinue;\n\t\tif (resp->status != nlm_lck_blocked)\n\t\t\tbreak;\n\t\t/* Wait on an NLM blocking lock */\n\t\tstatus = nlmclnt_block(block, req, NLMCLNT_POLL_TIMEOUT);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tif (resp->status != nlm_lck_blocked)\n\t\t\tbreak;\n\t}\n\n\t/* if we were interrupted while blocking, then cancel the lock request\n\t * and exit\n\t */\n\tif (resp->status == nlm_lck_blocked) {\n\t\tif (!req->a_args.block)\n\t\t\tgoto out_unlock;\n\t\tif (nlmclnt_cancel(host, req->a_args.block, fl) == 0)\n\t\t\tgoto out_unblock;\n\t}\n\n\tif (resp->status == nlm_granted) {\n\t\tdown_read(&host->h_rwsem);\n\t\t/* Check whether or not the server has rebooted */\n\t\tif (fl->fl_u.nfs_fl.state != host->h_state) {\n\t\t\tup_read(&host->h_rwsem);\n\t\t\tgoto again;\n\t\t}\n\t\t/* Ensure the resulting lock will get added to granted list */\n\t\tfl->fl_flags |= FL_SLEEP;\n\t\tif (do_vfs_lock(fl) < 0)\n\t\t\tprintk(KERN_WARNING \"%s: VFS is out of sync with lock manager!\\n\", __func__);\n\t\tup_read(&host->h_rwsem);\n\t\tfl->fl_flags = fl_flags;\n\t\tstatus = 0;\n\t}\n\tif (status < 0)\n\t\tgoto out_unlock;\n\t/*\n\t * EAGAIN doesn't make sense for sleeping locks, and in some\n\t * cases NLM_LCK_DENIED is returned for a permanent error.  So\n\t * turn it into an ENOLCK.\n\t */\n\tif (resp->status == nlm_lck_denied && (fl_flags & FL_SLEEP))\n\t\tstatus = -ENOLCK;\n\telse\n\t\tstatus = nlm_stat_to_errno(resp->status);\nout_unblock:\n\tnlmclnt_finish_block(block);\nout:\n\tnlmclnt_release_call(req);\n\treturn status;\nout_unlock:\n\t/* Fatal error: ensure that we remove the lock altogether */\n\tdprintk(\"lockd: lock attempt ended in fatal error.\\n\"\n\t\t\"       Attempting to unlock.\\n\");\n\tnlmclnt_finish_block(block);\n\tfl_type = fl->fl_type;\n\tfl->fl_type = F_UNLCK;\n\tdown_read(&host->h_rwsem);\n\tdo_vfs_lock(fl);\n\tup_read(&host->h_rwsem);\n\tfl->fl_type = fl_type;\n\tfl->fl_flags = fl_flags;\n\tnlmclnt_async_call(cred, req, NLMPROC_UNLOCK, &nlmclnt_unlock_ops);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SETLKW",
          "args": [
            "cmd"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SETLKW",
          "args": [
            "cmd"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SETLK",
          "args": [
            "cmd"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmclnt_setlockargs",
          "args": [
            "call",
            "fl"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_setlockargs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "124-141",
          "snippet": "static void nlmclnt_setlockargs(struct nlm_rqst *req, struct file_lock *fl)\n{\n\tstruct nlm_args\t*argp = &req->a_args;\n\tstruct nlm_lock\t*lock = &argp->lock;\n\tchar *nodename = req->a_host->h_rpcclnt->cl_nodename;\n\n\tnlmclnt_next_cookie(&argp->cookie);\n\tmemcpy(&lock->fh, NFS_FH(file_inode(fl->fl_file)), sizeof(struct nfs_fh));\n\tlock->caller  = nodename;\n\tlock->oh.data = req->a_owner;\n\tlock->oh.len  = snprintf(req->a_owner, sizeof(req->a_owner), \"%u@%s\",\n\t\t\t\t(unsigned int)fl->fl_u.nfs_fl.owner->pid,\n\t\t\t\tnodename);\n\tlock->svid = fl->fl_u.nfs_fl.owner->pid;\n\tlock->fl.fl_start = fl->fl_start;\n\tlock->fl.fl_end = fl->fl_end;\n\tlock->fl.fl_type = fl->fl_type;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);\n\nstatic void nlmclnt_setlockargs(struct nlm_rqst *req, struct file_lock *fl)\n{\n\tstruct nlm_args\t*argp = &req->a_args;\n\tstruct nlm_lock\t*lock = &argp->lock;\n\tchar *nodename = req->a_host->h_rpcclnt->cl_nodename;\n\n\tnlmclnt_next_cookie(&argp->cookie);\n\tmemcpy(&lock->fh, NFS_FH(file_inode(fl->fl_file)), sizeof(struct nfs_fh));\n\tlock->caller  = nodename;\n\tlock->oh.data = req->a_owner;\n\tlock->oh.len  = snprintf(req->a_owner, sizeof(req->a_owner), \"%u@%s\",\n\t\t\t\t(unsigned int)fl->fl_u.nfs_fl.owner->pid,\n\t\t\t\tnodename);\n\tlock->svid = fl->fl_u.nfs_fl.owner->pid;\n\tlock->fl.fl_start = fl->fl_start;\n\tlock->fl.fl_end = fl->fl_end;\n\tlock->fl.fl_type = fl->fl_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmclnt_release_call",
          "args": [
            "call"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_release_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "215-222",
          "snippet": "void nlmclnt_release_call(struct nlm_rqst *call)\n{\n\tif (!atomic_dec_and_test(&call->a_count))\n\t\treturn;\n\tnlmclnt_release_host(call->a_host);\n\tnlmclnt_release_lockargs(call);\n\tkfree(call);\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid nlmclnt_release_call(struct nlm_rqst *call)\n{\n\tif (!atomic_dec_and_test(&call->a_count))\n\t\treturn;\n\tnlmclnt_release_host(call->a_host);\n\tnlmclnt_release_lockargs(call);\n\tkfree(call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmclnt_locks_init_private",
          "args": [
            "fl",
            "host"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_locks_init_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "467-473",
          "snippet": "static void nlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host)\n{\n\tfl->fl_u.nfs_fl.state = 0;\n\tfl->fl_u.nfs_fl.owner = nlm_find_lockowner(host, fl->fl_owner);\n\tINIT_LIST_HEAD(&fl->fl_u.nfs_fl.list);\n\tfl->fl_ops = &nlmclnt_lock_ops;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);",
            "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);",
            "static int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);",
            "static const struct file_lock_operations nlmclnt_lock_ops = {\n\t.fl_copy_lock = nlmclnt_locks_copy_lock,\n\t.fl_release_private = nlmclnt_locks_release_private,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\nstatic int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);\nstatic const struct file_lock_operations nlmclnt_lock_ops = {\n\t.fl_copy_lock = nlmclnt_locks_copy_lock,\n\t.fl_release_private = nlmclnt_locks_release_private,\n};\n\nstatic void nlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host)\n{\n\tfl->fl_u.nfs_fl.state = 0;\n\tfl->fl_u.nfs_fl.owner = nlm_find_lockowner(host, fl->fl_owner);\n\tINIT_LIST_HEAD(&fl->fl_u.nfs_fl.list);\n\tfl->fl_ops = &nlmclnt_lock_ops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlm_alloc_call",
          "args": [
            "host"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_alloc_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "194-213",
          "snippet": "struct nlm_rqst *nlm_alloc_call(struct nlm_host *host)\n{\n\tstruct nlm_rqst\t*call;\n\n\tfor(;;) {\n\t\tcall = kzalloc(sizeof(*call), GFP_KERNEL);\n\t\tif (call != NULL) {\n\t\t\tatomic_set(&call->a_count, 1);\n\t\t\tlocks_init_lock(&call->a_args.lock.fl);\n\t\t\tlocks_init_lock(&call->a_res.lock.fl);\n\t\t\tcall->a_host = nlm_get_host(host);\n\t\t\treturn call;\n\t\t}\n\t\tif (signalled())\n\t\t\tbreak;\n\t\tprintk(\"nlm_alloc_call: failed, waiting for memory\\n\");\n\t\tschedule_timeout_interruptible(5*HZ);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\n\nstruct nlm_rqst *nlm_alloc_call(struct nlm_host *host)\n{\n\tstruct nlm_rqst\t*call;\n\n\tfor(;;) {\n\t\tcall = kzalloc(sizeof(*call), GFP_KERNEL);\n\t\tif (call != NULL) {\n\t\t\tatomic_set(&call->a_count, 1);\n\t\t\tlocks_init_lock(&call->a_args.lock.fl);\n\t\t\tlocks_init_lock(&call->a_res.lock.fl);\n\t\t\tcall->a_host = nlm_get_host(host);\n\t\t\treturn call;\n\t\t}\n\t\tif (signalled())\n\t\t\tbreak;\n\t\tprintk(\"nlm_alloc_call: failed, waiting for memory\\n\");\n\t\tschedule_timeout_interruptible(5*HZ);\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\nstatic int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);\n\nint nlmclnt_proc(struct nlm_host *host, int cmd, struct file_lock *fl)\n{\n\tstruct nlm_rqst\t\t*call;\n\tint\t\t\tstatus;\n\n\tcall = nlm_alloc_call(host);\n\tif (call == NULL)\n\t\treturn -ENOMEM;\n\n\tnlmclnt_locks_init_private(fl, host);\n\tif (!fl->fl_u.nfs_fl.owner) {\n\t\t/* lockowner allocation has failed */\n\t\tnlmclnt_release_call(call);\n\t\treturn -ENOMEM;\n\t}\n\t/* Set up the argument struct */\n\tnlmclnt_setlockargs(call, fl);\n\n\tif (IS_SETLK(cmd) || IS_SETLKW(cmd)) {\n\t\tif (fl->fl_type != F_UNLCK) {\n\t\t\tcall->a_args.block = IS_SETLKW(cmd) ? 1 : 0;\n\t\t\tstatus = nlmclnt_lock(call, fl);\n\t\t} else\n\t\t\tstatus = nlmclnt_unlock(call, fl);\n\t} else if (IS_GETLK(cmd))\n\t\tstatus = nlmclnt_test(call, fl);\n\telse\n\t\tstatus = -EINVAL;\n\tfl->fl_ops->fl_release_private(fl);\n\tfl->fl_ops = NULL;\n\n\tdprintk(\"lockd: clnt proc returns %d\\n\", status);\n\treturn status;\n}"
  },
  {
    "function_name": "nlmclnt_release_lockargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "143-146",
    "snippet": "static void nlmclnt_release_lockargs(struct nlm_rqst *req)\n{\n\tWARN_ON_ONCE(req->a_args.lock.fl.fl_ops != NULL);\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "req->a_args.lock.fl.fl_ops != NULL"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void nlmclnt_release_lockargs(struct nlm_rqst *req)\n{\n\tWARN_ON_ONCE(req->a_args.lock.fl.fl_ops != NULL);\n}"
  },
  {
    "function_name": "nlmclnt_setlockargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "124-141",
    "snippet": "static void nlmclnt_setlockargs(struct nlm_rqst *req, struct file_lock *fl)\n{\n\tstruct nlm_args\t*argp = &req->a_args;\n\tstruct nlm_lock\t*lock = &argp->lock;\n\tchar *nodename = req->a_host->h_rpcclnt->cl_nodename;\n\n\tnlmclnt_next_cookie(&argp->cookie);\n\tmemcpy(&lock->fh, NFS_FH(file_inode(fl->fl_file)), sizeof(struct nfs_fh));\n\tlock->caller  = nodename;\n\tlock->oh.data = req->a_owner;\n\tlock->oh.len  = snprintf(req->a_owner, sizeof(req->a_owner), \"%u@%s\",\n\t\t\t\t(unsigned int)fl->fl_u.nfs_fl.owner->pid,\n\t\t\t\tnodename);\n\tlock->svid = fl->fl_u.nfs_fl.owner->pid;\n\tlock->fl.fl_start = fl->fl_start;\n\tlock->fl.fl_end = fl->fl_end;\n\tlock->fl.fl_type = fl->fl_type;\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);",
      "static int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);",
      "static int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);",
      "static int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "req->a_owner",
            "sizeof(req->a_owner)",
            "\"%u@%s\"",
            "(unsigned int)fl->fl_u.nfs_fl.owner->pid",
            "nodename"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&lock->fh",
            "NFS_FH(file_inode(fl->fl_file))",
            "sizeof(struct nfs_fh)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_FH",
          "args": [
            "file_inode(fl->fl_file)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "fl->fl_file"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmclnt_next_cookie",
          "args": [
            "&argp->cookie"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_next_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "41-47",
          "snippet": "void nlmclnt_next_cookie(struct nlm_cookie *c)\n{\n\tu32\tcookie = atomic_inc_return(&nlm_cookie);\n\n\tmemcpy(c->data, &cookie, 4);\n\tc->len=4;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t\tnlm_cookie = ATOMIC_INIT(0x1234);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic atomic_t\tnlm_cookie = ATOMIC_INIT(0x1234);\n\nvoid nlmclnt_next_cookie(struct nlm_cookie *c)\n{\n\tu32\tcookie = atomic_inc_return(&nlm_cookie);\n\n\tmemcpy(c->data, &cookie, 4);\n\tc->len=4;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);\n\nstatic void nlmclnt_setlockargs(struct nlm_rqst *req, struct file_lock *fl)\n{\n\tstruct nlm_args\t*argp = &req->a_args;\n\tstruct nlm_lock\t*lock = &argp->lock;\n\tchar *nodename = req->a_host->h_rpcclnt->cl_nodename;\n\n\tnlmclnt_next_cookie(&argp->cookie);\n\tmemcpy(&lock->fh, NFS_FH(file_inode(fl->fl_file)), sizeof(struct nfs_fh));\n\tlock->caller  = nodename;\n\tlock->oh.data = req->a_owner;\n\tlock->oh.len  = snprintf(req->a_owner, sizeof(req->a_owner), \"%u@%s\",\n\t\t\t\t(unsigned int)fl->fl_u.nfs_fl.owner->pid,\n\t\t\t\tnodename);\n\tlock->svid = fl->fl_u.nfs_fl.owner->pid;\n\tlock->fl.fl_start = fl->fl_start;\n\tlock->fl.fl_end = fl->fl_end;\n\tlock->fl.fl_type = fl->fl_type;\n}"
  },
  {
    "function_name": "nlm_find_lockowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "95-119",
    "snippet": "static struct nlm_lockowner *nlm_find_lockowner(struct nlm_host *host, fl_owner_t owner)\n{\n\tstruct nlm_lockowner *res, *new = NULL;\n\n\tspin_lock(&host->h_lock);\n\tres = __nlm_find_lockowner(host, owner);\n\tif (res == NULL) {\n\t\tspin_unlock(&host->h_lock);\n\t\tnew = kmalloc(sizeof(*new), GFP_KERNEL);\n\t\tspin_lock(&host->h_lock);\n\t\tres = __nlm_find_lockowner(host, owner);\n\t\tif (res == NULL && new != NULL) {\n\t\t\tres = new;\n\t\t\tatomic_set(&new->count, 1);\n\t\t\tnew->owner = owner;\n\t\t\tnew->pid = __nlm_alloc_pid(host);\n\t\t\tnew->host = nlm_get_host(host);\n\t\t\tlist_add(&new->list, &host->h_lockowners);\n\t\t\tnew = NULL;\n\t\t}\n\t}\n\tspin_unlock(&host->h_lock);\n\tkfree(new);\n\treturn res;\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&host->h_lock"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&new->list",
            "&host->h_lockowners"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlm_get_host",
          "args": [
            "host"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_get_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "501-509",
          "snippet": "struct nlm_host * nlm_get_host(struct nlm_host *host)\n{\n\tif (host) {\n\t\tdprintk(\"lockd: get host %s\\n\", host->h_name);\n\t\tatomic_inc(&host->h_count);\n\t\thost->h_expires = jiffies + NLM_HOST_EXPIRE;\n\t}\n\treturn host;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NLM_HOST_EXPIRE\t\t(300 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NLM_HOST_EXPIRE\t\t(300 * HZ)\n\nstruct nlm_host * nlm_get_host(struct nlm_host *host)\n{\n\tif (host) {\n\t\tdprintk(\"lockd: get host %s\\n\", host->h_name);\n\t\tatomic_inc(&host->h_count);\n\t\thost->h_expires = jiffies + NLM_HOST_EXPIRE;\n\t}\n\treturn host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__nlm_alloc_pid",
          "args": [
            "host"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "__nlm_alloc_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "75-82",
          "snippet": "static inline uint32_t __nlm_alloc_pid(struct nlm_host *host)\n{\n\tuint32_t res;\n\tdo {\n\t\tres = host->h_pidcount++;\n\t} while (nlm_pidbusy(host, res) < 0);\n\treturn res;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\n\nstatic inline uint32_t __nlm_alloc_pid(struct nlm_host *host)\n{\n\tuint32_t res;\n\tdo {\n\t\tres = host->h_pidcount++;\n\t} while (nlm_pidbusy(host, res) < 0);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&new->count",
            "1"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__nlm_find_lockowner",
          "args": [
            "host",
            "owner"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "__nlm_find_lockowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "84-93",
          "snippet": "static struct nlm_lockowner *__nlm_find_lockowner(struct nlm_host *host, fl_owner_t owner)\n{\n\tstruct nlm_lockowner *lockowner;\n\tlist_for_each_entry(lockowner, &host->h_lockowners, list) {\n\t\tif (lockowner->owner != owner)\n\t\t\tcontinue;\n\t\treturn nlm_get_lockowner(lockowner);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\n\nstatic struct nlm_lockowner *__nlm_find_lockowner(struct nlm_host *host, fl_owner_t owner)\n{\n\tstruct nlm_lockowner *lockowner;\n\tlist_for_each_entry(lockowner, &host->h_lockowners, list) {\n\t\tif (lockowner->owner != owner)\n\t\t\tcontinue;\n\t\treturn nlm_get_lockowner(lockowner);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&host->h_lock"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*new)",
            "GFP_KERNEL"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\n\nstatic struct nlm_lockowner *nlm_find_lockowner(struct nlm_host *host, fl_owner_t owner)\n{\n\tstruct nlm_lockowner *res, *new = NULL;\n\n\tspin_lock(&host->h_lock);\n\tres = __nlm_find_lockowner(host, owner);\n\tif (res == NULL) {\n\t\tspin_unlock(&host->h_lock);\n\t\tnew = kmalloc(sizeof(*new), GFP_KERNEL);\n\t\tspin_lock(&host->h_lock);\n\t\tres = __nlm_find_lockowner(host, owner);\n\t\tif (res == NULL && new != NULL) {\n\t\t\tres = new;\n\t\t\tatomic_set(&new->count, 1);\n\t\t\tnew->owner = owner;\n\t\t\tnew->pid = __nlm_alloc_pid(host);\n\t\t\tnew->host = nlm_get_host(host);\n\t\t\tlist_add(&new->list, &host->h_lockowners);\n\t\t\tnew = NULL;\n\t\t}\n\t}\n\tspin_unlock(&host->h_lock);\n\tkfree(new);\n\treturn res;\n}"
  },
  {
    "function_name": "__nlm_find_lockowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "84-93",
    "snippet": "static struct nlm_lockowner *__nlm_find_lockowner(struct nlm_host *host, fl_owner_t owner)\n{\n\tstruct nlm_lockowner *lockowner;\n\tlist_for_each_entry(lockowner, &host->h_lockowners, list) {\n\t\tif (lockowner->owner != owner)\n\t\t\tcontinue;\n\t\treturn nlm_get_lockowner(lockowner);\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlm_get_lockowner",
          "args": [
            "lockowner"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_get_lockowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "49-53",
          "snippet": "static struct nlm_lockowner *nlm_get_lockowner(struct nlm_lockowner *lockowner)\n{\n\tatomic_inc(&lockowner->count);\n\treturn lockowner;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic struct nlm_lockowner *nlm_get_lockowner(struct nlm_lockowner *lockowner)\n{\n\tatomic_inc(&lockowner->count);\n\treturn lockowner;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lockowner",
            "&host->h_lockowners",
            "list"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\n\nstatic struct nlm_lockowner *__nlm_find_lockowner(struct nlm_host *host, fl_owner_t owner)\n{\n\tstruct nlm_lockowner *lockowner;\n\tlist_for_each_entry(lockowner, &host->h_lockowners, list) {\n\t\tif (lockowner->owner != owner)\n\t\t\tcontinue;\n\t\treturn nlm_get_lockowner(lockowner);\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "__nlm_alloc_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "75-82",
    "snippet": "static inline uint32_t __nlm_alloc_pid(struct nlm_host *host)\n{\n\tuint32_t res;\n\tdo {\n\t\tres = host->h_pidcount++;\n\t} while (nlm_pidbusy(host, res) < 0);\n\treturn res;\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlm_pidbusy",
          "args": [
            "host",
            "res"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_pidbusy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "65-73",
          "snippet": "static inline int nlm_pidbusy(struct nlm_host *host, uint32_t pid)\n{\n\tstruct nlm_lockowner *lockowner;\n\tlist_for_each_entry(lockowner, &host->h_lockowners, list) {\n\t\tif (lockowner->pid == pid)\n\t\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\n\nstatic inline int nlm_pidbusy(struct nlm_host *host, uint32_t pid)\n{\n\tstruct nlm_lockowner *lockowner;\n\tlist_for_each_entry(lockowner, &host->h_lockowners, list) {\n\t\tif (lockowner->pid == pid)\n\t\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\n\nstatic inline uint32_t __nlm_alloc_pid(struct nlm_host *host)\n{\n\tuint32_t res;\n\tdo {\n\t\tres = host->h_pidcount++;\n\t} while (nlm_pidbusy(host, res) < 0);\n\treturn res;\n}"
  },
  {
    "function_name": "nlm_pidbusy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "65-73",
    "snippet": "static inline int nlm_pidbusy(struct nlm_host *host, uint32_t pid)\n{\n\tstruct nlm_lockowner *lockowner;\n\tlist_for_each_entry(lockowner, &host->h_lockowners, list) {\n\t\tif (lockowner->pid == pid)\n\t\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lockowner",
            "&host->h_lockowners",
            "list"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\n\nstatic inline int nlm_pidbusy(struct nlm_host *host, uint32_t pid)\n{\n\tstruct nlm_lockowner *lockowner;\n\tlist_for_each_entry(lockowner, &host->h_lockowners, list) {\n\t\tif (lockowner->pid == pid)\n\t\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "nlm_put_lockowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "55-63",
    "snippet": "static void nlm_put_lockowner(struct nlm_lockowner *lockowner)\n{\n\tif (!atomic_dec_and_lock(&lockowner->count, &lockowner->host->h_lock))\n\t\treturn;\n\tlist_del(&lockowner->list);\n\tspin_unlock(&lockowner->host->h_lock);\n\tnlmclnt_release_host(lockowner->host);\n\tkfree(lockowner);\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lockowner"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmclnt_release_host",
          "args": [
            "lockowner->host"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_release_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "282-300",
          "snippet": "void nlmclnt_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release client host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(host->h_server);\n\n\tif (atomic_dec_and_test(&host->h_count)) {\n\t\tWARN_ON_ONCE(!list_empty(&host->h_lockowners));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_granted));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_reclaim));\n\n\t\tmutex_lock(&nlm_host_mutex);\n\t\tnlm_destroy_host_locked(host);\n\t\tmutex_unlock(&nlm_host_mutex);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nlm_host_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic DEFINE_MUTEX(nlm_host_mutex);\n\nvoid nlmclnt_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release client host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(host->h_server);\n\n\tif (atomic_dec_and_test(&host->h_count)) {\n\t\tWARN_ON_ONCE(!list_empty(&host->h_lockowners));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_granted));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_reclaim));\n\n\t\tmutex_lock(&nlm_host_mutex);\n\t\tnlm_destroy_host_locked(host);\n\t\tmutex_unlock(&nlm_host_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lockowner->host->h_lock"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&lockowner->list"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_lock",
          "args": [
            "&lockowner->count",
            "&lockowner->host->h_lock"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\n\nstatic void nlm_put_lockowner(struct nlm_lockowner *lockowner)\n{\n\tif (!atomic_dec_and_lock(&lockowner->count, &lockowner->host->h_lock))\n\t\treturn;\n\tlist_del(&lockowner->list);\n\tspin_unlock(&lockowner->host->h_lock);\n\tnlmclnt_release_host(lockowner->host);\n\tkfree(lockowner);\n}"
  },
  {
    "function_name": "nlm_get_lockowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "49-53",
    "snippet": "static struct nlm_lockowner *nlm_get_lockowner(struct nlm_lockowner *lockowner)\n{\n\tatomic_inc(&lockowner->count);\n\treturn lockowner;\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&lockowner->count"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic struct nlm_lockowner *nlm_get_lockowner(struct nlm_lockowner *lockowner)\n{\n\tatomic_inc(&lockowner->count);\n\treturn lockowner;\n}"
  },
  {
    "function_name": "nlmclnt_next_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
    "lines": "41-47",
    "snippet": "void nlmclnt_next_cookie(struct nlm_cookie *c)\n{\n\tu32\tcookie = atomic_inc_return(&nlm_cookie);\n\n\tmemcpy(c->data, &cookie, 4);\n\tc->len=4;\n}",
    "includes": [
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/freezer.h>",
      "#include <linux/utsname.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t\tnlm_cookie = ATOMIC_INIT(0x1234);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "c->data",
            "&cookie",
            "4"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&nlm_cookie"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic atomic_t\tnlm_cookie = ATOMIC_INIT(0x1234);\n\nvoid nlmclnt_next_cookie(struct nlm_cookie *c)\n{\n\tu32\tcookie = atomic_inc_return(&nlm_cookie);\n\n\tmemcpy(c->data, &cookie, 4);\n\tc->len=4;\n}"
  }
]